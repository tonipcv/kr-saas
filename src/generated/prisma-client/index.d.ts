
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model VerificationCode
 * 
 */
export type VerificationCode = $Result.DefaultSelection<Prisma.$VerificationCodePayload>
/**
 * Model PatientProfile
 * 
 */
export type PatientProfile = $Result.DefaultSelection<Prisma.$PatientProfilePayload>
/**
 * Model PointsLedger
 * 
 */
export type PointsLedger = $Result.DefaultSelection<Prisma.$PointsLedgerPayload>
/**
 * Model Clinic
 * 
 */
export type Clinic = $Result.DefaultSelection<Prisma.$ClinicPayload>
/**
 * Model ClinicMember
 * 
 */
export type ClinicMember = $Result.DefaultSelection<Prisma.$ClinicMemberPayload>
/**
 * Model Merchant
 * 
 */
export type Merchant = $Result.DefaultSelection<Prisma.$MerchantPayload>
/**
 * Model MerchantApplication
 * 
 */
export type MerchantApplication = $Result.DefaultSelection<Prisma.$MerchantApplicationPayload>
/**
 * Model MerchantDocument
 * 
 */
export type MerchantDocument = $Result.DefaultSelection<Prisma.$MerchantDocumentPayload>
/**
 * Model MerchantIntegration
 * 
 */
export type MerchantIntegration = $Result.DefaultSelection<Prisma.$MerchantIntegrationPayload>
/**
 * Model PaymentRoutingRule
 * 
 */
export type PaymentRoutingRule = $Result.DefaultSelection<Prisma.$PaymentRoutingRulePayload>
/**
 * Model ClinicPlan
 * 
 */
export type ClinicPlan = $Result.DefaultSelection<Prisma.$ClinicPlanPayload>
/**
 * Model ClinicAddOn
 * 
 */
export type ClinicAddOn = $Result.DefaultSelection<Prisma.$ClinicAddOnPayload>
/**
 * Model ClinicSubscription
 * 
 */
export type ClinicSubscription = $Result.DefaultSelection<Prisma.$ClinicSubscriptionPayload>
/**
 * Model ClinicAddOnSubscription
 * 
 */
export type ClinicAddOnSubscription = $Result.DefaultSelection<Prisma.$ClinicAddOnSubscriptionPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model CategoriesOnProducts
 * 
 */
export type CategoriesOnProducts = $Result.DefaultSelection<Prisma.$CategoriesOnProductsPayload>
/**
 * Model Offer
 * 
 */
export type Offer = $Result.DefaultSelection<Prisma.$OfferPayload>
/**
 * Model OfferPrice
 * 
 */
export type OfferPrice = $Result.DefaultSelection<Prisma.$OfferPricePayload>
/**
 * Model OfferPaymentMethod
 * 
 */
export type OfferPaymentMethod = $Result.DefaultSelection<Prisma.$OfferPaymentMethodPayload>
/**
 * Model ProductIntegration
 * 
 */
export type ProductIntegration = $Result.DefaultSelection<Prisma.$ProductIntegrationPayload>
/**
 * Model CheckoutSession
 * 
 */
export type CheckoutSession = $Result.DefaultSelection<Prisma.$CheckoutSessionPayload>
/**
 * Model PaymentTransaction
 * 
 */
export type PaymentTransaction = $Result.DefaultSelection<Prisma.$PaymentTransactionPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerProvider
 * 
 */
export type CustomerProvider = $Result.DefaultSelection<Prisma.$CustomerProviderPayload>
/**
 * Model CustomerPaymentMethod
 * 
 */
export type CustomerPaymentMethod = $Result.DefaultSelection<Prisma.$CustomerPaymentMethodPayload>
/**
 * Model CustomerSubscription
 * 
 */
export type CustomerSubscription = $Result.DefaultSelection<Prisma.$CustomerSubscriptionPayload>
/**
 * Model PaymentCustomer
 * 
 */
export type PaymentCustomer = $Result.DefaultSelection<Prisma.$PaymentCustomerPayload>
/**
 * Model MessageTemplate
 * 
 */
export type MessageTemplate = $Result.DefaultSelection<Prisma.$MessageTemplatePayload>
/**
 * Model MessageSequence
 * 
 */
export type MessageSequence = $Result.DefaultSelection<Prisma.$MessageSequencePayload>
/**
 * Model MessageSequenceStep
 * 
 */
export type MessageSequenceStep = $Result.DefaultSelection<Prisma.$MessageSequenceStepPayload>
/**
 * Model CampaignJob
 * 
 */
export type CampaignJob = $Result.DefaultSelection<Prisma.$CampaignJobPayload>
/**
 * Model OpenFinanceLink
 * 
 */
export type OpenFinanceLink = $Result.DefaultSelection<Prisma.$OpenFinanceLinkPayload>
/**
 * Model OpenFinanceConsent
 * 
 */
export type OpenFinanceConsent = $Result.DefaultSelection<Prisma.$OpenFinanceConsentPayload>
/**
 * Model OpenBankingPayment
 * 
 */
export type OpenBankingPayment = $Result.DefaultSelection<Prisma.$OpenBankingPaymentPayload>
/**
 * Model OpenBankingConsent
 * 
 */
export type OpenBankingConsent = $Result.DefaultSelection<Prisma.$OpenBankingConsentPayload>
/**
 * Model EnrollmentContext
 * 
 */
export type EnrollmentContext = $Result.DefaultSelection<Prisma.$EnrollmentContextPayload>
/**
 * Model PaymentConsent
 * 
 */
export type PaymentConsent = $Result.DefaultSelection<Prisma.$PaymentConsentPayload>
/**
 * Model OAuthState
 * 
 */
export type OAuthState = $Result.DefaultSelection<Prisma.$OAuthStatePayload>
/**
 * Model OAuthStateMeta
 * 
 */
export type OAuthStateMeta = $Result.DefaultSelection<Prisma.$OAuthStateMetaPayload>
/**
 * Model OAuthToken
 * 
 */
export type OAuthToken = $Result.DefaultSelection<Prisma.$OAuthTokenPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model WebhookEvent
 * 
 */
export type WebhookEvent = $Result.DefaultSelection<Prisma.$WebhookEventPayload>
/**
 * Model WebhookEndpoint
 * 
 */
export type WebhookEndpoint = $Result.DefaultSelection<Prisma.$WebhookEndpointPayload>
/**
 * Model OutboundWebhookEvent
 * 
 */
export type OutboundWebhookEvent = $Result.DefaultSelection<Prisma.$OutboundWebhookEventPayload>
/**
 * Model OutboundWebhookDelivery
 * 
 */
export type OutboundWebhookDelivery = $Result.DefaultSelection<Prisma.$OutboundWebhookDeliveryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ClinicRole: {
  OWNER: 'OWNER',
  MANAGER: 'MANAGER',
  PROVIDER: 'PROVIDER',
  STAFF: 'STAFF'
};

export type ClinicRole = (typeof ClinicRole)[keyof typeof ClinicRole]


export const ClinicTheme: {
  LIGHT: 'LIGHT',
  DARK: 'DARK'
};

export type ClinicTheme = (typeof ClinicTheme)[keyof typeof ClinicTheme]


export const MerchantStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  REJECTED: 'REJECTED',
  DISABLED: 'DISABLED'
};

export type MerchantStatus = (typeof MerchantStatus)[keyof typeof MerchantStatus]


export const MerchantType: {
  INDIVIDUAL: 'INDIVIDUAL',
  COMPANY: 'COMPANY'
};

export type MerchantType = (typeof MerchantType)[keyof typeof MerchantType]


export const MerchantAppStatus: {
  DRAFT: 'DRAFT',
  PENDING_DOCUMENTS: 'PENDING_DOCUMENTS',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type MerchantAppStatus = (typeof MerchantAppStatus)[keyof typeof MerchantAppStatus]


export const DocumentType: {
  ID_FRONT: 'ID_FRONT',
  ID_BACK: 'ID_BACK',
  SELFIE: 'SELFIE',
  CNPJ_CARD: 'CNPJ_CARD',
  ADDRESS_PROOF: 'ADDRESS_PROOF',
  CONTRACT_SOCIAL: 'CONTRACT_SOCIAL',
  BANK_STATEMENT: 'BANK_STATEMENT',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const DocumentStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type DocumentStatus = (typeof DocumentStatus)[keyof typeof DocumentStatus]


export const SubscriptionStatus: {
  TRIAL: 'TRIAL',
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  PAST_DUE: 'PAST_DUE',
  CANCELED: 'CANCELED',
  EXPIRED: 'EXPIRED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const PlanTier: {
  STARTER: 'STARTER',
  GROWTH: 'GROWTH',
  ENTERPRISE: 'ENTERPRISE'
};

export type PlanTier = (typeof PlanTier)[keyof typeof PlanTier]


export const AddOnType: {
  EXTRA_DOCTOR: 'EXTRA_DOCTOR',
  EXTRA_PATIENTS: 'EXTRA_PATIENTS',
  ADVANCED_REPORTS: 'ADVANCED_REPORTS',
  CUSTOM_BRANDING: 'CUSTOM_BRANDING',
  WHITE_LABEL: 'WHITE_LABEL',
  API_ACCESS: 'API_ACCESS'
};

export type AddOnType = (typeof AddOnType)[keyof typeof AddOnType]


export const ProductType: {
  PRODUCT: 'PRODUCT',
  SUBSCRIPTION: 'SUBSCRIPTION'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const SubscriptionInterval: {
  DAY: 'DAY',
  WEEK: 'WEEK',
  MONTH: 'MONTH',
  YEAR: 'YEAR'
};

export type SubscriptionInterval = (typeof SubscriptionInterval)[keyof typeof SubscriptionInterval]


export const Currency: {
  BRL: 'BRL',
  USD: 'USD',
  EUR: 'EUR',
  MXN: 'MXN'
};

export type Currency = (typeof Currency)[keyof typeof Currency]


export const PaymentMethod: {
  CARD: 'CARD',
  PIX: 'PIX',
  BOLETO: 'BOLETO',
  PAYPAL: 'PAYPAL',
  OPEN_FINANCE: 'OPEN_FINANCE',
  OPEN_FINANCE_AUTOMATIC: 'OPEN_FINANCE_AUTOMATIC'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentProvider: {
  KRXPAY: 'KRXPAY',
  STRIPE: 'STRIPE',
  ADYEN: 'ADYEN',
  APPMAX: 'APPMAX',
  PAYPAL: 'PAYPAL',
  MERCADOPAGO: 'MERCADOPAGO',
  PAGARME: 'PAGARME',
  OPENFINANCE: 'OPENFINANCE'
};

export type PaymentProvider = (typeof PaymentProvider)[keyof typeof PaymentProvider]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  REQUIRES_ACTION: 'REQUIRES_ACTION',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED',
  EXPIRED: 'EXPIRED',
  REFUNDING: 'REFUNDING',
  REFUNDED: 'REFUNDED',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED',
  CHARGEBACK: 'CHARGEBACK',
  DISPUTED: 'DISPUTED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const CheckoutSessionStatus: {
  started: 'started',
  pix_generated: 'pix_generated',
  paid: 'paid',
  abandoned: 'abandoned',
  canceled: 'canceled'
};

export type CheckoutSessionStatus = (typeof CheckoutSessionStatus)[keyof typeof CheckoutSessionStatus]


export const CheckoutPaymentMethod: {
  pix: 'pix',
  card: 'card',
  pix_ob: 'pix_ob',
  unknown: 'unknown'
};

export type CheckoutPaymentMethod = (typeof CheckoutPaymentMethod)[keyof typeof CheckoutPaymentMethod]


export const PaymentTypeOB: {
  SINGLE: 'SINGLE',
  RECURRING: 'RECURRING'
};

export type PaymentTypeOB = (typeof PaymentTypeOB)[keyof typeof PaymentTypeOB]


export const PaymentStatusOB: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED',
  ACCP: 'ACCP',
  PAGO: 'PAGO',
  RJCT: 'RJCT',
  CANC: 'CANC'
};

export type PaymentStatusOB = (typeof PaymentStatusOB)[keyof typeof PaymentStatusOB]


export const EnrollmentStatusOB: {
  PENDING: 'PENDING',
  AUTHORISED: 'AUTHORISED',
  REJECTED: 'REJECTED',
  REVOKED: 'REVOKED',
  EXPIRED: 'EXPIRED'
};

export type EnrollmentStatusOB = (typeof EnrollmentStatusOB)[keyof typeof EnrollmentStatusOB]


export const ConsentStatusOB: {
  AWAITING_AUTHORISATION: 'AWAITING_AUTHORISATION',
  AUTHORISED: 'AUTHORISED',
  REJECTED: 'REJECTED',
  CONSUMED: 'CONSUMED',
  EXPIRED: 'EXPIRED'
};

export type ConsentStatusOB = (typeof ConsentStatusOB)[keyof typeof ConsentStatusOB]


export const EventType: {
  customer_created: 'customer_created',
  customer_updated: 'customer_updated',
  customer_visit: 'customer_visit',
  lead_created: 'lead_created',
  lead_converted: 'lead_converted',
  review_submitted: 'review_submitted',
  feedback_negative: 'feedback_negative',
  purchase_made: 'purchase_made',
  purchase_refund: 'purchase_refund',
  payment_processed: 'payment_processed',
  subscription_billed: 'subscription_billed',
  subscription_canceled: 'subscription_canceled',
  chargeback_reported: 'chargeback_reported',
  reward_created: 'reward_created',
  reward_offered: 'reward_offered',
  reward_viewed: 'reward_viewed',
  reward_claimed: 'reward_claimed',
  reward_redeemed: 'reward_redeemed',
  reward_expired: 'reward_expired',
  points_earned: 'points_earned',
  points_spent: 'points_spent',
  campaign_sent: 'campaign_sent',
  campaign_opened: 'campaign_opened',
  campaign_clicked: 'campaign_clicked',
  campaign_replied: 'campaign_replied',
  conversation_started: 'conversation_started',
  conversation_closed: 'conversation_closed',
  membership_started: 'membership_started',
  membership_renewed: 'membership_renewed',
  membership_canceled: 'membership_canceled',
  membership_upgraded: 'membership_upgraded',
  prediction_made: 'prediction_made',
  action_taken: 'action_taken',
  outcome_recorded: 'outcome_recorded',
  user_logged_in: 'user_logged_in',
  config_changed: 'config_changed',
  integration_added: 'integration_added'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const EventActor: {
  customer: 'customer',
  clinic: 'clinic',
  system: 'system',
  ai: 'ai'
};

export type EventActor = (typeof EventActor)[keyof typeof EventActor]

}

export type ClinicRole = $Enums.ClinicRole

export const ClinicRole: typeof $Enums.ClinicRole

export type ClinicTheme = $Enums.ClinicTheme

export const ClinicTheme: typeof $Enums.ClinicTheme

export type MerchantStatus = $Enums.MerchantStatus

export const MerchantStatus: typeof $Enums.MerchantStatus

export type MerchantType = $Enums.MerchantType

export const MerchantType: typeof $Enums.MerchantType

export type MerchantAppStatus = $Enums.MerchantAppStatus

export const MerchantAppStatus: typeof $Enums.MerchantAppStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type DocumentStatus = $Enums.DocumentStatus

export const DocumentStatus: typeof $Enums.DocumentStatus

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type PlanTier = $Enums.PlanTier

export const PlanTier: typeof $Enums.PlanTier

export type AddOnType = $Enums.AddOnType

export const AddOnType: typeof $Enums.AddOnType

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type SubscriptionInterval = $Enums.SubscriptionInterval

export const SubscriptionInterval: typeof $Enums.SubscriptionInterval

export type Currency = $Enums.Currency

export const Currency: typeof $Enums.Currency

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentProvider = $Enums.PaymentProvider

export const PaymentProvider: typeof $Enums.PaymentProvider

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type CheckoutSessionStatus = $Enums.CheckoutSessionStatus

export const CheckoutSessionStatus: typeof $Enums.CheckoutSessionStatus

export type CheckoutPaymentMethod = $Enums.CheckoutPaymentMethod

export const CheckoutPaymentMethod: typeof $Enums.CheckoutPaymentMethod

export type PaymentTypeOB = $Enums.PaymentTypeOB

export const PaymentTypeOB: typeof $Enums.PaymentTypeOB

export type PaymentStatusOB = $Enums.PaymentStatusOB

export const PaymentStatusOB: typeof $Enums.PaymentStatusOB

export type EnrollmentStatusOB = $Enums.EnrollmentStatusOB

export const EnrollmentStatusOB: typeof $Enums.EnrollmentStatusOB

export type ConsentStatusOB = $Enums.ConsentStatusOB

export const ConsentStatusOB: typeof $Enums.ConsentStatusOB

export type EventType = $Enums.EventType

export const EventType: typeof $Enums.EventType

export type EventActor = $Enums.EventActor

export const EventActor: typeof $Enums.EventActor

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationCode`: Exposes CRUD operations for the **VerificationCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationCodes
    * const verificationCodes = await prisma.verificationCode.findMany()
    * ```
    */
  get verificationCode(): Prisma.VerificationCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patientProfile`: Exposes CRUD operations for the **PatientProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientProfiles
    * const patientProfiles = await prisma.patientProfile.findMany()
    * ```
    */
  get patientProfile(): Prisma.PatientProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pointsLedger`: Exposes CRUD operations for the **PointsLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointsLedgers
    * const pointsLedgers = await prisma.pointsLedger.findMany()
    * ```
    */
  get pointsLedger(): Prisma.PointsLedgerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinic`: Exposes CRUD operations for the **Clinic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinics
    * const clinics = await prisma.clinic.findMany()
    * ```
    */
  get clinic(): Prisma.ClinicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicMember`: Exposes CRUD operations for the **ClinicMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicMembers
    * const clinicMembers = await prisma.clinicMember.findMany()
    * ```
    */
  get clinicMember(): Prisma.ClinicMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchant`: Exposes CRUD operations for the **Merchant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Merchants
    * const merchants = await prisma.merchant.findMany()
    * ```
    */
  get merchant(): Prisma.MerchantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchantApplication`: Exposes CRUD operations for the **MerchantApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MerchantApplications
    * const merchantApplications = await prisma.merchantApplication.findMany()
    * ```
    */
  get merchantApplication(): Prisma.MerchantApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchantDocument`: Exposes CRUD operations for the **MerchantDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MerchantDocuments
    * const merchantDocuments = await prisma.merchantDocument.findMany()
    * ```
    */
  get merchantDocument(): Prisma.MerchantDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchantIntegration`: Exposes CRUD operations for the **MerchantIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MerchantIntegrations
    * const merchantIntegrations = await prisma.merchantIntegration.findMany()
    * ```
    */
  get merchantIntegration(): Prisma.MerchantIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentRoutingRule`: Exposes CRUD operations for the **PaymentRoutingRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentRoutingRules
    * const paymentRoutingRules = await prisma.paymentRoutingRule.findMany()
    * ```
    */
  get paymentRoutingRule(): Prisma.PaymentRoutingRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicPlan`: Exposes CRUD operations for the **ClinicPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicPlans
    * const clinicPlans = await prisma.clinicPlan.findMany()
    * ```
    */
  get clinicPlan(): Prisma.ClinicPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicAddOn`: Exposes CRUD operations for the **ClinicAddOn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicAddOns
    * const clinicAddOns = await prisma.clinicAddOn.findMany()
    * ```
    */
  get clinicAddOn(): Prisma.ClinicAddOnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicSubscription`: Exposes CRUD operations for the **ClinicSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicSubscriptions
    * const clinicSubscriptions = await prisma.clinicSubscription.findMany()
    * ```
    */
  get clinicSubscription(): Prisma.ClinicSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicAddOnSubscription`: Exposes CRUD operations for the **ClinicAddOnSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicAddOnSubscriptions
    * const clinicAddOnSubscriptions = await prisma.clinicAddOnSubscription.findMany()
    * ```
    */
  get clinicAddOnSubscription(): Prisma.ClinicAddOnSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoriesOnProducts`: Exposes CRUD operations for the **CategoriesOnProducts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoriesOnProducts
    * const categoriesOnProducts = await prisma.categoriesOnProducts.findMany()
    * ```
    */
  get categoriesOnProducts(): Prisma.CategoriesOnProductsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offerPrice`: Exposes CRUD operations for the **OfferPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferPrices
    * const offerPrices = await prisma.offerPrice.findMany()
    * ```
    */
  get offerPrice(): Prisma.OfferPriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offerPaymentMethod`: Exposes CRUD operations for the **OfferPaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferPaymentMethods
    * const offerPaymentMethods = await prisma.offerPaymentMethod.findMany()
    * ```
    */
  get offerPaymentMethod(): Prisma.OfferPaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productIntegration`: Exposes CRUD operations for the **ProductIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductIntegrations
    * const productIntegrations = await prisma.productIntegration.findMany()
    * ```
    */
  get productIntegration(): Prisma.ProductIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checkoutSession`: Exposes CRUD operations for the **CheckoutSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckoutSessions
    * const checkoutSessions = await prisma.checkoutSession.findMany()
    * ```
    */
  get checkoutSession(): Prisma.CheckoutSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentTransaction`: Exposes CRUD operations for the **PaymentTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentTransactions
    * const paymentTransactions = await prisma.paymentTransaction.findMany()
    * ```
    */
  get paymentTransaction(): Prisma.PaymentTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerProvider`: Exposes CRUD operations for the **CustomerProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerProviders
    * const customerProviders = await prisma.customerProvider.findMany()
    * ```
    */
  get customerProvider(): Prisma.CustomerProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerPaymentMethod`: Exposes CRUD operations for the **CustomerPaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerPaymentMethods
    * const customerPaymentMethods = await prisma.customerPaymentMethod.findMany()
    * ```
    */
  get customerPaymentMethod(): Prisma.CustomerPaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerSubscription`: Exposes CRUD operations for the **CustomerSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerSubscriptions
    * const customerSubscriptions = await prisma.customerSubscription.findMany()
    * ```
    */
  get customerSubscription(): Prisma.CustomerSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentCustomer`: Exposes CRUD operations for the **PaymentCustomer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentCustomers
    * const paymentCustomers = await prisma.paymentCustomer.findMany()
    * ```
    */
  get paymentCustomer(): Prisma.PaymentCustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageTemplate`: Exposes CRUD operations for the **MessageTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageTemplates
    * const messageTemplates = await prisma.messageTemplate.findMany()
    * ```
    */
  get messageTemplate(): Prisma.MessageTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageSequence`: Exposes CRUD operations for the **MessageSequence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageSequences
    * const messageSequences = await prisma.messageSequence.findMany()
    * ```
    */
  get messageSequence(): Prisma.MessageSequenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageSequenceStep`: Exposes CRUD operations for the **MessageSequenceStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageSequenceSteps
    * const messageSequenceSteps = await prisma.messageSequenceStep.findMany()
    * ```
    */
  get messageSequenceStep(): Prisma.MessageSequenceStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignJob`: Exposes CRUD operations for the **CampaignJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignJobs
    * const campaignJobs = await prisma.campaignJob.findMany()
    * ```
    */
  get campaignJob(): Prisma.CampaignJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.openFinanceLink`: Exposes CRUD operations for the **OpenFinanceLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpenFinanceLinks
    * const openFinanceLinks = await prisma.openFinanceLink.findMany()
    * ```
    */
  get openFinanceLink(): Prisma.OpenFinanceLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.openFinanceConsent`: Exposes CRUD operations for the **OpenFinanceConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpenFinanceConsents
    * const openFinanceConsents = await prisma.openFinanceConsent.findMany()
    * ```
    */
  get openFinanceConsent(): Prisma.OpenFinanceConsentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.openBankingPayment`: Exposes CRUD operations for the **OpenBankingPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpenBankingPayments
    * const openBankingPayments = await prisma.openBankingPayment.findMany()
    * ```
    */
  get openBankingPayment(): Prisma.OpenBankingPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.openBankingConsent`: Exposes CRUD operations for the **OpenBankingConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpenBankingConsents
    * const openBankingConsents = await prisma.openBankingConsent.findMany()
    * ```
    */
  get openBankingConsent(): Prisma.OpenBankingConsentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollmentContext`: Exposes CRUD operations for the **EnrollmentContext** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnrollmentContexts
    * const enrollmentContexts = await prisma.enrollmentContext.findMany()
    * ```
    */
  get enrollmentContext(): Prisma.EnrollmentContextDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentConsent`: Exposes CRUD operations for the **PaymentConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentConsents
    * const paymentConsents = await prisma.paymentConsent.findMany()
    * ```
    */
  get paymentConsent(): Prisma.PaymentConsentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oAuthState`: Exposes CRUD operations for the **OAuthState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthStates
    * const oAuthStates = await prisma.oAuthState.findMany()
    * ```
    */
  get oAuthState(): Prisma.OAuthStateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oAuthStateMeta`: Exposes CRUD operations for the **OAuthStateMeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthStateMetas
    * const oAuthStateMetas = await prisma.oAuthStateMeta.findMany()
    * ```
    */
  get oAuthStateMeta(): Prisma.OAuthStateMetaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oAuthToken`: Exposes CRUD operations for the **OAuthToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthTokens
    * const oAuthTokens = await prisma.oAuthToken.findMany()
    * ```
    */
  get oAuthToken(): Prisma.OAuthTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookEvent`: Exposes CRUD operations for the **WebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookEvents
    * const webhookEvents = await prisma.webhookEvent.findMany()
    * ```
    */
  get webhookEvent(): Prisma.WebhookEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookEndpoint`: Exposes CRUD operations for the **WebhookEndpoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookEndpoints
    * const webhookEndpoints = await prisma.webhookEndpoint.findMany()
    * ```
    */
  get webhookEndpoint(): Prisma.WebhookEndpointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outboundWebhookEvent`: Exposes CRUD operations for the **OutboundWebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutboundWebhookEvents
    * const outboundWebhookEvents = await prisma.outboundWebhookEvent.findMany()
    * ```
    */
  get outboundWebhookEvent(): Prisma.OutboundWebhookEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outboundWebhookDelivery`: Exposes CRUD operations for the **OutboundWebhookDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutboundWebhookDeliveries
    * const outboundWebhookDeliveries = await prisma.outboundWebhookDelivery.findMany()
    * ```
    */
  get outboundWebhookDelivery(): Prisma.OutboundWebhookDeliveryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    VerificationCode: 'VerificationCode',
    PatientProfile: 'PatientProfile',
    PointsLedger: 'PointsLedger',
    Clinic: 'Clinic',
    ClinicMember: 'ClinicMember',
    Merchant: 'Merchant',
    MerchantApplication: 'MerchantApplication',
    MerchantDocument: 'MerchantDocument',
    MerchantIntegration: 'MerchantIntegration',
    PaymentRoutingRule: 'PaymentRoutingRule',
    ClinicPlan: 'ClinicPlan',
    ClinicAddOn: 'ClinicAddOn',
    ClinicSubscription: 'ClinicSubscription',
    ClinicAddOnSubscription: 'ClinicAddOnSubscription',
    ProductCategory: 'ProductCategory',
    Product: 'Product',
    CategoriesOnProducts: 'CategoriesOnProducts',
    Offer: 'Offer',
    OfferPrice: 'OfferPrice',
    OfferPaymentMethod: 'OfferPaymentMethod',
    ProductIntegration: 'ProductIntegration',
    CheckoutSession: 'CheckoutSession',
    PaymentTransaction: 'PaymentTransaction',
    Purchase: 'Purchase',
    Customer: 'Customer',
    CustomerProvider: 'CustomerProvider',
    CustomerPaymentMethod: 'CustomerPaymentMethod',
    CustomerSubscription: 'CustomerSubscription',
    PaymentCustomer: 'PaymentCustomer',
    MessageTemplate: 'MessageTemplate',
    MessageSequence: 'MessageSequence',
    MessageSequenceStep: 'MessageSequenceStep',
    CampaignJob: 'CampaignJob',
    OpenFinanceLink: 'OpenFinanceLink',
    OpenFinanceConsent: 'OpenFinanceConsent',
    OpenBankingPayment: 'OpenBankingPayment',
    OpenBankingConsent: 'OpenBankingConsent',
    EnrollmentContext: 'EnrollmentContext',
    PaymentConsent: 'PaymentConsent',
    OAuthState: 'OAuthState',
    OAuthStateMeta: 'OAuthStateMeta',
    OAuthToken: 'OAuthToken',
    Event: 'Event',
    WebhookEvent: 'WebhookEvent',
    WebhookEndpoint: 'WebhookEndpoint',
    OutboundWebhookEvent: 'OutboundWebhookEvent',
    OutboundWebhookDelivery: 'OutboundWebhookDelivery'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "verificationCode" | "patientProfile" | "pointsLedger" | "clinic" | "clinicMember" | "merchant" | "merchantApplication" | "merchantDocument" | "merchantIntegration" | "paymentRoutingRule" | "clinicPlan" | "clinicAddOn" | "clinicSubscription" | "clinicAddOnSubscription" | "productCategory" | "product" | "categoriesOnProducts" | "offer" | "offerPrice" | "offerPaymentMethod" | "productIntegration" | "checkoutSession" | "paymentTransaction" | "purchase" | "customer" | "customerProvider" | "customerPaymentMethod" | "customerSubscription" | "paymentCustomer" | "messageTemplate" | "messageSequence" | "messageSequenceStep" | "campaignJob" | "openFinanceLink" | "openFinanceConsent" | "openBankingPayment" | "openBankingConsent" | "enrollmentContext" | "paymentConsent" | "oAuthState" | "oAuthStateMeta" | "oAuthToken" | "event" | "webhookEvent" | "webhookEndpoint" | "outboundWebhookEvent" | "outboundWebhookDelivery"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      VerificationCode: {
        payload: Prisma.$VerificationCodePayload<ExtArgs>
        fields: Prisma.VerificationCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          findFirst: {
            args: Prisma.VerificationCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          findMany: {
            args: Prisma.VerificationCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          create: {
            args: Prisma.VerificationCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          createMany: {
            args: Prisma.VerificationCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          delete: {
            args: Prisma.VerificationCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          update: {
            args: Prisma.VerificationCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          deleteMany: {
            args: Prisma.VerificationCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          upsert: {
            args: Prisma.VerificationCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          aggregate: {
            args: Prisma.VerificationCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationCode>
          }
          groupBy: {
            args: Prisma.VerificationCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCodeCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCodeCountAggregateOutputType> | number
          }
        }
      }
      PatientProfile: {
        payload: Prisma.$PatientProfilePayload<ExtArgs>
        fields: Prisma.PatientProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          findFirst: {
            args: Prisma.PatientProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          findMany: {
            args: Prisma.PatientProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>[]
          }
          create: {
            args: Prisma.PatientProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          createMany: {
            args: Prisma.PatientProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>[]
          }
          delete: {
            args: Prisma.PatientProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          update: {
            args: Prisma.PatientProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          deleteMany: {
            args: Prisma.PatientProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>[]
          }
          upsert: {
            args: Prisma.PatientProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          aggregate: {
            args: Prisma.PatientProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientProfile>
          }
          groupBy: {
            args: Prisma.PatientProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientProfileCountArgs<ExtArgs>
            result: $Utils.Optional<PatientProfileCountAggregateOutputType> | number
          }
        }
      }
      PointsLedger: {
        payload: Prisma.$PointsLedgerPayload<ExtArgs>
        fields: Prisma.PointsLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointsLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointsLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerPayload>
          }
          findFirst: {
            args: Prisma.PointsLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointsLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerPayload>
          }
          findMany: {
            args: Prisma.PointsLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerPayload>[]
          }
          create: {
            args: Prisma.PointsLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerPayload>
          }
          createMany: {
            args: Prisma.PointsLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointsLedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerPayload>[]
          }
          delete: {
            args: Prisma.PointsLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerPayload>
          }
          update: {
            args: Prisma.PointsLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerPayload>
          }
          deleteMany: {
            args: Prisma.PointsLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointsLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PointsLedgerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerPayload>[]
          }
          upsert: {
            args: Prisma.PointsLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerPayload>
          }
          aggregate: {
            args: Prisma.PointsLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointsLedger>
          }
          groupBy: {
            args: Prisma.PointsLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointsLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointsLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<PointsLedgerCountAggregateOutputType> | number
          }
        }
      }
      Clinic: {
        payload: Prisma.$ClinicPayload<ExtArgs>
        fields: Prisma.ClinicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findFirst: {
            args: Prisma.ClinicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findMany: {
            args: Prisma.ClinicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          create: {
            args: Prisma.ClinicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          createMany: {
            args: Prisma.ClinicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          delete: {
            args: Prisma.ClinicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          update: {
            args: Prisma.ClinicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          deleteMany: {
            args: Prisma.ClinicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          upsert: {
            args: Prisma.ClinicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          aggregate: {
            args: Prisma.ClinicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinic>
          }
          groupBy: {
            args: Prisma.ClinicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicCountAggregateOutputType> | number
          }
        }
      }
      ClinicMember: {
        payload: Prisma.$ClinicMemberPayload<ExtArgs>
        fields: Prisma.ClinicMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicMemberPayload>
          }
          findFirst: {
            args: Prisma.ClinicMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicMemberPayload>
          }
          findMany: {
            args: Prisma.ClinicMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicMemberPayload>[]
          }
          create: {
            args: Prisma.ClinicMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicMemberPayload>
          }
          createMany: {
            args: Prisma.ClinicMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicMemberPayload>[]
          }
          delete: {
            args: Prisma.ClinicMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicMemberPayload>
          }
          update: {
            args: Prisma.ClinicMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicMemberPayload>
          }
          deleteMany: {
            args: Prisma.ClinicMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicMemberPayload>[]
          }
          upsert: {
            args: Prisma.ClinicMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicMemberPayload>
          }
          aggregate: {
            args: Prisma.ClinicMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicMember>
          }
          groupBy: {
            args: Prisma.ClinicMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicMemberCountAggregateOutputType> | number
          }
        }
      }
      Merchant: {
        payload: Prisma.$MerchantPayload<ExtArgs>
        fields: Prisma.MerchantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerchantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerchantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findFirst: {
            args: Prisma.MerchantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerchantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findMany: {
            args: Prisma.MerchantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          create: {
            args: Prisma.MerchantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          createMany: {
            args: Prisma.MerchantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerchantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          delete: {
            args: Prisma.MerchantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          update: {
            args: Prisma.MerchantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          deleteMany: {
            args: Prisma.MerchantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerchantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MerchantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          upsert: {
            args: Prisma.MerchantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          aggregate: {
            args: Prisma.MerchantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchant>
          }
          groupBy: {
            args: Prisma.MerchantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerchantCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantCountAggregateOutputType> | number
          }
        }
      }
      MerchantApplication: {
        payload: Prisma.$MerchantApplicationPayload<ExtArgs>
        fields: Prisma.MerchantApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerchantApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerchantApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantApplicationPayload>
          }
          findFirst: {
            args: Prisma.MerchantApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerchantApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantApplicationPayload>
          }
          findMany: {
            args: Prisma.MerchantApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantApplicationPayload>[]
          }
          create: {
            args: Prisma.MerchantApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantApplicationPayload>
          }
          createMany: {
            args: Prisma.MerchantApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerchantApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantApplicationPayload>[]
          }
          delete: {
            args: Prisma.MerchantApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantApplicationPayload>
          }
          update: {
            args: Prisma.MerchantApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantApplicationPayload>
          }
          deleteMany: {
            args: Prisma.MerchantApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerchantApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MerchantApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantApplicationPayload>[]
          }
          upsert: {
            args: Prisma.MerchantApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantApplicationPayload>
          }
          aggregate: {
            args: Prisma.MerchantApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchantApplication>
          }
          groupBy: {
            args: Prisma.MerchantApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerchantApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantApplicationCountAggregateOutputType> | number
          }
        }
      }
      MerchantDocument: {
        payload: Prisma.$MerchantDocumentPayload<ExtArgs>
        fields: Prisma.MerchantDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerchantDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerchantDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantDocumentPayload>
          }
          findFirst: {
            args: Prisma.MerchantDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerchantDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantDocumentPayload>
          }
          findMany: {
            args: Prisma.MerchantDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantDocumentPayload>[]
          }
          create: {
            args: Prisma.MerchantDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantDocumentPayload>
          }
          createMany: {
            args: Prisma.MerchantDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerchantDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantDocumentPayload>[]
          }
          delete: {
            args: Prisma.MerchantDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantDocumentPayload>
          }
          update: {
            args: Prisma.MerchantDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantDocumentPayload>
          }
          deleteMany: {
            args: Prisma.MerchantDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerchantDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MerchantDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantDocumentPayload>[]
          }
          upsert: {
            args: Prisma.MerchantDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantDocumentPayload>
          }
          aggregate: {
            args: Prisma.MerchantDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchantDocument>
          }
          groupBy: {
            args: Prisma.MerchantDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerchantDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantDocumentCountAggregateOutputType> | number
          }
        }
      }
      MerchantIntegration: {
        payload: Prisma.$MerchantIntegrationPayload<ExtArgs>
        fields: Prisma.MerchantIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerchantIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerchantIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantIntegrationPayload>
          }
          findFirst: {
            args: Prisma.MerchantIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerchantIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantIntegrationPayload>
          }
          findMany: {
            args: Prisma.MerchantIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantIntegrationPayload>[]
          }
          create: {
            args: Prisma.MerchantIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantIntegrationPayload>
          }
          createMany: {
            args: Prisma.MerchantIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerchantIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantIntegrationPayload>[]
          }
          delete: {
            args: Prisma.MerchantIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantIntegrationPayload>
          }
          update: {
            args: Prisma.MerchantIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.MerchantIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerchantIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MerchantIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.MerchantIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantIntegrationPayload>
          }
          aggregate: {
            args: Prisma.MerchantIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchantIntegration>
          }
          groupBy: {
            args: Prisma.MerchantIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerchantIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantIntegrationCountAggregateOutputType> | number
          }
        }
      }
      PaymentRoutingRule: {
        payload: Prisma.$PaymentRoutingRulePayload<ExtArgs>
        fields: Prisma.PaymentRoutingRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentRoutingRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRoutingRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentRoutingRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRoutingRulePayload>
          }
          findFirst: {
            args: Prisma.PaymentRoutingRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRoutingRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentRoutingRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRoutingRulePayload>
          }
          findMany: {
            args: Prisma.PaymentRoutingRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRoutingRulePayload>[]
          }
          create: {
            args: Prisma.PaymentRoutingRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRoutingRulePayload>
          }
          createMany: {
            args: Prisma.PaymentRoutingRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentRoutingRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRoutingRulePayload>[]
          }
          delete: {
            args: Prisma.PaymentRoutingRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRoutingRulePayload>
          }
          update: {
            args: Prisma.PaymentRoutingRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRoutingRulePayload>
          }
          deleteMany: {
            args: Prisma.PaymentRoutingRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentRoutingRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentRoutingRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRoutingRulePayload>[]
          }
          upsert: {
            args: Prisma.PaymentRoutingRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRoutingRulePayload>
          }
          aggregate: {
            args: Prisma.PaymentRoutingRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentRoutingRule>
          }
          groupBy: {
            args: Prisma.PaymentRoutingRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentRoutingRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentRoutingRuleCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentRoutingRuleCountAggregateOutputType> | number
          }
        }
      }
      ClinicPlan: {
        payload: Prisma.$ClinicPlanPayload<ExtArgs>
        fields: Prisma.ClinicPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPlanPayload>
          }
          findFirst: {
            args: Prisma.ClinicPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPlanPayload>
          }
          findMany: {
            args: Prisma.ClinicPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPlanPayload>[]
          }
          create: {
            args: Prisma.ClinicPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPlanPayload>
          }
          createMany: {
            args: Prisma.ClinicPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPlanPayload>[]
          }
          delete: {
            args: Prisma.ClinicPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPlanPayload>
          }
          update: {
            args: Prisma.ClinicPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPlanPayload>
          }
          deleteMany: {
            args: Prisma.ClinicPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPlanPayload>[]
          }
          upsert: {
            args: Prisma.ClinicPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPlanPayload>
          }
          aggregate: {
            args: Prisma.ClinicPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicPlan>
          }
          groupBy: {
            args: Prisma.ClinicPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicPlanCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicPlanCountAggregateOutputType> | number
          }
        }
      }
      ClinicAddOn: {
        payload: Prisma.$ClinicAddOnPayload<ExtArgs>
        fields: Prisma.ClinicAddOnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicAddOnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicAddOnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnPayload>
          }
          findFirst: {
            args: Prisma.ClinicAddOnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicAddOnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnPayload>
          }
          findMany: {
            args: Prisma.ClinicAddOnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnPayload>[]
          }
          create: {
            args: Prisma.ClinicAddOnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnPayload>
          }
          createMany: {
            args: Prisma.ClinicAddOnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicAddOnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnPayload>[]
          }
          delete: {
            args: Prisma.ClinicAddOnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnPayload>
          }
          update: {
            args: Prisma.ClinicAddOnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnPayload>
          }
          deleteMany: {
            args: Prisma.ClinicAddOnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicAddOnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicAddOnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnPayload>[]
          }
          upsert: {
            args: Prisma.ClinicAddOnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnPayload>
          }
          aggregate: {
            args: Prisma.ClinicAddOnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicAddOn>
          }
          groupBy: {
            args: Prisma.ClinicAddOnGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicAddOnGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicAddOnCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicAddOnCountAggregateOutputType> | number
          }
        }
      }
      ClinicSubscription: {
        payload: Prisma.$ClinicSubscriptionPayload<ExtArgs>
        fields: Prisma.ClinicSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.ClinicSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicSubscriptionPayload>
          }
          findMany: {
            args: Prisma.ClinicSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicSubscriptionPayload>[]
          }
          create: {
            args: Prisma.ClinicSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicSubscriptionPayload>
          }
          createMany: {
            args: Prisma.ClinicSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.ClinicSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicSubscriptionPayload>
          }
          update: {
            args: Prisma.ClinicSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.ClinicSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.ClinicSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.ClinicSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicSubscription>
          }
          groupBy: {
            args: Prisma.ClinicSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      ClinicAddOnSubscription: {
        payload: Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>
        fields: Prisma.ClinicAddOnSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicAddOnSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicAddOnSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.ClinicAddOnSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicAddOnSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnSubscriptionPayload>
          }
          findMany: {
            args: Prisma.ClinicAddOnSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnSubscriptionPayload>[]
          }
          create: {
            args: Prisma.ClinicAddOnSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnSubscriptionPayload>
          }
          createMany: {
            args: Prisma.ClinicAddOnSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicAddOnSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.ClinicAddOnSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnSubscriptionPayload>
          }
          update: {
            args: Prisma.ClinicAddOnSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.ClinicAddOnSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicAddOnSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicAddOnSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.ClinicAddOnSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicAddOnSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.ClinicAddOnSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicAddOnSubscription>
          }
          groupBy: {
            args: Prisma.ClinicAddOnSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicAddOnSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicAddOnSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicAddOnSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      CategoriesOnProducts: {
        payload: Prisma.$CategoriesOnProductsPayload<ExtArgs>
        fields: Prisma.CategoriesOnProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriesOnProductsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesOnProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriesOnProductsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesOnProductsPayload>
          }
          findFirst: {
            args: Prisma.CategoriesOnProductsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesOnProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriesOnProductsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesOnProductsPayload>
          }
          findMany: {
            args: Prisma.CategoriesOnProductsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesOnProductsPayload>[]
          }
          create: {
            args: Prisma.CategoriesOnProductsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesOnProductsPayload>
          }
          createMany: {
            args: Prisma.CategoriesOnProductsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoriesOnProductsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesOnProductsPayload>[]
          }
          delete: {
            args: Prisma.CategoriesOnProductsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesOnProductsPayload>
          }
          update: {
            args: Prisma.CategoriesOnProductsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesOnProductsPayload>
          }
          deleteMany: {
            args: Prisma.CategoriesOnProductsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriesOnProductsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoriesOnProductsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesOnProductsPayload>[]
          }
          upsert: {
            args: Prisma.CategoriesOnProductsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesOnProductsPayload>
          }
          aggregate: {
            args: Prisma.CategoriesOnProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoriesOnProducts>
          }
          groupBy: {
            args: Prisma.CategoriesOnProductsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesOnProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriesOnProductsCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesOnProductsCountAggregateOutputType> | number
          }
        }
      }
      Offer: {
        payload: Prisma.$OfferPayload<ExtArgs>
        fields: Prisma.OfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findFirst: {
            args: Prisma.OfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findMany: {
            args: Prisma.OfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          create: {
            args: Prisma.OfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          createMany: {
            args: Prisma.OfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          delete: {
            args: Prisma.OfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          update: {
            args: Prisma.OfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          deleteMany: {
            args: Prisma.OfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OfferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          upsert: {
            args: Prisma.OfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          aggregate: {
            args: Prisma.OfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffer>
          }
          groupBy: {
            args: Prisma.OfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferCountArgs<ExtArgs>
            result: $Utils.Optional<OfferCountAggregateOutputType> | number
          }
        }
      }
      OfferPrice: {
        payload: Prisma.$OfferPricePayload<ExtArgs>
        fields: Prisma.OfferPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPricePayload>
          }
          findFirst: {
            args: Prisma.OfferPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPricePayload>
          }
          findMany: {
            args: Prisma.OfferPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPricePayload>[]
          }
          create: {
            args: Prisma.OfferPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPricePayload>
          }
          createMany: {
            args: Prisma.OfferPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPricePayload>[]
          }
          delete: {
            args: Prisma.OfferPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPricePayload>
          }
          update: {
            args: Prisma.OfferPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPricePayload>
          }
          deleteMany: {
            args: Prisma.OfferPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OfferPriceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPricePayload>[]
          }
          upsert: {
            args: Prisma.OfferPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPricePayload>
          }
          aggregate: {
            args: Prisma.OfferPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfferPrice>
          }
          groupBy: {
            args: Prisma.OfferPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferPriceCountArgs<ExtArgs>
            result: $Utils.Optional<OfferPriceCountAggregateOutputType> | number
          }
        }
      }
      OfferPaymentMethod: {
        payload: Prisma.$OfferPaymentMethodPayload<ExtArgs>
        fields: Prisma.OfferPaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferPaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferPaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.OfferPaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferPaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPaymentMethodPayload>
          }
          findMany: {
            args: Prisma.OfferPaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPaymentMethodPayload>[]
          }
          create: {
            args: Prisma.OfferPaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPaymentMethodPayload>
          }
          createMany: {
            args: Prisma.OfferPaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferPaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.OfferPaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPaymentMethodPayload>
          }
          update: {
            args: Prisma.OfferPaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.OfferPaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferPaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OfferPaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.OfferPaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.OfferPaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfferPaymentMethod>
          }
          groupBy: {
            args: Prisma.OfferPaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferPaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferPaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<OfferPaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      ProductIntegration: {
        payload: Prisma.$ProductIntegrationPayload<ExtArgs>
        fields: Prisma.ProductIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIntegrationPayload>
          }
          findFirst: {
            args: Prisma.ProductIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIntegrationPayload>
          }
          findMany: {
            args: Prisma.ProductIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIntegrationPayload>[]
          }
          create: {
            args: Prisma.ProductIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIntegrationPayload>
          }
          createMany: {
            args: Prisma.ProductIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIntegrationPayload>[]
          }
          delete: {
            args: Prisma.ProductIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIntegrationPayload>
          }
          update: {
            args: Prisma.ProductIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.ProductIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.ProductIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIntegrationPayload>
          }
          aggregate: {
            args: Prisma.ProductIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductIntegration>
          }
          groupBy: {
            args: Prisma.ProductIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductIntegrationCountAggregateOutputType> | number
          }
        }
      }
      CheckoutSession: {
        payload: Prisma.$CheckoutSessionPayload<ExtArgs>
        fields: Prisma.CheckoutSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckoutSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckoutSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutSessionPayload>
          }
          findFirst: {
            args: Prisma.CheckoutSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckoutSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutSessionPayload>
          }
          findMany: {
            args: Prisma.CheckoutSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutSessionPayload>[]
          }
          create: {
            args: Prisma.CheckoutSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutSessionPayload>
          }
          createMany: {
            args: Prisma.CheckoutSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheckoutSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutSessionPayload>[]
          }
          delete: {
            args: Prisma.CheckoutSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutSessionPayload>
          }
          update: {
            args: Prisma.CheckoutSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutSessionPayload>
          }
          deleteMany: {
            args: Prisma.CheckoutSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckoutSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CheckoutSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutSessionPayload>[]
          }
          upsert: {
            args: Prisma.CheckoutSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutSessionPayload>
          }
          aggregate: {
            args: Prisma.CheckoutSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckoutSession>
          }
          groupBy: {
            args: Prisma.CheckoutSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckoutSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckoutSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CheckoutSessionCountAggregateOutputType> | number
          }
        }
      }
      PaymentTransaction: {
        payload: Prisma.$PaymentTransactionPayload<ExtArgs>
        fields: Prisma.PaymentTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findFirst: {
            args: Prisma.PaymentTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findMany: {
            args: Prisma.PaymentTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          create: {
            args: Prisma.PaymentTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          createMany: {
            args: Prisma.PaymentTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          delete: {
            args: Prisma.PaymentTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          update: {
            args: Prisma.PaymentTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PaymentTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          upsert: {
            args: Prisma.PaymentTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          aggregate: {
            args: Prisma.PaymentTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentTransaction>
          }
          groupBy: {
            args: Prisma.PaymentTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerProvider: {
        payload: Prisma.$CustomerProviderPayload<ExtArgs>
        fields: Prisma.CustomerProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProviderPayload>
          }
          findFirst: {
            args: Prisma.CustomerProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProviderPayload>
          }
          findMany: {
            args: Prisma.CustomerProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProviderPayload>[]
          }
          create: {
            args: Prisma.CustomerProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProviderPayload>
          }
          createMany: {
            args: Prisma.CustomerProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProviderPayload>[]
          }
          delete: {
            args: Prisma.CustomerProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProviderPayload>
          }
          update: {
            args: Prisma.CustomerProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProviderPayload>
          }
          deleteMany: {
            args: Prisma.CustomerProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProviderPayload>[]
          }
          upsert: {
            args: Prisma.CustomerProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProviderPayload>
          }
          aggregate: {
            args: Prisma.CustomerProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerProvider>
          }
          groupBy: {
            args: Prisma.CustomerProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerProviderCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerProviderCountAggregateOutputType> | number
          }
        }
      }
      CustomerPaymentMethod: {
        payload: Prisma.$CustomerPaymentMethodPayload<ExtArgs>
        fields: Prisma.CustomerPaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerPaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerPaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.CustomerPaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerPaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentMethodPayload>
          }
          findMany: {
            args: Prisma.CustomerPaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentMethodPayload>[]
          }
          create: {
            args: Prisma.CustomerPaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentMethodPayload>
          }
          createMany: {
            args: Prisma.CustomerPaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerPaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.CustomerPaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentMethodPayload>
          }
          update: {
            args: Prisma.CustomerPaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.CustomerPaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerPaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerPaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.CustomerPaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.CustomerPaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerPaymentMethod>
          }
          groupBy: {
            args: Prisma.CustomerPaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerPaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerPaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerPaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      CustomerSubscription: {
        payload: Prisma.$CustomerSubscriptionPayload<ExtArgs>
        fields: Prisma.CustomerSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.CustomerSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubscriptionPayload>
          }
          findMany: {
            args: Prisma.CustomerSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubscriptionPayload>[]
          }
          create: {
            args: Prisma.CustomerSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubscriptionPayload>
          }
          createMany: {
            args: Prisma.CustomerSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.CustomerSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubscriptionPayload>
          }
          update: {
            args: Prisma.CustomerSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.CustomerSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.CustomerSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.CustomerSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerSubscription>
          }
          groupBy: {
            args: Prisma.CustomerSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      PaymentCustomer: {
        payload: Prisma.$PaymentCustomerPayload<ExtArgs>
        fields: Prisma.PaymentCustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentCustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentCustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentCustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentCustomerPayload>
          }
          findFirst: {
            args: Prisma.PaymentCustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentCustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentCustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentCustomerPayload>
          }
          findMany: {
            args: Prisma.PaymentCustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentCustomerPayload>[]
          }
          create: {
            args: Prisma.PaymentCustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentCustomerPayload>
          }
          createMany: {
            args: Prisma.PaymentCustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentCustomerPayload>[]
          }
          delete: {
            args: Prisma.PaymentCustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentCustomerPayload>
          }
          update: {
            args: Prisma.PaymentCustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentCustomerPayload>
          }
          deleteMany: {
            args: Prisma.PaymentCustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentCustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentCustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentCustomerPayload>[]
          }
          upsert: {
            args: Prisma.PaymentCustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentCustomerPayload>
          }
          aggregate: {
            args: Prisma.PaymentCustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentCustomer>
          }
          groupBy: {
            args: Prisma.PaymentCustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentCustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCustomerCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCustomerCountAggregateOutputType> | number
          }
        }
      }
      MessageTemplate: {
        payload: Prisma.$MessageTemplatePayload<ExtArgs>
        fields: Prisma.MessageTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findFirst: {
            args: Prisma.MessageTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findMany: {
            args: Prisma.MessageTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          create: {
            args: Prisma.MessageTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          createMany: {
            args: Prisma.MessageTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          delete: {
            args: Prisma.MessageTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          update: {
            args: Prisma.MessageTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          deleteMany: {
            args: Prisma.MessageTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          upsert: {
            args: Prisma.MessageTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          aggregate: {
            args: Prisma.MessageTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageTemplate>
          }
          groupBy: {
            args: Prisma.MessageTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateCountAggregateOutputType> | number
          }
        }
      }
      MessageSequence: {
        payload: Prisma.$MessageSequencePayload<ExtArgs>
        fields: Prisma.MessageSequenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageSequenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageSequenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequencePayload>
          }
          findFirst: {
            args: Prisma.MessageSequenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageSequenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequencePayload>
          }
          findMany: {
            args: Prisma.MessageSequenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequencePayload>[]
          }
          create: {
            args: Prisma.MessageSequenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequencePayload>
          }
          createMany: {
            args: Prisma.MessageSequenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageSequenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequencePayload>[]
          }
          delete: {
            args: Prisma.MessageSequenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequencePayload>
          }
          update: {
            args: Prisma.MessageSequenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequencePayload>
          }
          deleteMany: {
            args: Prisma.MessageSequenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageSequenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageSequenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequencePayload>[]
          }
          upsert: {
            args: Prisma.MessageSequenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequencePayload>
          }
          aggregate: {
            args: Prisma.MessageSequenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageSequence>
          }
          groupBy: {
            args: Prisma.MessageSequenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageSequenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageSequenceCountArgs<ExtArgs>
            result: $Utils.Optional<MessageSequenceCountAggregateOutputType> | number
          }
        }
      }
      MessageSequenceStep: {
        payload: Prisma.$MessageSequenceStepPayload<ExtArgs>
        fields: Prisma.MessageSequenceStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageSequenceStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequenceStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageSequenceStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequenceStepPayload>
          }
          findFirst: {
            args: Prisma.MessageSequenceStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequenceStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageSequenceStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequenceStepPayload>
          }
          findMany: {
            args: Prisma.MessageSequenceStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequenceStepPayload>[]
          }
          create: {
            args: Prisma.MessageSequenceStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequenceStepPayload>
          }
          createMany: {
            args: Prisma.MessageSequenceStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageSequenceStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequenceStepPayload>[]
          }
          delete: {
            args: Prisma.MessageSequenceStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequenceStepPayload>
          }
          update: {
            args: Prisma.MessageSequenceStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequenceStepPayload>
          }
          deleteMany: {
            args: Prisma.MessageSequenceStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageSequenceStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageSequenceStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequenceStepPayload>[]
          }
          upsert: {
            args: Prisma.MessageSequenceStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageSequenceStepPayload>
          }
          aggregate: {
            args: Prisma.MessageSequenceStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageSequenceStep>
          }
          groupBy: {
            args: Prisma.MessageSequenceStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageSequenceStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageSequenceStepCountArgs<ExtArgs>
            result: $Utils.Optional<MessageSequenceStepCountAggregateOutputType> | number
          }
        }
      }
      CampaignJob: {
        payload: Prisma.$CampaignJobPayload<ExtArgs>
        fields: Prisma.CampaignJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignJobPayload>
          }
          findFirst: {
            args: Prisma.CampaignJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignJobPayload>
          }
          findMany: {
            args: Prisma.CampaignJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignJobPayload>[]
          }
          create: {
            args: Prisma.CampaignJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignJobPayload>
          }
          createMany: {
            args: Prisma.CampaignJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignJobPayload>[]
          }
          delete: {
            args: Prisma.CampaignJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignJobPayload>
          }
          update: {
            args: Prisma.CampaignJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignJobPayload>
          }
          deleteMany: {
            args: Prisma.CampaignJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignJobPayload>[]
          }
          upsert: {
            args: Prisma.CampaignJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignJobPayload>
          }
          aggregate: {
            args: Prisma.CampaignJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignJob>
          }
          groupBy: {
            args: Prisma.CampaignJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignJobCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignJobCountAggregateOutputType> | number
          }
        }
      }
      OpenFinanceLink: {
        payload: Prisma.$OpenFinanceLinkPayload<ExtArgs>
        fields: Prisma.OpenFinanceLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpenFinanceLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpenFinanceLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceLinkPayload>
          }
          findFirst: {
            args: Prisma.OpenFinanceLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpenFinanceLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceLinkPayload>
          }
          findMany: {
            args: Prisma.OpenFinanceLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceLinkPayload>[]
          }
          create: {
            args: Prisma.OpenFinanceLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceLinkPayload>
          }
          createMany: {
            args: Prisma.OpenFinanceLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpenFinanceLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceLinkPayload>[]
          }
          delete: {
            args: Prisma.OpenFinanceLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceLinkPayload>
          }
          update: {
            args: Prisma.OpenFinanceLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceLinkPayload>
          }
          deleteMany: {
            args: Prisma.OpenFinanceLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpenFinanceLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpenFinanceLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceLinkPayload>[]
          }
          upsert: {
            args: Prisma.OpenFinanceLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceLinkPayload>
          }
          aggregate: {
            args: Prisma.OpenFinanceLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpenFinanceLink>
          }
          groupBy: {
            args: Prisma.OpenFinanceLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpenFinanceLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpenFinanceLinkCountArgs<ExtArgs>
            result: $Utils.Optional<OpenFinanceLinkCountAggregateOutputType> | number
          }
        }
      }
      OpenFinanceConsent: {
        payload: Prisma.$OpenFinanceConsentPayload<ExtArgs>
        fields: Prisma.OpenFinanceConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpenFinanceConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpenFinanceConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceConsentPayload>
          }
          findFirst: {
            args: Prisma.OpenFinanceConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpenFinanceConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceConsentPayload>
          }
          findMany: {
            args: Prisma.OpenFinanceConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceConsentPayload>[]
          }
          create: {
            args: Prisma.OpenFinanceConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceConsentPayload>
          }
          createMany: {
            args: Prisma.OpenFinanceConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpenFinanceConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceConsentPayload>[]
          }
          delete: {
            args: Prisma.OpenFinanceConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceConsentPayload>
          }
          update: {
            args: Prisma.OpenFinanceConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceConsentPayload>
          }
          deleteMany: {
            args: Prisma.OpenFinanceConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpenFinanceConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpenFinanceConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceConsentPayload>[]
          }
          upsert: {
            args: Prisma.OpenFinanceConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenFinanceConsentPayload>
          }
          aggregate: {
            args: Prisma.OpenFinanceConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpenFinanceConsent>
          }
          groupBy: {
            args: Prisma.OpenFinanceConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpenFinanceConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpenFinanceConsentCountArgs<ExtArgs>
            result: $Utils.Optional<OpenFinanceConsentCountAggregateOutputType> | number
          }
        }
      }
      OpenBankingPayment: {
        payload: Prisma.$OpenBankingPaymentPayload<ExtArgs>
        fields: Prisma.OpenBankingPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpenBankingPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpenBankingPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingPaymentPayload>
          }
          findFirst: {
            args: Prisma.OpenBankingPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpenBankingPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingPaymentPayload>
          }
          findMany: {
            args: Prisma.OpenBankingPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingPaymentPayload>[]
          }
          create: {
            args: Prisma.OpenBankingPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingPaymentPayload>
          }
          createMany: {
            args: Prisma.OpenBankingPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpenBankingPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingPaymentPayload>[]
          }
          delete: {
            args: Prisma.OpenBankingPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingPaymentPayload>
          }
          update: {
            args: Prisma.OpenBankingPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingPaymentPayload>
          }
          deleteMany: {
            args: Prisma.OpenBankingPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpenBankingPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpenBankingPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingPaymentPayload>[]
          }
          upsert: {
            args: Prisma.OpenBankingPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingPaymentPayload>
          }
          aggregate: {
            args: Prisma.OpenBankingPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpenBankingPayment>
          }
          groupBy: {
            args: Prisma.OpenBankingPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpenBankingPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpenBankingPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<OpenBankingPaymentCountAggregateOutputType> | number
          }
        }
      }
      OpenBankingConsent: {
        payload: Prisma.$OpenBankingConsentPayload<ExtArgs>
        fields: Prisma.OpenBankingConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpenBankingConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpenBankingConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingConsentPayload>
          }
          findFirst: {
            args: Prisma.OpenBankingConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpenBankingConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingConsentPayload>
          }
          findMany: {
            args: Prisma.OpenBankingConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingConsentPayload>[]
          }
          create: {
            args: Prisma.OpenBankingConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingConsentPayload>
          }
          createMany: {
            args: Prisma.OpenBankingConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpenBankingConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingConsentPayload>[]
          }
          delete: {
            args: Prisma.OpenBankingConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingConsentPayload>
          }
          update: {
            args: Prisma.OpenBankingConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingConsentPayload>
          }
          deleteMany: {
            args: Prisma.OpenBankingConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpenBankingConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpenBankingConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingConsentPayload>[]
          }
          upsert: {
            args: Prisma.OpenBankingConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenBankingConsentPayload>
          }
          aggregate: {
            args: Prisma.OpenBankingConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpenBankingConsent>
          }
          groupBy: {
            args: Prisma.OpenBankingConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpenBankingConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpenBankingConsentCountArgs<ExtArgs>
            result: $Utils.Optional<OpenBankingConsentCountAggregateOutputType> | number
          }
        }
      }
      EnrollmentContext: {
        payload: Prisma.$EnrollmentContextPayload<ExtArgs>
        fields: Prisma.EnrollmentContextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentContextFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentContextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentContextFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentContextPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentContextFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentContextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentContextFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentContextPayload>
          }
          findMany: {
            args: Prisma.EnrollmentContextFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentContextPayload>[]
          }
          create: {
            args: Prisma.EnrollmentContextCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentContextPayload>
          }
          createMany: {
            args: Prisma.EnrollmentContextCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnrollmentContextCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentContextPayload>[]
          }
          delete: {
            args: Prisma.EnrollmentContextDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentContextPayload>
          }
          update: {
            args: Prisma.EnrollmentContextUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentContextPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentContextDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentContextUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnrollmentContextUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentContextPayload>[]
          }
          upsert: {
            args: Prisma.EnrollmentContextUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentContextPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentContextAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollmentContext>
          }
          groupBy: {
            args: Prisma.EnrollmentContextGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentContextGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentContextCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentContextCountAggregateOutputType> | number
          }
        }
      }
      PaymentConsent: {
        payload: Prisma.$PaymentConsentPayload<ExtArgs>
        fields: Prisma.PaymentConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConsentPayload>
          }
          findFirst: {
            args: Prisma.PaymentConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConsentPayload>
          }
          findMany: {
            args: Prisma.PaymentConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConsentPayload>[]
          }
          create: {
            args: Prisma.PaymentConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConsentPayload>
          }
          createMany: {
            args: Prisma.PaymentConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConsentPayload>[]
          }
          delete: {
            args: Prisma.PaymentConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConsentPayload>
          }
          update: {
            args: Prisma.PaymentConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConsentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConsentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConsentPayload>
          }
          aggregate: {
            args: Prisma.PaymentConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentConsent>
          }
          groupBy: {
            args: Prisma.PaymentConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentConsentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentConsentCountAggregateOutputType> | number
          }
        }
      }
      OAuthState: {
        payload: Prisma.$OAuthStatePayload<ExtArgs>
        fields: Prisma.OAuthStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          findFirst: {
            args: Prisma.OAuthStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          findMany: {
            args: Prisma.OAuthStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>[]
          }
          create: {
            args: Prisma.OAuthStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          createMany: {
            args: Prisma.OAuthStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OAuthStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>[]
          }
          delete: {
            args: Prisma.OAuthStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          update: {
            args: Prisma.OAuthStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          deleteMany: {
            args: Prisma.OAuthStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OAuthStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>[]
          }
          upsert: {
            args: Prisma.OAuthStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          aggregate: {
            args: Prisma.OAuthStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthState>
          }
          groupBy: {
            args: Prisma.OAuthStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthStateCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthStateCountAggregateOutputType> | number
          }
        }
      }
      OAuthStateMeta: {
        payload: Prisma.$OAuthStateMetaPayload<ExtArgs>
        fields: Prisma.OAuthStateMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthStateMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStateMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthStateMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStateMetaPayload>
          }
          findFirst: {
            args: Prisma.OAuthStateMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStateMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthStateMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStateMetaPayload>
          }
          findMany: {
            args: Prisma.OAuthStateMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStateMetaPayload>[]
          }
          create: {
            args: Prisma.OAuthStateMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStateMetaPayload>
          }
          createMany: {
            args: Prisma.OAuthStateMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OAuthStateMetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStateMetaPayload>[]
          }
          delete: {
            args: Prisma.OAuthStateMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStateMetaPayload>
          }
          update: {
            args: Prisma.OAuthStateMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStateMetaPayload>
          }
          deleteMany: {
            args: Prisma.OAuthStateMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthStateMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OAuthStateMetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStateMetaPayload>[]
          }
          upsert: {
            args: Prisma.OAuthStateMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStateMetaPayload>
          }
          aggregate: {
            args: Prisma.OAuthStateMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthStateMeta>
          }
          groupBy: {
            args: Prisma.OAuthStateMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthStateMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthStateMetaCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthStateMetaCountAggregateOutputType> | number
          }
        }
      }
      OAuthToken: {
        payload: Prisma.$OAuthTokenPayload<ExtArgs>
        fields: Prisma.OAuthTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          findFirst: {
            args: Prisma.OAuthTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          findMany: {
            args: Prisma.OAuthTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>[]
          }
          create: {
            args: Prisma.OAuthTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          createMany: {
            args: Prisma.OAuthTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OAuthTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>[]
          }
          delete: {
            args: Prisma.OAuthTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          update: {
            args: Prisma.OAuthTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          deleteMany: {
            args: Prisma.OAuthTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OAuthTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>[]
          }
          upsert: {
            args: Prisma.OAuthTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          aggregate: {
            args: Prisma.OAuthTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthToken>
          }
          groupBy: {
            args: Prisma.OAuthTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthTokenCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthTokenCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      WebhookEvent: {
        payload: Prisma.$WebhookEventPayload<ExtArgs>
        fields: Prisma.WebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findFirst: {
            args: Prisma.WebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findMany: {
            args: Prisma.WebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          create: {
            args: Prisma.WebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          createMany: {
            args: Prisma.WebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          delete: {
            args: Prisma.WebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          update: {
            args: Prisma.WebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.WebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          upsert: {
            args: Prisma.WebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          aggregate: {
            args: Prisma.WebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookEvent>
          }
          groupBy: {
            args: Prisma.WebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventCountAggregateOutputType> | number
          }
        }
      }
      WebhookEndpoint: {
        payload: Prisma.$WebhookEndpointPayload<ExtArgs>
        fields: Prisma.WebhookEndpointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookEndpointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookEndpointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          findFirst: {
            args: Prisma.WebhookEndpointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookEndpointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          findMany: {
            args: Prisma.WebhookEndpointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>[]
          }
          create: {
            args: Prisma.WebhookEndpointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          createMany: {
            args: Prisma.WebhookEndpointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookEndpointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>[]
          }
          delete: {
            args: Prisma.WebhookEndpointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          update: {
            args: Prisma.WebhookEndpointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          deleteMany: {
            args: Prisma.WebhookEndpointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookEndpointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookEndpointUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>[]
          }
          upsert: {
            args: Prisma.WebhookEndpointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          aggregate: {
            args: Prisma.WebhookEndpointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookEndpoint>
          }
          groupBy: {
            args: Prisma.WebhookEndpointGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookEndpointGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookEndpointCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookEndpointCountAggregateOutputType> | number
          }
        }
      }
      OutboundWebhookEvent: {
        payload: Prisma.$OutboundWebhookEventPayload<ExtArgs>
        fields: Prisma.OutboundWebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutboundWebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutboundWebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookEventPayload>
          }
          findFirst: {
            args: Prisma.OutboundWebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutboundWebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookEventPayload>
          }
          findMany: {
            args: Prisma.OutboundWebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookEventPayload>[]
          }
          create: {
            args: Prisma.OutboundWebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookEventPayload>
          }
          createMany: {
            args: Prisma.OutboundWebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutboundWebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookEventPayload>[]
          }
          delete: {
            args: Prisma.OutboundWebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookEventPayload>
          }
          update: {
            args: Prisma.OutboundWebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.OutboundWebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutboundWebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutboundWebhookEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookEventPayload>[]
          }
          upsert: {
            args: Prisma.OutboundWebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookEventPayload>
          }
          aggregate: {
            args: Prisma.OutboundWebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutboundWebhookEvent>
          }
          groupBy: {
            args: Prisma.OutboundWebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutboundWebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutboundWebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<OutboundWebhookEventCountAggregateOutputType> | number
          }
        }
      }
      OutboundWebhookDelivery: {
        payload: Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>
        fields: Prisma.OutboundWebhookDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutboundWebhookDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutboundWebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookDeliveryPayload>
          }
          findFirst: {
            args: Prisma.OutboundWebhookDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutboundWebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookDeliveryPayload>
          }
          findMany: {
            args: Prisma.OutboundWebhookDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookDeliveryPayload>[]
          }
          create: {
            args: Prisma.OutboundWebhookDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookDeliveryPayload>
          }
          createMany: {
            args: Prisma.OutboundWebhookDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutboundWebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookDeliveryPayload>[]
          }
          delete: {
            args: Prisma.OutboundWebhookDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookDeliveryPayload>
          }
          update: {
            args: Prisma.OutboundWebhookDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.OutboundWebhookDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutboundWebhookDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutboundWebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookDeliveryPayload>[]
          }
          upsert: {
            args: Prisma.OutboundWebhookDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundWebhookDeliveryPayload>
          }
          aggregate: {
            args: Prisma.OutboundWebhookDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutboundWebhookDelivery>
          }
          groupBy: {
            args: Prisma.OutboundWebhookDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutboundWebhookDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutboundWebhookDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<OutboundWebhookDeliveryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    verificationCode?: VerificationCodeOmit
    patientProfile?: PatientProfileOmit
    pointsLedger?: PointsLedgerOmit
    clinic?: ClinicOmit
    clinicMember?: ClinicMemberOmit
    merchant?: MerchantOmit
    merchantApplication?: MerchantApplicationOmit
    merchantDocument?: MerchantDocumentOmit
    merchantIntegration?: MerchantIntegrationOmit
    paymentRoutingRule?: PaymentRoutingRuleOmit
    clinicPlan?: ClinicPlanOmit
    clinicAddOn?: ClinicAddOnOmit
    clinicSubscription?: ClinicSubscriptionOmit
    clinicAddOnSubscription?: ClinicAddOnSubscriptionOmit
    productCategory?: ProductCategoryOmit
    product?: ProductOmit
    categoriesOnProducts?: CategoriesOnProductsOmit
    offer?: OfferOmit
    offerPrice?: OfferPriceOmit
    offerPaymentMethod?: OfferPaymentMethodOmit
    productIntegration?: ProductIntegrationOmit
    checkoutSession?: CheckoutSessionOmit
    paymentTransaction?: PaymentTransactionOmit
    purchase?: PurchaseOmit
    customer?: CustomerOmit
    customerProvider?: CustomerProviderOmit
    customerPaymentMethod?: CustomerPaymentMethodOmit
    customerSubscription?: CustomerSubscriptionOmit
    paymentCustomer?: PaymentCustomerOmit
    messageTemplate?: MessageTemplateOmit
    messageSequence?: MessageSequenceOmit
    messageSequenceStep?: MessageSequenceStepOmit
    campaignJob?: CampaignJobOmit
    openFinanceLink?: OpenFinanceLinkOmit
    openFinanceConsent?: OpenFinanceConsentOmit
    openBankingPayment?: OpenBankingPaymentOmit
    openBankingConsent?: OpenBankingConsentOmit
    enrollmentContext?: EnrollmentContextOmit
    paymentConsent?: PaymentConsentOmit
    oAuthState?: OAuthStateOmit
    oAuthStateMeta?: OAuthStateMetaOmit
    oAuthToken?: OAuthTokenOmit
    event?: EventOmit
    webhookEvent?: WebhookEventOmit
    webhookEndpoint?: WebhookEndpointOmit
    outboundWebhookEvent?: OutboundWebhookEventOmit
    outboundWebhookDelivery?: OutboundWebhookDeliveryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    other_users: number
    clinic_memberships: number
    owned_clinics: number
    created_products: number
    created_categories: number
    user_verification_codes: number
    doctor_verification_codes: number
    purchases: number
    doctorPurchases: number
    pointsLedger: number
    doctor_profiles: number
    patient_profiles: number
    message_templates: number
    message_sequences: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    other_users?: boolean | UserCountOutputTypeCountOther_usersArgs
    clinic_memberships?: boolean | UserCountOutputTypeCountClinic_membershipsArgs
    owned_clinics?: boolean | UserCountOutputTypeCountOwned_clinicsArgs
    created_products?: boolean | UserCountOutputTypeCountCreated_productsArgs
    created_categories?: boolean | UserCountOutputTypeCountCreated_categoriesArgs
    user_verification_codes?: boolean | UserCountOutputTypeCountUser_verification_codesArgs
    doctor_verification_codes?: boolean | UserCountOutputTypeCountDoctor_verification_codesArgs
    purchases?: boolean | UserCountOutputTypeCountPurchasesArgs
    doctorPurchases?: boolean | UserCountOutputTypeCountDoctorPurchasesArgs
    pointsLedger?: boolean | UserCountOutputTypeCountPointsLedgerArgs
    doctor_profiles?: boolean | UserCountOutputTypeCountDoctor_profilesArgs
    patient_profiles?: boolean | UserCountOutputTypeCountPatient_profilesArgs
    message_templates?: boolean | UserCountOutputTypeCountMessage_templatesArgs
    message_sequences?: boolean | UserCountOutputTypeCountMessage_sequencesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOther_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClinic_membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwned_clinicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreated_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreated_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_verification_codesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctor_verification_codesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctorPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPointsLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointsLedgerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctor_profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientProfileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPatient_profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientProfileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_sequencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageSequenceWhereInput
  }


  /**
   * Count Type PatientProfileCountOutputType
   */

  export type PatientProfileCountOutputType = {
    pointsLedger: number
  }

  export type PatientProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pointsLedger?: boolean | PatientProfileCountOutputTypeCountPointsLedgerArgs
  }

  // Custom InputTypes
  /**
   * PatientProfileCountOutputType without action
   */
  export type PatientProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfileCountOutputType
     */
    select?: PatientProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientProfileCountOutputType without action
   */
  export type PatientProfileCountOutputTypeCountPointsLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointsLedgerWhereInput
  }


  /**
   * Count Type ClinicCountOutputType
   */

  export type ClinicCountOutputType = {
    members: number
    subscriptions: number
    products: number
    webhookEndpoints: number
    outboundEvents: number
  }

  export type ClinicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ClinicCountOutputTypeCountMembersArgs
    subscriptions?: boolean | ClinicCountOutputTypeCountSubscriptionsArgs
    products?: boolean | ClinicCountOutputTypeCountProductsArgs
    webhookEndpoints?: boolean | ClinicCountOutputTypeCountWebhookEndpointsArgs
    outboundEvents?: boolean | ClinicCountOutputTypeCountOutboundEventsArgs
  }

  // Custom InputTypes
  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicCountOutputType
     */
    select?: ClinicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicMemberWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicSubscriptionWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountWebhookEndpointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEndpointWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountOutboundEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboundWebhookEventWhereInput
  }


  /**
   * Count Type MerchantCountOutputType
   */

  export type MerchantCountOutputType = {
    integrations: number
  }

  export type MerchantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integrations?: boolean | MerchantCountOutputTypeCountIntegrationsArgs
  }

  // Custom InputTypes
  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantCountOutputType
     */
    select?: MerchantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantIntegrationWhereInput
  }


  /**
   * Count Type MerchantApplicationCountOutputType
   */

  export type MerchantApplicationCountOutputType = {
    documents: number
  }

  export type MerchantApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | MerchantApplicationCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * MerchantApplicationCountOutputType without action
   */
  export type MerchantApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplicationCountOutputType
     */
    select?: MerchantApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MerchantApplicationCountOutputType without action
   */
  export type MerchantApplicationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantDocumentWhereInput
  }


  /**
   * Count Type ClinicPlanCountOutputType
   */

  export type ClinicPlanCountOutputType = {
    subscriptions: number
  }

  export type ClinicPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | ClinicPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * ClinicPlanCountOutputType without action
   */
  export type ClinicPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlanCountOutputType
     */
    select?: ClinicPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicPlanCountOutputType without action
   */
  export type ClinicPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicSubscriptionWhereInput
  }


  /**
   * Count Type ClinicAddOnCountOutputType
   */

  export type ClinicAddOnCountOutputType = {
    subscriptions: number
  }

  export type ClinicAddOnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | ClinicAddOnCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * ClinicAddOnCountOutputType without action
   */
  export type ClinicAddOnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnCountOutputType
     */
    select?: ClinicAddOnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicAddOnCountOutputType without action
   */
  export type ClinicAddOnCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicAddOnSubscriptionWhereInput
  }


  /**
   * Count Type ClinicSubscriptionCountOutputType
   */

  export type ClinicSubscriptionCountOutputType = {
    addOns: number
  }

  export type ClinicSubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addOns?: boolean | ClinicSubscriptionCountOutputTypeCountAddOnsArgs
  }

  // Custom InputTypes
  /**
   * ClinicSubscriptionCountOutputType without action
   */
  export type ClinicSubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscriptionCountOutputType
     */
    select?: ClinicSubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicSubscriptionCountOutputType without action
   */
  export type ClinicSubscriptionCountOutputTypeCountAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicAddOnSubscriptionWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    products: number
    categories: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
    categories?: boolean | ProductCategoryCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriesOnProductsWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    purchases: number
    categories: number
    offers: number
    integrations: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | ProductCountOutputTypeCountPurchasesArgs
    categories?: boolean | ProductCountOutputTypeCountCategoriesArgs
    offers?: boolean | ProductCountOutputTypeCountOffersArgs
    integrations?: boolean | ProductCountOutputTypeCountIntegrationsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriesOnProductsWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductIntegrationWhereInput
  }


  /**
   * Count Type OfferCountOutputType
   */

  export type OfferCountOutputType = {
    paymentMethods: number
    prices: number
  }

  export type OfferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentMethods?: boolean | OfferCountOutputTypeCountPaymentMethodsArgs
    prices?: boolean | OfferCountOutputTypeCountPricesArgs
  }

  // Custom InputTypes
  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferCountOutputType
     */
    select?: OfferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferPaymentMethodWhereInput
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferPriceWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    providers: number
    paymentMethods: number
    subscriptions: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | CustomerCountOutputTypeCountProvidersArgs
    paymentMethods?: boolean | CustomerCountOutputTypeCountPaymentMethodsArgs
    subscriptions?: boolean | CustomerCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerProviderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPaymentMethodWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerSubscriptionWhereInput
  }


  /**
   * Count Type CustomerProviderCountOutputType
   */

  export type CustomerProviderCountOutputType = {
    paymentMethods: number
    subscriptions: number
  }

  export type CustomerProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentMethods?: boolean | CustomerProviderCountOutputTypeCountPaymentMethodsArgs
    subscriptions?: boolean | CustomerProviderCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * CustomerProviderCountOutputType without action
   */
  export type CustomerProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProviderCountOutputType
     */
    select?: CustomerProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerProviderCountOutputType without action
   */
  export type CustomerProviderCountOutputTypeCountPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPaymentMethodWhereInput
  }

  /**
   * CustomerProviderCountOutputType without action
   */
  export type CustomerProviderCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerSubscriptionWhereInput
  }


  /**
   * Count Type MessageTemplateCountOutputType
   */

  export type MessageTemplateCountOutputType = {
    steps: number
  }

  export type MessageTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | MessageTemplateCountOutputTypeCountStepsArgs
  }

  // Custom InputTypes
  /**
   * MessageTemplateCountOutputType without action
   */
  export type MessageTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplateCountOutputType
     */
    select?: MessageTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageTemplateCountOutputType without action
   */
  export type MessageTemplateCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageSequenceStepWhereInput
  }


  /**
   * Count Type MessageSequenceCountOutputType
   */

  export type MessageSequenceCountOutputType = {
    steps: number
  }

  export type MessageSequenceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | MessageSequenceCountOutputTypeCountStepsArgs
  }

  // Custom InputTypes
  /**
   * MessageSequenceCountOutputType without action
   */
  export type MessageSequenceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceCountOutputType
     */
    select?: MessageSequenceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageSequenceCountOutputType without action
   */
  export type MessageSequenceCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageSequenceStepWhereInput
  }


  /**
   * Count Type WebhookEndpointCountOutputType
   */

  export type WebhookEndpointCountOutputType = {
    deliveries: number
  }

  export type WebhookEndpointCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | WebhookEndpointCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * WebhookEndpointCountOutputType without action
   */
  export type WebhookEndpointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpointCountOutputType
     */
    select?: WebhookEndpointCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebhookEndpointCountOutputType without action
   */
  export type WebhookEndpointCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboundWebhookDeliveryWhereInput
  }


  /**
   * Count Type OutboundWebhookEventCountOutputType
   */

  export type OutboundWebhookEventCountOutputType = {
    deliveries: number
  }

  export type OutboundWebhookEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | OutboundWebhookEventCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * OutboundWebhookEventCountOutputType without action
   */
  export type OutboundWebhookEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEventCountOutputType
     */
    select?: OutboundWebhookEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OutboundWebhookEventCountOutputType without action
   */
  export type OutboundWebhookEventCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboundWebhookDeliveryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    image: string | null
    public_cover_image_url: string | null
    doctor_slug: string | null
    role: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    email_verified: Date | null
    password: string | null
    reset_token: string | null
    reset_token_expiry: Date | null
    verification_code: string | null
    verification_code_expiry: Date | null
    doctor_id: string | null
    referral_code: string | null
    phone: string | null
    birth_date: Date | null
    gender: string | null
    address: string | null
    emergency_contact: string | null
    emergency_phone: string | null
    medical_history: string | null
    allergies: string | null
    medications: string | null
    notes: string | null
    google_review_link: string | null
    stripe_connect_id: string | null
    accessGranted: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    image: string | null
    public_cover_image_url: string | null
    doctor_slug: string | null
    role: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    email_verified: Date | null
    password: string | null
    reset_token: string | null
    reset_token_expiry: Date | null
    verification_code: string | null
    verification_code_expiry: Date | null
    doctor_id: string | null
    referral_code: string | null
    phone: string | null
    birth_date: Date | null
    gender: string | null
    address: string | null
    emergency_contact: string | null
    emergency_phone: string | null
    medical_history: string | null
    allergies: string | null
    medications: string | null
    notes: string | null
    google_review_link: string | null
    stripe_connect_id: string | null
    accessGranted: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    image: number
    public_cover_image_url: number
    doctor_slug: number
    role: number
    is_active: number
    created_at: number
    updated_at: number
    email_verified: number
    password: number
    reset_token: number
    reset_token_expiry: number
    verification_code: number
    verification_code_expiry: number
    doctor_id: number
    referral_code: number
    phone: number
    birth_date: number
    gender: number
    address: number
    emergency_contact: number
    emergency_phone: number
    medical_history: number
    allergies: number
    medications: number
    notes: number
    google_review_link: number
    stripe_connect_id: number
    accessGranted: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    public_cover_image_url?: true
    doctor_slug?: true
    role?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    email_verified?: true
    password?: true
    reset_token?: true
    reset_token_expiry?: true
    verification_code?: true
    verification_code_expiry?: true
    doctor_id?: true
    referral_code?: true
    phone?: true
    birth_date?: true
    gender?: true
    address?: true
    emergency_contact?: true
    emergency_phone?: true
    medical_history?: true
    allergies?: true
    medications?: true
    notes?: true
    google_review_link?: true
    stripe_connect_id?: true
    accessGranted?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    public_cover_image_url?: true
    doctor_slug?: true
    role?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    email_verified?: true
    password?: true
    reset_token?: true
    reset_token_expiry?: true
    verification_code?: true
    verification_code_expiry?: true
    doctor_id?: true
    referral_code?: true
    phone?: true
    birth_date?: true
    gender?: true
    address?: true
    emergency_contact?: true
    emergency_phone?: true
    medical_history?: true
    allergies?: true
    medications?: true
    notes?: true
    google_review_link?: true
    stripe_connect_id?: true
    accessGranted?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    public_cover_image_url?: true
    doctor_slug?: true
    role?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    email_verified?: true
    password?: true
    reset_token?: true
    reset_token_expiry?: true
    verification_code?: true
    verification_code_expiry?: true
    doctor_id?: true
    referral_code?: true
    phone?: true
    birth_date?: true
    gender?: true
    address?: true
    emergency_contact?: true
    emergency_phone?: true
    medical_history?: true
    allergies?: true
    medications?: true
    notes?: true
    google_review_link?: true
    stripe_connect_id?: true
    accessGranted?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    image: string | null
    public_cover_image_url: string | null
    doctor_slug: string | null
    role: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    email_verified: Date | null
    password: string | null
    reset_token: string | null
    reset_token_expiry: Date | null
    verification_code: string | null
    verification_code_expiry: Date | null
    doctor_id: string | null
    referral_code: string | null
    phone: string | null
    birth_date: Date | null
    gender: string | null
    address: string | null
    emergency_contact: string | null
    emergency_phone: string | null
    medical_history: string | null
    allergies: string | null
    medications: string | null
    notes: string | null
    google_review_link: string | null
    stripe_connect_id: string | null
    accessGranted: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    public_cover_image_url?: boolean
    doctor_slug?: boolean
    role?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    email_verified?: boolean
    password?: boolean
    reset_token?: boolean
    reset_token_expiry?: boolean
    verification_code?: boolean
    verification_code_expiry?: boolean
    doctor_id?: boolean
    referral_code?: boolean
    phone?: boolean
    birth_date?: boolean
    gender?: boolean
    address?: boolean
    emergency_contact?: boolean
    emergency_phone?: boolean
    medical_history?: boolean
    allergies?: boolean
    medications?: boolean
    notes?: boolean
    google_review_link?: boolean
    stripe_connect_id?: boolean
    accessGranted?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    User?: boolean | User$UserArgs<ExtArgs>
    other_users?: boolean | User$other_usersArgs<ExtArgs>
    clinic_memberships?: boolean | User$clinic_membershipsArgs<ExtArgs>
    owned_clinics?: boolean | User$owned_clinicsArgs<ExtArgs>
    created_products?: boolean | User$created_productsArgs<ExtArgs>
    created_categories?: boolean | User$created_categoriesArgs<ExtArgs>
    user_verification_codes?: boolean | User$user_verification_codesArgs<ExtArgs>
    doctor_verification_codes?: boolean | User$doctor_verification_codesArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    doctorPurchases?: boolean | User$doctorPurchasesArgs<ExtArgs>
    pointsLedger?: boolean | User$pointsLedgerArgs<ExtArgs>
    doctor_profiles?: boolean | User$doctor_profilesArgs<ExtArgs>
    patient_profiles?: boolean | User$patient_profilesArgs<ExtArgs>
    message_templates?: boolean | User$message_templatesArgs<ExtArgs>
    message_sequences?: boolean | User$message_sequencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    public_cover_image_url?: boolean
    doctor_slug?: boolean
    role?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    email_verified?: boolean
    password?: boolean
    reset_token?: boolean
    reset_token_expiry?: boolean
    verification_code?: boolean
    verification_code_expiry?: boolean
    doctor_id?: boolean
    referral_code?: boolean
    phone?: boolean
    birth_date?: boolean
    gender?: boolean
    address?: boolean
    emergency_contact?: boolean
    emergency_phone?: boolean
    medical_history?: boolean
    allergies?: boolean
    medications?: boolean
    notes?: boolean
    google_review_link?: boolean
    stripe_connect_id?: boolean
    accessGranted?: boolean
    User?: boolean | User$UserArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    public_cover_image_url?: boolean
    doctor_slug?: boolean
    role?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    email_verified?: boolean
    password?: boolean
    reset_token?: boolean
    reset_token_expiry?: boolean
    verification_code?: boolean
    verification_code_expiry?: boolean
    doctor_id?: boolean
    referral_code?: boolean
    phone?: boolean
    birth_date?: boolean
    gender?: boolean
    address?: boolean
    emergency_contact?: boolean
    emergency_phone?: boolean
    medical_history?: boolean
    allergies?: boolean
    medications?: boolean
    notes?: boolean
    google_review_link?: boolean
    stripe_connect_id?: boolean
    accessGranted?: boolean
    User?: boolean | User$UserArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    public_cover_image_url?: boolean
    doctor_slug?: boolean
    role?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    email_verified?: boolean
    password?: boolean
    reset_token?: boolean
    reset_token_expiry?: boolean
    verification_code?: boolean
    verification_code_expiry?: boolean
    doctor_id?: boolean
    referral_code?: boolean
    phone?: boolean
    birth_date?: boolean
    gender?: boolean
    address?: boolean
    emergency_contact?: boolean
    emergency_phone?: boolean
    medical_history?: boolean
    allergies?: boolean
    medications?: boolean
    notes?: boolean
    google_review_link?: boolean
    stripe_connect_id?: boolean
    accessGranted?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "image" | "public_cover_image_url" | "doctor_slug" | "role" | "is_active" | "created_at" | "updated_at" | "email_verified" | "password" | "reset_token" | "reset_token_expiry" | "verification_code" | "verification_code_expiry" | "doctor_id" | "referral_code" | "phone" | "birth_date" | "gender" | "address" | "emergency_contact" | "emergency_phone" | "medical_history" | "allergies" | "medications" | "notes" | "google_review_link" | "stripe_connect_id" | "accessGranted", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    User?: boolean | User$UserArgs<ExtArgs>
    other_users?: boolean | User$other_usersArgs<ExtArgs>
    clinic_memberships?: boolean | User$clinic_membershipsArgs<ExtArgs>
    owned_clinics?: boolean | User$owned_clinicsArgs<ExtArgs>
    created_products?: boolean | User$created_productsArgs<ExtArgs>
    created_categories?: boolean | User$created_categoriesArgs<ExtArgs>
    user_verification_codes?: boolean | User$user_verification_codesArgs<ExtArgs>
    doctor_verification_codes?: boolean | User$doctor_verification_codesArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    doctorPurchases?: boolean | User$doctorPurchasesArgs<ExtArgs>
    pointsLedger?: boolean | User$pointsLedgerArgs<ExtArgs>
    doctor_profiles?: boolean | User$doctor_profilesArgs<ExtArgs>
    patient_profiles?: boolean | User$patient_profilesArgs<ExtArgs>
    message_templates?: boolean | User$message_templatesArgs<ExtArgs>
    message_sequences?: boolean | User$message_sequencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | User$UserArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | User$UserArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs> | null
      other_users: Prisma.$UserPayload<ExtArgs>[]
      clinic_memberships: Prisma.$ClinicMemberPayload<ExtArgs>[]
      owned_clinics: Prisma.$ClinicPayload<ExtArgs>[]
      created_products: Prisma.$ProductPayload<ExtArgs>[]
      created_categories: Prisma.$ProductCategoryPayload<ExtArgs>[]
      user_verification_codes: Prisma.$VerificationCodePayload<ExtArgs>[]
      doctor_verification_codes: Prisma.$VerificationCodePayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      doctorPurchases: Prisma.$PurchasePayload<ExtArgs>[]
      pointsLedger: Prisma.$PointsLedgerPayload<ExtArgs>[]
      doctor_profiles: Prisma.$PatientProfilePayload<ExtArgs>[]
      patient_profiles: Prisma.$PatientProfilePayload<ExtArgs>[]
      message_templates: Prisma.$MessageTemplatePayload<ExtArgs>[]
      message_sequences: Prisma.$MessageSequencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      image: string | null
      public_cover_image_url: string | null
      doctor_slug: string | null
      role: string
      is_active: boolean
      created_at: Date
      updated_at: Date
      email_verified: Date | null
      password: string | null
      reset_token: string | null
      reset_token_expiry: Date | null
      verification_code: string | null
      verification_code_expiry: Date | null
      doctor_id: string | null
      referral_code: string | null
      phone: string | null
      birth_date: Date | null
      gender: string | null
      address: string | null
      emergency_contact: string | null
      emergency_phone: string | null
      medical_history: string | null
      allergies: string | null
      medications: string | null
      notes: string | null
      google_review_link: string | null
      stripe_connect_id: string | null
      accessGranted: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends User$UserArgs<ExtArgs> = {}>(args?: Subset<T, User$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_users<T extends User$other_usersArgs<ExtArgs> = {}>(args?: Subset<T, User$other_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clinic_memberships<T extends User$clinic_membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$clinic_membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    owned_clinics<T extends User$owned_clinicsArgs<ExtArgs> = {}>(args?: Subset<T, User$owned_clinicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    created_products<T extends User$created_productsArgs<ExtArgs> = {}>(args?: Subset<T, User$created_productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    created_categories<T extends User$created_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$created_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_verification_codes<T extends User$user_verification_codesArgs<ExtArgs> = {}>(args?: Subset<T, User$user_verification_codesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctor_verification_codes<T extends User$doctor_verification_codesArgs<ExtArgs> = {}>(args?: Subset<T, User$doctor_verification_codesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchases<T extends User$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, User$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctorPurchases<T extends User$doctorPurchasesArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorPurchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pointsLedger<T extends User$pointsLedgerArgs<ExtArgs> = {}>(args?: Subset<T, User$pointsLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctor_profiles<T extends User$doctor_profilesArgs<ExtArgs> = {}>(args?: Subset<T, User$doctor_profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patient_profiles<T extends User$patient_profilesArgs<ExtArgs> = {}>(args?: Subset<T, User$patient_profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    message_templates<T extends User$message_templatesArgs<ExtArgs> = {}>(args?: Subset<T, User$message_templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    message_sequences<T extends User$message_sequencesArgs<ExtArgs> = {}>(args?: Subset<T, User$message_sequencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly public_cover_image_url: FieldRef<"User", 'String'>
    readonly doctor_slug: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly is_active: FieldRef<"User", 'Boolean'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly email_verified: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly reset_token: FieldRef<"User", 'String'>
    readonly reset_token_expiry: FieldRef<"User", 'DateTime'>
    readonly verification_code: FieldRef<"User", 'String'>
    readonly verification_code_expiry: FieldRef<"User", 'DateTime'>
    readonly doctor_id: FieldRef<"User", 'String'>
    readonly referral_code: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly birth_date: FieldRef<"User", 'DateTime'>
    readonly gender: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly emergency_contact: FieldRef<"User", 'String'>
    readonly emergency_phone: FieldRef<"User", 'String'>
    readonly medical_history: FieldRef<"User", 'String'>
    readonly allergies: FieldRef<"User", 'String'>
    readonly medications: FieldRef<"User", 'String'>
    readonly notes: FieldRef<"User", 'String'>
    readonly google_review_link: FieldRef<"User", 'String'>
    readonly stripe_connect_id: FieldRef<"User", 'String'>
    readonly accessGranted: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.User
   */
  export type User$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.other_users
   */
  export type User$other_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.clinic_memberships
   */
  export type User$clinic_membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
    where?: ClinicMemberWhereInput
    orderBy?: ClinicMemberOrderByWithRelationInput | ClinicMemberOrderByWithRelationInput[]
    cursor?: ClinicMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicMemberScalarFieldEnum | ClinicMemberScalarFieldEnum[]
  }

  /**
   * User.owned_clinics
   */
  export type User$owned_clinicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    cursor?: ClinicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * User.created_products
   */
  export type User$created_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * User.created_categories
   */
  export type User$created_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * User.user_verification_codes
   */
  export type User$user_verification_codesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    where?: VerificationCodeWhereInput
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    cursor?: VerificationCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * User.doctor_verification_codes
   */
  export type User$doctor_verification_codesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    where?: VerificationCodeWhereInput
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    cursor?: VerificationCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * User.purchases
   */
  export type User$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * User.doctorPurchases
   */
  export type User$doctorPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * User.pointsLedger
   */
  export type User$pointsLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
    where?: PointsLedgerWhereInput
    orderBy?: PointsLedgerOrderByWithRelationInput | PointsLedgerOrderByWithRelationInput[]
    cursor?: PointsLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointsLedgerScalarFieldEnum | PointsLedgerScalarFieldEnum[]
  }

  /**
   * User.doctor_profiles
   */
  export type User$doctor_profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    where?: PatientProfileWhereInput
    orderBy?: PatientProfileOrderByWithRelationInput | PatientProfileOrderByWithRelationInput[]
    cursor?: PatientProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientProfileScalarFieldEnum | PatientProfileScalarFieldEnum[]
  }

  /**
   * User.patient_profiles
   */
  export type User$patient_profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    where?: PatientProfileWhereInput
    orderBy?: PatientProfileOrderByWithRelationInput | PatientProfileOrderByWithRelationInput[]
    cursor?: PatientProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientProfileScalarFieldEnum | PatientProfileScalarFieldEnum[]
  }

  /**
   * User.message_templates
   */
  export type User$message_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    where?: MessageTemplateWhereInput
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    cursor?: MessageTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * User.message_sequences
   */
  export type User$message_sequencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceInclude<ExtArgs> | null
    where?: MessageSequenceWhereInput
    orderBy?: MessageSequenceOrderByWithRelationInput | MessageSequenceOrderByWithRelationInput[]
    cursor?: MessageSequenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageSequenceScalarFieldEnum | MessageSequenceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model VerificationCode
   */

  export type AggregateVerificationCode = {
    _count: VerificationCodeCountAggregateOutputType | null
    _min: VerificationCodeMinAggregateOutputType | null
    _max: VerificationCodeMaxAggregateOutputType | null
  }

  export type VerificationCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    user_id: string | null
    doctor_id: string | null
    type: string | null
    created_at: Date | null
    expires_at: Date | null
    used_at: Date | null
  }

  export type VerificationCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    user_id: string | null
    doctor_id: string | null
    type: string | null
    created_at: Date | null
    expires_at: Date | null
    used_at: Date | null
  }

  export type VerificationCodeCountAggregateOutputType = {
    id: number
    code: number
    user_id: number
    doctor_id: number
    type: number
    created_at: number
    expires_at: number
    used_at: number
    _all: number
  }


  export type VerificationCodeMinAggregateInputType = {
    id?: true
    code?: true
    user_id?: true
    doctor_id?: true
    type?: true
    created_at?: true
    expires_at?: true
    used_at?: true
  }

  export type VerificationCodeMaxAggregateInputType = {
    id?: true
    code?: true
    user_id?: true
    doctor_id?: true
    type?: true
    created_at?: true
    expires_at?: true
    used_at?: true
  }

  export type VerificationCodeCountAggregateInputType = {
    id?: true
    code?: true
    user_id?: true
    doctor_id?: true
    type?: true
    created_at?: true
    expires_at?: true
    used_at?: true
    _all?: true
  }

  export type VerificationCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationCode to aggregate.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationCodes
    **/
    _count?: true | VerificationCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationCodeMaxAggregateInputType
  }

  export type GetVerificationCodeAggregateType<T extends VerificationCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationCode[P]>
      : GetScalarType<T[P], AggregateVerificationCode[P]>
  }




  export type VerificationCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationCodeWhereInput
    orderBy?: VerificationCodeOrderByWithAggregationInput | VerificationCodeOrderByWithAggregationInput[]
    by: VerificationCodeScalarFieldEnum[] | VerificationCodeScalarFieldEnum
    having?: VerificationCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCodeCountAggregateInputType | true
    _min?: VerificationCodeMinAggregateInputType
    _max?: VerificationCodeMaxAggregateInputType
  }

  export type VerificationCodeGroupByOutputType = {
    id: string
    code: string
    user_id: string
    doctor_id: string
    type: string
    created_at: Date
    expires_at: Date
    used_at: Date | null
    _count: VerificationCodeCountAggregateOutputType | null
    _min: VerificationCodeMinAggregateOutputType | null
    _max: VerificationCodeMaxAggregateOutputType | null
  }

  type GetVerificationCodeGroupByPayload<T extends VerificationCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationCodeGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationCodeGroupByOutputType[P]>
        }
      >
    >


  export type VerificationCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    user_id?: boolean
    doctor_id?: boolean
    type?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    user_id?: boolean
    doctor_id?: boolean
    type?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    user_id?: boolean
    doctor_id?: boolean
    type?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectScalar = {
    id?: boolean
    code?: boolean
    user_id?: boolean
    doctor_id?: boolean
    type?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
  }

  export type VerificationCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "user_id" | "doctor_id" | "type" | "created_at" | "expires_at" | "used_at", ExtArgs["result"]["verificationCode"]>
  export type VerificationCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VerificationCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationCode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      user_id: string
      doctor_id: string
      type: string
      created_at: Date
      expires_at: Date
      used_at: Date | null
    }, ExtArgs["result"]["verificationCode"]>
    composites: {}
  }

  type VerificationCodeGetPayload<S extends boolean | null | undefined | VerificationCodeDefaultArgs> = $Result.GetResult<Prisma.$VerificationCodePayload, S>

  type VerificationCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCodeCountAggregateInputType | true
    }

  export interface VerificationCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationCode'], meta: { name: 'VerificationCode' } }
    /**
     * Find zero or one VerificationCode that matches the filter.
     * @param {VerificationCodeFindUniqueArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationCodeFindUniqueArgs>(args: SelectSubset<T, VerificationCodeFindUniqueArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationCodeFindUniqueOrThrowArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindFirstArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationCodeFindFirstArgs>(args?: SelectSubset<T, VerificationCodeFindFirstArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindFirstOrThrowArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationCodes
     * const verificationCodes = await prisma.verificationCode.findMany()
     * 
     * // Get first 10 VerificationCodes
     * const verificationCodes = await prisma.verificationCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationCodeFindManyArgs>(args?: SelectSubset<T, VerificationCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationCode.
     * @param {VerificationCodeCreateArgs} args - Arguments to create a VerificationCode.
     * @example
     * // Create one VerificationCode
     * const VerificationCode = await prisma.verificationCode.create({
     *   data: {
     *     // ... data to create a VerificationCode
     *   }
     * })
     * 
     */
    create<T extends VerificationCodeCreateArgs>(args: SelectSubset<T, VerificationCodeCreateArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationCodes.
     * @param {VerificationCodeCreateManyArgs} args - Arguments to create many VerificationCodes.
     * @example
     * // Create many VerificationCodes
     * const verificationCode = await prisma.verificationCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCodeCreateManyArgs>(args?: SelectSubset<T, VerificationCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationCodes and returns the data saved in the database.
     * @param {VerificationCodeCreateManyAndReturnArgs} args - Arguments to create many VerificationCodes.
     * @example
     * // Create many VerificationCodes
     * const verificationCode = await prisma.verificationCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationCodes and only return the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationCode.
     * @param {VerificationCodeDeleteArgs} args - Arguments to delete one VerificationCode.
     * @example
     * // Delete one VerificationCode
     * const VerificationCode = await prisma.verificationCode.delete({
     *   where: {
     *     // ... filter to delete one VerificationCode
     *   }
     * })
     * 
     */
    delete<T extends VerificationCodeDeleteArgs>(args: SelectSubset<T, VerificationCodeDeleteArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationCode.
     * @param {VerificationCodeUpdateArgs} args - Arguments to update one VerificationCode.
     * @example
     * // Update one VerificationCode
     * const verificationCode = await prisma.verificationCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationCodeUpdateArgs>(args: SelectSubset<T, VerificationCodeUpdateArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationCodes.
     * @param {VerificationCodeDeleteManyArgs} args - Arguments to filter VerificationCodes to delete.
     * @example
     * // Delete a few VerificationCodes
     * const { count } = await prisma.verificationCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationCodeDeleteManyArgs>(args?: SelectSubset<T, VerificationCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationCodes
     * const verificationCode = await prisma.verificationCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationCodeUpdateManyArgs>(args: SelectSubset<T, VerificationCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationCodes and returns the data updated in the database.
     * @param {VerificationCodeUpdateManyAndReturnArgs} args - Arguments to update many VerificationCodes.
     * @example
     * // Update many VerificationCodes
     * const verificationCode = await prisma.verificationCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationCodes and only return the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationCode.
     * @param {VerificationCodeUpsertArgs} args - Arguments to update or create a VerificationCode.
     * @example
     * // Update or create a VerificationCode
     * const verificationCode = await prisma.verificationCode.upsert({
     *   create: {
     *     // ... data to create a VerificationCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationCode we want to update
     *   }
     * })
     */
    upsert<T extends VerificationCodeUpsertArgs>(args: SelectSubset<T, VerificationCodeUpsertArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeCountArgs} args - Arguments to filter VerificationCodes to count.
     * @example
     * // Count the number of VerificationCodes
     * const count = await prisma.verificationCode.count({
     *   where: {
     *     // ... the filter for the VerificationCodes we want to count
     *   }
     * })
    **/
    count<T extends VerificationCodeCountArgs>(
      args?: Subset<T, VerificationCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationCodeAggregateArgs>(args: Subset<T, VerificationCodeAggregateArgs>): Prisma.PrismaPromise<GetVerificationCodeAggregateType<T>>

    /**
     * Group by VerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationCodeGroupByArgs['orderBy'] }
        : { orderBy?: VerificationCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationCode model
   */
  readonly fields: VerificationCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationCode model
   */
  interface VerificationCodeFieldRefs {
    readonly id: FieldRef<"VerificationCode", 'String'>
    readonly code: FieldRef<"VerificationCode", 'String'>
    readonly user_id: FieldRef<"VerificationCode", 'String'>
    readonly doctor_id: FieldRef<"VerificationCode", 'String'>
    readonly type: FieldRef<"VerificationCode", 'String'>
    readonly created_at: FieldRef<"VerificationCode", 'DateTime'>
    readonly expires_at: FieldRef<"VerificationCode", 'DateTime'>
    readonly used_at: FieldRef<"VerificationCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationCode findUnique
   */
  export type VerificationCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode findUniqueOrThrow
   */
  export type VerificationCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode findFirst
   */
  export type VerificationCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationCodes.
     */
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode findFirstOrThrow
   */
  export type VerificationCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationCodes.
     */
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode findMany
   */
  export type VerificationCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCodes to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode create
   */
  export type VerificationCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a VerificationCode.
     */
    data: XOR<VerificationCodeCreateInput, VerificationCodeUncheckedCreateInput>
  }

  /**
   * VerificationCode createMany
   */
  export type VerificationCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationCodes.
     */
    data: VerificationCodeCreateManyInput | VerificationCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationCode createManyAndReturn
   */
  export type VerificationCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationCodes.
     */
    data: VerificationCodeCreateManyInput | VerificationCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationCode update
   */
  export type VerificationCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a VerificationCode.
     */
    data: XOR<VerificationCodeUpdateInput, VerificationCodeUncheckedUpdateInput>
    /**
     * Choose, which VerificationCode to update.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode updateMany
   */
  export type VerificationCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationCodes.
     */
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyInput>
    /**
     * Filter which VerificationCodes to update
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to update.
     */
    limit?: number
  }

  /**
   * VerificationCode updateManyAndReturn
   */
  export type VerificationCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data used to update VerificationCodes.
     */
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyInput>
    /**
     * Filter which VerificationCodes to update
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationCode upsert
   */
  export type VerificationCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the VerificationCode to update in case it exists.
     */
    where: VerificationCodeWhereUniqueInput
    /**
     * In case the VerificationCode found by the `where` argument doesn't exist, create a new VerificationCode with this data.
     */
    create: XOR<VerificationCodeCreateInput, VerificationCodeUncheckedCreateInput>
    /**
     * In case the VerificationCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationCodeUpdateInput, VerificationCodeUncheckedUpdateInput>
  }

  /**
   * VerificationCode delete
   */
  export type VerificationCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter which VerificationCode to delete.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode deleteMany
   */
  export type VerificationCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationCodes to delete
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to delete.
     */
    limit?: number
  }

  /**
   * VerificationCode without action
   */
  export type VerificationCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
  }


  /**
   * Model PatientProfile
   */

  export type AggregatePatientProfile = {
    _count: PatientProfileCountAggregateOutputType | null
    _avg: PatientProfileAvgAggregateOutputType | null
    _sum: PatientProfileSumAggregateOutputType | null
    _min: PatientProfileMinAggregateOutputType | null
    _max: PatientProfileMaxAggregateOutputType | null
  }

  export type PatientProfileAvgAggregateOutputType = {
    totalPoints: number | null
    currentPoints: number | null
  }

  export type PatientProfileSumAggregateOutputType = {
    totalPoints: number | null
    currentPoints: number | null
  }

  export type PatientProfileMinAggregateOutputType = {
    id: string | null
    doctorId: string | null
    userId: string | null
    name: string | null
    phone: string | null
    address: string | null
    emergency_contact: string | null
    emergency_phone: string | null
    medical_history: string | null
    allergies: string | null
    medications: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    totalPoints: number | null
    currentPoints: number | null
  }

  export type PatientProfileMaxAggregateOutputType = {
    id: string | null
    doctorId: string | null
    userId: string | null
    name: string | null
    phone: string | null
    address: string | null
    emergency_contact: string | null
    emergency_phone: string | null
    medical_history: string | null
    allergies: string | null
    medications: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    totalPoints: number | null
    currentPoints: number | null
  }

  export type PatientProfileCountAggregateOutputType = {
    id: number
    doctorId: number
    userId: number
    name: number
    phone: number
    address: number
    emergency_contact: number
    emergency_phone: number
    medical_history: number
    allergies: number
    medications: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    totalPoints: number
    currentPoints: number
    _all: number
  }


  export type PatientProfileAvgAggregateInputType = {
    totalPoints?: true
    currentPoints?: true
  }

  export type PatientProfileSumAggregateInputType = {
    totalPoints?: true
    currentPoints?: true
  }

  export type PatientProfileMinAggregateInputType = {
    id?: true
    doctorId?: true
    userId?: true
    name?: true
    phone?: true
    address?: true
    emergency_contact?: true
    emergency_phone?: true
    medical_history?: true
    allergies?: true
    medications?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    totalPoints?: true
    currentPoints?: true
  }

  export type PatientProfileMaxAggregateInputType = {
    id?: true
    doctorId?: true
    userId?: true
    name?: true
    phone?: true
    address?: true
    emergency_contact?: true
    emergency_phone?: true
    medical_history?: true
    allergies?: true
    medications?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    totalPoints?: true
    currentPoints?: true
  }

  export type PatientProfileCountAggregateInputType = {
    id?: true
    doctorId?: true
    userId?: true
    name?: true
    phone?: true
    address?: true
    emergency_contact?: true
    emergency_phone?: true
    medical_history?: true
    allergies?: true
    medications?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    totalPoints?: true
    currentPoints?: true
    _all?: true
  }

  export type PatientProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientProfile to aggregate.
     */
    where?: PatientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientProfiles to fetch.
     */
    orderBy?: PatientProfileOrderByWithRelationInput | PatientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientProfiles
    **/
    _count?: true | PatientProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientProfileMaxAggregateInputType
  }

  export type GetPatientProfileAggregateType<T extends PatientProfileAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientProfile[P]>
      : GetScalarType<T[P], AggregatePatientProfile[P]>
  }




  export type PatientProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientProfileWhereInput
    orderBy?: PatientProfileOrderByWithAggregationInput | PatientProfileOrderByWithAggregationInput[]
    by: PatientProfileScalarFieldEnum[] | PatientProfileScalarFieldEnum
    having?: PatientProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientProfileCountAggregateInputType | true
    _avg?: PatientProfileAvgAggregateInputType
    _sum?: PatientProfileSumAggregateInputType
    _min?: PatientProfileMinAggregateInputType
    _max?: PatientProfileMaxAggregateInputType
  }

  export type PatientProfileGroupByOutputType = {
    id: string
    doctorId: string
    userId: string
    name: string | null
    phone: string | null
    address: string | null
    emergency_contact: string | null
    emergency_phone: string | null
    medical_history: string | null
    allergies: string | null
    medications: string | null
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    totalPoints: number
    currentPoints: number
    _count: PatientProfileCountAggregateOutputType | null
    _avg: PatientProfileAvgAggregateOutputType | null
    _sum: PatientProfileSumAggregateOutputType | null
    _min: PatientProfileMinAggregateOutputType | null
    _max: PatientProfileMaxAggregateOutputType | null
  }

  type GetPatientProfileGroupByPayload<T extends PatientProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientProfileGroupByOutputType[P]>
            : GetScalarType<T[P], PatientProfileGroupByOutputType[P]>
        }
      >
    >


  export type PatientProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    emergency_contact?: boolean
    emergency_phone?: boolean
    medical_history?: boolean
    allergies?: boolean
    medications?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    totalPoints?: boolean
    currentPoints?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
    pointsLedger?: boolean | PatientProfile$pointsLedgerArgs<ExtArgs>
    _count?: boolean | PatientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientProfile"]>

  export type PatientProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    emergency_contact?: boolean
    emergency_phone?: boolean
    medical_history?: boolean
    allergies?: boolean
    medications?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    totalPoints?: boolean
    currentPoints?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientProfile"]>

  export type PatientProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    emergency_contact?: boolean
    emergency_phone?: boolean
    medical_history?: boolean
    allergies?: boolean
    medications?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    totalPoints?: boolean
    currentPoints?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientProfile"]>

  export type PatientProfileSelectScalar = {
    id?: boolean
    doctorId?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    emergency_contact?: boolean
    emergency_phone?: boolean
    medical_history?: boolean
    allergies?: boolean
    medications?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    totalPoints?: boolean
    currentPoints?: boolean
  }

  export type PatientProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doctorId" | "userId" | "name" | "phone" | "address" | "emergency_contact" | "emergency_phone" | "medical_history" | "allergies" | "medications" | "notes" | "isActive" | "createdAt" | "updatedAt" | "totalPoints" | "currentPoints", ExtArgs["result"]["patientProfile"]>
  export type PatientProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
    pointsLedger?: boolean | PatientProfile$pointsLedgerArgs<ExtArgs>
    _count?: boolean | PatientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PatientProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PatientProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientProfile"
    objects: {
      doctor: Prisma.$UserPayload<ExtArgs>
      patient: Prisma.$UserPayload<ExtArgs>
      pointsLedger: Prisma.$PointsLedgerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      doctorId: string
      userId: string
      name: string | null
      phone: string | null
      address: string | null
      emergency_contact: string | null
      emergency_phone: string | null
      medical_history: string | null
      allergies: string | null
      medications: string | null
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      totalPoints: number
      currentPoints: number
    }, ExtArgs["result"]["patientProfile"]>
    composites: {}
  }

  type PatientProfileGetPayload<S extends boolean | null | undefined | PatientProfileDefaultArgs> = $Result.GetResult<Prisma.$PatientProfilePayload, S>

  type PatientProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientProfileCountAggregateInputType | true
    }

  export interface PatientProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientProfile'], meta: { name: 'PatientProfile' } }
    /**
     * Find zero or one PatientProfile that matches the filter.
     * @param {PatientProfileFindUniqueArgs} args - Arguments to find a PatientProfile
     * @example
     * // Get one PatientProfile
     * const patientProfile = await prisma.patientProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientProfileFindUniqueArgs>(args: SelectSubset<T, PatientProfileFindUniqueArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatientProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientProfileFindUniqueOrThrowArgs} args - Arguments to find a PatientProfile
     * @example
     * // Get one PatientProfile
     * const patientProfile = await prisma.patientProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileFindFirstArgs} args - Arguments to find a PatientProfile
     * @example
     * // Get one PatientProfile
     * const patientProfile = await prisma.patientProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientProfileFindFirstArgs>(args?: SelectSubset<T, PatientProfileFindFirstArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileFindFirstOrThrowArgs} args - Arguments to find a PatientProfile
     * @example
     * // Get one PatientProfile
     * const patientProfile = await prisma.patientProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatientProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientProfiles
     * const patientProfiles = await prisma.patientProfile.findMany()
     * 
     * // Get first 10 PatientProfiles
     * const patientProfiles = await prisma.patientProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientProfileWithIdOnly = await prisma.patientProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientProfileFindManyArgs>(args?: SelectSubset<T, PatientProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatientProfile.
     * @param {PatientProfileCreateArgs} args - Arguments to create a PatientProfile.
     * @example
     * // Create one PatientProfile
     * const PatientProfile = await prisma.patientProfile.create({
     *   data: {
     *     // ... data to create a PatientProfile
     *   }
     * })
     * 
     */
    create<T extends PatientProfileCreateArgs>(args: SelectSubset<T, PatientProfileCreateArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatientProfiles.
     * @param {PatientProfileCreateManyArgs} args - Arguments to create many PatientProfiles.
     * @example
     * // Create many PatientProfiles
     * const patientProfile = await prisma.patientProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientProfileCreateManyArgs>(args?: SelectSubset<T, PatientProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientProfiles and returns the data saved in the database.
     * @param {PatientProfileCreateManyAndReturnArgs} args - Arguments to create many PatientProfiles.
     * @example
     * // Create many PatientProfiles
     * const patientProfile = await prisma.patientProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientProfiles and only return the `id`
     * const patientProfileWithIdOnly = await prisma.patientProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatientProfile.
     * @param {PatientProfileDeleteArgs} args - Arguments to delete one PatientProfile.
     * @example
     * // Delete one PatientProfile
     * const PatientProfile = await prisma.patientProfile.delete({
     *   where: {
     *     // ... filter to delete one PatientProfile
     *   }
     * })
     * 
     */
    delete<T extends PatientProfileDeleteArgs>(args: SelectSubset<T, PatientProfileDeleteArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatientProfile.
     * @param {PatientProfileUpdateArgs} args - Arguments to update one PatientProfile.
     * @example
     * // Update one PatientProfile
     * const patientProfile = await prisma.patientProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientProfileUpdateArgs>(args: SelectSubset<T, PatientProfileUpdateArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatientProfiles.
     * @param {PatientProfileDeleteManyArgs} args - Arguments to filter PatientProfiles to delete.
     * @example
     * // Delete a few PatientProfiles
     * const { count } = await prisma.patientProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientProfileDeleteManyArgs>(args?: SelectSubset<T, PatientProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientProfiles
     * const patientProfile = await prisma.patientProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientProfileUpdateManyArgs>(args: SelectSubset<T, PatientProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientProfiles and returns the data updated in the database.
     * @param {PatientProfileUpdateManyAndReturnArgs} args - Arguments to update many PatientProfiles.
     * @example
     * // Update many PatientProfiles
     * const patientProfile = await prisma.patientProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PatientProfiles and only return the `id`
     * const patientProfileWithIdOnly = await prisma.patientProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatientProfile.
     * @param {PatientProfileUpsertArgs} args - Arguments to update or create a PatientProfile.
     * @example
     * // Update or create a PatientProfile
     * const patientProfile = await prisma.patientProfile.upsert({
     *   create: {
     *     // ... data to create a PatientProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientProfile we want to update
     *   }
     * })
     */
    upsert<T extends PatientProfileUpsertArgs>(args: SelectSubset<T, PatientProfileUpsertArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileCountArgs} args - Arguments to filter PatientProfiles to count.
     * @example
     * // Count the number of PatientProfiles
     * const count = await prisma.patientProfile.count({
     *   where: {
     *     // ... the filter for the PatientProfiles we want to count
     *   }
     * })
    **/
    count<T extends PatientProfileCountArgs>(
      args?: Subset<T, PatientProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientProfileAggregateArgs>(args: Subset<T, PatientProfileAggregateArgs>): Prisma.PrismaPromise<GetPatientProfileAggregateType<T>>

    /**
     * Group by PatientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientProfileGroupByArgs['orderBy'] }
        : { orderBy?: PatientProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientProfile model
   */
  readonly fields: PatientProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pointsLedger<T extends PatientProfile$pointsLedgerArgs<ExtArgs> = {}>(args?: Subset<T, PatientProfile$pointsLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientProfile model
   */
  interface PatientProfileFieldRefs {
    readonly id: FieldRef<"PatientProfile", 'String'>
    readonly doctorId: FieldRef<"PatientProfile", 'String'>
    readonly userId: FieldRef<"PatientProfile", 'String'>
    readonly name: FieldRef<"PatientProfile", 'String'>
    readonly phone: FieldRef<"PatientProfile", 'String'>
    readonly address: FieldRef<"PatientProfile", 'String'>
    readonly emergency_contact: FieldRef<"PatientProfile", 'String'>
    readonly emergency_phone: FieldRef<"PatientProfile", 'String'>
    readonly medical_history: FieldRef<"PatientProfile", 'String'>
    readonly allergies: FieldRef<"PatientProfile", 'String'>
    readonly medications: FieldRef<"PatientProfile", 'String'>
    readonly notes: FieldRef<"PatientProfile", 'String'>
    readonly isActive: FieldRef<"PatientProfile", 'Boolean'>
    readonly createdAt: FieldRef<"PatientProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"PatientProfile", 'DateTime'>
    readonly totalPoints: FieldRef<"PatientProfile", 'Int'>
    readonly currentPoints: FieldRef<"PatientProfile", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PatientProfile findUnique
   */
  export type PatientProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter, which PatientProfile to fetch.
     */
    where: PatientProfileWhereUniqueInput
  }

  /**
   * PatientProfile findUniqueOrThrow
   */
  export type PatientProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter, which PatientProfile to fetch.
     */
    where: PatientProfileWhereUniqueInput
  }

  /**
   * PatientProfile findFirst
   */
  export type PatientProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter, which PatientProfile to fetch.
     */
    where?: PatientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientProfiles to fetch.
     */
    orderBy?: PatientProfileOrderByWithRelationInput | PatientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientProfiles.
     */
    cursor?: PatientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientProfiles.
     */
    distinct?: PatientProfileScalarFieldEnum | PatientProfileScalarFieldEnum[]
  }

  /**
   * PatientProfile findFirstOrThrow
   */
  export type PatientProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter, which PatientProfile to fetch.
     */
    where?: PatientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientProfiles to fetch.
     */
    orderBy?: PatientProfileOrderByWithRelationInput | PatientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientProfiles.
     */
    cursor?: PatientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientProfiles.
     */
    distinct?: PatientProfileScalarFieldEnum | PatientProfileScalarFieldEnum[]
  }

  /**
   * PatientProfile findMany
   */
  export type PatientProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter, which PatientProfiles to fetch.
     */
    where?: PatientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientProfiles to fetch.
     */
    orderBy?: PatientProfileOrderByWithRelationInput | PatientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientProfiles.
     */
    cursor?: PatientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientProfiles.
     */
    skip?: number
    distinct?: PatientProfileScalarFieldEnum | PatientProfileScalarFieldEnum[]
  }

  /**
   * PatientProfile create
   */
  export type PatientProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientProfile.
     */
    data: XOR<PatientProfileCreateInput, PatientProfileUncheckedCreateInput>
  }

  /**
   * PatientProfile createMany
   */
  export type PatientProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientProfiles.
     */
    data: PatientProfileCreateManyInput | PatientProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientProfile createManyAndReturn
   */
  export type PatientProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * The data used to create many PatientProfiles.
     */
    data: PatientProfileCreateManyInput | PatientProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientProfile update
   */
  export type PatientProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientProfile.
     */
    data: XOR<PatientProfileUpdateInput, PatientProfileUncheckedUpdateInput>
    /**
     * Choose, which PatientProfile to update.
     */
    where: PatientProfileWhereUniqueInput
  }

  /**
   * PatientProfile updateMany
   */
  export type PatientProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientProfiles.
     */
    data: XOR<PatientProfileUpdateManyMutationInput, PatientProfileUncheckedUpdateManyInput>
    /**
     * Filter which PatientProfiles to update
     */
    where?: PatientProfileWhereInput
    /**
     * Limit how many PatientProfiles to update.
     */
    limit?: number
  }

  /**
   * PatientProfile updateManyAndReturn
   */
  export type PatientProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * The data used to update PatientProfiles.
     */
    data: XOR<PatientProfileUpdateManyMutationInput, PatientProfileUncheckedUpdateManyInput>
    /**
     * Filter which PatientProfiles to update
     */
    where?: PatientProfileWhereInput
    /**
     * Limit how many PatientProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientProfile upsert
   */
  export type PatientProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientProfile to update in case it exists.
     */
    where: PatientProfileWhereUniqueInput
    /**
     * In case the PatientProfile found by the `where` argument doesn't exist, create a new PatientProfile with this data.
     */
    create: XOR<PatientProfileCreateInput, PatientProfileUncheckedCreateInput>
    /**
     * In case the PatientProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientProfileUpdateInput, PatientProfileUncheckedUpdateInput>
  }

  /**
   * PatientProfile delete
   */
  export type PatientProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter which PatientProfile to delete.
     */
    where: PatientProfileWhereUniqueInput
  }

  /**
   * PatientProfile deleteMany
   */
  export type PatientProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientProfiles to delete
     */
    where?: PatientProfileWhereInput
    /**
     * Limit how many PatientProfiles to delete.
     */
    limit?: number
  }

  /**
   * PatientProfile.pointsLedger
   */
  export type PatientProfile$pointsLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
    where?: PointsLedgerWhereInput
    orderBy?: PointsLedgerOrderByWithRelationInput | PointsLedgerOrderByWithRelationInput[]
    cursor?: PointsLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointsLedgerScalarFieldEnum | PointsLedgerScalarFieldEnum[]
  }

  /**
   * PatientProfile without action
   */
  export type PatientProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
  }


  /**
   * Model PointsLedger
   */

  export type AggregatePointsLedger = {
    _count: PointsLedgerCountAggregateOutputType | null
    _avg: PointsLedgerAvgAggregateOutputType | null
    _sum: PointsLedgerSumAggregateOutputType | null
    _min: PointsLedgerMinAggregateOutputType | null
    _max: PointsLedgerMaxAggregateOutputType | null
  }

  export type PointsLedgerAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PointsLedgerSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PointsLedgerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    patientProfileId: string | null
    sourceType: string | null
    sourceId: string | null
    amount: Decimal | null
    description: string | null
    createdAt: Date | null
  }

  export type PointsLedgerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    patientProfileId: string | null
    sourceType: string | null
    sourceId: string | null
    amount: Decimal | null
    description: string | null
    createdAt: Date | null
  }

  export type PointsLedgerCountAggregateOutputType = {
    id: number
    userId: number
    patientProfileId: number
    sourceType: number
    sourceId: number
    amount: number
    description: number
    createdAt: number
    _all: number
  }


  export type PointsLedgerAvgAggregateInputType = {
    amount?: true
  }

  export type PointsLedgerSumAggregateInputType = {
    amount?: true
  }

  export type PointsLedgerMinAggregateInputType = {
    id?: true
    userId?: true
    patientProfileId?: true
    sourceType?: true
    sourceId?: true
    amount?: true
    description?: true
    createdAt?: true
  }

  export type PointsLedgerMaxAggregateInputType = {
    id?: true
    userId?: true
    patientProfileId?: true
    sourceType?: true
    sourceId?: true
    amount?: true
    description?: true
    createdAt?: true
  }

  export type PointsLedgerCountAggregateInputType = {
    id?: true
    userId?: true
    patientProfileId?: true
    sourceType?: true
    sourceId?: true
    amount?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type PointsLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointsLedger to aggregate.
     */
    where?: PointsLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsLedgers to fetch.
     */
    orderBy?: PointsLedgerOrderByWithRelationInput | PointsLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointsLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointsLedgers
    **/
    _count?: true | PointsLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointsLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointsLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointsLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointsLedgerMaxAggregateInputType
  }

  export type GetPointsLedgerAggregateType<T extends PointsLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregatePointsLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointsLedger[P]>
      : GetScalarType<T[P], AggregatePointsLedger[P]>
  }




  export type PointsLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointsLedgerWhereInput
    orderBy?: PointsLedgerOrderByWithAggregationInput | PointsLedgerOrderByWithAggregationInput[]
    by: PointsLedgerScalarFieldEnum[] | PointsLedgerScalarFieldEnum
    having?: PointsLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointsLedgerCountAggregateInputType | true
    _avg?: PointsLedgerAvgAggregateInputType
    _sum?: PointsLedgerSumAggregateInputType
    _min?: PointsLedgerMinAggregateInputType
    _max?: PointsLedgerMaxAggregateInputType
  }

  export type PointsLedgerGroupByOutputType = {
    id: string
    userId: string
    patientProfileId: string | null
    sourceType: string
    sourceId: string
    amount: Decimal
    description: string | null
    createdAt: Date
    _count: PointsLedgerCountAggregateOutputType | null
    _avg: PointsLedgerAvgAggregateOutputType | null
    _sum: PointsLedgerSumAggregateOutputType | null
    _min: PointsLedgerMinAggregateOutputType | null
    _max: PointsLedgerMaxAggregateOutputType | null
  }

  type GetPointsLedgerGroupByPayload<T extends PointsLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointsLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointsLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointsLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], PointsLedgerGroupByOutputType[P]>
        }
      >
    >


  export type PointsLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patientProfileId?: boolean
    sourceType?: boolean
    sourceId?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    patientProfile?: boolean | PointsLedger$patientProfileArgs<ExtArgs>
  }, ExtArgs["result"]["pointsLedger"]>

  export type PointsLedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patientProfileId?: boolean
    sourceType?: boolean
    sourceId?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    patientProfile?: boolean | PointsLedger$patientProfileArgs<ExtArgs>
  }, ExtArgs["result"]["pointsLedger"]>

  export type PointsLedgerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patientProfileId?: boolean
    sourceType?: boolean
    sourceId?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    patientProfile?: boolean | PointsLedger$patientProfileArgs<ExtArgs>
  }, ExtArgs["result"]["pointsLedger"]>

  export type PointsLedgerSelectScalar = {
    id?: boolean
    userId?: boolean
    patientProfileId?: boolean
    sourceType?: boolean
    sourceId?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type PointsLedgerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "patientProfileId" | "sourceType" | "sourceId" | "amount" | "description" | "createdAt", ExtArgs["result"]["pointsLedger"]>
  export type PointsLedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    patientProfile?: boolean | PointsLedger$patientProfileArgs<ExtArgs>
  }
  export type PointsLedgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    patientProfile?: boolean | PointsLedger$patientProfileArgs<ExtArgs>
  }
  export type PointsLedgerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    patientProfile?: boolean | PointsLedger$patientProfileArgs<ExtArgs>
  }

  export type $PointsLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointsLedger"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      patientProfile: Prisma.$PatientProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      patientProfileId: string | null
      sourceType: string
      sourceId: string
      amount: Prisma.Decimal
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["pointsLedger"]>
    composites: {}
  }

  type PointsLedgerGetPayload<S extends boolean | null | undefined | PointsLedgerDefaultArgs> = $Result.GetResult<Prisma.$PointsLedgerPayload, S>

  type PointsLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointsLedgerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointsLedgerCountAggregateInputType | true
    }

  export interface PointsLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointsLedger'], meta: { name: 'PointsLedger' } }
    /**
     * Find zero or one PointsLedger that matches the filter.
     * @param {PointsLedgerFindUniqueArgs} args - Arguments to find a PointsLedger
     * @example
     * // Get one PointsLedger
     * const pointsLedger = await prisma.pointsLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointsLedgerFindUniqueArgs>(args: SelectSubset<T, PointsLedgerFindUniqueArgs<ExtArgs>>): Prisma__PointsLedgerClient<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PointsLedger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointsLedgerFindUniqueOrThrowArgs} args - Arguments to find a PointsLedger
     * @example
     * // Get one PointsLedger
     * const pointsLedger = await prisma.pointsLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointsLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, PointsLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointsLedgerClient<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointsLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerFindFirstArgs} args - Arguments to find a PointsLedger
     * @example
     * // Get one PointsLedger
     * const pointsLedger = await prisma.pointsLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointsLedgerFindFirstArgs>(args?: SelectSubset<T, PointsLedgerFindFirstArgs<ExtArgs>>): Prisma__PointsLedgerClient<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointsLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerFindFirstOrThrowArgs} args - Arguments to find a PointsLedger
     * @example
     * // Get one PointsLedger
     * const pointsLedger = await prisma.pointsLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointsLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, PointsLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointsLedgerClient<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PointsLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointsLedgers
     * const pointsLedgers = await prisma.pointsLedger.findMany()
     * 
     * // Get first 10 PointsLedgers
     * const pointsLedgers = await prisma.pointsLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointsLedgerWithIdOnly = await prisma.pointsLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointsLedgerFindManyArgs>(args?: SelectSubset<T, PointsLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PointsLedger.
     * @param {PointsLedgerCreateArgs} args - Arguments to create a PointsLedger.
     * @example
     * // Create one PointsLedger
     * const PointsLedger = await prisma.pointsLedger.create({
     *   data: {
     *     // ... data to create a PointsLedger
     *   }
     * })
     * 
     */
    create<T extends PointsLedgerCreateArgs>(args: SelectSubset<T, PointsLedgerCreateArgs<ExtArgs>>): Prisma__PointsLedgerClient<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PointsLedgers.
     * @param {PointsLedgerCreateManyArgs} args - Arguments to create many PointsLedgers.
     * @example
     * // Create many PointsLedgers
     * const pointsLedger = await prisma.pointsLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointsLedgerCreateManyArgs>(args?: SelectSubset<T, PointsLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PointsLedgers and returns the data saved in the database.
     * @param {PointsLedgerCreateManyAndReturnArgs} args - Arguments to create many PointsLedgers.
     * @example
     * // Create many PointsLedgers
     * const pointsLedger = await prisma.pointsLedger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PointsLedgers and only return the `id`
     * const pointsLedgerWithIdOnly = await prisma.pointsLedger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointsLedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, PointsLedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PointsLedger.
     * @param {PointsLedgerDeleteArgs} args - Arguments to delete one PointsLedger.
     * @example
     * // Delete one PointsLedger
     * const PointsLedger = await prisma.pointsLedger.delete({
     *   where: {
     *     // ... filter to delete one PointsLedger
     *   }
     * })
     * 
     */
    delete<T extends PointsLedgerDeleteArgs>(args: SelectSubset<T, PointsLedgerDeleteArgs<ExtArgs>>): Prisma__PointsLedgerClient<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PointsLedger.
     * @param {PointsLedgerUpdateArgs} args - Arguments to update one PointsLedger.
     * @example
     * // Update one PointsLedger
     * const pointsLedger = await prisma.pointsLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointsLedgerUpdateArgs>(args: SelectSubset<T, PointsLedgerUpdateArgs<ExtArgs>>): Prisma__PointsLedgerClient<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PointsLedgers.
     * @param {PointsLedgerDeleteManyArgs} args - Arguments to filter PointsLedgers to delete.
     * @example
     * // Delete a few PointsLedgers
     * const { count } = await prisma.pointsLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointsLedgerDeleteManyArgs>(args?: SelectSubset<T, PointsLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointsLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointsLedgers
     * const pointsLedger = await prisma.pointsLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointsLedgerUpdateManyArgs>(args: SelectSubset<T, PointsLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointsLedgers and returns the data updated in the database.
     * @param {PointsLedgerUpdateManyAndReturnArgs} args - Arguments to update many PointsLedgers.
     * @example
     * // Update many PointsLedgers
     * const pointsLedger = await prisma.pointsLedger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PointsLedgers and only return the `id`
     * const pointsLedgerWithIdOnly = await prisma.pointsLedger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PointsLedgerUpdateManyAndReturnArgs>(args: SelectSubset<T, PointsLedgerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PointsLedger.
     * @param {PointsLedgerUpsertArgs} args - Arguments to update or create a PointsLedger.
     * @example
     * // Update or create a PointsLedger
     * const pointsLedger = await prisma.pointsLedger.upsert({
     *   create: {
     *     // ... data to create a PointsLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointsLedger we want to update
     *   }
     * })
     */
    upsert<T extends PointsLedgerUpsertArgs>(args: SelectSubset<T, PointsLedgerUpsertArgs<ExtArgs>>): Prisma__PointsLedgerClient<$Result.GetResult<Prisma.$PointsLedgerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PointsLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerCountArgs} args - Arguments to filter PointsLedgers to count.
     * @example
     * // Count the number of PointsLedgers
     * const count = await prisma.pointsLedger.count({
     *   where: {
     *     // ... the filter for the PointsLedgers we want to count
     *   }
     * })
    **/
    count<T extends PointsLedgerCountArgs>(
      args?: Subset<T, PointsLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointsLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointsLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointsLedgerAggregateArgs>(args: Subset<T, PointsLedgerAggregateArgs>): Prisma.PrismaPromise<GetPointsLedgerAggregateType<T>>

    /**
     * Group by PointsLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointsLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointsLedgerGroupByArgs['orderBy'] }
        : { orderBy?: PointsLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointsLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointsLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointsLedger model
   */
  readonly fields: PointsLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointsLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointsLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patientProfile<T extends PointsLedger$patientProfileArgs<ExtArgs> = {}>(args?: Subset<T, PointsLedger$patientProfileArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointsLedger model
   */
  interface PointsLedgerFieldRefs {
    readonly id: FieldRef<"PointsLedger", 'String'>
    readonly userId: FieldRef<"PointsLedger", 'String'>
    readonly patientProfileId: FieldRef<"PointsLedger", 'String'>
    readonly sourceType: FieldRef<"PointsLedger", 'String'>
    readonly sourceId: FieldRef<"PointsLedger", 'String'>
    readonly amount: FieldRef<"PointsLedger", 'Decimal'>
    readonly description: FieldRef<"PointsLedger", 'String'>
    readonly createdAt: FieldRef<"PointsLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PointsLedger findUnique
   */
  export type PointsLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
    /**
     * Filter, which PointsLedger to fetch.
     */
    where: PointsLedgerWhereUniqueInput
  }

  /**
   * PointsLedger findUniqueOrThrow
   */
  export type PointsLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
    /**
     * Filter, which PointsLedger to fetch.
     */
    where: PointsLedgerWhereUniqueInput
  }

  /**
   * PointsLedger findFirst
   */
  export type PointsLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
    /**
     * Filter, which PointsLedger to fetch.
     */
    where?: PointsLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsLedgers to fetch.
     */
    orderBy?: PointsLedgerOrderByWithRelationInput | PointsLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointsLedgers.
     */
    cursor?: PointsLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointsLedgers.
     */
    distinct?: PointsLedgerScalarFieldEnum | PointsLedgerScalarFieldEnum[]
  }

  /**
   * PointsLedger findFirstOrThrow
   */
  export type PointsLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
    /**
     * Filter, which PointsLedger to fetch.
     */
    where?: PointsLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsLedgers to fetch.
     */
    orderBy?: PointsLedgerOrderByWithRelationInput | PointsLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointsLedgers.
     */
    cursor?: PointsLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointsLedgers.
     */
    distinct?: PointsLedgerScalarFieldEnum | PointsLedgerScalarFieldEnum[]
  }

  /**
   * PointsLedger findMany
   */
  export type PointsLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
    /**
     * Filter, which PointsLedgers to fetch.
     */
    where?: PointsLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsLedgers to fetch.
     */
    orderBy?: PointsLedgerOrderByWithRelationInput | PointsLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointsLedgers.
     */
    cursor?: PointsLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsLedgers.
     */
    skip?: number
    distinct?: PointsLedgerScalarFieldEnum | PointsLedgerScalarFieldEnum[]
  }

  /**
   * PointsLedger create
   */
  export type PointsLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a PointsLedger.
     */
    data: XOR<PointsLedgerCreateInput, PointsLedgerUncheckedCreateInput>
  }

  /**
   * PointsLedger createMany
   */
  export type PointsLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointsLedgers.
     */
    data: PointsLedgerCreateManyInput | PointsLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointsLedger createManyAndReturn
   */
  export type PointsLedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * The data used to create many PointsLedgers.
     */
    data: PointsLedgerCreateManyInput | PointsLedgerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointsLedger update
   */
  export type PointsLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a PointsLedger.
     */
    data: XOR<PointsLedgerUpdateInput, PointsLedgerUncheckedUpdateInput>
    /**
     * Choose, which PointsLedger to update.
     */
    where: PointsLedgerWhereUniqueInput
  }

  /**
   * PointsLedger updateMany
   */
  export type PointsLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointsLedgers.
     */
    data: XOR<PointsLedgerUpdateManyMutationInput, PointsLedgerUncheckedUpdateManyInput>
    /**
     * Filter which PointsLedgers to update
     */
    where?: PointsLedgerWhereInput
    /**
     * Limit how many PointsLedgers to update.
     */
    limit?: number
  }

  /**
   * PointsLedger updateManyAndReturn
   */
  export type PointsLedgerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * The data used to update PointsLedgers.
     */
    data: XOR<PointsLedgerUpdateManyMutationInput, PointsLedgerUncheckedUpdateManyInput>
    /**
     * Filter which PointsLedgers to update
     */
    where?: PointsLedgerWhereInput
    /**
     * Limit how many PointsLedgers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointsLedger upsert
   */
  export type PointsLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the PointsLedger to update in case it exists.
     */
    where: PointsLedgerWhereUniqueInput
    /**
     * In case the PointsLedger found by the `where` argument doesn't exist, create a new PointsLedger with this data.
     */
    create: XOR<PointsLedgerCreateInput, PointsLedgerUncheckedCreateInput>
    /**
     * In case the PointsLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointsLedgerUpdateInput, PointsLedgerUncheckedUpdateInput>
  }

  /**
   * PointsLedger delete
   */
  export type PointsLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
    /**
     * Filter which PointsLedger to delete.
     */
    where: PointsLedgerWhereUniqueInput
  }

  /**
   * PointsLedger deleteMany
   */
  export type PointsLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointsLedgers to delete
     */
    where?: PointsLedgerWhereInput
    /**
     * Limit how many PointsLedgers to delete.
     */
    limit?: number
  }

  /**
   * PointsLedger.patientProfile
   */
  export type PointsLedger$patientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientProfile
     */
    omit?: PatientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    where?: PatientProfileWhereInput
  }

  /**
   * PointsLedger without action
   */
  export type PointsLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedger
     */
    select?: PointsLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedger
     */
    omit?: PointsLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerInclude<ExtArgs> | null
  }


  /**
   * Model Clinic
   */

  export type AggregateClinic = {
    _count: ClinicCountAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  export type ClinicMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    website: string | null
    logo: string | null
    slug: string | null
    subdomain: string | null
    monthlyRevenueRange: string | null
    currentGateway: string | null
    theme: $Enums.ClinicTheme | null
    buttonColor: string | null
    buttonTextColor: string | null
  }

  export type ClinicMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    website: string | null
    logo: string | null
    slug: string | null
    subdomain: string | null
    monthlyRevenueRange: string | null
    currentGateway: string | null
    theme: $Enums.ClinicTheme | null
    buttonColor: string | null
    buttonTextColor: string | null
  }

  export type ClinicCountAggregateOutputType = {
    id: number
    name: number
    description: number
    ownerId: number
    isActive: number
    createdAt: number
    updatedAt: number
    email: number
    phone: number
    address: number
    city: number
    state: number
    zipCode: number
    country: number
    website: number
    logo: number
    slug: number
    subdomain: number
    monthlyRevenueRange: number
    currentGateway: number
    theme: number
    buttonColor: number
    buttonTextColor: number
    _all: number
  }


  export type ClinicMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    website?: true
    logo?: true
    slug?: true
    subdomain?: true
    monthlyRevenueRange?: true
    currentGateway?: true
    theme?: true
    buttonColor?: true
    buttonTextColor?: true
  }

  export type ClinicMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    website?: true
    logo?: true
    slug?: true
    subdomain?: true
    monthlyRevenueRange?: true
    currentGateway?: true
    theme?: true
    buttonColor?: true
    buttonTextColor?: true
  }

  export type ClinicCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    website?: true
    logo?: true
    slug?: true
    subdomain?: true
    monthlyRevenueRange?: true
    currentGateway?: true
    theme?: true
    buttonColor?: true
    buttonTextColor?: true
    _all?: true
  }

  export type ClinicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinic to aggregate.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clinics
    **/
    _count?: true | ClinicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicMaxAggregateInputType
  }

  export type GetClinicAggregateType<T extends ClinicAggregateArgs> = {
        [P in keyof T & keyof AggregateClinic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic[P]>
      : GetScalarType<T[P], AggregateClinic[P]>
  }




  export type ClinicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicWhereInput
    orderBy?: ClinicOrderByWithAggregationInput | ClinicOrderByWithAggregationInput[]
    by: ClinicScalarFieldEnum[] | ClinicScalarFieldEnum
    having?: ClinicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicCountAggregateInputType | true
    _min?: ClinicMinAggregateInputType
    _max?: ClinicMaxAggregateInputType
  }

  export type ClinicGroupByOutputType = {
    id: string
    name: string
    description: string | null
    ownerId: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    website: string | null
    logo: string | null
    slug: string | null
    subdomain: string | null
    monthlyRevenueRange: string | null
    currentGateway: string | null
    theme: $Enums.ClinicTheme
    buttonColor: string | null
    buttonTextColor: string | null
    _count: ClinicCountAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  type GetClinicGroupByPayload<T extends ClinicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicGroupByOutputType[P]>
        }
      >
    >


  export type ClinicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    website?: boolean
    logo?: boolean
    slug?: boolean
    subdomain?: boolean
    monthlyRevenueRange?: boolean
    currentGateway?: boolean
    theme?: boolean
    buttonColor?: boolean
    buttonTextColor?: boolean
    members?: boolean | Clinic$membersArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    subscriptions?: boolean | Clinic$subscriptionsArgs<ExtArgs>
    products?: boolean | Clinic$productsArgs<ExtArgs>
    merchant?: boolean | Clinic$merchantArgs<ExtArgs>
    merchantApplication?: boolean | Clinic$merchantApplicationArgs<ExtArgs>
    webhookEndpoints?: boolean | Clinic$webhookEndpointsArgs<ExtArgs>
    outboundEvents?: boolean | Clinic$outboundEventsArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    website?: boolean
    logo?: boolean
    slug?: boolean
    subdomain?: boolean
    monthlyRevenueRange?: boolean
    currentGateway?: boolean
    theme?: boolean
    buttonColor?: boolean
    buttonTextColor?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    website?: boolean
    logo?: boolean
    slug?: boolean
    subdomain?: boolean
    monthlyRevenueRange?: boolean
    currentGateway?: boolean
    theme?: boolean
    buttonColor?: boolean
    buttonTextColor?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    website?: boolean
    logo?: boolean
    slug?: boolean
    subdomain?: boolean
    monthlyRevenueRange?: boolean
    currentGateway?: boolean
    theme?: boolean
    buttonColor?: boolean
    buttonTextColor?: boolean
  }

  export type ClinicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "ownerId" | "isActive" | "createdAt" | "updatedAt" | "email" | "phone" | "address" | "city" | "state" | "zipCode" | "country" | "website" | "logo" | "slug" | "subdomain" | "monthlyRevenueRange" | "currentGateway" | "theme" | "buttonColor" | "buttonTextColor", ExtArgs["result"]["clinic"]>
  export type ClinicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Clinic$membersArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    subscriptions?: boolean | Clinic$subscriptionsArgs<ExtArgs>
    products?: boolean | Clinic$productsArgs<ExtArgs>
    merchant?: boolean | Clinic$merchantArgs<ExtArgs>
    merchantApplication?: boolean | Clinic$merchantApplicationArgs<ExtArgs>
    webhookEndpoints?: boolean | Clinic$webhookEndpointsArgs<ExtArgs>
    outboundEvents?: boolean | Clinic$outboundEventsArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClinicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClinicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClinicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clinic"
    objects: {
      members: Prisma.$ClinicMemberPayload<ExtArgs>[]
      owner: Prisma.$UserPayload<ExtArgs>
      subscriptions: Prisma.$ClinicSubscriptionPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      merchant: Prisma.$MerchantPayload<ExtArgs> | null
      merchantApplication: Prisma.$MerchantApplicationPayload<ExtArgs> | null
      webhookEndpoints: Prisma.$WebhookEndpointPayload<ExtArgs>[]
      outboundEvents: Prisma.$OutboundWebhookEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      ownerId: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      email: string | null
      phone: string | null
      address: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      country: string | null
      website: string | null
      logo: string | null
      slug: string | null
      subdomain: string | null
      monthlyRevenueRange: string | null
      currentGateway: string | null
      theme: $Enums.ClinicTheme
      buttonColor: string | null
      buttonTextColor: string | null
    }, ExtArgs["result"]["clinic"]>
    composites: {}
  }

  type ClinicGetPayload<S extends boolean | null | undefined | ClinicDefaultArgs> = $Result.GetResult<Prisma.$ClinicPayload, S>

  type ClinicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicCountAggregateInputType | true
    }

  export interface ClinicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clinic'], meta: { name: 'Clinic' } }
    /**
     * Find zero or one Clinic that matches the filter.
     * @param {ClinicFindUniqueArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicFindUniqueArgs>(args: SelectSubset<T, ClinicFindUniqueArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clinic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicFindUniqueOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clinic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicFindFirstArgs>(args?: SelectSubset<T, ClinicFindFirstArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clinic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clinics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinics
     * const clinics = await prisma.clinic.findMany()
     * 
     * // Get first 10 Clinics
     * const clinics = await prisma.clinic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicWithIdOnly = await prisma.clinic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicFindManyArgs>(args?: SelectSubset<T, ClinicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clinic.
     * @param {ClinicCreateArgs} args - Arguments to create a Clinic.
     * @example
     * // Create one Clinic
     * const Clinic = await prisma.clinic.create({
     *   data: {
     *     // ... data to create a Clinic
     *   }
     * })
     * 
     */
    create<T extends ClinicCreateArgs>(args: SelectSubset<T, ClinicCreateArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clinics.
     * @param {ClinicCreateManyArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicCreateManyArgs>(args?: SelectSubset<T, ClinicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clinics and returns the data saved in the database.
     * @param {ClinicCreateManyAndReturnArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clinics and only return the `id`
     * const clinicWithIdOnly = await prisma.clinic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clinic.
     * @param {ClinicDeleteArgs} args - Arguments to delete one Clinic.
     * @example
     * // Delete one Clinic
     * const Clinic = await prisma.clinic.delete({
     *   where: {
     *     // ... filter to delete one Clinic
     *   }
     * })
     * 
     */
    delete<T extends ClinicDeleteArgs>(args: SelectSubset<T, ClinicDeleteArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clinic.
     * @param {ClinicUpdateArgs} args - Arguments to update one Clinic.
     * @example
     * // Update one Clinic
     * const clinic = await prisma.clinic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicUpdateArgs>(args: SelectSubset<T, ClinicUpdateArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clinics.
     * @param {ClinicDeleteManyArgs} args - Arguments to filter Clinics to delete.
     * @example
     * // Delete a few Clinics
     * const { count } = await prisma.clinic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicDeleteManyArgs>(args?: SelectSubset<T, ClinicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicUpdateManyArgs>(args: SelectSubset<T, ClinicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinics and returns the data updated in the database.
     * @param {ClinicUpdateManyAndReturnArgs} args - Arguments to update many Clinics.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clinics and only return the `id`
     * const clinicWithIdOnly = await prisma.clinic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clinic.
     * @param {ClinicUpsertArgs} args - Arguments to update or create a Clinic.
     * @example
     * // Update or create a Clinic
     * const clinic = await prisma.clinic.upsert({
     *   create: {
     *     // ... data to create a Clinic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic we want to update
     *   }
     * })
     */
    upsert<T extends ClinicUpsertArgs>(args: SelectSubset<T, ClinicUpsertArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicCountArgs} args - Arguments to filter Clinics to count.
     * @example
     * // Count the number of Clinics
     * const count = await prisma.clinic.count({
     *   where: {
     *     // ... the filter for the Clinics we want to count
     *   }
     * })
    **/
    count<T extends ClinicCountArgs>(
      args?: Subset<T, ClinicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicAggregateArgs>(args: Subset<T, ClinicAggregateArgs>): Prisma.PrismaPromise<GetClinicAggregateType<T>>

    /**
     * Group by Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicGroupByArgs['orderBy'] }
        : { orderBy?: ClinicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clinic model
   */
  readonly fields: ClinicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clinic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Clinic$membersArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscriptions<T extends Clinic$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Clinic$productsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    merchant<T extends Clinic$merchantArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$merchantArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    merchantApplication<T extends Clinic$merchantApplicationArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$merchantApplicationArgs<ExtArgs>>): Prisma__MerchantApplicationClient<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    webhookEndpoints<T extends Clinic$webhookEndpointsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$webhookEndpointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    outboundEvents<T extends Clinic$outboundEventsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$outboundEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Clinic model
   */
  interface ClinicFieldRefs {
    readonly id: FieldRef<"Clinic", 'String'>
    readonly name: FieldRef<"Clinic", 'String'>
    readonly description: FieldRef<"Clinic", 'String'>
    readonly ownerId: FieldRef<"Clinic", 'String'>
    readonly isActive: FieldRef<"Clinic", 'Boolean'>
    readonly createdAt: FieldRef<"Clinic", 'DateTime'>
    readonly updatedAt: FieldRef<"Clinic", 'DateTime'>
    readonly email: FieldRef<"Clinic", 'String'>
    readonly phone: FieldRef<"Clinic", 'String'>
    readonly address: FieldRef<"Clinic", 'String'>
    readonly city: FieldRef<"Clinic", 'String'>
    readonly state: FieldRef<"Clinic", 'String'>
    readonly zipCode: FieldRef<"Clinic", 'String'>
    readonly country: FieldRef<"Clinic", 'String'>
    readonly website: FieldRef<"Clinic", 'String'>
    readonly logo: FieldRef<"Clinic", 'String'>
    readonly slug: FieldRef<"Clinic", 'String'>
    readonly subdomain: FieldRef<"Clinic", 'String'>
    readonly monthlyRevenueRange: FieldRef<"Clinic", 'String'>
    readonly currentGateway: FieldRef<"Clinic", 'String'>
    readonly theme: FieldRef<"Clinic", 'ClinicTheme'>
    readonly buttonColor: FieldRef<"Clinic", 'String'>
    readonly buttonTextColor: FieldRef<"Clinic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Clinic findUnique
   */
  export type ClinicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic findUniqueOrThrow
   */
  export type ClinicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic findFirst
   */
  export type ClinicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic findFirstOrThrow
   */
  export type ClinicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic findMany
   */
  export type ClinicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinics to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic create
   */
  export type ClinicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to create a Clinic.
     */
    data: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
  }

  /**
   * Clinic createMany
   */
  export type ClinicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinic createManyAndReturn
   */
  export type ClinicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Clinic update
   */
  export type ClinicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to update a Clinic.
     */
    data: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
    /**
     * Choose, which Clinic to update.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic updateMany
   */
  export type ClinicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to update.
     */
    limit?: number
  }

  /**
   * Clinic updateManyAndReturn
   */
  export type ClinicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Clinic upsert
   */
  export type ClinicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The filter to search for the Clinic to update in case it exists.
     */
    where: ClinicWhereUniqueInput
    /**
     * In case the Clinic found by the `where` argument doesn't exist, create a new Clinic with this data.
     */
    create: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
    /**
     * In case the Clinic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
  }

  /**
   * Clinic delete
   */
  export type ClinicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter which Clinic to delete.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic deleteMany
   */
  export type ClinicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinics to delete
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to delete.
     */
    limit?: number
  }

  /**
   * Clinic.members
   */
  export type Clinic$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
    where?: ClinicMemberWhereInput
    orderBy?: ClinicMemberOrderByWithRelationInput | ClinicMemberOrderByWithRelationInput[]
    cursor?: ClinicMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicMemberScalarFieldEnum | ClinicMemberScalarFieldEnum[]
  }

  /**
   * Clinic.subscriptions
   */
  export type Clinic$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
    where?: ClinicSubscriptionWhereInput
    orderBy?: ClinicSubscriptionOrderByWithRelationInput | ClinicSubscriptionOrderByWithRelationInput[]
    cursor?: ClinicSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicSubscriptionScalarFieldEnum | ClinicSubscriptionScalarFieldEnum[]
  }

  /**
   * Clinic.products
   */
  export type Clinic$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Clinic.merchant
   */
  export type Clinic$merchantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    where?: MerchantWhereInput
  }

  /**
   * Clinic.merchantApplication
   */
  export type Clinic$merchantApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationInclude<ExtArgs> | null
    where?: MerchantApplicationWhereInput
  }

  /**
   * Clinic.webhookEndpoints
   */
  export type Clinic$webhookEndpointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointInclude<ExtArgs> | null
    where?: WebhookEndpointWhereInput
    orderBy?: WebhookEndpointOrderByWithRelationInput | WebhookEndpointOrderByWithRelationInput[]
    cursor?: WebhookEndpointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookEndpointScalarFieldEnum | WebhookEndpointScalarFieldEnum[]
  }

  /**
   * Clinic.outboundEvents
   */
  export type Clinic$outboundEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventInclude<ExtArgs> | null
    where?: OutboundWebhookEventWhereInput
    orderBy?: OutboundWebhookEventOrderByWithRelationInput | OutboundWebhookEventOrderByWithRelationInput[]
    cursor?: OutboundWebhookEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutboundWebhookEventScalarFieldEnum | OutboundWebhookEventScalarFieldEnum[]
  }

  /**
   * Clinic without action
   */
  export type ClinicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
  }


  /**
   * Model ClinicMember
   */

  export type AggregateClinicMember = {
    _count: ClinicMemberCountAggregateOutputType | null
    _min: ClinicMemberMinAggregateOutputType | null
    _max: ClinicMemberMaxAggregateOutputType | null
  }

  export type ClinicMemberMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    userId: string | null
    role: $Enums.ClinicRole | null
    isActive: boolean | null
    joinedAt: Date | null
  }

  export type ClinicMemberMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    userId: string | null
    role: $Enums.ClinicRole | null
    isActive: boolean | null
    joinedAt: Date | null
  }

  export type ClinicMemberCountAggregateOutputType = {
    id: number
    clinicId: number
    userId: number
    role: number
    isActive: number
    joinedAt: number
    _all: number
  }


  export type ClinicMemberMinAggregateInputType = {
    id?: true
    clinicId?: true
    userId?: true
    role?: true
    isActive?: true
    joinedAt?: true
  }

  export type ClinicMemberMaxAggregateInputType = {
    id?: true
    clinicId?: true
    userId?: true
    role?: true
    isActive?: true
    joinedAt?: true
  }

  export type ClinicMemberCountAggregateInputType = {
    id?: true
    clinicId?: true
    userId?: true
    role?: true
    isActive?: true
    joinedAt?: true
    _all?: true
  }

  export type ClinicMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicMember to aggregate.
     */
    where?: ClinicMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicMembers to fetch.
     */
    orderBy?: ClinicMemberOrderByWithRelationInput | ClinicMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicMembers
    **/
    _count?: true | ClinicMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicMemberMaxAggregateInputType
  }

  export type GetClinicMemberAggregateType<T extends ClinicMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicMember[P]>
      : GetScalarType<T[P], AggregateClinicMember[P]>
  }




  export type ClinicMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicMemberWhereInput
    orderBy?: ClinicMemberOrderByWithAggregationInput | ClinicMemberOrderByWithAggregationInput[]
    by: ClinicMemberScalarFieldEnum[] | ClinicMemberScalarFieldEnum
    having?: ClinicMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicMemberCountAggregateInputType | true
    _min?: ClinicMemberMinAggregateInputType
    _max?: ClinicMemberMaxAggregateInputType
  }

  export type ClinicMemberGroupByOutputType = {
    id: string
    clinicId: string
    userId: string
    role: $Enums.ClinicRole
    isActive: boolean
    joinedAt: Date
    _count: ClinicMemberCountAggregateOutputType | null
    _min: ClinicMemberMinAggregateOutputType | null
    _max: ClinicMemberMaxAggregateOutputType | null
  }

  type GetClinicMemberGroupByPayload<T extends ClinicMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicMemberGroupByOutputType[P]>
        }
      >
    >


  export type ClinicMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    role?: boolean
    isActive?: boolean
    joinedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicMember"]>

  export type ClinicMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    role?: boolean
    isActive?: boolean
    joinedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicMember"]>

  export type ClinicMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    role?: boolean
    isActive?: boolean
    joinedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicMember"]>

  export type ClinicMemberSelectScalar = {
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    role?: boolean
    isActive?: boolean
    joinedAt?: boolean
  }

  export type ClinicMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "userId" | "role" | "isActive" | "joinedAt", ExtArgs["result"]["clinicMember"]>
  export type ClinicMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClinicMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClinicMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClinicMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicMember"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      userId: string
      role: $Enums.ClinicRole
      isActive: boolean
      joinedAt: Date
    }, ExtArgs["result"]["clinicMember"]>
    composites: {}
  }

  type ClinicMemberGetPayload<S extends boolean | null | undefined | ClinicMemberDefaultArgs> = $Result.GetResult<Prisma.$ClinicMemberPayload, S>

  type ClinicMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicMemberCountAggregateInputType | true
    }

  export interface ClinicMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicMember'], meta: { name: 'ClinicMember' } }
    /**
     * Find zero or one ClinicMember that matches the filter.
     * @param {ClinicMemberFindUniqueArgs} args - Arguments to find a ClinicMember
     * @example
     * // Get one ClinicMember
     * const clinicMember = await prisma.clinicMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicMemberFindUniqueArgs>(args: SelectSubset<T, ClinicMemberFindUniqueArgs<ExtArgs>>): Prisma__ClinicMemberClient<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicMemberFindUniqueOrThrowArgs} args - Arguments to find a ClinicMember
     * @example
     * // Get one ClinicMember
     * const clinicMember = await prisma.clinicMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicMemberClient<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicMemberFindFirstArgs} args - Arguments to find a ClinicMember
     * @example
     * // Get one ClinicMember
     * const clinicMember = await prisma.clinicMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicMemberFindFirstArgs>(args?: SelectSubset<T, ClinicMemberFindFirstArgs<ExtArgs>>): Prisma__ClinicMemberClient<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicMemberFindFirstOrThrowArgs} args - Arguments to find a ClinicMember
     * @example
     * // Get one ClinicMember
     * const clinicMember = await prisma.clinicMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicMemberClient<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicMembers
     * const clinicMembers = await prisma.clinicMember.findMany()
     * 
     * // Get first 10 ClinicMembers
     * const clinicMembers = await prisma.clinicMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicMemberWithIdOnly = await prisma.clinicMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicMemberFindManyArgs>(args?: SelectSubset<T, ClinicMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicMember.
     * @param {ClinicMemberCreateArgs} args - Arguments to create a ClinicMember.
     * @example
     * // Create one ClinicMember
     * const ClinicMember = await prisma.clinicMember.create({
     *   data: {
     *     // ... data to create a ClinicMember
     *   }
     * })
     * 
     */
    create<T extends ClinicMemberCreateArgs>(args: SelectSubset<T, ClinicMemberCreateArgs<ExtArgs>>): Prisma__ClinicMemberClient<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicMembers.
     * @param {ClinicMemberCreateManyArgs} args - Arguments to create many ClinicMembers.
     * @example
     * // Create many ClinicMembers
     * const clinicMember = await prisma.clinicMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicMemberCreateManyArgs>(args?: SelectSubset<T, ClinicMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicMembers and returns the data saved in the database.
     * @param {ClinicMemberCreateManyAndReturnArgs} args - Arguments to create many ClinicMembers.
     * @example
     * // Create many ClinicMembers
     * const clinicMember = await prisma.clinicMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicMembers and only return the `id`
     * const clinicMemberWithIdOnly = await prisma.clinicMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicMember.
     * @param {ClinicMemberDeleteArgs} args - Arguments to delete one ClinicMember.
     * @example
     * // Delete one ClinicMember
     * const ClinicMember = await prisma.clinicMember.delete({
     *   where: {
     *     // ... filter to delete one ClinicMember
     *   }
     * })
     * 
     */
    delete<T extends ClinicMemberDeleteArgs>(args: SelectSubset<T, ClinicMemberDeleteArgs<ExtArgs>>): Prisma__ClinicMemberClient<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicMember.
     * @param {ClinicMemberUpdateArgs} args - Arguments to update one ClinicMember.
     * @example
     * // Update one ClinicMember
     * const clinicMember = await prisma.clinicMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicMemberUpdateArgs>(args: SelectSubset<T, ClinicMemberUpdateArgs<ExtArgs>>): Prisma__ClinicMemberClient<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicMembers.
     * @param {ClinicMemberDeleteManyArgs} args - Arguments to filter ClinicMembers to delete.
     * @example
     * // Delete a few ClinicMembers
     * const { count } = await prisma.clinicMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicMemberDeleteManyArgs>(args?: SelectSubset<T, ClinicMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicMembers
     * const clinicMember = await prisma.clinicMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicMemberUpdateManyArgs>(args: SelectSubset<T, ClinicMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicMembers and returns the data updated in the database.
     * @param {ClinicMemberUpdateManyAndReturnArgs} args - Arguments to update many ClinicMembers.
     * @example
     * // Update many ClinicMembers
     * const clinicMember = await prisma.clinicMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicMembers and only return the `id`
     * const clinicMemberWithIdOnly = await prisma.clinicMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicMember.
     * @param {ClinicMemberUpsertArgs} args - Arguments to update or create a ClinicMember.
     * @example
     * // Update or create a ClinicMember
     * const clinicMember = await prisma.clinicMember.upsert({
     *   create: {
     *     // ... data to create a ClinicMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicMember we want to update
     *   }
     * })
     */
    upsert<T extends ClinicMemberUpsertArgs>(args: SelectSubset<T, ClinicMemberUpsertArgs<ExtArgs>>): Prisma__ClinicMemberClient<$Result.GetResult<Prisma.$ClinicMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicMemberCountArgs} args - Arguments to filter ClinicMembers to count.
     * @example
     * // Count the number of ClinicMembers
     * const count = await prisma.clinicMember.count({
     *   where: {
     *     // ... the filter for the ClinicMembers we want to count
     *   }
     * })
    **/
    count<T extends ClinicMemberCountArgs>(
      args?: Subset<T, ClinicMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicMemberAggregateArgs>(args: Subset<T, ClinicMemberAggregateArgs>): Prisma.PrismaPromise<GetClinicMemberAggregateType<T>>

    /**
     * Group by ClinicMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicMemberGroupByArgs['orderBy'] }
        : { orderBy?: ClinicMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicMember model
   */
  readonly fields: ClinicMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicMember model
   */
  interface ClinicMemberFieldRefs {
    readonly id: FieldRef<"ClinicMember", 'String'>
    readonly clinicId: FieldRef<"ClinicMember", 'String'>
    readonly userId: FieldRef<"ClinicMember", 'String'>
    readonly role: FieldRef<"ClinicMember", 'ClinicRole'>
    readonly isActive: FieldRef<"ClinicMember", 'Boolean'>
    readonly joinedAt: FieldRef<"ClinicMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicMember findUnique
   */
  export type ClinicMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClinicMember to fetch.
     */
    where: ClinicMemberWhereUniqueInput
  }

  /**
   * ClinicMember findUniqueOrThrow
   */
  export type ClinicMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClinicMember to fetch.
     */
    where: ClinicMemberWhereUniqueInput
  }

  /**
   * ClinicMember findFirst
   */
  export type ClinicMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClinicMember to fetch.
     */
    where?: ClinicMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicMembers to fetch.
     */
    orderBy?: ClinicMemberOrderByWithRelationInput | ClinicMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicMembers.
     */
    cursor?: ClinicMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicMembers.
     */
    distinct?: ClinicMemberScalarFieldEnum | ClinicMemberScalarFieldEnum[]
  }

  /**
   * ClinicMember findFirstOrThrow
   */
  export type ClinicMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClinicMember to fetch.
     */
    where?: ClinicMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicMembers to fetch.
     */
    orderBy?: ClinicMemberOrderByWithRelationInput | ClinicMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicMembers.
     */
    cursor?: ClinicMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicMembers.
     */
    distinct?: ClinicMemberScalarFieldEnum | ClinicMemberScalarFieldEnum[]
  }

  /**
   * ClinicMember findMany
   */
  export type ClinicMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClinicMembers to fetch.
     */
    where?: ClinicMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicMembers to fetch.
     */
    orderBy?: ClinicMemberOrderByWithRelationInput | ClinicMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicMembers.
     */
    cursor?: ClinicMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicMembers.
     */
    skip?: number
    distinct?: ClinicMemberScalarFieldEnum | ClinicMemberScalarFieldEnum[]
  }

  /**
   * ClinicMember create
   */
  export type ClinicMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicMember.
     */
    data: XOR<ClinicMemberCreateInput, ClinicMemberUncheckedCreateInput>
  }

  /**
   * ClinicMember createMany
   */
  export type ClinicMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicMembers.
     */
    data: ClinicMemberCreateManyInput | ClinicMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicMember createManyAndReturn
   */
  export type ClinicMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicMembers.
     */
    data: ClinicMemberCreateManyInput | ClinicMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicMember update
   */
  export type ClinicMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicMember.
     */
    data: XOR<ClinicMemberUpdateInput, ClinicMemberUncheckedUpdateInput>
    /**
     * Choose, which ClinicMember to update.
     */
    where: ClinicMemberWhereUniqueInput
  }

  /**
   * ClinicMember updateMany
   */
  export type ClinicMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicMembers.
     */
    data: XOR<ClinicMemberUpdateManyMutationInput, ClinicMemberUncheckedUpdateManyInput>
    /**
     * Filter which ClinicMembers to update
     */
    where?: ClinicMemberWhereInput
    /**
     * Limit how many ClinicMembers to update.
     */
    limit?: number
  }

  /**
   * ClinicMember updateManyAndReturn
   */
  export type ClinicMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * The data used to update ClinicMembers.
     */
    data: XOR<ClinicMemberUpdateManyMutationInput, ClinicMemberUncheckedUpdateManyInput>
    /**
     * Filter which ClinicMembers to update
     */
    where?: ClinicMemberWhereInput
    /**
     * Limit how many ClinicMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicMember upsert
   */
  export type ClinicMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicMember to update in case it exists.
     */
    where: ClinicMemberWhereUniqueInput
    /**
     * In case the ClinicMember found by the `where` argument doesn't exist, create a new ClinicMember with this data.
     */
    create: XOR<ClinicMemberCreateInput, ClinicMemberUncheckedCreateInput>
    /**
     * In case the ClinicMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicMemberUpdateInput, ClinicMemberUncheckedUpdateInput>
  }

  /**
   * ClinicMember delete
   */
  export type ClinicMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
    /**
     * Filter which ClinicMember to delete.
     */
    where: ClinicMemberWhereUniqueInput
  }

  /**
   * ClinicMember deleteMany
   */
  export type ClinicMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicMembers to delete
     */
    where?: ClinicMemberWhereInput
    /**
     * Limit how many ClinicMembers to delete.
     */
    limit?: number
  }

  /**
   * ClinicMember without action
   */
  export type ClinicMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicMember
     */
    select?: ClinicMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicMember
     */
    omit?: ClinicMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicMemberInclude<ExtArgs> | null
  }


  /**
   * Model Merchant
   */

  export type AggregateMerchant = {
    _count: MerchantCountAggregateOutputType | null
    _avg: MerchantAvgAggregateOutputType | null
    _sum: MerchantSumAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  export type MerchantAvgAggregateOutputType = {
    splitPercent: number | null
    platformFeeBps: number | null
    transactionFeeCents: number | null
  }

  export type MerchantSumAggregateOutputType = {
    splitPercent: number | null
    platformFeeBps: number | null
    transactionFeeCents: number | null
  }

  export type MerchantMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    status: $Enums.MerchantStatus | null
    recipientId: string | null
    externalAccountId: string | null
    splitPercent: number | null
    platformFeeBps: number | null
    transactionFeeCents: number | null
    transactionFeeType: string | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    status: $Enums.MerchantStatus | null
    recipientId: string | null
    externalAccountId: string | null
    splitPercent: number | null
    platformFeeBps: number | null
    transactionFeeCents: number | null
    transactionFeeType: string | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantCountAggregateOutputType = {
    id: number
    clinicId: number
    status: number
    recipientId: number
    externalAccountId: number
    onboardingState: number
    splitPercent: number
    platformFeeBps: number
    transactionFeeCents: number
    transactionFeeType: number
    lastSyncAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MerchantAvgAggregateInputType = {
    splitPercent?: true
    platformFeeBps?: true
    transactionFeeCents?: true
  }

  export type MerchantSumAggregateInputType = {
    splitPercent?: true
    platformFeeBps?: true
    transactionFeeCents?: true
  }

  export type MerchantMinAggregateInputType = {
    id?: true
    clinicId?: true
    status?: true
    recipientId?: true
    externalAccountId?: true
    splitPercent?: true
    platformFeeBps?: true
    transactionFeeCents?: true
    transactionFeeType?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantMaxAggregateInputType = {
    id?: true
    clinicId?: true
    status?: true
    recipientId?: true
    externalAccountId?: true
    splitPercent?: true
    platformFeeBps?: true
    transactionFeeCents?: true
    transactionFeeType?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantCountAggregateInputType = {
    id?: true
    clinicId?: true
    status?: true
    recipientId?: true
    externalAccountId?: true
    onboardingState?: true
    splitPercent?: true
    platformFeeBps?: true
    transactionFeeCents?: true
    transactionFeeType?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MerchantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchant to aggregate.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Merchants
    **/
    _count?: true | MerchantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MerchantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MerchantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantMaxAggregateInputType
  }

  export type GetMerchantAggregateType<T extends MerchantAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchant[P]>
      : GetScalarType<T[P], AggregateMerchant[P]>
  }




  export type MerchantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantWhereInput
    orderBy?: MerchantOrderByWithAggregationInput | MerchantOrderByWithAggregationInput[]
    by: MerchantScalarFieldEnum[] | MerchantScalarFieldEnum
    having?: MerchantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantCountAggregateInputType | true
    _avg?: MerchantAvgAggregateInputType
    _sum?: MerchantSumAggregateInputType
    _min?: MerchantMinAggregateInputType
    _max?: MerchantMaxAggregateInputType
  }

  export type MerchantGroupByOutputType = {
    id: string
    clinicId: string
    status: $Enums.MerchantStatus
    recipientId: string | null
    externalAccountId: string | null
    onboardingState: JsonValue | null
    splitPercent: number
    platformFeeBps: number
    transactionFeeCents: number | null
    transactionFeeType: string | null
    lastSyncAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MerchantCountAggregateOutputType | null
    _avg: MerchantAvgAggregateOutputType | null
    _sum: MerchantSumAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  type GetMerchantGroupByPayload<T extends MerchantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantGroupByOutputType[P]>
        }
      >
    >


  export type MerchantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    status?: boolean
    recipientId?: boolean
    externalAccountId?: boolean
    onboardingState?: boolean
    splitPercent?: boolean
    platformFeeBps?: boolean
    transactionFeeCents?: boolean
    transactionFeeType?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    integrations?: boolean | Merchant$integrationsArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    status?: boolean
    recipientId?: boolean
    externalAccountId?: boolean
    onboardingState?: boolean
    splitPercent?: boolean
    platformFeeBps?: boolean
    transactionFeeCents?: boolean
    transactionFeeType?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    status?: boolean
    recipientId?: boolean
    externalAccountId?: boolean
    onboardingState?: boolean
    splitPercent?: boolean
    platformFeeBps?: boolean
    transactionFeeCents?: boolean
    transactionFeeType?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectScalar = {
    id?: boolean
    clinicId?: boolean
    status?: boolean
    recipientId?: boolean
    externalAccountId?: boolean
    onboardingState?: boolean
    splitPercent?: boolean
    platformFeeBps?: boolean
    transactionFeeCents?: boolean
    transactionFeeType?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MerchantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "status" | "recipientId" | "externalAccountId" | "onboardingState" | "splitPercent" | "platformFeeBps" | "transactionFeeCents" | "transactionFeeType" | "lastSyncAt" | "createdAt" | "updatedAt", ExtArgs["result"]["merchant"]>
  export type MerchantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    integrations?: boolean | Merchant$integrationsArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MerchantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }
  export type MerchantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }

  export type $MerchantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Merchant"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      integrations: Prisma.$MerchantIntegrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      status: $Enums.MerchantStatus
      recipientId: string | null
      externalAccountId: string | null
      onboardingState: Prisma.JsonValue | null
      splitPercent: number
      platformFeeBps: number
      transactionFeeCents: number | null
      transactionFeeType: string | null
      lastSyncAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["merchant"]>
    composites: {}
  }

  type MerchantGetPayload<S extends boolean | null | undefined | MerchantDefaultArgs> = $Result.GetResult<Prisma.$MerchantPayload, S>

  type MerchantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MerchantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantCountAggregateInputType | true
    }

  export interface MerchantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Merchant'], meta: { name: 'Merchant' } }
    /**
     * Find zero or one Merchant that matches the filter.
     * @param {MerchantFindUniqueArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerchantFindUniqueArgs>(args: SelectSubset<T, MerchantFindUniqueArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Merchant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MerchantFindUniqueOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerchantFindUniqueOrThrowArgs>(args: SelectSubset<T, MerchantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerchantFindFirstArgs>(args?: SelectSubset<T, MerchantFindFirstArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerchantFindFirstOrThrowArgs>(args?: SelectSubset<T, MerchantFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Merchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Merchants
     * const merchants = await prisma.merchant.findMany()
     * 
     * // Get first 10 Merchants
     * const merchants = await prisma.merchant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantWithIdOnly = await prisma.merchant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MerchantFindManyArgs>(args?: SelectSubset<T, MerchantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Merchant.
     * @param {MerchantCreateArgs} args - Arguments to create a Merchant.
     * @example
     * // Create one Merchant
     * const Merchant = await prisma.merchant.create({
     *   data: {
     *     // ... data to create a Merchant
     *   }
     * })
     * 
     */
    create<T extends MerchantCreateArgs>(args: SelectSubset<T, MerchantCreateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Merchants.
     * @param {MerchantCreateManyArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerchantCreateManyArgs>(args?: SelectSubset<T, MerchantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Merchants and returns the data saved in the database.
     * @param {MerchantCreateManyAndReturnArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerchantCreateManyAndReturnArgs>(args?: SelectSubset<T, MerchantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Merchant.
     * @param {MerchantDeleteArgs} args - Arguments to delete one Merchant.
     * @example
     * // Delete one Merchant
     * const Merchant = await prisma.merchant.delete({
     *   where: {
     *     // ... filter to delete one Merchant
     *   }
     * })
     * 
     */
    delete<T extends MerchantDeleteArgs>(args: SelectSubset<T, MerchantDeleteArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Merchant.
     * @param {MerchantUpdateArgs} args - Arguments to update one Merchant.
     * @example
     * // Update one Merchant
     * const merchant = await prisma.merchant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerchantUpdateArgs>(args: SelectSubset<T, MerchantUpdateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Merchants.
     * @param {MerchantDeleteManyArgs} args - Arguments to filter Merchants to delete.
     * @example
     * // Delete a few Merchants
     * const { count } = await prisma.merchant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerchantDeleteManyArgs>(args?: SelectSubset<T, MerchantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerchantUpdateManyArgs>(args: SelectSubset<T, MerchantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants and returns the data updated in the database.
     * @param {MerchantUpdateManyAndReturnArgs} args - Arguments to update many Merchants.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MerchantUpdateManyAndReturnArgs>(args: SelectSubset<T, MerchantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Merchant.
     * @param {MerchantUpsertArgs} args - Arguments to update or create a Merchant.
     * @example
     * // Update or create a Merchant
     * const merchant = await prisma.merchant.upsert({
     *   create: {
     *     // ... data to create a Merchant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Merchant we want to update
     *   }
     * })
     */
    upsert<T extends MerchantUpsertArgs>(args: SelectSubset<T, MerchantUpsertArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantCountArgs} args - Arguments to filter Merchants to count.
     * @example
     * // Count the number of Merchants
     * const count = await prisma.merchant.count({
     *   where: {
     *     // ... the filter for the Merchants we want to count
     *   }
     * })
    **/
    count<T extends MerchantCountArgs>(
      args?: Subset<T, MerchantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantAggregateArgs>(args: Subset<T, MerchantAggregateArgs>): Prisma.PrismaPromise<GetMerchantAggregateType<T>>

    /**
     * Group by Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantGroupByArgs['orderBy'] }
        : { orderBy?: MerchantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Merchant model
   */
  readonly fields: MerchantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Merchant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerchantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    integrations<T extends Merchant$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Merchant model
   */
  interface MerchantFieldRefs {
    readonly id: FieldRef<"Merchant", 'String'>
    readonly clinicId: FieldRef<"Merchant", 'String'>
    readonly status: FieldRef<"Merchant", 'MerchantStatus'>
    readonly recipientId: FieldRef<"Merchant", 'String'>
    readonly externalAccountId: FieldRef<"Merchant", 'String'>
    readonly onboardingState: FieldRef<"Merchant", 'Json'>
    readonly splitPercent: FieldRef<"Merchant", 'Int'>
    readonly platformFeeBps: FieldRef<"Merchant", 'Int'>
    readonly transactionFeeCents: FieldRef<"Merchant", 'Int'>
    readonly transactionFeeType: FieldRef<"Merchant", 'String'>
    readonly lastSyncAt: FieldRef<"Merchant", 'DateTime'>
    readonly createdAt: FieldRef<"Merchant", 'DateTime'>
    readonly updatedAt: FieldRef<"Merchant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Merchant findUnique
   */
  export type MerchantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findUniqueOrThrow
   */
  export type MerchantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findFirst
   */
  export type MerchantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findFirstOrThrow
   */
  export type MerchantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findMany
   */
  export type MerchantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchants to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant create
   */
  export type MerchantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to create a Merchant.
     */
    data: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
  }

  /**
   * Merchant createMany
   */
  export type MerchantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Merchant createManyAndReturn
   */
  export type MerchantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Merchant update
   */
  export type MerchantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to update a Merchant.
     */
    data: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
    /**
     * Choose, which Merchant to update.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant updateMany
   */
  export type MerchantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Merchants.
     */
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    /**
     * Filter which Merchants to update
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to update.
     */
    limit?: number
  }

  /**
   * Merchant updateManyAndReturn
   */
  export type MerchantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * The data used to update Merchants.
     */
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    /**
     * Filter which Merchants to update
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Merchant upsert
   */
  export type MerchantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The filter to search for the Merchant to update in case it exists.
     */
    where: MerchantWhereUniqueInput
    /**
     * In case the Merchant found by the `where` argument doesn't exist, create a new Merchant with this data.
     */
    create: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
    /**
     * In case the Merchant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
  }

  /**
   * Merchant delete
   */
  export type MerchantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter which Merchant to delete.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant deleteMany
   */
  export type MerchantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchants to delete
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to delete.
     */
    limit?: number
  }

  /**
   * Merchant.integrations
   */
  export type Merchant$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationInclude<ExtArgs> | null
    where?: MerchantIntegrationWhereInput
    orderBy?: MerchantIntegrationOrderByWithRelationInput | MerchantIntegrationOrderByWithRelationInput[]
    cursor?: MerchantIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MerchantIntegrationScalarFieldEnum | MerchantIntegrationScalarFieldEnum[]
  }

  /**
   * Merchant without action
   */
  export type MerchantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
  }


  /**
   * Model MerchantApplication
   */

  export type AggregateMerchantApplication = {
    _count: MerchantApplicationCountAggregateOutputType | null
    _min: MerchantApplicationMinAggregateOutputType | null
    _max: MerchantApplicationMaxAggregateOutputType | null
  }

  export type MerchantApplicationMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    type: $Enums.MerchantType | null
    businessName: string | null
    fullName: string | null
    documentNumber: string | null
    email: string | null
    phone: string | null
    recipientId: string | null
    status: $Enums.MerchantAppStatus | null
    reviewNotes: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantApplicationMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    type: $Enums.MerchantType | null
    businessName: string | null
    fullName: string | null
    documentNumber: string | null
    email: string | null
    phone: string | null
    recipientId: string | null
    status: $Enums.MerchantAppStatus | null
    reviewNotes: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantApplicationCountAggregateOutputType = {
    id: number
    clinicId: number
    type: number
    businessName: number
    fullName: number
    documentNumber: number
    email: number
    phone: number
    address: number
    bankAccount: number
    recipientId: number
    status: number
    reviewNotes: number
    reviewedBy: number
    reviewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MerchantApplicationMinAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    businessName?: true
    fullName?: true
    documentNumber?: true
    email?: true
    phone?: true
    recipientId?: true
    status?: true
    reviewNotes?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantApplicationMaxAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    businessName?: true
    fullName?: true
    documentNumber?: true
    email?: true
    phone?: true
    recipientId?: true
    status?: true
    reviewNotes?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantApplicationCountAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    businessName?: true
    fullName?: true
    documentNumber?: true
    email?: true
    phone?: true
    address?: true
    bankAccount?: true
    recipientId?: true
    status?: true
    reviewNotes?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MerchantApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerchantApplication to aggregate.
     */
    where?: MerchantApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantApplications to fetch.
     */
    orderBy?: MerchantApplicationOrderByWithRelationInput | MerchantApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerchantApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MerchantApplications
    **/
    _count?: true | MerchantApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantApplicationMaxAggregateInputType
  }

  export type GetMerchantApplicationAggregateType<T extends MerchantApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchantApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchantApplication[P]>
      : GetScalarType<T[P], AggregateMerchantApplication[P]>
  }




  export type MerchantApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantApplicationWhereInput
    orderBy?: MerchantApplicationOrderByWithAggregationInput | MerchantApplicationOrderByWithAggregationInput[]
    by: MerchantApplicationScalarFieldEnum[] | MerchantApplicationScalarFieldEnum
    having?: MerchantApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantApplicationCountAggregateInputType | true
    _min?: MerchantApplicationMinAggregateInputType
    _max?: MerchantApplicationMaxAggregateInputType
  }

  export type MerchantApplicationGroupByOutputType = {
    id: string
    clinicId: string
    type: $Enums.MerchantType
    businessName: string | null
    fullName: string | null
    documentNumber: string | null
    email: string | null
    phone: string | null
    address: JsonValue | null
    bankAccount: JsonValue | null
    recipientId: string | null
    status: $Enums.MerchantAppStatus
    reviewNotes: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MerchantApplicationCountAggregateOutputType | null
    _min: MerchantApplicationMinAggregateOutputType | null
    _max: MerchantApplicationMaxAggregateOutputType | null
  }

  type GetMerchantApplicationGroupByPayload<T extends MerchantApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantApplicationGroupByOutputType[P]>
        }
      >
    >


  export type MerchantApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    businessName?: boolean
    fullName?: boolean
    documentNumber?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    bankAccount?: boolean
    recipientId?: boolean
    status?: boolean
    reviewNotes?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    documents?: boolean | MerchantApplication$documentsArgs<ExtArgs>
    _count?: boolean | MerchantApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantApplication"]>

  export type MerchantApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    businessName?: boolean
    fullName?: boolean
    documentNumber?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    bankAccount?: boolean
    recipientId?: boolean
    status?: boolean
    reviewNotes?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantApplication"]>

  export type MerchantApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    businessName?: boolean
    fullName?: boolean
    documentNumber?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    bankAccount?: boolean
    recipientId?: boolean
    status?: boolean
    reviewNotes?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantApplication"]>

  export type MerchantApplicationSelectScalar = {
    id?: boolean
    clinicId?: boolean
    type?: boolean
    businessName?: boolean
    fullName?: boolean
    documentNumber?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    bankAccount?: boolean
    recipientId?: boolean
    status?: boolean
    reviewNotes?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MerchantApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "type" | "businessName" | "fullName" | "documentNumber" | "email" | "phone" | "address" | "bankAccount" | "recipientId" | "status" | "reviewNotes" | "reviewedBy" | "reviewedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["merchantApplication"]>
  export type MerchantApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    documents?: boolean | MerchantApplication$documentsArgs<ExtArgs>
    _count?: boolean | MerchantApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MerchantApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }
  export type MerchantApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }

  export type $MerchantApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MerchantApplication"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      documents: Prisma.$MerchantDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      type: $Enums.MerchantType
      businessName: string | null
      fullName: string | null
      documentNumber: string | null
      email: string | null
      phone: string | null
      address: Prisma.JsonValue | null
      bankAccount: Prisma.JsonValue | null
      recipientId: string | null
      status: $Enums.MerchantAppStatus
      reviewNotes: string | null
      reviewedBy: string | null
      reviewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["merchantApplication"]>
    composites: {}
  }

  type MerchantApplicationGetPayload<S extends boolean | null | undefined | MerchantApplicationDefaultArgs> = $Result.GetResult<Prisma.$MerchantApplicationPayload, S>

  type MerchantApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MerchantApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantApplicationCountAggregateInputType | true
    }

  export interface MerchantApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MerchantApplication'], meta: { name: 'MerchantApplication' } }
    /**
     * Find zero or one MerchantApplication that matches the filter.
     * @param {MerchantApplicationFindUniqueArgs} args - Arguments to find a MerchantApplication
     * @example
     * // Get one MerchantApplication
     * const merchantApplication = await prisma.merchantApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerchantApplicationFindUniqueArgs>(args: SelectSubset<T, MerchantApplicationFindUniqueArgs<ExtArgs>>): Prisma__MerchantApplicationClient<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MerchantApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MerchantApplicationFindUniqueOrThrowArgs} args - Arguments to find a MerchantApplication
     * @example
     * // Get one MerchantApplication
     * const merchantApplication = await prisma.merchantApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerchantApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, MerchantApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerchantApplicationClient<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MerchantApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantApplicationFindFirstArgs} args - Arguments to find a MerchantApplication
     * @example
     * // Get one MerchantApplication
     * const merchantApplication = await prisma.merchantApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerchantApplicationFindFirstArgs>(args?: SelectSubset<T, MerchantApplicationFindFirstArgs<ExtArgs>>): Prisma__MerchantApplicationClient<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MerchantApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantApplicationFindFirstOrThrowArgs} args - Arguments to find a MerchantApplication
     * @example
     * // Get one MerchantApplication
     * const merchantApplication = await prisma.merchantApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerchantApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, MerchantApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerchantApplicationClient<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MerchantApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MerchantApplications
     * const merchantApplications = await prisma.merchantApplication.findMany()
     * 
     * // Get first 10 MerchantApplications
     * const merchantApplications = await prisma.merchantApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantApplicationWithIdOnly = await prisma.merchantApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MerchantApplicationFindManyArgs>(args?: SelectSubset<T, MerchantApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MerchantApplication.
     * @param {MerchantApplicationCreateArgs} args - Arguments to create a MerchantApplication.
     * @example
     * // Create one MerchantApplication
     * const MerchantApplication = await prisma.merchantApplication.create({
     *   data: {
     *     // ... data to create a MerchantApplication
     *   }
     * })
     * 
     */
    create<T extends MerchantApplicationCreateArgs>(args: SelectSubset<T, MerchantApplicationCreateArgs<ExtArgs>>): Prisma__MerchantApplicationClient<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MerchantApplications.
     * @param {MerchantApplicationCreateManyArgs} args - Arguments to create many MerchantApplications.
     * @example
     * // Create many MerchantApplications
     * const merchantApplication = await prisma.merchantApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerchantApplicationCreateManyArgs>(args?: SelectSubset<T, MerchantApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MerchantApplications and returns the data saved in the database.
     * @param {MerchantApplicationCreateManyAndReturnArgs} args - Arguments to create many MerchantApplications.
     * @example
     * // Create many MerchantApplications
     * const merchantApplication = await prisma.merchantApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MerchantApplications and only return the `id`
     * const merchantApplicationWithIdOnly = await prisma.merchantApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerchantApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, MerchantApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MerchantApplication.
     * @param {MerchantApplicationDeleteArgs} args - Arguments to delete one MerchantApplication.
     * @example
     * // Delete one MerchantApplication
     * const MerchantApplication = await prisma.merchantApplication.delete({
     *   where: {
     *     // ... filter to delete one MerchantApplication
     *   }
     * })
     * 
     */
    delete<T extends MerchantApplicationDeleteArgs>(args: SelectSubset<T, MerchantApplicationDeleteArgs<ExtArgs>>): Prisma__MerchantApplicationClient<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MerchantApplication.
     * @param {MerchantApplicationUpdateArgs} args - Arguments to update one MerchantApplication.
     * @example
     * // Update one MerchantApplication
     * const merchantApplication = await prisma.merchantApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerchantApplicationUpdateArgs>(args: SelectSubset<T, MerchantApplicationUpdateArgs<ExtArgs>>): Prisma__MerchantApplicationClient<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MerchantApplications.
     * @param {MerchantApplicationDeleteManyArgs} args - Arguments to filter MerchantApplications to delete.
     * @example
     * // Delete a few MerchantApplications
     * const { count } = await prisma.merchantApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerchantApplicationDeleteManyArgs>(args?: SelectSubset<T, MerchantApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerchantApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MerchantApplications
     * const merchantApplication = await prisma.merchantApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerchantApplicationUpdateManyArgs>(args: SelectSubset<T, MerchantApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerchantApplications and returns the data updated in the database.
     * @param {MerchantApplicationUpdateManyAndReturnArgs} args - Arguments to update many MerchantApplications.
     * @example
     * // Update many MerchantApplications
     * const merchantApplication = await prisma.merchantApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MerchantApplications and only return the `id`
     * const merchantApplicationWithIdOnly = await prisma.merchantApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MerchantApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, MerchantApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MerchantApplication.
     * @param {MerchantApplicationUpsertArgs} args - Arguments to update or create a MerchantApplication.
     * @example
     * // Update or create a MerchantApplication
     * const merchantApplication = await prisma.merchantApplication.upsert({
     *   create: {
     *     // ... data to create a MerchantApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MerchantApplication we want to update
     *   }
     * })
     */
    upsert<T extends MerchantApplicationUpsertArgs>(args: SelectSubset<T, MerchantApplicationUpsertArgs<ExtArgs>>): Prisma__MerchantApplicationClient<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MerchantApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantApplicationCountArgs} args - Arguments to filter MerchantApplications to count.
     * @example
     * // Count the number of MerchantApplications
     * const count = await prisma.merchantApplication.count({
     *   where: {
     *     // ... the filter for the MerchantApplications we want to count
     *   }
     * })
    **/
    count<T extends MerchantApplicationCountArgs>(
      args?: Subset<T, MerchantApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MerchantApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantApplicationAggregateArgs>(args: Subset<T, MerchantApplicationAggregateArgs>): Prisma.PrismaPromise<GetMerchantApplicationAggregateType<T>>

    /**
     * Group by MerchantApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantApplicationGroupByArgs['orderBy'] }
        : { orderBy?: MerchantApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MerchantApplication model
   */
  readonly fields: MerchantApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MerchantApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerchantApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    documents<T extends MerchantApplication$documentsArgs<ExtArgs> = {}>(args?: Subset<T, MerchantApplication$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MerchantApplication model
   */
  interface MerchantApplicationFieldRefs {
    readonly id: FieldRef<"MerchantApplication", 'String'>
    readonly clinicId: FieldRef<"MerchantApplication", 'String'>
    readonly type: FieldRef<"MerchantApplication", 'MerchantType'>
    readonly businessName: FieldRef<"MerchantApplication", 'String'>
    readonly fullName: FieldRef<"MerchantApplication", 'String'>
    readonly documentNumber: FieldRef<"MerchantApplication", 'String'>
    readonly email: FieldRef<"MerchantApplication", 'String'>
    readonly phone: FieldRef<"MerchantApplication", 'String'>
    readonly address: FieldRef<"MerchantApplication", 'Json'>
    readonly bankAccount: FieldRef<"MerchantApplication", 'Json'>
    readonly recipientId: FieldRef<"MerchantApplication", 'String'>
    readonly status: FieldRef<"MerchantApplication", 'MerchantAppStatus'>
    readonly reviewNotes: FieldRef<"MerchantApplication", 'String'>
    readonly reviewedBy: FieldRef<"MerchantApplication", 'String'>
    readonly reviewedAt: FieldRef<"MerchantApplication", 'DateTime'>
    readonly createdAt: FieldRef<"MerchantApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"MerchantApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MerchantApplication findUnique
   */
  export type MerchantApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationInclude<ExtArgs> | null
    /**
     * Filter, which MerchantApplication to fetch.
     */
    where: MerchantApplicationWhereUniqueInput
  }

  /**
   * MerchantApplication findUniqueOrThrow
   */
  export type MerchantApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationInclude<ExtArgs> | null
    /**
     * Filter, which MerchantApplication to fetch.
     */
    where: MerchantApplicationWhereUniqueInput
  }

  /**
   * MerchantApplication findFirst
   */
  export type MerchantApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationInclude<ExtArgs> | null
    /**
     * Filter, which MerchantApplication to fetch.
     */
    where?: MerchantApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantApplications to fetch.
     */
    orderBy?: MerchantApplicationOrderByWithRelationInput | MerchantApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerchantApplications.
     */
    cursor?: MerchantApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerchantApplications.
     */
    distinct?: MerchantApplicationScalarFieldEnum | MerchantApplicationScalarFieldEnum[]
  }

  /**
   * MerchantApplication findFirstOrThrow
   */
  export type MerchantApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationInclude<ExtArgs> | null
    /**
     * Filter, which MerchantApplication to fetch.
     */
    where?: MerchantApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantApplications to fetch.
     */
    orderBy?: MerchantApplicationOrderByWithRelationInput | MerchantApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerchantApplications.
     */
    cursor?: MerchantApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerchantApplications.
     */
    distinct?: MerchantApplicationScalarFieldEnum | MerchantApplicationScalarFieldEnum[]
  }

  /**
   * MerchantApplication findMany
   */
  export type MerchantApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationInclude<ExtArgs> | null
    /**
     * Filter, which MerchantApplications to fetch.
     */
    where?: MerchantApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantApplications to fetch.
     */
    orderBy?: MerchantApplicationOrderByWithRelationInput | MerchantApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MerchantApplications.
     */
    cursor?: MerchantApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantApplications.
     */
    skip?: number
    distinct?: MerchantApplicationScalarFieldEnum | MerchantApplicationScalarFieldEnum[]
  }

  /**
   * MerchantApplication create
   */
  export type MerchantApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a MerchantApplication.
     */
    data: XOR<MerchantApplicationCreateInput, MerchantApplicationUncheckedCreateInput>
  }

  /**
   * MerchantApplication createMany
   */
  export type MerchantApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MerchantApplications.
     */
    data: MerchantApplicationCreateManyInput | MerchantApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MerchantApplication createManyAndReturn
   */
  export type MerchantApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many MerchantApplications.
     */
    data: MerchantApplicationCreateManyInput | MerchantApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerchantApplication update
   */
  export type MerchantApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a MerchantApplication.
     */
    data: XOR<MerchantApplicationUpdateInput, MerchantApplicationUncheckedUpdateInput>
    /**
     * Choose, which MerchantApplication to update.
     */
    where: MerchantApplicationWhereUniqueInput
  }

  /**
   * MerchantApplication updateMany
   */
  export type MerchantApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MerchantApplications.
     */
    data: XOR<MerchantApplicationUpdateManyMutationInput, MerchantApplicationUncheckedUpdateManyInput>
    /**
     * Filter which MerchantApplications to update
     */
    where?: MerchantApplicationWhereInput
    /**
     * Limit how many MerchantApplications to update.
     */
    limit?: number
  }

  /**
   * MerchantApplication updateManyAndReturn
   */
  export type MerchantApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * The data used to update MerchantApplications.
     */
    data: XOR<MerchantApplicationUpdateManyMutationInput, MerchantApplicationUncheckedUpdateManyInput>
    /**
     * Filter which MerchantApplications to update
     */
    where?: MerchantApplicationWhereInput
    /**
     * Limit how many MerchantApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerchantApplication upsert
   */
  export type MerchantApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the MerchantApplication to update in case it exists.
     */
    where: MerchantApplicationWhereUniqueInput
    /**
     * In case the MerchantApplication found by the `where` argument doesn't exist, create a new MerchantApplication with this data.
     */
    create: XOR<MerchantApplicationCreateInput, MerchantApplicationUncheckedCreateInput>
    /**
     * In case the MerchantApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerchantApplicationUpdateInput, MerchantApplicationUncheckedUpdateInput>
  }

  /**
   * MerchantApplication delete
   */
  export type MerchantApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationInclude<ExtArgs> | null
    /**
     * Filter which MerchantApplication to delete.
     */
    where: MerchantApplicationWhereUniqueInput
  }

  /**
   * MerchantApplication deleteMany
   */
  export type MerchantApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerchantApplications to delete
     */
    where?: MerchantApplicationWhereInput
    /**
     * Limit how many MerchantApplications to delete.
     */
    limit?: number
  }

  /**
   * MerchantApplication.documents
   */
  export type MerchantApplication$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentInclude<ExtArgs> | null
    where?: MerchantDocumentWhereInput
    orderBy?: MerchantDocumentOrderByWithRelationInput | MerchantDocumentOrderByWithRelationInput[]
    cursor?: MerchantDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MerchantDocumentScalarFieldEnum | MerchantDocumentScalarFieldEnum[]
  }

  /**
   * MerchantApplication without action
   */
  export type MerchantApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantApplication
     */
    select?: MerchantApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantApplication
     */
    omit?: MerchantApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantApplicationInclude<ExtArgs> | null
  }


  /**
   * Model MerchantDocument
   */

  export type AggregateMerchantDocument = {
    _count: MerchantDocumentCountAggregateOutputType | null
    _min: MerchantDocumentMinAggregateOutputType | null
    _max: MerchantDocumentMaxAggregateOutputType | null
  }

  export type MerchantDocumentMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    type: $Enums.DocumentType | null
    fileUrl: string | null
    status: $Enums.DocumentStatus | null
    notes: string | null
    uploadedAt: Date | null
    reviewedAt: Date | null
  }

  export type MerchantDocumentMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    type: $Enums.DocumentType | null
    fileUrl: string | null
    status: $Enums.DocumentStatus | null
    notes: string | null
    uploadedAt: Date | null
    reviewedAt: Date | null
  }

  export type MerchantDocumentCountAggregateOutputType = {
    id: number
    applicationId: number
    type: number
    fileUrl: number
    status: number
    notes: number
    uploadedAt: number
    reviewedAt: number
    _all: number
  }


  export type MerchantDocumentMinAggregateInputType = {
    id?: true
    applicationId?: true
    type?: true
    fileUrl?: true
    status?: true
    notes?: true
    uploadedAt?: true
    reviewedAt?: true
  }

  export type MerchantDocumentMaxAggregateInputType = {
    id?: true
    applicationId?: true
    type?: true
    fileUrl?: true
    status?: true
    notes?: true
    uploadedAt?: true
    reviewedAt?: true
  }

  export type MerchantDocumentCountAggregateInputType = {
    id?: true
    applicationId?: true
    type?: true
    fileUrl?: true
    status?: true
    notes?: true
    uploadedAt?: true
    reviewedAt?: true
    _all?: true
  }

  export type MerchantDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerchantDocument to aggregate.
     */
    where?: MerchantDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantDocuments to fetch.
     */
    orderBy?: MerchantDocumentOrderByWithRelationInput | MerchantDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerchantDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MerchantDocuments
    **/
    _count?: true | MerchantDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantDocumentMaxAggregateInputType
  }

  export type GetMerchantDocumentAggregateType<T extends MerchantDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchantDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchantDocument[P]>
      : GetScalarType<T[P], AggregateMerchantDocument[P]>
  }




  export type MerchantDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantDocumentWhereInput
    orderBy?: MerchantDocumentOrderByWithAggregationInput | MerchantDocumentOrderByWithAggregationInput[]
    by: MerchantDocumentScalarFieldEnum[] | MerchantDocumentScalarFieldEnum
    having?: MerchantDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantDocumentCountAggregateInputType | true
    _min?: MerchantDocumentMinAggregateInputType
    _max?: MerchantDocumentMaxAggregateInputType
  }

  export type MerchantDocumentGroupByOutputType = {
    id: string
    applicationId: string
    type: $Enums.DocumentType
    fileUrl: string
    status: $Enums.DocumentStatus
    notes: string | null
    uploadedAt: Date
    reviewedAt: Date | null
    _count: MerchantDocumentCountAggregateOutputType | null
    _min: MerchantDocumentMinAggregateOutputType | null
    _max: MerchantDocumentMaxAggregateOutputType | null
  }

  type GetMerchantDocumentGroupByPayload<T extends MerchantDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantDocumentGroupByOutputType[P]>
        }
      >
    >


  export type MerchantDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    type?: boolean
    fileUrl?: boolean
    status?: boolean
    notes?: boolean
    uploadedAt?: boolean
    reviewedAt?: boolean
    application?: boolean | MerchantApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantDocument"]>

  export type MerchantDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    type?: boolean
    fileUrl?: boolean
    status?: boolean
    notes?: boolean
    uploadedAt?: boolean
    reviewedAt?: boolean
    application?: boolean | MerchantApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantDocument"]>

  export type MerchantDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    type?: boolean
    fileUrl?: boolean
    status?: boolean
    notes?: boolean
    uploadedAt?: boolean
    reviewedAt?: boolean
    application?: boolean | MerchantApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantDocument"]>

  export type MerchantDocumentSelectScalar = {
    id?: boolean
    applicationId?: boolean
    type?: boolean
    fileUrl?: boolean
    status?: boolean
    notes?: boolean
    uploadedAt?: boolean
    reviewedAt?: boolean
  }

  export type MerchantDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "type" | "fileUrl" | "status" | "notes" | "uploadedAt" | "reviewedAt", ExtArgs["result"]["merchantDocument"]>
  export type MerchantDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | MerchantApplicationDefaultArgs<ExtArgs>
  }
  export type MerchantDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | MerchantApplicationDefaultArgs<ExtArgs>
  }
  export type MerchantDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | MerchantApplicationDefaultArgs<ExtArgs>
  }

  export type $MerchantDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MerchantDocument"
    objects: {
      application: Prisma.$MerchantApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      type: $Enums.DocumentType
      fileUrl: string
      status: $Enums.DocumentStatus
      notes: string | null
      uploadedAt: Date
      reviewedAt: Date | null
    }, ExtArgs["result"]["merchantDocument"]>
    composites: {}
  }

  type MerchantDocumentGetPayload<S extends boolean | null | undefined | MerchantDocumentDefaultArgs> = $Result.GetResult<Prisma.$MerchantDocumentPayload, S>

  type MerchantDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MerchantDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantDocumentCountAggregateInputType | true
    }

  export interface MerchantDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MerchantDocument'], meta: { name: 'MerchantDocument' } }
    /**
     * Find zero or one MerchantDocument that matches the filter.
     * @param {MerchantDocumentFindUniqueArgs} args - Arguments to find a MerchantDocument
     * @example
     * // Get one MerchantDocument
     * const merchantDocument = await prisma.merchantDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerchantDocumentFindUniqueArgs>(args: SelectSubset<T, MerchantDocumentFindUniqueArgs<ExtArgs>>): Prisma__MerchantDocumentClient<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MerchantDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MerchantDocumentFindUniqueOrThrowArgs} args - Arguments to find a MerchantDocument
     * @example
     * // Get one MerchantDocument
     * const merchantDocument = await prisma.merchantDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerchantDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, MerchantDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerchantDocumentClient<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MerchantDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantDocumentFindFirstArgs} args - Arguments to find a MerchantDocument
     * @example
     * // Get one MerchantDocument
     * const merchantDocument = await prisma.merchantDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerchantDocumentFindFirstArgs>(args?: SelectSubset<T, MerchantDocumentFindFirstArgs<ExtArgs>>): Prisma__MerchantDocumentClient<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MerchantDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantDocumentFindFirstOrThrowArgs} args - Arguments to find a MerchantDocument
     * @example
     * // Get one MerchantDocument
     * const merchantDocument = await prisma.merchantDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerchantDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, MerchantDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerchantDocumentClient<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MerchantDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MerchantDocuments
     * const merchantDocuments = await prisma.merchantDocument.findMany()
     * 
     * // Get first 10 MerchantDocuments
     * const merchantDocuments = await prisma.merchantDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantDocumentWithIdOnly = await prisma.merchantDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MerchantDocumentFindManyArgs>(args?: SelectSubset<T, MerchantDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MerchantDocument.
     * @param {MerchantDocumentCreateArgs} args - Arguments to create a MerchantDocument.
     * @example
     * // Create one MerchantDocument
     * const MerchantDocument = await prisma.merchantDocument.create({
     *   data: {
     *     // ... data to create a MerchantDocument
     *   }
     * })
     * 
     */
    create<T extends MerchantDocumentCreateArgs>(args: SelectSubset<T, MerchantDocumentCreateArgs<ExtArgs>>): Prisma__MerchantDocumentClient<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MerchantDocuments.
     * @param {MerchantDocumentCreateManyArgs} args - Arguments to create many MerchantDocuments.
     * @example
     * // Create many MerchantDocuments
     * const merchantDocument = await prisma.merchantDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerchantDocumentCreateManyArgs>(args?: SelectSubset<T, MerchantDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MerchantDocuments and returns the data saved in the database.
     * @param {MerchantDocumentCreateManyAndReturnArgs} args - Arguments to create many MerchantDocuments.
     * @example
     * // Create many MerchantDocuments
     * const merchantDocument = await prisma.merchantDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MerchantDocuments and only return the `id`
     * const merchantDocumentWithIdOnly = await prisma.merchantDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerchantDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, MerchantDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MerchantDocument.
     * @param {MerchantDocumentDeleteArgs} args - Arguments to delete one MerchantDocument.
     * @example
     * // Delete one MerchantDocument
     * const MerchantDocument = await prisma.merchantDocument.delete({
     *   where: {
     *     // ... filter to delete one MerchantDocument
     *   }
     * })
     * 
     */
    delete<T extends MerchantDocumentDeleteArgs>(args: SelectSubset<T, MerchantDocumentDeleteArgs<ExtArgs>>): Prisma__MerchantDocumentClient<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MerchantDocument.
     * @param {MerchantDocumentUpdateArgs} args - Arguments to update one MerchantDocument.
     * @example
     * // Update one MerchantDocument
     * const merchantDocument = await prisma.merchantDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerchantDocumentUpdateArgs>(args: SelectSubset<T, MerchantDocumentUpdateArgs<ExtArgs>>): Prisma__MerchantDocumentClient<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MerchantDocuments.
     * @param {MerchantDocumentDeleteManyArgs} args - Arguments to filter MerchantDocuments to delete.
     * @example
     * // Delete a few MerchantDocuments
     * const { count } = await prisma.merchantDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerchantDocumentDeleteManyArgs>(args?: SelectSubset<T, MerchantDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerchantDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MerchantDocuments
     * const merchantDocument = await prisma.merchantDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerchantDocumentUpdateManyArgs>(args: SelectSubset<T, MerchantDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerchantDocuments and returns the data updated in the database.
     * @param {MerchantDocumentUpdateManyAndReturnArgs} args - Arguments to update many MerchantDocuments.
     * @example
     * // Update many MerchantDocuments
     * const merchantDocument = await prisma.merchantDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MerchantDocuments and only return the `id`
     * const merchantDocumentWithIdOnly = await prisma.merchantDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MerchantDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, MerchantDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MerchantDocument.
     * @param {MerchantDocumentUpsertArgs} args - Arguments to update or create a MerchantDocument.
     * @example
     * // Update or create a MerchantDocument
     * const merchantDocument = await prisma.merchantDocument.upsert({
     *   create: {
     *     // ... data to create a MerchantDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MerchantDocument we want to update
     *   }
     * })
     */
    upsert<T extends MerchantDocumentUpsertArgs>(args: SelectSubset<T, MerchantDocumentUpsertArgs<ExtArgs>>): Prisma__MerchantDocumentClient<$Result.GetResult<Prisma.$MerchantDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MerchantDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantDocumentCountArgs} args - Arguments to filter MerchantDocuments to count.
     * @example
     * // Count the number of MerchantDocuments
     * const count = await prisma.merchantDocument.count({
     *   where: {
     *     // ... the filter for the MerchantDocuments we want to count
     *   }
     * })
    **/
    count<T extends MerchantDocumentCountArgs>(
      args?: Subset<T, MerchantDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MerchantDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantDocumentAggregateArgs>(args: Subset<T, MerchantDocumentAggregateArgs>): Prisma.PrismaPromise<GetMerchantDocumentAggregateType<T>>

    /**
     * Group by MerchantDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantDocumentGroupByArgs['orderBy'] }
        : { orderBy?: MerchantDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MerchantDocument model
   */
  readonly fields: MerchantDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MerchantDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerchantDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends MerchantApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantApplicationDefaultArgs<ExtArgs>>): Prisma__MerchantApplicationClient<$Result.GetResult<Prisma.$MerchantApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MerchantDocument model
   */
  interface MerchantDocumentFieldRefs {
    readonly id: FieldRef<"MerchantDocument", 'String'>
    readonly applicationId: FieldRef<"MerchantDocument", 'String'>
    readonly type: FieldRef<"MerchantDocument", 'DocumentType'>
    readonly fileUrl: FieldRef<"MerchantDocument", 'String'>
    readonly status: FieldRef<"MerchantDocument", 'DocumentStatus'>
    readonly notes: FieldRef<"MerchantDocument", 'String'>
    readonly uploadedAt: FieldRef<"MerchantDocument", 'DateTime'>
    readonly reviewedAt: FieldRef<"MerchantDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MerchantDocument findUnique
   */
  export type MerchantDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MerchantDocument to fetch.
     */
    where: MerchantDocumentWhereUniqueInput
  }

  /**
   * MerchantDocument findUniqueOrThrow
   */
  export type MerchantDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MerchantDocument to fetch.
     */
    where: MerchantDocumentWhereUniqueInput
  }

  /**
   * MerchantDocument findFirst
   */
  export type MerchantDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MerchantDocument to fetch.
     */
    where?: MerchantDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantDocuments to fetch.
     */
    orderBy?: MerchantDocumentOrderByWithRelationInput | MerchantDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerchantDocuments.
     */
    cursor?: MerchantDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerchantDocuments.
     */
    distinct?: MerchantDocumentScalarFieldEnum | MerchantDocumentScalarFieldEnum[]
  }

  /**
   * MerchantDocument findFirstOrThrow
   */
  export type MerchantDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MerchantDocument to fetch.
     */
    where?: MerchantDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantDocuments to fetch.
     */
    orderBy?: MerchantDocumentOrderByWithRelationInput | MerchantDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerchantDocuments.
     */
    cursor?: MerchantDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerchantDocuments.
     */
    distinct?: MerchantDocumentScalarFieldEnum | MerchantDocumentScalarFieldEnum[]
  }

  /**
   * MerchantDocument findMany
   */
  export type MerchantDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MerchantDocuments to fetch.
     */
    where?: MerchantDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantDocuments to fetch.
     */
    orderBy?: MerchantDocumentOrderByWithRelationInput | MerchantDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MerchantDocuments.
     */
    cursor?: MerchantDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantDocuments.
     */
    skip?: number
    distinct?: MerchantDocumentScalarFieldEnum | MerchantDocumentScalarFieldEnum[]
  }

  /**
   * MerchantDocument create
   */
  export type MerchantDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a MerchantDocument.
     */
    data: XOR<MerchantDocumentCreateInput, MerchantDocumentUncheckedCreateInput>
  }

  /**
   * MerchantDocument createMany
   */
  export type MerchantDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MerchantDocuments.
     */
    data: MerchantDocumentCreateManyInput | MerchantDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MerchantDocument createManyAndReturn
   */
  export type MerchantDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many MerchantDocuments.
     */
    data: MerchantDocumentCreateManyInput | MerchantDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerchantDocument update
   */
  export type MerchantDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a MerchantDocument.
     */
    data: XOR<MerchantDocumentUpdateInput, MerchantDocumentUncheckedUpdateInput>
    /**
     * Choose, which MerchantDocument to update.
     */
    where: MerchantDocumentWhereUniqueInput
  }

  /**
   * MerchantDocument updateMany
   */
  export type MerchantDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MerchantDocuments.
     */
    data: XOR<MerchantDocumentUpdateManyMutationInput, MerchantDocumentUncheckedUpdateManyInput>
    /**
     * Filter which MerchantDocuments to update
     */
    where?: MerchantDocumentWhereInput
    /**
     * Limit how many MerchantDocuments to update.
     */
    limit?: number
  }

  /**
   * MerchantDocument updateManyAndReturn
   */
  export type MerchantDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * The data used to update MerchantDocuments.
     */
    data: XOR<MerchantDocumentUpdateManyMutationInput, MerchantDocumentUncheckedUpdateManyInput>
    /**
     * Filter which MerchantDocuments to update
     */
    where?: MerchantDocumentWhereInput
    /**
     * Limit how many MerchantDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerchantDocument upsert
   */
  export type MerchantDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the MerchantDocument to update in case it exists.
     */
    where: MerchantDocumentWhereUniqueInput
    /**
     * In case the MerchantDocument found by the `where` argument doesn't exist, create a new MerchantDocument with this data.
     */
    create: XOR<MerchantDocumentCreateInput, MerchantDocumentUncheckedCreateInput>
    /**
     * In case the MerchantDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerchantDocumentUpdateInput, MerchantDocumentUncheckedUpdateInput>
  }

  /**
   * MerchantDocument delete
   */
  export type MerchantDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentInclude<ExtArgs> | null
    /**
     * Filter which MerchantDocument to delete.
     */
    where: MerchantDocumentWhereUniqueInput
  }

  /**
   * MerchantDocument deleteMany
   */
  export type MerchantDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerchantDocuments to delete
     */
    where?: MerchantDocumentWhereInput
    /**
     * Limit how many MerchantDocuments to delete.
     */
    limit?: number
  }

  /**
   * MerchantDocument without action
   */
  export type MerchantDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantDocument
     */
    select?: MerchantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantDocument
     */
    omit?: MerchantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantDocumentInclude<ExtArgs> | null
  }


  /**
   * Model MerchantIntegration
   */

  export type AggregateMerchantIntegration = {
    _count: MerchantIntegrationCountAggregateOutputType | null
    _min: MerchantIntegrationMinAggregateOutputType | null
    _max: MerchantIntegrationMaxAggregateOutputType | null
  }

  export type MerchantIntegrationMinAggregateOutputType = {
    id: string | null
    merchantId: string | null
    provider: $Enums.PaymentProvider | null
    isActive: boolean | null
    isPrimary: boolean | null
    connectedAt: Date | null
    lastUsedAt: Date | null
    lastError: string | null
    lastErrorAt: Date | null
  }

  export type MerchantIntegrationMaxAggregateOutputType = {
    id: string | null
    merchantId: string | null
    provider: $Enums.PaymentProvider | null
    isActive: boolean | null
    isPrimary: boolean | null
    connectedAt: Date | null
    lastUsedAt: Date | null
    lastError: string | null
    lastErrorAt: Date | null
  }

  export type MerchantIntegrationCountAggregateOutputType = {
    id: number
    merchantId: number
    provider: number
    credentials: number
    config: number
    isActive: number
    isPrimary: number
    connectedAt: number
    lastUsedAt: number
    lastError: number
    lastErrorAt: number
    _all: number
  }


  export type MerchantIntegrationMinAggregateInputType = {
    id?: true
    merchantId?: true
    provider?: true
    isActive?: true
    isPrimary?: true
    connectedAt?: true
    lastUsedAt?: true
    lastError?: true
    lastErrorAt?: true
  }

  export type MerchantIntegrationMaxAggregateInputType = {
    id?: true
    merchantId?: true
    provider?: true
    isActive?: true
    isPrimary?: true
    connectedAt?: true
    lastUsedAt?: true
    lastError?: true
    lastErrorAt?: true
  }

  export type MerchantIntegrationCountAggregateInputType = {
    id?: true
    merchantId?: true
    provider?: true
    credentials?: true
    config?: true
    isActive?: true
    isPrimary?: true
    connectedAt?: true
    lastUsedAt?: true
    lastError?: true
    lastErrorAt?: true
    _all?: true
  }

  export type MerchantIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerchantIntegration to aggregate.
     */
    where?: MerchantIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantIntegrations to fetch.
     */
    orderBy?: MerchantIntegrationOrderByWithRelationInput | MerchantIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerchantIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MerchantIntegrations
    **/
    _count?: true | MerchantIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantIntegrationMaxAggregateInputType
  }

  export type GetMerchantIntegrationAggregateType<T extends MerchantIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchantIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchantIntegration[P]>
      : GetScalarType<T[P], AggregateMerchantIntegration[P]>
  }




  export type MerchantIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantIntegrationWhereInput
    orderBy?: MerchantIntegrationOrderByWithAggregationInput | MerchantIntegrationOrderByWithAggregationInput[]
    by: MerchantIntegrationScalarFieldEnum[] | MerchantIntegrationScalarFieldEnum
    having?: MerchantIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantIntegrationCountAggregateInputType | true
    _min?: MerchantIntegrationMinAggregateInputType
    _max?: MerchantIntegrationMaxAggregateInputType
  }

  export type MerchantIntegrationGroupByOutputType = {
    id: string
    merchantId: string
    provider: $Enums.PaymentProvider
    credentials: JsonValue
    config: JsonValue | null
    isActive: boolean
    isPrimary: boolean
    connectedAt: Date
    lastUsedAt: Date | null
    lastError: string | null
    lastErrorAt: Date | null
    _count: MerchantIntegrationCountAggregateOutputType | null
    _min: MerchantIntegrationMinAggregateOutputType | null
    _max: MerchantIntegrationMaxAggregateOutputType | null
  }

  type GetMerchantIntegrationGroupByPayload<T extends MerchantIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type MerchantIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    provider?: boolean
    credentials?: boolean
    config?: boolean
    isActive?: boolean
    isPrimary?: boolean
    connectedAt?: boolean
    lastUsedAt?: boolean
    lastError?: boolean
    lastErrorAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantIntegration"]>

  export type MerchantIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    provider?: boolean
    credentials?: boolean
    config?: boolean
    isActive?: boolean
    isPrimary?: boolean
    connectedAt?: boolean
    lastUsedAt?: boolean
    lastError?: boolean
    lastErrorAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantIntegration"]>

  export type MerchantIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    provider?: boolean
    credentials?: boolean
    config?: boolean
    isActive?: boolean
    isPrimary?: boolean
    connectedAt?: boolean
    lastUsedAt?: boolean
    lastError?: boolean
    lastErrorAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantIntegration"]>

  export type MerchantIntegrationSelectScalar = {
    id?: boolean
    merchantId?: boolean
    provider?: boolean
    credentials?: boolean
    config?: boolean
    isActive?: boolean
    isPrimary?: boolean
    connectedAt?: boolean
    lastUsedAt?: boolean
    lastError?: boolean
    lastErrorAt?: boolean
  }

  export type MerchantIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "merchantId" | "provider" | "credentials" | "config" | "isActive" | "isPrimary" | "connectedAt" | "lastUsedAt" | "lastError" | "lastErrorAt", ExtArgs["result"]["merchantIntegration"]>
  export type MerchantIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }
  export type MerchantIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }
  export type MerchantIntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }

  export type $MerchantIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MerchantIntegration"
    objects: {
      merchant: Prisma.$MerchantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchantId: string
      provider: $Enums.PaymentProvider
      credentials: Prisma.JsonValue
      config: Prisma.JsonValue | null
      isActive: boolean
      isPrimary: boolean
      connectedAt: Date
      lastUsedAt: Date | null
      lastError: string | null
      lastErrorAt: Date | null
    }, ExtArgs["result"]["merchantIntegration"]>
    composites: {}
  }

  type MerchantIntegrationGetPayload<S extends boolean | null | undefined | MerchantIntegrationDefaultArgs> = $Result.GetResult<Prisma.$MerchantIntegrationPayload, S>

  type MerchantIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MerchantIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantIntegrationCountAggregateInputType | true
    }

  export interface MerchantIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MerchantIntegration'], meta: { name: 'MerchantIntegration' } }
    /**
     * Find zero or one MerchantIntegration that matches the filter.
     * @param {MerchantIntegrationFindUniqueArgs} args - Arguments to find a MerchantIntegration
     * @example
     * // Get one MerchantIntegration
     * const merchantIntegration = await prisma.merchantIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerchantIntegrationFindUniqueArgs>(args: SelectSubset<T, MerchantIntegrationFindUniqueArgs<ExtArgs>>): Prisma__MerchantIntegrationClient<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MerchantIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MerchantIntegrationFindUniqueOrThrowArgs} args - Arguments to find a MerchantIntegration
     * @example
     * // Get one MerchantIntegration
     * const merchantIntegration = await prisma.merchantIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerchantIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, MerchantIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerchantIntegrationClient<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MerchantIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantIntegrationFindFirstArgs} args - Arguments to find a MerchantIntegration
     * @example
     * // Get one MerchantIntegration
     * const merchantIntegration = await prisma.merchantIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerchantIntegrationFindFirstArgs>(args?: SelectSubset<T, MerchantIntegrationFindFirstArgs<ExtArgs>>): Prisma__MerchantIntegrationClient<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MerchantIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantIntegrationFindFirstOrThrowArgs} args - Arguments to find a MerchantIntegration
     * @example
     * // Get one MerchantIntegration
     * const merchantIntegration = await prisma.merchantIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerchantIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, MerchantIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerchantIntegrationClient<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MerchantIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MerchantIntegrations
     * const merchantIntegrations = await prisma.merchantIntegration.findMany()
     * 
     * // Get first 10 MerchantIntegrations
     * const merchantIntegrations = await prisma.merchantIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantIntegrationWithIdOnly = await prisma.merchantIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MerchantIntegrationFindManyArgs>(args?: SelectSubset<T, MerchantIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MerchantIntegration.
     * @param {MerchantIntegrationCreateArgs} args - Arguments to create a MerchantIntegration.
     * @example
     * // Create one MerchantIntegration
     * const MerchantIntegration = await prisma.merchantIntegration.create({
     *   data: {
     *     // ... data to create a MerchantIntegration
     *   }
     * })
     * 
     */
    create<T extends MerchantIntegrationCreateArgs>(args: SelectSubset<T, MerchantIntegrationCreateArgs<ExtArgs>>): Prisma__MerchantIntegrationClient<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MerchantIntegrations.
     * @param {MerchantIntegrationCreateManyArgs} args - Arguments to create many MerchantIntegrations.
     * @example
     * // Create many MerchantIntegrations
     * const merchantIntegration = await prisma.merchantIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerchantIntegrationCreateManyArgs>(args?: SelectSubset<T, MerchantIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MerchantIntegrations and returns the data saved in the database.
     * @param {MerchantIntegrationCreateManyAndReturnArgs} args - Arguments to create many MerchantIntegrations.
     * @example
     * // Create many MerchantIntegrations
     * const merchantIntegration = await prisma.merchantIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MerchantIntegrations and only return the `id`
     * const merchantIntegrationWithIdOnly = await prisma.merchantIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerchantIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, MerchantIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MerchantIntegration.
     * @param {MerchantIntegrationDeleteArgs} args - Arguments to delete one MerchantIntegration.
     * @example
     * // Delete one MerchantIntegration
     * const MerchantIntegration = await prisma.merchantIntegration.delete({
     *   where: {
     *     // ... filter to delete one MerchantIntegration
     *   }
     * })
     * 
     */
    delete<T extends MerchantIntegrationDeleteArgs>(args: SelectSubset<T, MerchantIntegrationDeleteArgs<ExtArgs>>): Prisma__MerchantIntegrationClient<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MerchantIntegration.
     * @param {MerchantIntegrationUpdateArgs} args - Arguments to update one MerchantIntegration.
     * @example
     * // Update one MerchantIntegration
     * const merchantIntegration = await prisma.merchantIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerchantIntegrationUpdateArgs>(args: SelectSubset<T, MerchantIntegrationUpdateArgs<ExtArgs>>): Prisma__MerchantIntegrationClient<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MerchantIntegrations.
     * @param {MerchantIntegrationDeleteManyArgs} args - Arguments to filter MerchantIntegrations to delete.
     * @example
     * // Delete a few MerchantIntegrations
     * const { count } = await prisma.merchantIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerchantIntegrationDeleteManyArgs>(args?: SelectSubset<T, MerchantIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerchantIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MerchantIntegrations
     * const merchantIntegration = await prisma.merchantIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerchantIntegrationUpdateManyArgs>(args: SelectSubset<T, MerchantIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerchantIntegrations and returns the data updated in the database.
     * @param {MerchantIntegrationUpdateManyAndReturnArgs} args - Arguments to update many MerchantIntegrations.
     * @example
     * // Update many MerchantIntegrations
     * const merchantIntegration = await prisma.merchantIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MerchantIntegrations and only return the `id`
     * const merchantIntegrationWithIdOnly = await prisma.merchantIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MerchantIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, MerchantIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MerchantIntegration.
     * @param {MerchantIntegrationUpsertArgs} args - Arguments to update or create a MerchantIntegration.
     * @example
     * // Update or create a MerchantIntegration
     * const merchantIntegration = await prisma.merchantIntegration.upsert({
     *   create: {
     *     // ... data to create a MerchantIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MerchantIntegration we want to update
     *   }
     * })
     */
    upsert<T extends MerchantIntegrationUpsertArgs>(args: SelectSubset<T, MerchantIntegrationUpsertArgs<ExtArgs>>): Prisma__MerchantIntegrationClient<$Result.GetResult<Prisma.$MerchantIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MerchantIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantIntegrationCountArgs} args - Arguments to filter MerchantIntegrations to count.
     * @example
     * // Count the number of MerchantIntegrations
     * const count = await prisma.merchantIntegration.count({
     *   where: {
     *     // ... the filter for the MerchantIntegrations we want to count
     *   }
     * })
    **/
    count<T extends MerchantIntegrationCountArgs>(
      args?: Subset<T, MerchantIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MerchantIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantIntegrationAggregateArgs>(args: Subset<T, MerchantIntegrationAggregateArgs>): Prisma.PrismaPromise<GetMerchantIntegrationAggregateType<T>>

    /**
     * Group by MerchantIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: MerchantIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MerchantIntegration model
   */
  readonly fields: MerchantIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MerchantIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerchantIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchant<T extends MerchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantDefaultArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MerchantIntegration model
   */
  interface MerchantIntegrationFieldRefs {
    readonly id: FieldRef<"MerchantIntegration", 'String'>
    readonly merchantId: FieldRef<"MerchantIntegration", 'String'>
    readonly provider: FieldRef<"MerchantIntegration", 'PaymentProvider'>
    readonly credentials: FieldRef<"MerchantIntegration", 'Json'>
    readonly config: FieldRef<"MerchantIntegration", 'Json'>
    readonly isActive: FieldRef<"MerchantIntegration", 'Boolean'>
    readonly isPrimary: FieldRef<"MerchantIntegration", 'Boolean'>
    readonly connectedAt: FieldRef<"MerchantIntegration", 'DateTime'>
    readonly lastUsedAt: FieldRef<"MerchantIntegration", 'DateTime'>
    readonly lastError: FieldRef<"MerchantIntegration", 'String'>
    readonly lastErrorAt: FieldRef<"MerchantIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MerchantIntegration findUnique
   */
  export type MerchantIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which MerchantIntegration to fetch.
     */
    where: MerchantIntegrationWhereUniqueInput
  }

  /**
   * MerchantIntegration findUniqueOrThrow
   */
  export type MerchantIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which MerchantIntegration to fetch.
     */
    where: MerchantIntegrationWhereUniqueInput
  }

  /**
   * MerchantIntegration findFirst
   */
  export type MerchantIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which MerchantIntegration to fetch.
     */
    where?: MerchantIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantIntegrations to fetch.
     */
    orderBy?: MerchantIntegrationOrderByWithRelationInput | MerchantIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerchantIntegrations.
     */
    cursor?: MerchantIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerchantIntegrations.
     */
    distinct?: MerchantIntegrationScalarFieldEnum | MerchantIntegrationScalarFieldEnum[]
  }

  /**
   * MerchantIntegration findFirstOrThrow
   */
  export type MerchantIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which MerchantIntegration to fetch.
     */
    where?: MerchantIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantIntegrations to fetch.
     */
    orderBy?: MerchantIntegrationOrderByWithRelationInput | MerchantIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerchantIntegrations.
     */
    cursor?: MerchantIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerchantIntegrations.
     */
    distinct?: MerchantIntegrationScalarFieldEnum | MerchantIntegrationScalarFieldEnum[]
  }

  /**
   * MerchantIntegration findMany
   */
  export type MerchantIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which MerchantIntegrations to fetch.
     */
    where?: MerchantIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantIntegrations to fetch.
     */
    orderBy?: MerchantIntegrationOrderByWithRelationInput | MerchantIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MerchantIntegrations.
     */
    cursor?: MerchantIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantIntegrations.
     */
    skip?: number
    distinct?: MerchantIntegrationScalarFieldEnum | MerchantIntegrationScalarFieldEnum[]
  }

  /**
   * MerchantIntegration create
   */
  export type MerchantIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a MerchantIntegration.
     */
    data: XOR<MerchantIntegrationCreateInput, MerchantIntegrationUncheckedCreateInput>
  }

  /**
   * MerchantIntegration createMany
   */
  export type MerchantIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MerchantIntegrations.
     */
    data: MerchantIntegrationCreateManyInput | MerchantIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MerchantIntegration createManyAndReturn
   */
  export type MerchantIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many MerchantIntegrations.
     */
    data: MerchantIntegrationCreateManyInput | MerchantIntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerchantIntegration update
   */
  export type MerchantIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a MerchantIntegration.
     */
    data: XOR<MerchantIntegrationUpdateInput, MerchantIntegrationUncheckedUpdateInput>
    /**
     * Choose, which MerchantIntegration to update.
     */
    where: MerchantIntegrationWhereUniqueInput
  }

  /**
   * MerchantIntegration updateMany
   */
  export type MerchantIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MerchantIntegrations.
     */
    data: XOR<MerchantIntegrationUpdateManyMutationInput, MerchantIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which MerchantIntegrations to update
     */
    where?: MerchantIntegrationWhereInput
    /**
     * Limit how many MerchantIntegrations to update.
     */
    limit?: number
  }

  /**
   * MerchantIntegration updateManyAndReturn
   */
  export type MerchantIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update MerchantIntegrations.
     */
    data: XOR<MerchantIntegrationUpdateManyMutationInput, MerchantIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which MerchantIntegrations to update
     */
    where?: MerchantIntegrationWhereInput
    /**
     * Limit how many MerchantIntegrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerchantIntegration upsert
   */
  export type MerchantIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the MerchantIntegration to update in case it exists.
     */
    where: MerchantIntegrationWhereUniqueInput
    /**
     * In case the MerchantIntegration found by the `where` argument doesn't exist, create a new MerchantIntegration with this data.
     */
    create: XOR<MerchantIntegrationCreateInput, MerchantIntegrationUncheckedCreateInput>
    /**
     * In case the MerchantIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerchantIntegrationUpdateInput, MerchantIntegrationUncheckedUpdateInput>
  }

  /**
   * MerchantIntegration delete
   */
  export type MerchantIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationInclude<ExtArgs> | null
    /**
     * Filter which MerchantIntegration to delete.
     */
    where: MerchantIntegrationWhereUniqueInput
  }

  /**
   * MerchantIntegration deleteMany
   */
  export type MerchantIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerchantIntegrations to delete
     */
    where?: MerchantIntegrationWhereInput
    /**
     * Limit how many MerchantIntegrations to delete.
     */
    limit?: number
  }

  /**
   * MerchantIntegration without action
   */
  export type MerchantIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantIntegration
     */
    select?: MerchantIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantIntegration
     */
    omit?: MerchantIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantIntegrationInclude<ExtArgs> | null
  }


  /**
   * Model PaymentRoutingRule
   */

  export type AggregatePaymentRoutingRule = {
    _count: PaymentRoutingRuleCountAggregateOutputType | null
    _avg: PaymentRoutingRuleAvgAggregateOutputType | null
    _sum: PaymentRoutingRuleSumAggregateOutputType | null
    _min: PaymentRoutingRuleMinAggregateOutputType | null
    _max: PaymentRoutingRuleMaxAggregateOutputType | null
  }

  export type PaymentRoutingRuleAvgAggregateOutputType = {
    priority: number | null
  }

  export type PaymentRoutingRuleSumAggregateOutputType = {
    priority: number | null
  }

  export type PaymentRoutingRuleMinAggregateOutputType = {
    id: string | null
    merchantId: string | null
    productId: string | null
    offerId: string | null
    country: string | null
    method: $Enums.PaymentMethod | null
    provider: $Enums.PaymentProvider | null
    priority: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentRoutingRuleMaxAggregateOutputType = {
    id: string | null
    merchantId: string | null
    productId: string | null
    offerId: string | null
    country: string | null
    method: $Enums.PaymentMethod | null
    provider: $Enums.PaymentProvider | null
    priority: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentRoutingRuleCountAggregateOutputType = {
    id: number
    merchantId: number
    productId: number
    offerId: number
    country: number
    method: number
    provider: number
    priority: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentRoutingRuleAvgAggregateInputType = {
    priority?: true
  }

  export type PaymentRoutingRuleSumAggregateInputType = {
    priority?: true
  }

  export type PaymentRoutingRuleMinAggregateInputType = {
    id?: true
    merchantId?: true
    productId?: true
    offerId?: true
    country?: true
    method?: true
    provider?: true
    priority?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentRoutingRuleMaxAggregateInputType = {
    id?: true
    merchantId?: true
    productId?: true
    offerId?: true
    country?: true
    method?: true
    provider?: true
    priority?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentRoutingRuleCountAggregateInputType = {
    id?: true
    merchantId?: true
    productId?: true
    offerId?: true
    country?: true
    method?: true
    provider?: true
    priority?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentRoutingRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentRoutingRule to aggregate.
     */
    where?: PaymentRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRoutingRules to fetch.
     */
    orderBy?: PaymentRoutingRuleOrderByWithRelationInput | PaymentRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentRoutingRules
    **/
    _count?: true | PaymentRoutingRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentRoutingRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentRoutingRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentRoutingRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentRoutingRuleMaxAggregateInputType
  }

  export type GetPaymentRoutingRuleAggregateType<T extends PaymentRoutingRuleAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentRoutingRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentRoutingRule[P]>
      : GetScalarType<T[P], AggregatePaymentRoutingRule[P]>
  }




  export type PaymentRoutingRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRoutingRuleWhereInput
    orderBy?: PaymentRoutingRuleOrderByWithAggregationInput | PaymentRoutingRuleOrderByWithAggregationInput[]
    by: PaymentRoutingRuleScalarFieldEnum[] | PaymentRoutingRuleScalarFieldEnum
    having?: PaymentRoutingRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentRoutingRuleCountAggregateInputType | true
    _avg?: PaymentRoutingRuleAvgAggregateInputType
    _sum?: PaymentRoutingRuleSumAggregateInputType
    _min?: PaymentRoutingRuleMinAggregateInputType
    _max?: PaymentRoutingRuleMaxAggregateInputType
  }

  export type PaymentRoutingRuleGroupByOutputType = {
    id: string
    merchantId: string
    productId: string | null
    offerId: string | null
    country: string | null
    method: $Enums.PaymentMethod | null
    provider: $Enums.PaymentProvider
    priority: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaymentRoutingRuleCountAggregateOutputType | null
    _avg: PaymentRoutingRuleAvgAggregateOutputType | null
    _sum: PaymentRoutingRuleSumAggregateOutputType | null
    _min: PaymentRoutingRuleMinAggregateOutputType | null
    _max: PaymentRoutingRuleMaxAggregateOutputType | null
  }

  type GetPaymentRoutingRuleGroupByPayload<T extends PaymentRoutingRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentRoutingRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentRoutingRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentRoutingRuleGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentRoutingRuleGroupByOutputType[P]>
        }
      >
    >


  export type PaymentRoutingRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    productId?: boolean
    offerId?: boolean
    country?: boolean
    method?: boolean
    provider?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentRoutingRule"]>

  export type PaymentRoutingRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    productId?: boolean
    offerId?: boolean
    country?: boolean
    method?: boolean
    provider?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentRoutingRule"]>

  export type PaymentRoutingRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    productId?: boolean
    offerId?: boolean
    country?: boolean
    method?: boolean
    provider?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentRoutingRule"]>

  export type PaymentRoutingRuleSelectScalar = {
    id?: boolean
    merchantId?: boolean
    productId?: boolean
    offerId?: boolean
    country?: boolean
    method?: boolean
    provider?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentRoutingRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "merchantId" | "productId" | "offerId" | "country" | "method" | "provider" | "priority" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentRoutingRule"]>

  export type $PaymentRoutingRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentRoutingRule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchantId: string
      productId: string | null
      offerId: string | null
      country: string | null
      method: $Enums.PaymentMethod | null
      provider: $Enums.PaymentProvider
      priority: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentRoutingRule"]>
    composites: {}
  }

  type PaymentRoutingRuleGetPayload<S extends boolean | null | undefined | PaymentRoutingRuleDefaultArgs> = $Result.GetResult<Prisma.$PaymentRoutingRulePayload, S>

  type PaymentRoutingRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentRoutingRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentRoutingRuleCountAggregateInputType | true
    }

  export interface PaymentRoutingRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentRoutingRule'], meta: { name: 'PaymentRoutingRule' } }
    /**
     * Find zero or one PaymentRoutingRule that matches the filter.
     * @param {PaymentRoutingRuleFindUniqueArgs} args - Arguments to find a PaymentRoutingRule
     * @example
     * // Get one PaymentRoutingRule
     * const paymentRoutingRule = await prisma.paymentRoutingRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentRoutingRuleFindUniqueArgs>(args: SelectSubset<T, PaymentRoutingRuleFindUniqueArgs<ExtArgs>>): Prisma__PaymentRoutingRuleClient<$Result.GetResult<Prisma.$PaymentRoutingRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentRoutingRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentRoutingRuleFindUniqueOrThrowArgs} args - Arguments to find a PaymentRoutingRule
     * @example
     * // Get one PaymentRoutingRule
     * const paymentRoutingRule = await prisma.paymentRoutingRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentRoutingRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentRoutingRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentRoutingRuleClient<$Result.GetResult<Prisma.$PaymentRoutingRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentRoutingRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRoutingRuleFindFirstArgs} args - Arguments to find a PaymentRoutingRule
     * @example
     * // Get one PaymentRoutingRule
     * const paymentRoutingRule = await prisma.paymentRoutingRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentRoutingRuleFindFirstArgs>(args?: SelectSubset<T, PaymentRoutingRuleFindFirstArgs<ExtArgs>>): Prisma__PaymentRoutingRuleClient<$Result.GetResult<Prisma.$PaymentRoutingRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentRoutingRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRoutingRuleFindFirstOrThrowArgs} args - Arguments to find a PaymentRoutingRule
     * @example
     * // Get one PaymentRoutingRule
     * const paymentRoutingRule = await prisma.paymentRoutingRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentRoutingRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentRoutingRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentRoutingRuleClient<$Result.GetResult<Prisma.$PaymentRoutingRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentRoutingRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRoutingRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentRoutingRules
     * const paymentRoutingRules = await prisma.paymentRoutingRule.findMany()
     * 
     * // Get first 10 PaymentRoutingRules
     * const paymentRoutingRules = await prisma.paymentRoutingRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentRoutingRuleWithIdOnly = await prisma.paymentRoutingRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentRoutingRuleFindManyArgs>(args?: SelectSubset<T, PaymentRoutingRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRoutingRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentRoutingRule.
     * @param {PaymentRoutingRuleCreateArgs} args - Arguments to create a PaymentRoutingRule.
     * @example
     * // Create one PaymentRoutingRule
     * const PaymentRoutingRule = await prisma.paymentRoutingRule.create({
     *   data: {
     *     // ... data to create a PaymentRoutingRule
     *   }
     * })
     * 
     */
    create<T extends PaymentRoutingRuleCreateArgs>(args: SelectSubset<T, PaymentRoutingRuleCreateArgs<ExtArgs>>): Prisma__PaymentRoutingRuleClient<$Result.GetResult<Prisma.$PaymentRoutingRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentRoutingRules.
     * @param {PaymentRoutingRuleCreateManyArgs} args - Arguments to create many PaymentRoutingRules.
     * @example
     * // Create many PaymentRoutingRules
     * const paymentRoutingRule = await prisma.paymentRoutingRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentRoutingRuleCreateManyArgs>(args?: SelectSubset<T, PaymentRoutingRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentRoutingRules and returns the data saved in the database.
     * @param {PaymentRoutingRuleCreateManyAndReturnArgs} args - Arguments to create many PaymentRoutingRules.
     * @example
     * // Create many PaymentRoutingRules
     * const paymentRoutingRule = await prisma.paymentRoutingRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentRoutingRules and only return the `id`
     * const paymentRoutingRuleWithIdOnly = await prisma.paymentRoutingRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentRoutingRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentRoutingRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRoutingRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentRoutingRule.
     * @param {PaymentRoutingRuleDeleteArgs} args - Arguments to delete one PaymentRoutingRule.
     * @example
     * // Delete one PaymentRoutingRule
     * const PaymentRoutingRule = await prisma.paymentRoutingRule.delete({
     *   where: {
     *     // ... filter to delete one PaymentRoutingRule
     *   }
     * })
     * 
     */
    delete<T extends PaymentRoutingRuleDeleteArgs>(args: SelectSubset<T, PaymentRoutingRuleDeleteArgs<ExtArgs>>): Prisma__PaymentRoutingRuleClient<$Result.GetResult<Prisma.$PaymentRoutingRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentRoutingRule.
     * @param {PaymentRoutingRuleUpdateArgs} args - Arguments to update one PaymentRoutingRule.
     * @example
     * // Update one PaymentRoutingRule
     * const paymentRoutingRule = await prisma.paymentRoutingRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentRoutingRuleUpdateArgs>(args: SelectSubset<T, PaymentRoutingRuleUpdateArgs<ExtArgs>>): Prisma__PaymentRoutingRuleClient<$Result.GetResult<Prisma.$PaymentRoutingRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentRoutingRules.
     * @param {PaymentRoutingRuleDeleteManyArgs} args - Arguments to filter PaymentRoutingRules to delete.
     * @example
     * // Delete a few PaymentRoutingRules
     * const { count } = await prisma.paymentRoutingRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentRoutingRuleDeleteManyArgs>(args?: SelectSubset<T, PaymentRoutingRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentRoutingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRoutingRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentRoutingRules
     * const paymentRoutingRule = await prisma.paymentRoutingRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentRoutingRuleUpdateManyArgs>(args: SelectSubset<T, PaymentRoutingRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentRoutingRules and returns the data updated in the database.
     * @param {PaymentRoutingRuleUpdateManyAndReturnArgs} args - Arguments to update many PaymentRoutingRules.
     * @example
     * // Update many PaymentRoutingRules
     * const paymentRoutingRule = await prisma.paymentRoutingRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentRoutingRules and only return the `id`
     * const paymentRoutingRuleWithIdOnly = await prisma.paymentRoutingRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentRoutingRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentRoutingRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRoutingRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentRoutingRule.
     * @param {PaymentRoutingRuleUpsertArgs} args - Arguments to update or create a PaymentRoutingRule.
     * @example
     * // Update or create a PaymentRoutingRule
     * const paymentRoutingRule = await prisma.paymentRoutingRule.upsert({
     *   create: {
     *     // ... data to create a PaymentRoutingRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentRoutingRule we want to update
     *   }
     * })
     */
    upsert<T extends PaymentRoutingRuleUpsertArgs>(args: SelectSubset<T, PaymentRoutingRuleUpsertArgs<ExtArgs>>): Prisma__PaymentRoutingRuleClient<$Result.GetResult<Prisma.$PaymentRoutingRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentRoutingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRoutingRuleCountArgs} args - Arguments to filter PaymentRoutingRules to count.
     * @example
     * // Count the number of PaymentRoutingRules
     * const count = await prisma.paymentRoutingRule.count({
     *   where: {
     *     // ... the filter for the PaymentRoutingRules we want to count
     *   }
     * })
    **/
    count<T extends PaymentRoutingRuleCountArgs>(
      args?: Subset<T, PaymentRoutingRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentRoutingRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentRoutingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRoutingRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentRoutingRuleAggregateArgs>(args: Subset<T, PaymentRoutingRuleAggregateArgs>): Prisma.PrismaPromise<GetPaymentRoutingRuleAggregateType<T>>

    /**
     * Group by PaymentRoutingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRoutingRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentRoutingRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentRoutingRuleGroupByArgs['orderBy'] }
        : { orderBy?: PaymentRoutingRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentRoutingRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentRoutingRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentRoutingRule model
   */
  readonly fields: PaymentRoutingRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentRoutingRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentRoutingRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentRoutingRule model
   */
  interface PaymentRoutingRuleFieldRefs {
    readonly id: FieldRef<"PaymentRoutingRule", 'String'>
    readonly merchantId: FieldRef<"PaymentRoutingRule", 'String'>
    readonly productId: FieldRef<"PaymentRoutingRule", 'String'>
    readonly offerId: FieldRef<"PaymentRoutingRule", 'String'>
    readonly country: FieldRef<"PaymentRoutingRule", 'String'>
    readonly method: FieldRef<"PaymentRoutingRule", 'PaymentMethod'>
    readonly provider: FieldRef<"PaymentRoutingRule", 'PaymentProvider'>
    readonly priority: FieldRef<"PaymentRoutingRule", 'Int'>
    readonly isActive: FieldRef<"PaymentRoutingRule", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentRoutingRule", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentRoutingRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentRoutingRule findUnique
   */
  export type PaymentRoutingRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter, which PaymentRoutingRule to fetch.
     */
    where: PaymentRoutingRuleWhereUniqueInput
  }

  /**
   * PaymentRoutingRule findUniqueOrThrow
   */
  export type PaymentRoutingRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter, which PaymentRoutingRule to fetch.
     */
    where: PaymentRoutingRuleWhereUniqueInput
  }

  /**
   * PaymentRoutingRule findFirst
   */
  export type PaymentRoutingRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter, which PaymentRoutingRule to fetch.
     */
    where?: PaymentRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRoutingRules to fetch.
     */
    orderBy?: PaymentRoutingRuleOrderByWithRelationInput | PaymentRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentRoutingRules.
     */
    cursor?: PaymentRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentRoutingRules.
     */
    distinct?: PaymentRoutingRuleScalarFieldEnum | PaymentRoutingRuleScalarFieldEnum[]
  }

  /**
   * PaymentRoutingRule findFirstOrThrow
   */
  export type PaymentRoutingRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter, which PaymentRoutingRule to fetch.
     */
    where?: PaymentRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRoutingRules to fetch.
     */
    orderBy?: PaymentRoutingRuleOrderByWithRelationInput | PaymentRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentRoutingRules.
     */
    cursor?: PaymentRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentRoutingRules.
     */
    distinct?: PaymentRoutingRuleScalarFieldEnum | PaymentRoutingRuleScalarFieldEnum[]
  }

  /**
   * PaymentRoutingRule findMany
   */
  export type PaymentRoutingRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter, which PaymentRoutingRules to fetch.
     */
    where?: PaymentRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRoutingRules to fetch.
     */
    orderBy?: PaymentRoutingRuleOrderByWithRelationInput | PaymentRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentRoutingRules.
     */
    cursor?: PaymentRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRoutingRules.
     */
    skip?: number
    distinct?: PaymentRoutingRuleScalarFieldEnum | PaymentRoutingRuleScalarFieldEnum[]
  }

  /**
   * PaymentRoutingRule create
   */
  export type PaymentRoutingRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentRoutingRule.
     */
    data: XOR<PaymentRoutingRuleCreateInput, PaymentRoutingRuleUncheckedCreateInput>
  }

  /**
   * PaymentRoutingRule createMany
   */
  export type PaymentRoutingRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentRoutingRules.
     */
    data: PaymentRoutingRuleCreateManyInput | PaymentRoutingRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentRoutingRule createManyAndReturn
   */
  export type PaymentRoutingRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentRoutingRules.
     */
    data: PaymentRoutingRuleCreateManyInput | PaymentRoutingRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentRoutingRule update
   */
  export type PaymentRoutingRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentRoutingRule.
     */
    data: XOR<PaymentRoutingRuleUpdateInput, PaymentRoutingRuleUncheckedUpdateInput>
    /**
     * Choose, which PaymentRoutingRule to update.
     */
    where: PaymentRoutingRuleWhereUniqueInput
  }

  /**
   * PaymentRoutingRule updateMany
   */
  export type PaymentRoutingRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentRoutingRules.
     */
    data: XOR<PaymentRoutingRuleUpdateManyMutationInput, PaymentRoutingRuleUncheckedUpdateManyInput>
    /**
     * Filter which PaymentRoutingRules to update
     */
    where?: PaymentRoutingRuleWhereInput
    /**
     * Limit how many PaymentRoutingRules to update.
     */
    limit?: number
  }

  /**
   * PaymentRoutingRule updateManyAndReturn
   */
  export type PaymentRoutingRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
    /**
     * The data used to update PaymentRoutingRules.
     */
    data: XOR<PaymentRoutingRuleUpdateManyMutationInput, PaymentRoutingRuleUncheckedUpdateManyInput>
    /**
     * Filter which PaymentRoutingRules to update
     */
    where?: PaymentRoutingRuleWhereInput
    /**
     * Limit how many PaymentRoutingRules to update.
     */
    limit?: number
  }

  /**
   * PaymentRoutingRule upsert
   */
  export type PaymentRoutingRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentRoutingRule to update in case it exists.
     */
    where: PaymentRoutingRuleWhereUniqueInput
    /**
     * In case the PaymentRoutingRule found by the `where` argument doesn't exist, create a new PaymentRoutingRule with this data.
     */
    create: XOR<PaymentRoutingRuleCreateInput, PaymentRoutingRuleUncheckedCreateInput>
    /**
     * In case the PaymentRoutingRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentRoutingRuleUpdateInput, PaymentRoutingRuleUncheckedUpdateInput>
  }

  /**
   * PaymentRoutingRule delete
   */
  export type PaymentRoutingRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter which PaymentRoutingRule to delete.
     */
    where: PaymentRoutingRuleWhereUniqueInput
  }

  /**
   * PaymentRoutingRule deleteMany
   */
  export type PaymentRoutingRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentRoutingRules to delete
     */
    where?: PaymentRoutingRuleWhereInput
    /**
     * Limit how many PaymentRoutingRules to delete.
     */
    limit?: number
  }

  /**
   * PaymentRoutingRule without action
   */
  export type PaymentRoutingRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRoutingRule
     */
    select?: PaymentRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRoutingRule
     */
    omit?: PaymentRoutingRuleOmit<ExtArgs> | null
  }


  /**
   * Model ClinicPlan
   */

  export type AggregateClinicPlan = {
    _count: ClinicPlanCountAggregateOutputType | null
    _avg: ClinicPlanAvgAggregateOutputType | null
    _sum: ClinicPlanSumAggregateOutputType | null
    _min: ClinicPlanMinAggregateOutputType | null
    _max: ClinicPlanMaxAggregateOutputType | null
  }

  export type ClinicPlanAvgAggregateOutputType = {
    monthlyPrice: Decimal | null
    monthlyTxLimit: number | null
    trialDays: number | null
  }

  export type ClinicPlanSumAggregateOutputType = {
    monthlyPrice: Decimal | null
    monthlyTxLimit: number | null
    trialDays: number | null
  }

  export type ClinicPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    tier: $Enums.PlanTier | null
    description: string | null
    monthlyPrice: Decimal | null
    monthlyTxLimit: number | null
    trialDays: number | null
    requireCard: boolean | null
    isActive: boolean | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    tier: $Enums.PlanTier | null
    description: string | null
    monthlyPrice: Decimal | null
    monthlyTxLimit: number | null
    trialDays: number | null
    requireCard: boolean | null
    isActive: boolean | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicPlanCountAggregateOutputType = {
    id: number
    name: number
    tier: number
    description: number
    monthlyPrice: number
    monthlyTxLimit: number
    features: number
    trialDays: number
    requireCard: number
    isActive: number
    isPublic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicPlanAvgAggregateInputType = {
    monthlyPrice?: true
    monthlyTxLimit?: true
    trialDays?: true
  }

  export type ClinicPlanSumAggregateInputType = {
    monthlyPrice?: true
    monthlyTxLimit?: true
    trialDays?: true
  }

  export type ClinicPlanMinAggregateInputType = {
    id?: true
    name?: true
    tier?: true
    description?: true
    monthlyPrice?: true
    monthlyTxLimit?: true
    trialDays?: true
    requireCard?: true
    isActive?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicPlanMaxAggregateInputType = {
    id?: true
    name?: true
    tier?: true
    description?: true
    monthlyPrice?: true
    monthlyTxLimit?: true
    trialDays?: true
    requireCard?: true
    isActive?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicPlanCountAggregateInputType = {
    id?: true
    name?: true
    tier?: true
    description?: true
    monthlyPrice?: true
    monthlyTxLimit?: true
    features?: true
    trialDays?: true
    requireCard?: true
    isActive?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicPlan to aggregate.
     */
    where?: ClinicPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicPlans to fetch.
     */
    orderBy?: ClinicPlanOrderByWithRelationInput | ClinicPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicPlans
    **/
    _count?: true | ClinicPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClinicPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClinicPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicPlanMaxAggregateInputType
  }

  export type GetClinicPlanAggregateType<T extends ClinicPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicPlan[P]>
      : GetScalarType<T[P], AggregateClinicPlan[P]>
  }




  export type ClinicPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicPlanWhereInput
    orderBy?: ClinicPlanOrderByWithAggregationInput | ClinicPlanOrderByWithAggregationInput[]
    by: ClinicPlanScalarFieldEnum[] | ClinicPlanScalarFieldEnum
    having?: ClinicPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicPlanCountAggregateInputType | true
    _avg?: ClinicPlanAvgAggregateInputType
    _sum?: ClinicPlanSumAggregateInputType
    _min?: ClinicPlanMinAggregateInputType
    _max?: ClinicPlanMaxAggregateInputType
  }

  export type ClinicPlanGroupByOutputType = {
    id: string
    name: string
    tier: $Enums.PlanTier
    description: string | null
    monthlyPrice: Decimal
    monthlyTxLimit: number
    features: JsonValue
    trialDays: number
    requireCard: boolean
    isActive: boolean
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClinicPlanCountAggregateOutputType | null
    _avg: ClinicPlanAvgAggregateOutputType | null
    _sum: ClinicPlanSumAggregateOutputType | null
    _min: ClinicPlanMinAggregateOutputType | null
    _max: ClinicPlanMaxAggregateOutputType | null
  }

  type GetClinicPlanGroupByPayload<T extends ClinicPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicPlanGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicPlanGroupByOutputType[P]>
        }
      >
    >


  export type ClinicPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tier?: boolean
    description?: boolean
    monthlyPrice?: boolean
    monthlyTxLimit?: boolean
    features?: boolean
    trialDays?: boolean
    requireCard?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | ClinicPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | ClinicPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicPlan"]>

  export type ClinicPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tier?: boolean
    description?: boolean
    monthlyPrice?: boolean
    monthlyTxLimit?: boolean
    features?: boolean
    trialDays?: boolean
    requireCard?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["clinicPlan"]>

  export type ClinicPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tier?: boolean
    description?: boolean
    monthlyPrice?: boolean
    monthlyTxLimit?: boolean
    features?: boolean
    trialDays?: boolean
    requireCard?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["clinicPlan"]>

  export type ClinicPlanSelectScalar = {
    id?: boolean
    name?: boolean
    tier?: boolean
    description?: boolean
    monthlyPrice?: boolean
    monthlyTxLimit?: boolean
    features?: boolean
    trialDays?: boolean
    requireCard?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "tier" | "description" | "monthlyPrice" | "monthlyTxLimit" | "features" | "trialDays" | "requireCard" | "isActive" | "isPublic" | "createdAt" | "updatedAt", ExtArgs["result"]["clinicPlan"]>
  export type ClinicPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | ClinicPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | ClinicPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClinicPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClinicPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClinicPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicPlan"
    objects: {
      subscriptions: Prisma.$ClinicSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      tier: $Enums.PlanTier
      description: string | null
      monthlyPrice: Prisma.Decimal
      monthlyTxLimit: number
      features: Prisma.JsonValue
      trialDays: number
      requireCard: boolean
      isActive: boolean
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinicPlan"]>
    composites: {}
  }

  type ClinicPlanGetPayload<S extends boolean | null | undefined | ClinicPlanDefaultArgs> = $Result.GetResult<Prisma.$ClinicPlanPayload, S>

  type ClinicPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicPlanCountAggregateInputType | true
    }

  export interface ClinicPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicPlan'], meta: { name: 'ClinicPlan' } }
    /**
     * Find zero or one ClinicPlan that matches the filter.
     * @param {ClinicPlanFindUniqueArgs} args - Arguments to find a ClinicPlan
     * @example
     * // Get one ClinicPlan
     * const clinicPlan = await prisma.clinicPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicPlanFindUniqueArgs>(args: SelectSubset<T, ClinicPlanFindUniqueArgs<ExtArgs>>): Prisma__ClinicPlanClient<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicPlanFindUniqueOrThrowArgs} args - Arguments to find a ClinicPlan
     * @example
     * // Get one ClinicPlan
     * const clinicPlan = await prisma.clinicPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicPlanClient<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPlanFindFirstArgs} args - Arguments to find a ClinicPlan
     * @example
     * // Get one ClinicPlan
     * const clinicPlan = await prisma.clinicPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicPlanFindFirstArgs>(args?: SelectSubset<T, ClinicPlanFindFirstArgs<ExtArgs>>): Prisma__ClinicPlanClient<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPlanFindFirstOrThrowArgs} args - Arguments to find a ClinicPlan
     * @example
     * // Get one ClinicPlan
     * const clinicPlan = await prisma.clinicPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicPlanClient<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicPlans
     * const clinicPlans = await prisma.clinicPlan.findMany()
     * 
     * // Get first 10 ClinicPlans
     * const clinicPlans = await prisma.clinicPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicPlanWithIdOnly = await prisma.clinicPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicPlanFindManyArgs>(args?: SelectSubset<T, ClinicPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicPlan.
     * @param {ClinicPlanCreateArgs} args - Arguments to create a ClinicPlan.
     * @example
     * // Create one ClinicPlan
     * const ClinicPlan = await prisma.clinicPlan.create({
     *   data: {
     *     // ... data to create a ClinicPlan
     *   }
     * })
     * 
     */
    create<T extends ClinicPlanCreateArgs>(args: SelectSubset<T, ClinicPlanCreateArgs<ExtArgs>>): Prisma__ClinicPlanClient<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicPlans.
     * @param {ClinicPlanCreateManyArgs} args - Arguments to create many ClinicPlans.
     * @example
     * // Create many ClinicPlans
     * const clinicPlan = await prisma.clinicPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicPlanCreateManyArgs>(args?: SelectSubset<T, ClinicPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicPlans and returns the data saved in the database.
     * @param {ClinicPlanCreateManyAndReturnArgs} args - Arguments to create many ClinicPlans.
     * @example
     * // Create many ClinicPlans
     * const clinicPlan = await prisma.clinicPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicPlans and only return the `id`
     * const clinicPlanWithIdOnly = await prisma.clinicPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicPlan.
     * @param {ClinicPlanDeleteArgs} args - Arguments to delete one ClinicPlan.
     * @example
     * // Delete one ClinicPlan
     * const ClinicPlan = await prisma.clinicPlan.delete({
     *   where: {
     *     // ... filter to delete one ClinicPlan
     *   }
     * })
     * 
     */
    delete<T extends ClinicPlanDeleteArgs>(args: SelectSubset<T, ClinicPlanDeleteArgs<ExtArgs>>): Prisma__ClinicPlanClient<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicPlan.
     * @param {ClinicPlanUpdateArgs} args - Arguments to update one ClinicPlan.
     * @example
     * // Update one ClinicPlan
     * const clinicPlan = await prisma.clinicPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicPlanUpdateArgs>(args: SelectSubset<T, ClinicPlanUpdateArgs<ExtArgs>>): Prisma__ClinicPlanClient<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicPlans.
     * @param {ClinicPlanDeleteManyArgs} args - Arguments to filter ClinicPlans to delete.
     * @example
     * // Delete a few ClinicPlans
     * const { count } = await prisma.clinicPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicPlanDeleteManyArgs>(args?: SelectSubset<T, ClinicPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicPlans
     * const clinicPlan = await prisma.clinicPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicPlanUpdateManyArgs>(args: SelectSubset<T, ClinicPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicPlans and returns the data updated in the database.
     * @param {ClinicPlanUpdateManyAndReturnArgs} args - Arguments to update many ClinicPlans.
     * @example
     * // Update many ClinicPlans
     * const clinicPlan = await prisma.clinicPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicPlans and only return the `id`
     * const clinicPlanWithIdOnly = await prisma.clinicPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicPlan.
     * @param {ClinicPlanUpsertArgs} args - Arguments to update or create a ClinicPlan.
     * @example
     * // Update or create a ClinicPlan
     * const clinicPlan = await prisma.clinicPlan.upsert({
     *   create: {
     *     // ... data to create a ClinicPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicPlan we want to update
     *   }
     * })
     */
    upsert<T extends ClinicPlanUpsertArgs>(args: SelectSubset<T, ClinicPlanUpsertArgs<ExtArgs>>): Prisma__ClinicPlanClient<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPlanCountArgs} args - Arguments to filter ClinicPlans to count.
     * @example
     * // Count the number of ClinicPlans
     * const count = await prisma.clinicPlan.count({
     *   where: {
     *     // ... the filter for the ClinicPlans we want to count
     *   }
     * })
    **/
    count<T extends ClinicPlanCountArgs>(
      args?: Subset<T, ClinicPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicPlanAggregateArgs>(args: Subset<T, ClinicPlanAggregateArgs>): Prisma.PrismaPromise<GetClinicPlanAggregateType<T>>

    /**
     * Group by ClinicPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicPlanGroupByArgs['orderBy'] }
        : { orderBy?: ClinicPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicPlan model
   */
  readonly fields: ClinicPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends ClinicPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, ClinicPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicPlan model
   */
  interface ClinicPlanFieldRefs {
    readonly id: FieldRef<"ClinicPlan", 'String'>
    readonly name: FieldRef<"ClinicPlan", 'String'>
    readonly tier: FieldRef<"ClinicPlan", 'PlanTier'>
    readonly description: FieldRef<"ClinicPlan", 'String'>
    readonly monthlyPrice: FieldRef<"ClinicPlan", 'Decimal'>
    readonly monthlyTxLimit: FieldRef<"ClinicPlan", 'Int'>
    readonly features: FieldRef<"ClinicPlan", 'Json'>
    readonly trialDays: FieldRef<"ClinicPlan", 'Int'>
    readonly requireCard: FieldRef<"ClinicPlan", 'Boolean'>
    readonly isActive: FieldRef<"ClinicPlan", 'Boolean'>
    readonly isPublic: FieldRef<"ClinicPlan", 'Boolean'>
    readonly createdAt: FieldRef<"ClinicPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"ClinicPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicPlan findUnique
   */
  export type ClinicPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicPlanInclude<ExtArgs> | null
    /**
     * Filter, which ClinicPlan to fetch.
     */
    where: ClinicPlanWhereUniqueInput
  }

  /**
   * ClinicPlan findUniqueOrThrow
   */
  export type ClinicPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicPlanInclude<ExtArgs> | null
    /**
     * Filter, which ClinicPlan to fetch.
     */
    where: ClinicPlanWhereUniqueInput
  }

  /**
   * ClinicPlan findFirst
   */
  export type ClinicPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicPlanInclude<ExtArgs> | null
    /**
     * Filter, which ClinicPlan to fetch.
     */
    where?: ClinicPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicPlans to fetch.
     */
    orderBy?: ClinicPlanOrderByWithRelationInput | ClinicPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicPlans.
     */
    cursor?: ClinicPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicPlans.
     */
    distinct?: ClinicPlanScalarFieldEnum | ClinicPlanScalarFieldEnum[]
  }

  /**
   * ClinicPlan findFirstOrThrow
   */
  export type ClinicPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicPlanInclude<ExtArgs> | null
    /**
     * Filter, which ClinicPlan to fetch.
     */
    where?: ClinicPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicPlans to fetch.
     */
    orderBy?: ClinicPlanOrderByWithRelationInput | ClinicPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicPlans.
     */
    cursor?: ClinicPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicPlans.
     */
    distinct?: ClinicPlanScalarFieldEnum | ClinicPlanScalarFieldEnum[]
  }

  /**
   * ClinicPlan findMany
   */
  export type ClinicPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicPlanInclude<ExtArgs> | null
    /**
     * Filter, which ClinicPlans to fetch.
     */
    where?: ClinicPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicPlans to fetch.
     */
    orderBy?: ClinicPlanOrderByWithRelationInput | ClinicPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicPlans.
     */
    cursor?: ClinicPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicPlans.
     */
    skip?: number
    distinct?: ClinicPlanScalarFieldEnum | ClinicPlanScalarFieldEnum[]
  }

  /**
   * ClinicPlan create
   */
  export type ClinicPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicPlan.
     */
    data: XOR<ClinicPlanCreateInput, ClinicPlanUncheckedCreateInput>
  }

  /**
   * ClinicPlan createMany
   */
  export type ClinicPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicPlans.
     */
    data: ClinicPlanCreateManyInput | ClinicPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicPlan createManyAndReturn
   */
  export type ClinicPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicPlans.
     */
    data: ClinicPlanCreateManyInput | ClinicPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicPlan update
   */
  export type ClinicPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicPlan.
     */
    data: XOR<ClinicPlanUpdateInput, ClinicPlanUncheckedUpdateInput>
    /**
     * Choose, which ClinicPlan to update.
     */
    where: ClinicPlanWhereUniqueInput
  }

  /**
   * ClinicPlan updateMany
   */
  export type ClinicPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicPlans.
     */
    data: XOR<ClinicPlanUpdateManyMutationInput, ClinicPlanUncheckedUpdateManyInput>
    /**
     * Filter which ClinicPlans to update
     */
    where?: ClinicPlanWhereInput
    /**
     * Limit how many ClinicPlans to update.
     */
    limit?: number
  }

  /**
   * ClinicPlan updateManyAndReturn
   */
  export type ClinicPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * The data used to update ClinicPlans.
     */
    data: XOR<ClinicPlanUpdateManyMutationInput, ClinicPlanUncheckedUpdateManyInput>
    /**
     * Filter which ClinicPlans to update
     */
    where?: ClinicPlanWhereInput
    /**
     * Limit how many ClinicPlans to update.
     */
    limit?: number
  }

  /**
   * ClinicPlan upsert
   */
  export type ClinicPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicPlan to update in case it exists.
     */
    where: ClinicPlanWhereUniqueInput
    /**
     * In case the ClinicPlan found by the `where` argument doesn't exist, create a new ClinicPlan with this data.
     */
    create: XOR<ClinicPlanCreateInput, ClinicPlanUncheckedCreateInput>
    /**
     * In case the ClinicPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicPlanUpdateInput, ClinicPlanUncheckedUpdateInput>
  }

  /**
   * ClinicPlan delete
   */
  export type ClinicPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicPlanInclude<ExtArgs> | null
    /**
     * Filter which ClinicPlan to delete.
     */
    where: ClinicPlanWhereUniqueInput
  }

  /**
   * ClinicPlan deleteMany
   */
  export type ClinicPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicPlans to delete
     */
    where?: ClinicPlanWhereInput
    /**
     * Limit how many ClinicPlans to delete.
     */
    limit?: number
  }

  /**
   * ClinicPlan.subscriptions
   */
  export type ClinicPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
    where?: ClinicSubscriptionWhereInput
    orderBy?: ClinicSubscriptionOrderByWithRelationInput | ClinicSubscriptionOrderByWithRelationInput[]
    cursor?: ClinicSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicSubscriptionScalarFieldEnum | ClinicSubscriptionScalarFieldEnum[]
  }

  /**
   * ClinicPlan without action
   */
  export type ClinicPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPlan
     */
    select?: ClinicPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPlan
     */
    omit?: ClinicPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicPlanInclude<ExtArgs> | null
  }


  /**
   * Model ClinicAddOn
   */

  export type AggregateClinicAddOn = {
    _count: ClinicAddOnCountAggregateOutputType | null
    _avg: ClinicAddOnAvgAggregateOutputType | null
    _sum: ClinicAddOnSumAggregateOutputType | null
    _min: ClinicAddOnMinAggregateOutputType | null
    _max: ClinicAddOnMaxAggregateOutputType | null
  }

  export type ClinicAddOnAvgAggregateOutputType = {
    monthlyPrice: Decimal | null
    quantity: number | null
  }

  export type ClinicAddOnSumAggregateOutputType = {
    monthlyPrice: Decimal | null
    quantity: number | null
  }

  export type ClinicAddOnMinAggregateOutputType = {
    id: string | null
    type: $Enums.AddOnType | null
    name: string | null
    description: string | null
    monthlyPrice: Decimal | null
    quantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicAddOnMaxAggregateOutputType = {
    id: string | null
    type: $Enums.AddOnType | null
    name: string | null
    description: string | null
    monthlyPrice: Decimal | null
    quantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicAddOnCountAggregateOutputType = {
    id: number
    type: number
    name: number
    description: number
    monthlyPrice: number
    quantity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicAddOnAvgAggregateInputType = {
    monthlyPrice?: true
    quantity?: true
  }

  export type ClinicAddOnSumAggregateInputType = {
    monthlyPrice?: true
    quantity?: true
  }

  export type ClinicAddOnMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    monthlyPrice?: true
    quantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicAddOnMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    monthlyPrice?: true
    quantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicAddOnCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    monthlyPrice?: true
    quantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicAddOnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicAddOn to aggregate.
     */
    where?: ClinicAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicAddOns to fetch.
     */
    orderBy?: ClinicAddOnOrderByWithRelationInput | ClinicAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicAddOns
    **/
    _count?: true | ClinicAddOnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClinicAddOnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClinicAddOnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicAddOnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicAddOnMaxAggregateInputType
  }

  export type GetClinicAddOnAggregateType<T extends ClinicAddOnAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicAddOn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicAddOn[P]>
      : GetScalarType<T[P], AggregateClinicAddOn[P]>
  }




  export type ClinicAddOnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicAddOnWhereInput
    orderBy?: ClinicAddOnOrderByWithAggregationInput | ClinicAddOnOrderByWithAggregationInput[]
    by: ClinicAddOnScalarFieldEnum[] | ClinicAddOnScalarFieldEnum
    having?: ClinicAddOnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicAddOnCountAggregateInputType | true
    _avg?: ClinicAddOnAvgAggregateInputType
    _sum?: ClinicAddOnSumAggregateInputType
    _min?: ClinicAddOnMinAggregateInputType
    _max?: ClinicAddOnMaxAggregateInputType
  }

  export type ClinicAddOnGroupByOutputType = {
    id: string
    type: $Enums.AddOnType
    name: string
    description: string | null
    monthlyPrice: Decimal
    quantity: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClinicAddOnCountAggregateOutputType | null
    _avg: ClinicAddOnAvgAggregateOutputType | null
    _sum: ClinicAddOnSumAggregateOutputType | null
    _min: ClinicAddOnMinAggregateOutputType | null
    _max: ClinicAddOnMaxAggregateOutputType | null
  }

  type GetClinicAddOnGroupByPayload<T extends ClinicAddOnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicAddOnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicAddOnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicAddOnGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicAddOnGroupByOutputType[P]>
        }
      >
    >


  export type ClinicAddOnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    monthlyPrice?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | ClinicAddOn$subscriptionsArgs<ExtArgs>
    _count?: boolean | ClinicAddOnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicAddOn"]>

  export type ClinicAddOnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    monthlyPrice?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["clinicAddOn"]>

  export type ClinicAddOnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    monthlyPrice?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["clinicAddOn"]>

  export type ClinicAddOnSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    monthlyPrice?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicAddOnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "description" | "monthlyPrice" | "quantity" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["clinicAddOn"]>
  export type ClinicAddOnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | ClinicAddOn$subscriptionsArgs<ExtArgs>
    _count?: boolean | ClinicAddOnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClinicAddOnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClinicAddOnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClinicAddOnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicAddOn"
    objects: {
      subscriptions: Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.AddOnType
      name: string
      description: string | null
      monthlyPrice: Prisma.Decimal
      quantity: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinicAddOn"]>
    composites: {}
  }

  type ClinicAddOnGetPayload<S extends boolean | null | undefined | ClinicAddOnDefaultArgs> = $Result.GetResult<Prisma.$ClinicAddOnPayload, S>

  type ClinicAddOnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicAddOnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicAddOnCountAggregateInputType | true
    }

  export interface ClinicAddOnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicAddOn'], meta: { name: 'ClinicAddOn' } }
    /**
     * Find zero or one ClinicAddOn that matches the filter.
     * @param {ClinicAddOnFindUniqueArgs} args - Arguments to find a ClinicAddOn
     * @example
     * // Get one ClinicAddOn
     * const clinicAddOn = await prisma.clinicAddOn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicAddOnFindUniqueArgs>(args: SelectSubset<T, ClinicAddOnFindUniqueArgs<ExtArgs>>): Prisma__ClinicAddOnClient<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicAddOn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicAddOnFindUniqueOrThrowArgs} args - Arguments to find a ClinicAddOn
     * @example
     * // Get one ClinicAddOn
     * const clinicAddOn = await prisma.clinicAddOn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicAddOnFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicAddOnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicAddOnClient<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicAddOn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnFindFirstArgs} args - Arguments to find a ClinicAddOn
     * @example
     * // Get one ClinicAddOn
     * const clinicAddOn = await prisma.clinicAddOn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicAddOnFindFirstArgs>(args?: SelectSubset<T, ClinicAddOnFindFirstArgs<ExtArgs>>): Prisma__ClinicAddOnClient<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicAddOn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnFindFirstOrThrowArgs} args - Arguments to find a ClinicAddOn
     * @example
     * // Get one ClinicAddOn
     * const clinicAddOn = await prisma.clinicAddOn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicAddOnFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicAddOnFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicAddOnClient<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicAddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicAddOns
     * const clinicAddOns = await prisma.clinicAddOn.findMany()
     * 
     * // Get first 10 ClinicAddOns
     * const clinicAddOns = await prisma.clinicAddOn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicAddOnWithIdOnly = await prisma.clinicAddOn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicAddOnFindManyArgs>(args?: SelectSubset<T, ClinicAddOnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicAddOn.
     * @param {ClinicAddOnCreateArgs} args - Arguments to create a ClinicAddOn.
     * @example
     * // Create one ClinicAddOn
     * const ClinicAddOn = await prisma.clinicAddOn.create({
     *   data: {
     *     // ... data to create a ClinicAddOn
     *   }
     * })
     * 
     */
    create<T extends ClinicAddOnCreateArgs>(args: SelectSubset<T, ClinicAddOnCreateArgs<ExtArgs>>): Prisma__ClinicAddOnClient<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicAddOns.
     * @param {ClinicAddOnCreateManyArgs} args - Arguments to create many ClinicAddOns.
     * @example
     * // Create many ClinicAddOns
     * const clinicAddOn = await prisma.clinicAddOn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicAddOnCreateManyArgs>(args?: SelectSubset<T, ClinicAddOnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicAddOns and returns the data saved in the database.
     * @param {ClinicAddOnCreateManyAndReturnArgs} args - Arguments to create many ClinicAddOns.
     * @example
     * // Create many ClinicAddOns
     * const clinicAddOn = await prisma.clinicAddOn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicAddOns and only return the `id`
     * const clinicAddOnWithIdOnly = await prisma.clinicAddOn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicAddOnCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicAddOnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicAddOn.
     * @param {ClinicAddOnDeleteArgs} args - Arguments to delete one ClinicAddOn.
     * @example
     * // Delete one ClinicAddOn
     * const ClinicAddOn = await prisma.clinicAddOn.delete({
     *   where: {
     *     // ... filter to delete one ClinicAddOn
     *   }
     * })
     * 
     */
    delete<T extends ClinicAddOnDeleteArgs>(args: SelectSubset<T, ClinicAddOnDeleteArgs<ExtArgs>>): Prisma__ClinicAddOnClient<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicAddOn.
     * @param {ClinicAddOnUpdateArgs} args - Arguments to update one ClinicAddOn.
     * @example
     * // Update one ClinicAddOn
     * const clinicAddOn = await prisma.clinicAddOn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicAddOnUpdateArgs>(args: SelectSubset<T, ClinicAddOnUpdateArgs<ExtArgs>>): Prisma__ClinicAddOnClient<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicAddOns.
     * @param {ClinicAddOnDeleteManyArgs} args - Arguments to filter ClinicAddOns to delete.
     * @example
     * // Delete a few ClinicAddOns
     * const { count } = await prisma.clinicAddOn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicAddOnDeleteManyArgs>(args?: SelectSubset<T, ClinicAddOnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicAddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicAddOns
     * const clinicAddOn = await prisma.clinicAddOn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicAddOnUpdateManyArgs>(args: SelectSubset<T, ClinicAddOnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicAddOns and returns the data updated in the database.
     * @param {ClinicAddOnUpdateManyAndReturnArgs} args - Arguments to update many ClinicAddOns.
     * @example
     * // Update many ClinicAddOns
     * const clinicAddOn = await prisma.clinicAddOn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicAddOns and only return the `id`
     * const clinicAddOnWithIdOnly = await prisma.clinicAddOn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicAddOnUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicAddOnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicAddOn.
     * @param {ClinicAddOnUpsertArgs} args - Arguments to update or create a ClinicAddOn.
     * @example
     * // Update or create a ClinicAddOn
     * const clinicAddOn = await prisma.clinicAddOn.upsert({
     *   create: {
     *     // ... data to create a ClinicAddOn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicAddOn we want to update
     *   }
     * })
     */
    upsert<T extends ClinicAddOnUpsertArgs>(args: SelectSubset<T, ClinicAddOnUpsertArgs<ExtArgs>>): Prisma__ClinicAddOnClient<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicAddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnCountArgs} args - Arguments to filter ClinicAddOns to count.
     * @example
     * // Count the number of ClinicAddOns
     * const count = await prisma.clinicAddOn.count({
     *   where: {
     *     // ... the filter for the ClinicAddOns we want to count
     *   }
     * })
    **/
    count<T extends ClinicAddOnCountArgs>(
      args?: Subset<T, ClinicAddOnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicAddOnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicAddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicAddOnAggregateArgs>(args: Subset<T, ClinicAddOnAggregateArgs>): Prisma.PrismaPromise<GetClinicAddOnAggregateType<T>>

    /**
     * Group by ClinicAddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicAddOnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicAddOnGroupByArgs['orderBy'] }
        : { orderBy?: ClinicAddOnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicAddOnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicAddOnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicAddOn model
   */
  readonly fields: ClinicAddOnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicAddOn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicAddOnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends ClinicAddOn$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, ClinicAddOn$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicAddOn model
   */
  interface ClinicAddOnFieldRefs {
    readonly id: FieldRef<"ClinicAddOn", 'String'>
    readonly type: FieldRef<"ClinicAddOn", 'AddOnType'>
    readonly name: FieldRef<"ClinicAddOn", 'String'>
    readonly description: FieldRef<"ClinicAddOn", 'String'>
    readonly monthlyPrice: FieldRef<"ClinicAddOn", 'Decimal'>
    readonly quantity: FieldRef<"ClinicAddOn", 'Int'>
    readonly isActive: FieldRef<"ClinicAddOn", 'Boolean'>
    readonly createdAt: FieldRef<"ClinicAddOn", 'DateTime'>
    readonly updatedAt: FieldRef<"ClinicAddOn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicAddOn findUnique
   */
  export type ClinicAddOnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ClinicAddOn to fetch.
     */
    where: ClinicAddOnWhereUniqueInput
  }

  /**
   * ClinicAddOn findUniqueOrThrow
   */
  export type ClinicAddOnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ClinicAddOn to fetch.
     */
    where: ClinicAddOnWhereUniqueInput
  }

  /**
   * ClinicAddOn findFirst
   */
  export type ClinicAddOnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ClinicAddOn to fetch.
     */
    where?: ClinicAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicAddOns to fetch.
     */
    orderBy?: ClinicAddOnOrderByWithRelationInput | ClinicAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicAddOns.
     */
    cursor?: ClinicAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicAddOns.
     */
    distinct?: ClinicAddOnScalarFieldEnum | ClinicAddOnScalarFieldEnum[]
  }

  /**
   * ClinicAddOn findFirstOrThrow
   */
  export type ClinicAddOnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ClinicAddOn to fetch.
     */
    where?: ClinicAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicAddOns to fetch.
     */
    orderBy?: ClinicAddOnOrderByWithRelationInput | ClinicAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicAddOns.
     */
    cursor?: ClinicAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicAddOns.
     */
    distinct?: ClinicAddOnScalarFieldEnum | ClinicAddOnScalarFieldEnum[]
  }

  /**
   * ClinicAddOn findMany
   */
  export type ClinicAddOnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ClinicAddOns to fetch.
     */
    where?: ClinicAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicAddOns to fetch.
     */
    orderBy?: ClinicAddOnOrderByWithRelationInput | ClinicAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicAddOns.
     */
    cursor?: ClinicAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicAddOns.
     */
    skip?: number
    distinct?: ClinicAddOnScalarFieldEnum | ClinicAddOnScalarFieldEnum[]
  }

  /**
   * ClinicAddOn create
   */
  export type ClinicAddOnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicAddOn.
     */
    data: XOR<ClinicAddOnCreateInput, ClinicAddOnUncheckedCreateInput>
  }

  /**
   * ClinicAddOn createMany
   */
  export type ClinicAddOnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicAddOns.
     */
    data: ClinicAddOnCreateManyInput | ClinicAddOnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicAddOn createManyAndReturn
   */
  export type ClinicAddOnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicAddOns.
     */
    data: ClinicAddOnCreateManyInput | ClinicAddOnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicAddOn update
   */
  export type ClinicAddOnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicAddOn.
     */
    data: XOR<ClinicAddOnUpdateInput, ClinicAddOnUncheckedUpdateInput>
    /**
     * Choose, which ClinicAddOn to update.
     */
    where: ClinicAddOnWhereUniqueInput
  }

  /**
   * ClinicAddOn updateMany
   */
  export type ClinicAddOnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicAddOns.
     */
    data: XOR<ClinicAddOnUpdateManyMutationInput, ClinicAddOnUncheckedUpdateManyInput>
    /**
     * Filter which ClinicAddOns to update
     */
    where?: ClinicAddOnWhereInput
    /**
     * Limit how many ClinicAddOns to update.
     */
    limit?: number
  }

  /**
   * ClinicAddOn updateManyAndReturn
   */
  export type ClinicAddOnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * The data used to update ClinicAddOns.
     */
    data: XOR<ClinicAddOnUpdateManyMutationInput, ClinicAddOnUncheckedUpdateManyInput>
    /**
     * Filter which ClinicAddOns to update
     */
    where?: ClinicAddOnWhereInput
    /**
     * Limit how many ClinicAddOns to update.
     */
    limit?: number
  }

  /**
   * ClinicAddOn upsert
   */
  export type ClinicAddOnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicAddOn to update in case it exists.
     */
    where: ClinicAddOnWhereUniqueInput
    /**
     * In case the ClinicAddOn found by the `where` argument doesn't exist, create a new ClinicAddOn with this data.
     */
    create: XOR<ClinicAddOnCreateInput, ClinicAddOnUncheckedCreateInput>
    /**
     * In case the ClinicAddOn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicAddOnUpdateInput, ClinicAddOnUncheckedUpdateInput>
  }

  /**
   * ClinicAddOn delete
   */
  export type ClinicAddOnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnInclude<ExtArgs> | null
    /**
     * Filter which ClinicAddOn to delete.
     */
    where: ClinicAddOnWhereUniqueInput
  }

  /**
   * ClinicAddOn deleteMany
   */
  export type ClinicAddOnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicAddOns to delete
     */
    where?: ClinicAddOnWhereInput
    /**
     * Limit how many ClinicAddOns to delete.
     */
    limit?: number
  }

  /**
   * ClinicAddOn.subscriptions
   */
  export type ClinicAddOn$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
    where?: ClinicAddOnSubscriptionWhereInput
    orderBy?: ClinicAddOnSubscriptionOrderByWithRelationInput | ClinicAddOnSubscriptionOrderByWithRelationInput[]
    cursor?: ClinicAddOnSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicAddOnSubscriptionScalarFieldEnum | ClinicAddOnSubscriptionScalarFieldEnum[]
  }

  /**
   * ClinicAddOn without action
   */
  export type ClinicAddOnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOn
     */
    select?: ClinicAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOn
     */
    omit?: ClinicAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnInclude<ExtArgs> | null
  }


  /**
   * Model ClinicSubscription
   */

  export type AggregateClinicSubscription = {
    _count: ClinicSubscriptionCountAggregateOutputType | null
    _avg: ClinicSubscriptionAvgAggregateOutputType | null
    _sum: ClinicSubscriptionSumAggregateOutputType | null
    _min: ClinicSubscriptionMinAggregateOutputType | null
    _max: ClinicSubscriptionMaxAggregateOutputType | null
  }

  export type ClinicSubscriptionAvgAggregateOutputType = {
    currentDoctorsCount: number | null
    currentPatientsCount: number | null
  }

  export type ClinicSubscriptionSumAggregateOutputType = {
    currentDoctorsCount: number | null
    currentPatientsCount: number | null
  }

  export type ClinicSubscriptionMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    canceledAt: Date | null
    cancelReason: string | null
    currentDoctorsCount: number | null
    currentPatientsCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicSubscriptionMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    canceledAt: Date | null
    cancelReason: string | null
    currentDoctorsCount: number | null
    currentPatientsCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicSubscriptionCountAggregateOutputType = {
    id: number
    clinicId: number
    planId: number
    status: number
    startDate: number
    trialEndsAt: number
    currentPeriodStart: number
    currentPeriodEnd: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    canceledAt: number
    cancelReason: number
    currentDoctorsCount: number
    currentPatientsCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicSubscriptionAvgAggregateInputType = {
    currentDoctorsCount?: true
    currentPatientsCount?: true
  }

  export type ClinicSubscriptionSumAggregateInputType = {
    currentDoctorsCount?: true
    currentPatientsCount?: true
  }

  export type ClinicSubscriptionMinAggregateInputType = {
    id?: true
    clinicId?: true
    planId?: true
    status?: true
    startDate?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    canceledAt?: true
    cancelReason?: true
    currentDoctorsCount?: true
    currentPatientsCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicSubscriptionMaxAggregateInputType = {
    id?: true
    clinicId?: true
    planId?: true
    status?: true
    startDate?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    canceledAt?: true
    cancelReason?: true
    currentDoctorsCount?: true
    currentPatientsCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicSubscriptionCountAggregateInputType = {
    id?: true
    clinicId?: true
    planId?: true
    status?: true
    startDate?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    canceledAt?: true
    cancelReason?: true
    currentDoctorsCount?: true
    currentPatientsCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicSubscription to aggregate.
     */
    where?: ClinicSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicSubscriptions to fetch.
     */
    orderBy?: ClinicSubscriptionOrderByWithRelationInput | ClinicSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicSubscriptions
    **/
    _count?: true | ClinicSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClinicSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClinicSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicSubscriptionMaxAggregateInputType
  }

  export type GetClinicSubscriptionAggregateType<T extends ClinicSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicSubscription[P]>
      : GetScalarType<T[P], AggregateClinicSubscription[P]>
  }




  export type ClinicSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicSubscriptionWhereInput
    orderBy?: ClinicSubscriptionOrderByWithAggregationInput | ClinicSubscriptionOrderByWithAggregationInput[]
    by: ClinicSubscriptionScalarFieldEnum[] | ClinicSubscriptionScalarFieldEnum
    having?: ClinicSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicSubscriptionCountAggregateInputType | true
    _avg?: ClinicSubscriptionAvgAggregateInputType
    _sum?: ClinicSubscriptionSumAggregateInputType
    _min?: ClinicSubscriptionMinAggregateInputType
    _max?: ClinicSubscriptionMaxAggregateInputType
  }

  export type ClinicSubscriptionGroupByOutputType = {
    id: string
    clinicId: string
    planId: string
    status: $Enums.SubscriptionStatus
    startDate: Date
    trialEndsAt: Date
    currentPeriodStart: Date
    currentPeriodEnd: Date
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    canceledAt: Date | null
    cancelReason: string | null
    currentDoctorsCount: number
    currentPatientsCount: number
    createdAt: Date
    updatedAt: Date
    _count: ClinicSubscriptionCountAggregateOutputType | null
    _avg: ClinicSubscriptionAvgAggregateOutputType | null
    _sum: ClinicSubscriptionSumAggregateOutputType | null
    _min: ClinicSubscriptionMinAggregateOutputType | null
    _max: ClinicSubscriptionMaxAggregateOutputType | null
  }

  type GetClinicSubscriptionGroupByPayload<T extends ClinicSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type ClinicSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    planId?: boolean
    status?: boolean
    startDate?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    canceledAt?: boolean
    cancelReason?: boolean
    currentDoctorsCount?: boolean
    currentPatientsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    plan?: boolean | ClinicPlanDefaultArgs<ExtArgs>
    addOns?: boolean | ClinicSubscription$addOnsArgs<ExtArgs>
    _count?: boolean | ClinicSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicSubscription"]>

  export type ClinicSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    planId?: boolean
    status?: boolean
    startDate?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    canceledAt?: boolean
    cancelReason?: boolean
    currentDoctorsCount?: boolean
    currentPatientsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    plan?: boolean | ClinicPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicSubscription"]>

  export type ClinicSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    planId?: boolean
    status?: boolean
    startDate?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    canceledAt?: boolean
    cancelReason?: boolean
    currentDoctorsCount?: boolean
    currentPatientsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    plan?: boolean | ClinicPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicSubscription"]>

  export type ClinicSubscriptionSelectScalar = {
    id?: boolean
    clinicId?: boolean
    planId?: boolean
    status?: boolean
    startDate?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    canceledAt?: boolean
    cancelReason?: boolean
    currentDoctorsCount?: boolean
    currentPatientsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "planId" | "status" | "startDate" | "trialEndsAt" | "currentPeriodStart" | "currentPeriodEnd" | "stripeCustomerId" | "stripeSubscriptionId" | "canceledAt" | "cancelReason" | "currentDoctorsCount" | "currentPatientsCount" | "createdAt" | "updatedAt", ExtArgs["result"]["clinicSubscription"]>
  export type ClinicSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    plan?: boolean | ClinicPlanDefaultArgs<ExtArgs>
    addOns?: boolean | ClinicSubscription$addOnsArgs<ExtArgs>
    _count?: boolean | ClinicSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClinicSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    plan?: boolean | ClinicPlanDefaultArgs<ExtArgs>
  }
  export type ClinicSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    plan?: boolean | ClinicPlanDefaultArgs<ExtArgs>
  }

  export type $ClinicSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicSubscription"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      plan: Prisma.$ClinicPlanPayload<ExtArgs>
      addOns: Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      planId: string
      status: $Enums.SubscriptionStatus
      startDate: Date
      trialEndsAt: Date
      currentPeriodStart: Date
      currentPeriodEnd: Date
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      canceledAt: Date | null
      cancelReason: string | null
      currentDoctorsCount: number
      currentPatientsCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinicSubscription"]>
    composites: {}
  }

  type ClinicSubscriptionGetPayload<S extends boolean | null | undefined | ClinicSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$ClinicSubscriptionPayload, S>

  type ClinicSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicSubscriptionCountAggregateInputType | true
    }

  export interface ClinicSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicSubscription'], meta: { name: 'ClinicSubscription' } }
    /**
     * Find zero or one ClinicSubscription that matches the filter.
     * @param {ClinicSubscriptionFindUniqueArgs} args - Arguments to find a ClinicSubscription
     * @example
     * // Get one ClinicSubscription
     * const clinicSubscription = await prisma.clinicSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicSubscriptionFindUniqueArgs>(args: SelectSubset<T, ClinicSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__ClinicSubscriptionClient<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a ClinicSubscription
     * @example
     * // Get one ClinicSubscription
     * const clinicSubscription = await prisma.clinicSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicSubscriptionClient<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicSubscriptionFindFirstArgs} args - Arguments to find a ClinicSubscription
     * @example
     * // Get one ClinicSubscription
     * const clinicSubscription = await prisma.clinicSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicSubscriptionFindFirstArgs>(args?: SelectSubset<T, ClinicSubscriptionFindFirstArgs<ExtArgs>>): Prisma__ClinicSubscriptionClient<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicSubscriptionFindFirstOrThrowArgs} args - Arguments to find a ClinicSubscription
     * @example
     * // Get one ClinicSubscription
     * const clinicSubscription = await prisma.clinicSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicSubscriptionClient<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicSubscriptions
     * const clinicSubscriptions = await prisma.clinicSubscription.findMany()
     * 
     * // Get first 10 ClinicSubscriptions
     * const clinicSubscriptions = await prisma.clinicSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicSubscriptionWithIdOnly = await prisma.clinicSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicSubscriptionFindManyArgs>(args?: SelectSubset<T, ClinicSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicSubscription.
     * @param {ClinicSubscriptionCreateArgs} args - Arguments to create a ClinicSubscription.
     * @example
     * // Create one ClinicSubscription
     * const ClinicSubscription = await prisma.clinicSubscription.create({
     *   data: {
     *     // ... data to create a ClinicSubscription
     *   }
     * })
     * 
     */
    create<T extends ClinicSubscriptionCreateArgs>(args: SelectSubset<T, ClinicSubscriptionCreateArgs<ExtArgs>>): Prisma__ClinicSubscriptionClient<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicSubscriptions.
     * @param {ClinicSubscriptionCreateManyArgs} args - Arguments to create many ClinicSubscriptions.
     * @example
     * // Create many ClinicSubscriptions
     * const clinicSubscription = await prisma.clinicSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicSubscriptionCreateManyArgs>(args?: SelectSubset<T, ClinicSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicSubscriptions and returns the data saved in the database.
     * @param {ClinicSubscriptionCreateManyAndReturnArgs} args - Arguments to create many ClinicSubscriptions.
     * @example
     * // Create many ClinicSubscriptions
     * const clinicSubscription = await prisma.clinicSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicSubscriptions and only return the `id`
     * const clinicSubscriptionWithIdOnly = await prisma.clinicSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicSubscription.
     * @param {ClinicSubscriptionDeleteArgs} args - Arguments to delete one ClinicSubscription.
     * @example
     * // Delete one ClinicSubscription
     * const ClinicSubscription = await prisma.clinicSubscription.delete({
     *   where: {
     *     // ... filter to delete one ClinicSubscription
     *   }
     * })
     * 
     */
    delete<T extends ClinicSubscriptionDeleteArgs>(args: SelectSubset<T, ClinicSubscriptionDeleteArgs<ExtArgs>>): Prisma__ClinicSubscriptionClient<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicSubscription.
     * @param {ClinicSubscriptionUpdateArgs} args - Arguments to update one ClinicSubscription.
     * @example
     * // Update one ClinicSubscription
     * const clinicSubscription = await prisma.clinicSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicSubscriptionUpdateArgs>(args: SelectSubset<T, ClinicSubscriptionUpdateArgs<ExtArgs>>): Prisma__ClinicSubscriptionClient<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicSubscriptions.
     * @param {ClinicSubscriptionDeleteManyArgs} args - Arguments to filter ClinicSubscriptions to delete.
     * @example
     * // Delete a few ClinicSubscriptions
     * const { count } = await prisma.clinicSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicSubscriptionDeleteManyArgs>(args?: SelectSubset<T, ClinicSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicSubscriptions
     * const clinicSubscription = await prisma.clinicSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicSubscriptionUpdateManyArgs>(args: SelectSubset<T, ClinicSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicSubscriptions and returns the data updated in the database.
     * @param {ClinicSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many ClinicSubscriptions.
     * @example
     * // Update many ClinicSubscriptions
     * const clinicSubscription = await prisma.clinicSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicSubscriptions and only return the `id`
     * const clinicSubscriptionWithIdOnly = await prisma.clinicSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicSubscription.
     * @param {ClinicSubscriptionUpsertArgs} args - Arguments to update or create a ClinicSubscription.
     * @example
     * // Update or create a ClinicSubscription
     * const clinicSubscription = await prisma.clinicSubscription.upsert({
     *   create: {
     *     // ... data to create a ClinicSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicSubscription we want to update
     *   }
     * })
     */
    upsert<T extends ClinicSubscriptionUpsertArgs>(args: SelectSubset<T, ClinicSubscriptionUpsertArgs<ExtArgs>>): Prisma__ClinicSubscriptionClient<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicSubscriptionCountArgs} args - Arguments to filter ClinicSubscriptions to count.
     * @example
     * // Count the number of ClinicSubscriptions
     * const count = await prisma.clinicSubscription.count({
     *   where: {
     *     // ... the filter for the ClinicSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends ClinicSubscriptionCountArgs>(
      args?: Subset<T, ClinicSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicSubscriptionAggregateArgs>(args: Subset<T, ClinicSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetClinicSubscriptionAggregateType<T>>

    /**
     * Group by ClinicSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: ClinicSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicSubscription model
   */
  readonly fields: ClinicSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends ClinicPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicPlanDefaultArgs<ExtArgs>>): Prisma__ClinicPlanClient<$Result.GetResult<Prisma.$ClinicPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addOns<T extends ClinicSubscription$addOnsArgs<ExtArgs> = {}>(args?: Subset<T, ClinicSubscription$addOnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicSubscription model
   */
  interface ClinicSubscriptionFieldRefs {
    readonly id: FieldRef<"ClinicSubscription", 'String'>
    readonly clinicId: FieldRef<"ClinicSubscription", 'String'>
    readonly planId: FieldRef<"ClinicSubscription", 'String'>
    readonly status: FieldRef<"ClinicSubscription", 'SubscriptionStatus'>
    readonly startDate: FieldRef<"ClinicSubscription", 'DateTime'>
    readonly trialEndsAt: FieldRef<"ClinicSubscription", 'DateTime'>
    readonly currentPeriodStart: FieldRef<"ClinicSubscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"ClinicSubscription", 'DateTime'>
    readonly stripeCustomerId: FieldRef<"ClinicSubscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"ClinicSubscription", 'String'>
    readonly canceledAt: FieldRef<"ClinicSubscription", 'DateTime'>
    readonly cancelReason: FieldRef<"ClinicSubscription", 'String'>
    readonly currentDoctorsCount: FieldRef<"ClinicSubscription", 'Int'>
    readonly currentPatientsCount: FieldRef<"ClinicSubscription", 'Int'>
    readonly createdAt: FieldRef<"ClinicSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"ClinicSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicSubscription findUnique
   */
  export type ClinicSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClinicSubscription to fetch.
     */
    where: ClinicSubscriptionWhereUniqueInput
  }

  /**
   * ClinicSubscription findUniqueOrThrow
   */
  export type ClinicSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClinicSubscription to fetch.
     */
    where: ClinicSubscriptionWhereUniqueInput
  }

  /**
   * ClinicSubscription findFirst
   */
  export type ClinicSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClinicSubscription to fetch.
     */
    where?: ClinicSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicSubscriptions to fetch.
     */
    orderBy?: ClinicSubscriptionOrderByWithRelationInput | ClinicSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicSubscriptions.
     */
    cursor?: ClinicSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicSubscriptions.
     */
    distinct?: ClinicSubscriptionScalarFieldEnum | ClinicSubscriptionScalarFieldEnum[]
  }

  /**
   * ClinicSubscription findFirstOrThrow
   */
  export type ClinicSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClinicSubscription to fetch.
     */
    where?: ClinicSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicSubscriptions to fetch.
     */
    orderBy?: ClinicSubscriptionOrderByWithRelationInput | ClinicSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicSubscriptions.
     */
    cursor?: ClinicSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicSubscriptions.
     */
    distinct?: ClinicSubscriptionScalarFieldEnum | ClinicSubscriptionScalarFieldEnum[]
  }

  /**
   * ClinicSubscription findMany
   */
  export type ClinicSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClinicSubscriptions to fetch.
     */
    where?: ClinicSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicSubscriptions to fetch.
     */
    orderBy?: ClinicSubscriptionOrderByWithRelationInput | ClinicSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicSubscriptions.
     */
    cursor?: ClinicSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicSubscriptions.
     */
    skip?: number
    distinct?: ClinicSubscriptionScalarFieldEnum | ClinicSubscriptionScalarFieldEnum[]
  }

  /**
   * ClinicSubscription create
   */
  export type ClinicSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicSubscription.
     */
    data: XOR<ClinicSubscriptionCreateInput, ClinicSubscriptionUncheckedCreateInput>
  }

  /**
   * ClinicSubscription createMany
   */
  export type ClinicSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicSubscriptions.
     */
    data: ClinicSubscriptionCreateManyInput | ClinicSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicSubscription createManyAndReturn
   */
  export type ClinicSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicSubscriptions.
     */
    data: ClinicSubscriptionCreateManyInput | ClinicSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicSubscription update
   */
  export type ClinicSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicSubscription.
     */
    data: XOR<ClinicSubscriptionUpdateInput, ClinicSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which ClinicSubscription to update.
     */
    where: ClinicSubscriptionWhereUniqueInput
  }

  /**
   * ClinicSubscription updateMany
   */
  export type ClinicSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicSubscriptions.
     */
    data: XOR<ClinicSubscriptionUpdateManyMutationInput, ClinicSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which ClinicSubscriptions to update
     */
    where?: ClinicSubscriptionWhereInput
    /**
     * Limit how many ClinicSubscriptions to update.
     */
    limit?: number
  }

  /**
   * ClinicSubscription updateManyAndReturn
   */
  export type ClinicSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update ClinicSubscriptions.
     */
    data: XOR<ClinicSubscriptionUpdateManyMutationInput, ClinicSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which ClinicSubscriptions to update
     */
    where?: ClinicSubscriptionWhereInput
    /**
     * Limit how many ClinicSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicSubscription upsert
   */
  export type ClinicSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicSubscription to update in case it exists.
     */
    where: ClinicSubscriptionWhereUniqueInput
    /**
     * In case the ClinicSubscription found by the `where` argument doesn't exist, create a new ClinicSubscription with this data.
     */
    create: XOR<ClinicSubscriptionCreateInput, ClinicSubscriptionUncheckedCreateInput>
    /**
     * In case the ClinicSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicSubscriptionUpdateInput, ClinicSubscriptionUncheckedUpdateInput>
  }

  /**
   * ClinicSubscription delete
   */
  export type ClinicSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which ClinicSubscription to delete.
     */
    where: ClinicSubscriptionWhereUniqueInput
  }

  /**
   * ClinicSubscription deleteMany
   */
  export type ClinicSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicSubscriptions to delete
     */
    where?: ClinicSubscriptionWhereInput
    /**
     * Limit how many ClinicSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * ClinicSubscription.addOns
   */
  export type ClinicSubscription$addOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
    where?: ClinicAddOnSubscriptionWhereInput
    orderBy?: ClinicAddOnSubscriptionOrderByWithRelationInput | ClinicAddOnSubscriptionOrderByWithRelationInput[]
    cursor?: ClinicAddOnSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicAddOnSubscriptionScalarFieldEnum | ClinicAddOnSubscriptionScalarFieldEnum[]
  }

  /**
   * ClinicSubscription without action
   */
  export type ClinicSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicSubscription
     */
    select?: ClinicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicSubscription
     */
    omit?: ClinicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model ClinicAddOnSubscription
   */

  export type AggregateClinicAddOnSubscription = {
    _count: ClinicAddOnSubscriptionCountAggregateOutputType | null
    _avg: ClinicAddOnSubscriptionAvgAggregateOutputType | null
    _sum: ClinicAddOnSubscriptionSumAggregateOutputType | null
    _min: ClinicAddOnSubscriptionMinAggregateOutputType | null
    _max: ClinicAddOnSubscriptionMaxAggregateOutputType | null
  }

  export type ClinicAddOnSubscriptionAvgAggregateOutputType = {
    quantity: number | null
  }

  export type ClinicAddOnSubscriptionSumAggregateOutputType = {
    quantity: number | null
  }

  export type ClinicAddOnSubscriptionMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    addOnId: string | null
    quantity: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicAddOnSubscriptionMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    addOnId: string | null
    quantity: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicAddOnSubscriptionCountAggregateOutputType = {
    id: number
    subscriptionId: number
    addOnId: number
    quantity: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicAddOnSubscriptionAvgAggregateInputType = {
    quantity?: true
  }

  export type ClinicAddOnSubscriptionSumAggregateInputType = {
    quantity?: true
  }

  export type ClinicAddOnSubscriptionMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    addOnId?: true
    quantity?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicAddOnSubscriptionMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    addOnId?: true
    quantity?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicAddOnSubscriptionCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    addOnId?: true
    quantity?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicAddOnSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicAddOnSubscription to aggregate.
     */
    where?: ClinicAddOnSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicAddOnSubscriptions to fetch.
     */
    orderBy?: ClinicAddOnSubscriptionOrderByWithRelationInput | ClinicAddOnSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicAddOnSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicAddOnSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicAddOnSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicAddOnSubscriptions
    **/
    _count?: true | ClinicAddOnSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClinicAddOnSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClinicAddOnSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicAddOnSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicAddOnSubscriptionMaxAggregateInputType
  }

  export type GetClinicAddOnSubscriptionAggregateType<T extends ClinicAddOnSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicAddOnSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicAddOnSubscription[P]>
      : GetScalarType<T[P], AggregateClinicAddOnSubscription[P]>
  }




  export type ClinicAddOnSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicAddOnSubscriptionWhereInput
    orderBy?: ClinicAddOnSubscriptionOrderByWithAggregationInput | ClinicAddOnSubscriptionOrderByWithAggregationInput[]
    by: ClinicAddOnSubscriptionScalarFieldEnum[] | ClinicAddOnSubscriptionScalarFieldEnum
    having?: ClinicAddOnSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicAddOnSubscriptionCountAggregateInputType | true
    _avg?: ClinicAddOnSubscriptionAvgAggregateInputType
    _sum?: ClinicAddOnSubscriptionSumAggregateInputType
    _min?: ClinicAddOnSubscriptionMinAggregateInputType
    _max?: ClinicAddOnSubscriptionMaxAggregateInputType
  }

  export type ClinicAddOnSubscriptionGroupByOutputType = {
    id: string
    subscriptionId: string
    addOnId: string
    quantity: number
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ClinicAddOnSubscriptionCountAggregateOutputType | null
    _avg: ClinicAddOnSubscriptionAvgAggregateOutputType | null
    _sum: ClinicAddOnSubscriptionSumAggregateOutputType | null
    _min: ClinicAddOnSubscriptionMinAggregateOutputType | null
    _max: ClinicAddOnSubscriptionMaxAggregateOutputType | null
  }

  type GetClinicAddOnSubscriptionGroupByPayload<T extends ClinicAddOnSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicAddOnSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicAddOnSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicAddOnSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicAddOnSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type ClinicAddOnSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    addOnId?: boolean
    quantity?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | ClinicSubscriptionDefaultArgs<ExtArgs>
    addOn?: boolean | ClinicAddOnDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicAddOnSubscription"]>

  export type ClinicAddOnSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    addOnId?: boolean
    quantity?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | ClinicSubscriptionDefaultArgs<ExtArgs>
    addOn?: boolean | ClinicAddOnDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicAddOnSubscription"]>

  export type ClinicAddOnSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    addOnId?: boolean
    quantity?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | ClinicSubscriptionDefaultArgs<ExtArgs>
    addOn?: boolean | ClinicAddOnDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicAddOnSubscription"]>

  export type ClinicAddOnSubscriptionSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    addOnId?: boolean
    quantity?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicAddOnSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "addOnId" | "quantity" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["clinicAddOnSubscription"]>
  export type ClinicAddOnSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | ClinicSubscriptionDefaultArgs<ExtArgs>
    addOn?: boolean | ClinicAddOnDefaultArgs<ExtArgs>
  }
  export type ClinicAddOnSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | ClinicSubscriptionDefaultArgs<ExtArgs>
    addOn?: boolean | ClinicAddOnDefaultArgs<ExtArgs>
  }
  export type ClinicAddOnSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | ClinicSubscriptionDefaultArgs<ExtArgs>
    addOn?: boolean | ClinicAddOnDefaultArgs<ExtArgs>
  }

  export type $ClinicAddOnSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicAddOnSubscription"
    objects: {
      subscription: Prisma.$ClinicSubscriptionPayload<ExtArgs>
      addOn: Prisma.$ClinicAddOnPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      addOnId: string
      quantity: number
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinicAddOnSubscription"]>
    composites: {}
  }

  type ClinicAddOnSubscriptionGetPayload<S extends boolean | null | undefined | ClinicAddOnSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload, S>

  type ClinicAddOnSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicAddOnSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicAddOnSubscriptionCountAggregateInputType | true
    }

  export interface ClinicAddOnSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicAddOnSubscription'], meta: { name: 'ClinicAddOnSubscription' } }
    /**
     * Find zero or one ClinicAddOnSubscription that matches the filter.
     * @param {ClinicAddOnSubscriptionFindUniqueArgs} args - Arguments to find a ClinicAddOnSubscription
     * @example
     * // Get one ClinicAddOnSubscription
     * const clinicAddOnSubscription = await prisma.clinicAddOnSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicAddOnSubscriptionFindUniqueArgs>(args: SelectSubset<T, ClinicAddOnSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__ClinicAddOnSubscriptionClient<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicAddOnSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicAddOnSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a ClinicAddOnSubscription
     * @example
     * // Get one ClinicAddOnSubscription
     * const clinicAddOnSubscription = await prisma.clinicAddOnSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicAddOnSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicAddOnSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicAddOnSubscriptionClient<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicAddOnSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnSubscriptionFindFirstArgs} args - Arguments to find a ClinicAddOnSubscription
     * @example
     * // Get one ClinicAddOnSubscription
     * const clinicAddOnSubscription = await prisma.clinicAddOnSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicAddOnSubscriptionFindFirstArgs>(args?: SelectSubset<T, ClinicAddOnSubscriptionFindFirstArgs<ExtArgs>>): Prisma__ClinicAddOnSubscriptionClient<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicAddOnSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnSubscriptionFindFirstOrThrowArgs} args - Arguments to find a ClinicAddOnSubscription
     * @example
     * // Get one ClinicAddOnSubscription
     * const clinicAddOnSubscription = await prisma.clinicAddOnSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicAddOnSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicAddOnSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicAddOnSubscriptionClient<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicAddOnSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicAddOnSubscriptions
     * const clinicAddOnSubscriptions = await prisma.clinicAddOnSubscription.findMany()
     * 
     * // Get first 10 ClinicAddOnSubscriptions
     * const clinicAddOnSubscriptions = await prisma.clinicAddOnSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicAddOnSubscriptionWithIdOnly = await prisma.clinicAddOnSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicAddOnSubscriptionFindManyArgs>(args?: SelectSubset<T, ClinicAddOnSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicAddOnSubscription.
     * @param {ClinicAddOnSubscriptionCreateArgs} args - Arguments to create a ClinicAddOnSubscription.
     * @example
     * // Create one ClinicAddOnSubscription
     * const ClinicAddOnSubscription = await prisma.clinicAddOnSubscription.create({
     *   data: {
     *     // ... data to create a ClinicAddOnSubscription
     *   }
     * })
     * 
     */
    create<T extends ClinicAddOnSubscriptionCreateArgs>(args: SelectSubset<T, ClinicAddOnSubscriptionCreateArgs<ExtArgs>>): Prisma__ClinicAddOnSubscriptionClient<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicAddOnSubscriptions.
     * @param {ClinicAddOnSubscriptionCreateManyArgs} args - Arguments to create many ClinicAddOnSubscriptions.
     * @example
     * // Create many ClinicAddOnSubscriptions
     * const clinicAddOnSubscription = await prisma.clinicAddOnSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicAddOnSubscriptionCreateManyArgs>(args?: SelectSubset<T, ClinicAddOnSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicAddOnSubscriptions and returns the data saved in the database.
     * @param {ClinicAddOnSubscriptionCreateManyAndReturnArgs} args - Arguments to create many ClinicAddOnSubscriptions.
     * @example
     * // Create many ClinicAddOnSubscriptions
     * const clinicAddOnSubscription = await prisma.clinicAddOnSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicAddOnSubscriptions and only return the `id`
     * const clinicAddOnSubscriptionWithIdOnly = await prisma.clinicAddOnSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicAddOnSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicAddOnSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicAddOnSubscription.
     * @param {ClinicAddOnSubscriptionDeleteArgs} args - Arguments to delete one ClinicAddOnSubscription.
     * @example
     * // Delete one ClinicAddOnSubscription
     * const ClinicAddOnSubscription = await prisma.clinicAddOnSubscription.delete({
     *   where: {
     *     // ... filter to delete one ClinicAddOnSubscription
     *   }
     * })
     * 
     */
    delete<T extends ClinicAddOnSubscriptionDeleteArgs>(args: SelectSubset<T, ClinicAddOnSubscriptionDeleteArgs<ExtArgs>>): Prisma__ClinicAddOnSubscriptionClient<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicAddOnSubscription.
     * @param {ClinicAddOnSubscriptionUpdateArgs} args - Arguments to update one ClinicAddOnSubscription.
     * @example
     * // Update one ClinicAddOnSubscription
     * const clinicAddOnSubscription = await prisma.clinicAddOnSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicAddOnSubscriptionUpdateArgs>(args: SelectSubset<T, ClinicAddOnSubscriptionUpdateArgs<ExtArgs>>): Prisma__ClinicAddOnSubscriptionClient<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicAddOnSubscriptions.
     * @param {ClinicAddOnSubscriptionDeleteManyArgs} args - Arguments to filter ClinicAddOnSubscriptions to delete.
     * @example
     * // Delete a few ClinicAddOnSubscriptions
     * const { count } = await prisma.clinicAddOnSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicAddOnSubscriptionDeleteManyArgs>(args?: SelectSubset<T, ClinicAddOnSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicAddOnSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicAddOnSubscriptions
     * const clinicAddOnSubscription = await prisma.clinicAddOnSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicAddOnSubscriptionUpdateManyArgs>(args: SelectSubset<T, ClinicAddOnSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicAddOnSubscriptions and returns the data updated in the database.
     * @param {ClinicAddOnSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many ClinicAddOnSubscriptions.
     * @example
     * // Update many ClinicAddOnSubscriptions
     * const clinicAddOnSubscription = await prisma.clinicAddOnSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicAddOnSubscriptions and only return the `id`
     * const clinicAddOnSubscriptionWithIdOnly = await prisma.clinicAddOnSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicAddOnSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicAddOnSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicAddOnSubscription.
     * @param {ClinicAddOnSubscriptionUpsertArgs} args - Arguments to update or create a ClinicAddOnSubscription.
     * @example
     * // Update or create a ClinicAddOnSubscription
     * const clinicAddOnSubscription = await prisma.clinicAddOnSubscription.upsert({
     *   create: {
     *     // ... data to create a ClinicAddOnSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicAddOnSubscription we want to update
     *   }
     * })
     */
    upsert<T extends ClinicAddOnSubscriptionUpsertArgs>(args: SelectSubset<T, ClinicAddOnSubscriptionUpsertArgs<ExtArgs>>): Prisma__ClinicAddOnSubscriptionClient<$Result.GetResult<Prisma.$ClinicAddOnSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicAddOnSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnSubscriptionCountArgs} args - Arguments to filter ClinicAddOnSubscriptions to count.
     * @example
     * // Count the number of ClinicAddOnSubscriptions
     * const count = await prisma.clinicAddOnSubscription.count({
     *   where: {
     *     // ... the filter for the ClinicAddOnSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends ClinicAddOnSubscriptionCountArgs>(
      args?: Subset<T, ClinicAddOnSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicAddOnSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicAddOnSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicAddOnSubscriptionAggregateArgs>(args: Subset<T, ClinicAddOnSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetClinicAddOnSubscriptionAggregateType<T>>

    /**
     * Group by ClinicAddOnSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAddOnSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicAddOnSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicAddOnSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: ClinicAddOnSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicAddOnSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicAddOnSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicAddOnSubscription model
   */
  readonly fields: ClinicAddOnSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicAddOnSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicAddOnSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends ClinicSubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicSubscriptionDefaultArgs<ExtArgs>>): Prisma__ClinicSubscriptionClient<$Result.GetResult<Prisma.$ClinicSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addOn<T extends ClinicAddOnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicAddOnDefaultArgs<ExtArgs>>): Prisma__ClinicAddOnClient<$Result.GetResult<Prisma.$ClinicAddOnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicAddOnSubscription model
   */
  interface ClinicAddOnSubscriptionFieldRefs {
    readonly id: FieldRef<"ClinicAddOnSubscription", 'String'>
    readonly subscriptionId: FieldRef<"ClinicAddOnSubscription", 'String'>
    readonly addOnId: FieldRef<"ClinicAddOnSubscription", 'String'>
    readonly quantity: FieldRef<"ClinicAddOnSubscription", 'Int'>
    readonly startDate: FieldRef<"ClinicAddOnSubscription", 'DateTime'>
    readonly endDate: FieldRef<"ClinicAddOnSubscription", 'DateTime'>
    readonly createdAt: FieldRef<"ClinicAddOnSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"ClinicAddOnSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicAddOnSubscription findUnique
   */
  export type ClinicAddOnSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClinicAddOnSubscription to fetch.
     */
    where: ClinicAddOnSubscriptionWhereUniqueInput
  }

  /**
   * ClinicAddOnSubscription findUniqueOrThrow
   */
  export type ClinicAddOnSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClinicAddOnSubscription to fetch.
     */
    where: ClinicAddOnSubscriptionWhereUniqueInput
  }

  /**
   * ClinicAddOnSubscription findFirst
   */
  export type ClinicAddOnSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClinicAddOnSubscription to fetch.
     */
    where?: ClinicAddOnSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicAddOnSubscriptions to fetch.
     */
    orderBy?: ClinicAddOnSubscriptionOrderByWithRelationInput | ClinicAddOnSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicAddOnSubscriptions.
     */
    cursor?: ClinicAddOnSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicAddOnSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicAddOnSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicAddOnSubscriptions.
     */
    distinct?: ClinicAddOnSubscriptionScalarFieldEnum | ClinicAddOnSubscriptionScalarFieldEnum[]
  }

  /**
   * ClinicAddOnSubscription findFirstOrThrow
   */
  export type ClinicAddOnSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClinicAddOnSubscription to fetch.
     */
    where?: ClinicAddOnSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicAddOnSubscriptions to fetch.
     */
    orderBy?: ClinicAddOnSubscriptionOrderByWithRelationInput | ClinicAddOnSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicAddOnSubscriptions.
     */
    cursor?: ClinicAddOnSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicAddOnSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicAddOnSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicAddOnSubscriptions.
     */
    distinct?: ClinicAddOnSubscriptionScalarFieldEnum | ClinicAddOnSubscriptionScalarFieldEnum[]
  }

  /**
   * ClinicAddOnSubscription findMany
   */
  export type ClinicAddOnSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClinicAddOnSubscriptions to fetch.
     */
    where?: ClinicAddOnSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicAddOnSubscriptions to fetch.
     */
    orderBy?: ClinicAddOnSubscriptionOrderByWithRelationInput | ClinicAddOnSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicAddOnSubscriptions.
     */
    cursor?: ClinicAddOnSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicAddOnSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicAddOnSubscriptions.
     */
    skip?: number
    distinct?: ClinicAddOnSubscriptionScalarFieldEnum | ClinicAddOnSubscriptionScalarFieldEnum[]
  }

  /**
   * ClinicAddOnSubscription create
   */
  export type ClinicAddOnSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicAddOnSubscription.
     */
    data: XOR<ClinicAddOnSubscriptionCreateInput, ClinicAddOnSubscriptionUncheckedCreateInput>
  }

  /**
   * ClinicAddOnSubscription createMany
   */
  export type ClinicAddOnSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicAddOnSubscriptions.
     */
    data: ClinicAddOnSubscriptionCreateManyInput | ClinicAddOnSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicAddOnSubscription createManyAndReturn
   */
  export type ClinicAddOnSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicAddOnSubscriptions.
     */
    data: ClinicAddOnSubscriptionCreateManyInput | ClinicAddOnSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicAddOnSubscription update
   */
  export type ClinicAddOnSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicAddOnSubscription.
     */
    data: XOR<ClinicAddOnSubscriptionUpdateInput, ClinicAddOnSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which ClinicAddOnSubscription to update.
     */
    where: ClinicAddOnSubscriptionWhereUniqueInput
  }

  /**
   * ClinicAddOnSubscription updateMany
   */
  export type ClinicAddOnSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicAddOnSubscriptions.
     */
    data: XOR<ClinicAddOnSubscriptionUpdateManyMutationInput, ClinicAddOnSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which ClinicAddOnSubscriptions to update
     */
    where?: ClinicAddOnSubscriptionWhereInput
    /**
     * Limit how many ClinicAddOnSubscriptions to update.
     */
    limit?: number
  }

  /**
   * ClinicAddOnSubscription updateManyAndReturn
   */
  export type ClinicAddOnSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update ClinicAddOnSubscriptions.
     */
    data: XOR<ClinicAddOnSubscriptionUpdateManyMutationInput, ClinicAddOnSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which ClinicAddOnSubscriptions to update
     */
    where?: ClinicAddOnSubscriptionWhereInput
    /**
     * Limit how many ClinicAddOnSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicAddOnSubscription upsert
   */
  export type ClinicAddOnSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicAddOnSubscription to update in case it exists.
     */
    where: ClinicAddOnSubscriptionWhereUniqueInput
    /**
     * In case the ClinicAddOnSubscription found by the `where` argument doesn't exist, create a new ClinicAddOnSubscription with this data.
     */
    create: XOR<ClinicAddOnSubscriptionCreateInput, ClinicAddOnSubscriptionUncheckedCreateInput>
    /**
     * In case the ClinicAddOnSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicAddOnSubscriptionUpdateInput, ClinicAddOnSubscriptionUncheckedUpdateInput>
  }

  /**
   * ClinicAddOnSubscription delete
   */
  export type ClinicAddOnSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which ClinicAddOnSubscription to delete.
     */
    where: ClinicAddOnSubscriptionWhereUniqueInput
  }

  /**
   * ClinicAddOnSubscription deleteMany
   */
  export type ClinicAddOnSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicAddOnSubscriptions to delete
     */
    where?: ClinicAddOnSubscriptionWhereInput
    /**
     * Limit how many ClinicAddOnSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * ClinicAddOnSubscription without action
   */
  export type ClinicAddOnSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicAddOnSubscription
     */
    select?: ClinicAddOnSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicAddOnSubscription
     */
    omit?: ClinicAddOnSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicAddOnSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    doctorId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    doctorId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    doctorId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    doctorId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    doctorId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    doctorId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    doctorId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    doctorId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | ProductCategory$doctorArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    categories?: boolean | ProductCategory$categoriesArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    doctorId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | ProductCategory$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    doctorId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | ProductCategory$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    doctorId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "doctorId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | ProductCategory$doctorArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    categories?: boolean | ProductCategory$categoriesArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | ProductCategory$doctorArgs<ExtArgs>
  }
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | ProductCategory$doctorArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      doctor: Prisma.$UserPayload<ExtArgs> | null
      products: Prisma.$ProductPayload<ExtArgs>[]
      categories: Prisma.$CategoriesOnProductsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      doctorId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends ProductCategory$doctorArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$doctorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends ProductCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends ProductCategory$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly slug: FieldRef<"ProductCategory", 'String'>
    readonly doctorId: FieldRef<"ProductCategory", 'String'>
    readonly isActive: FieldRef<"ProductCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.doctor
   */
  export type ProductCategory$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProductCategory.products
   */
  export type ProductCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory.categories
   */
  export type ProductCategory$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
    where?: CategoriesOnProductsWhereInput
    orderBy?: CategoriesOnProductsOrderByWithRelationInput | CategoriesOnProductsOrderByWithRelationInput[]
    cursor?: CategoriesOnProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriesOnProductsScalarFieldEnum | CategoriesOnProductsScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    creditsPerUnit: Decimal | null
    priority: number | null
    intervalCount: number | null
    trialDays: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    creditsPerUnit: Decimal | null
    priority: number | null
    intervalCount: number | null
    trialDays: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    subtitle: string | null
    description: string | null
    price: Decimal | null
    creditsPerUnit: Decimal | null
    category: string | null
    isActive: boolean | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    doctorId: string | null
    clinicId: string | null
    imageUrl: string | null
    confirmationUrl: string | null
    categoryId: string | null
    type: $Enums.ProductType | null
    interval: $Enums.SubscriptionInterval | null
    intervalCount: number | null
    trialDays: number | null
    providerPlanId: string | null
    autoRenew: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subtitle: string | null
    description: string | null
    price: Decimal | null
    creditsPerUnit: Decimal | null
    category: string | null
    isActive: boolean | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    doctorId: string | null
    clinicId: string | null
    imageUrl: string | null
    confirmationUrl: string | null
    categoryId: string | null
    type: $Enums.ProductType | null
    interval: $Enums.SubscriptionInterval | null
    intervalCount: number | null
    trialDays: number | null
    providerPlanId: string | null
    autoRenew: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    subtitle: number
    description: number
    price: number
    creditsPerUnit: number
    category: number
    isActive: number
    priority: number
    createdAt: number
    updatedAt: number
    doctorId: number
    clinicId: number
    imageUrl: number
    confirmationUrl: number
    categoryId: number
    type: number
    interval: number
    intervalCount: number
    trialDays: number
    providerPlanId: number
    providerPlanData: number
    autoRenew: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    creditsPerUnit?: true
    priority?: true
    intervalCount?: true
    trialDays?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    creditsPerUnit?: true
    priority?: true
    intervalCount?: true
    trialDays?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    subtitle?: true
    description?: true
    price?: true
    creditsPerUnit?: true
    category?: true
    isActive?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    doctorId?: true
    clinicId?: true
    imageUrl?: true
    confirmationUrl?: true
    categoryId?: true
    type?: true
    interval?: true
    intervalCount?: true
    trialDays?: true
    providerPlanId?: true
    autoRenew?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    subtitle?: true
    description?: true
    price?: true
    creditsPerUnit?: true
    category?: true
    isActive?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    doctorId?: true
    clinicId?: true
    imageUrl?: true
    confirmationUrl?: true
    categoryId?: true
    type?: true
    interval?: true
    intervalCount?: true
    trialDays?: true
    providerPlanId?: true
    autoRenew?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    subtitle?: true
    description?: true
    price?: true
    creditsPerUnit?: true
    category?: true
    isActive?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    doctorId?: true
    clinicId?: true
    imageUrl?: true
    confirmationUrl?: true
    categoryId?: true
    type?: true
    interval?: true
    intervalCount?: true
    trialDays?: true
    providerPlanId?: true
    providerPlanData?: true
    autoRenew?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    subtitle: string | null
    description: string | null
    price: Decimal
    creditsPerUnit: Decimal
    category: string
    isActive: boolean
    priority: number
    createdAt: Date
    updatedAt: Date
    doctorId: string | null
    clinicId: string | null
    imageUrl: string | null
    confirmationUrl: string | null
    categoryId: string | null
    type: $Enums.ProductType
    interval: $Enums.SubscriptionInterval | null
    intervalCount: number | null
    trialDays: number | null
    providerPlanId: string | null
    providerPlanData: JsonValue | null
    autoRenew: boolean | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subtitle?: boolean
    description?: boolean
    price?: boolean
    creditsPerUnit?: boolean
    category?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorId?: boolean
    clinicId?: boolean
    imageUrl?: boolean
    confirmationUrl?: boolean
    categoryId?: boolean
    type?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialDays?: boolean
    providerPlanId?: boolean
    providerPlanData?: boolean
    autoRenew?: boolean
    doctor?: boolean | Product$doctorArgs<ExtArgs>
    clinic?: boolean | Product$clinicArgs<ExtArgs>
    productCategory?: boolean | Product$productCategoryArgs<ExtArgs>
    purchases?: boolean | Product$purchasesArgs<ExtArgs>
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    offers?: boolean | Product$offersArgs<ExtArgs>
    integrations?: boolean | Product$integrationsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subtitle?: boolean
    description?: boolean
    price?: boolean
    creditsPerUnit?: boolean
    category?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorId?: boolean
    clinicId?: boolean
    imageUrl?: boolean
    confirmationUrl?: boolean
    categoryId?: boolean
    type?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialDays?: boolean
    providerPlanId?: boolean
    providerPlanData?: boolean
    autoRenew?: boolean
    doctor?: boolean | Product$doctorArgs<ExtArgs>
    clinic?: boolean | Product$clinicArgs<ExtArgs>
    productCategory?: boolean | Product$productCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subtitle?: boolean
    description?: boolean
    price?: boolean
    creditsPerUnit?: boolean
    category?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorId?: boolean
    clinicId?: boolean
    imageUrl?: boolean
    confirmationUrl?: boolean
    categoryId?: boolean
    type?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialDays?: boolean
    providerPlanId?: boolean
    providerPlanData?: boolean
    autoRenew?: boolean
    doctor?: boolean | Product$doctorArgs<ExtArgs>
    clinic?: boolean | Product$clinicArgs<ExtArgs>
    productCategory?: boolean | Product$productCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    subtitle?: boolean
    description?: boolean
    price?: boolean
    creditsPerUnit?: boolean
    category?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorId?: boolean
    clinicId?: boolean
    imageUrl?: boolean
    confirmationUrl?: boolean
    categoryId?: boolean
    type?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialDays?: boolean
    providerPlanId?: boolean
    providerPlanData?: boolean
    autoRenew?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subtitle" | "description" | "price" | "creditsPerUnit" | "category" | "isActive" | "priority" | "createdAt" | "updatedAt" | "doctorId" | "clinicId" | "imageUrl" | "confirmationUrl" | "categoryId" | "type" | "interval" | "intervalCount" | "trialDays" | "providerPlanId" | "providerPlanData" | "autoRenew", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | Product$doctorArgs<ExtArgs>
    clinic?: boolean | Product$clinicArgs<ExtArgs>
    productCategory?: boolean | Product$productCategoryArgs<ExtArgs>
    purchases?: boolean | Product$purchasesArgs<ExtArgs>
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    offers?: boolean | Product$offersArgs<ExtArgs>
    integrations?: boolean | Product$integrationsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | Product$doctorArgs<ExtArgs>
    clinic?: boolean | Product$clinicArgs<ExtArgs>
    productCategory?: boolean | Product$productCategoryArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | Product$doctorArgs<ExtArgs>
    clinic?: boolean | Product$clinicArgs<ExtArgs>
    productCategory?: boolean | Product$productCategoryArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      doctor: Prisma.$UserPayload<ExtArgs> | null
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      productCategory: Prisma.$ProductCategoryPayload<ExtArgs> | null
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      categories: Prisma.$CategoriesOnProductsPayload<ExtArgs>[]
      offers: Prisma.$OfferPayload<ExtArgs>[]
      integrations: Prisma.$ProductIntegrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subtitle: string | null
      description: string | null
      price: Prisma.Decimal
      creditsPerUnit: Prisma.Decimal
      category: string
      isActive: boolean
      priority: number
      createdAt: Date
      updatedAt: Date
      doctorId: string | null
      clinicId: string | null
      imageUrl: string | null
      confirmationUrl: string | null
      categoryId: string | null
      type: $Enums.ProductType
      interval: $Enums.SubscriptionInterval | null
      intervalCount: number | null
      trialDays: number | null
      providerPlanId: string | null
      providerPlanData: Prisma.JsonValue | null
      autoRenew: boolean | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends Product$doctorArgs<ExtArgs> = {}>(args?: Subset<T, Product$doctorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clinic<T extends Product$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Product$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productCategory<T extends Product$productCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$productCategoryArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchases<T extends Product$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Product$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offers<T extends Product$offersArgs<ExtArgs> = {}>(args?: Subset<T, Product$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integrations<T extends Product$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly subtitle: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly creditsPerUnit: FieldRef<"Product", 'Decimal'>
    readonly category: FieldRef<"Product", 'String'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly priority: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly doctorId: FieldRef<"Product", 'String'>
    readonly clinicId: FieldRef<"Product", 'String'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly confirmationUrl: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly type: FieldRef<"Product", 'ProductType'>
    readonly interval: FieldRef<"Product", 'SubscriptionInterval'>
    readonly intervalCount: FieldRef<"Product", 'Int'>
    readonly trialDays: FieldRef<"Product", 'Int'>
    readonly providerPlanId: FieldRef<"Product", 'String'>
    readonly providerPlanData: FieldRef<"Product", 'Json'>
    readonly autoRenew: FieldRef<"Product", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.doctor
   */
  export type Product$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Product.clinic
   */
  export type Product$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Product.productCategory
   */
  export type Product$productCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * Product.purchases
   */
  export type Product$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Product.categories
   */
  export type Product$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
    where?: CategoriesOnProductsWhereInput
    orderBy?: CategoriesOnProductsOrderByWithRelationInput | CategoriesOnProductsOrderByWithRelationInput[]
    cursor?: CategoriesOnProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriesOnProductsScalarFieldEnum | CategoriesOnProductsScalarFieldEnum[]
  }

  /**
   * Product.offers
   */
  export type Product$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Product.integrations
   */
  export type Product$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationInclude<ExtArgs> | null
    where?: ProductIntegrationWhereInput
    orderBy?: ProductIntegrationOrderByWithRelationInput | ProductIntegrationOrderByWithRelationInput[]
    cursor?: ProductIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductIntegrationScalarFieldEnum | ProductIntegrationScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model CategoriesOnProducts
   */

  export type AggregateCategoriesOnProducts = {
    _count: CategoriesOnProductsCountAggregateOutputType | null
    _min: CategoriesOnProductsMinAggregateOutputType | null
    _max: CategoriesOnProductsMaxAggregateOutputType | null
  }

  export type CategoriesOnProductsMinAggregateOutputType = {
    productId: string | null
    categoryId: string | null
    assignedAt: Date | null
  }

  export type CategoriesOnProductsMaxAggregateOutputType = {
    productId: string | null
    categoryId: string | null
    assignedAt: Date | null
  }

  export type CategoriesOnProductsCountAggregateOutputType = {
    productId: number
    categoryId: number
    assignedAt: number
    _all: number
  }


  export type CategoriesOnProductsMinAggregateInputType = {
    productId?: true
    categoryId?: true
    assignedAt?: true
  }

  export type CategoriesOnProductsMaxAggregateInputType = {
    productId?: true
    categoryId?: true
    assignedAt?: true
  }

  export type CategoriesOnProductsCountAggregateInputType = {
    productId?: true
    categoryId?: true
    assignedAt?: true
    _all?: true
  }

  export type CategoriesOnProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoriesOnProducts to aggregate.
     */
    where?: CategoriesOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriesOnProducts to fetch.
     */
    orderBy?: CategoriesOnProductsOrderByWithRelationInput | CategoriesOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriesOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriesOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriesOnProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoriesOnProducts
    **/
    _count?: true | CategoriesOnProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesOnProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesOnProductsMaxAggregateInputType
  }

  export type GetCategoriesOnProductsAggregateType<T extends CategoriesOnProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoriesOnProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoriesOnProducts[P]>
      : GetScalarType<T[P], AggregateCategoriesOnProducts[P]>
  }




  export type CategoriesOnProductsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriesOnProductsWhereInput
    orderBy?: CategoriesOnProductsOrderByWithAggregationInput | CategoriesOnProductsOrderByWithAggregationInput[]
    by: CategoriesOnProductsScalarFieldEnum[] | CategoriesOnProductsScalarFieldEnum
    having?: CategoriesOnProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesOnProductsCountAggregateInputType | true
    _min?: CategoriesOnProductsMinAggregateInputType
    _max?: CategoriesOnProductsMaxAggregateInputType
  }

  export type CategoriesOnProductsGroupByOutputType = {
    productId: string
    categoryId: string
    assignedAt: Date
    _count: CategoriesOnProductsCountAggregateOutputType | null
    _min: CategoriesOnProductsMinAggregateOutputType | null
    _max: CategoriesOnProductsMaxAggregateOutputType | null
  }

  type GetCategoriesOnProductsGroupByPayload<T extends CategoriesOnProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesOnProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesOnProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesOnProductsGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesOnProductsGroupByOutputType[P]>
        }
      >
    >


  export type CategoriesOnProductsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    categoryId?: boolean
    assignedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriesOnProducts"]>

  export type CategoriesOnProductsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    categoryId?: boolean
    assignedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriesOnProducts"]>

  export type CategoriesOnProductsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    categoryId?: boolean
    assignedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriesOnProducts"]>

  export type CategoriesOnProductsSelectScalar = {
    productId?: boolean
    categoryId?: boolean
    assignedAt?: boolean
  }

  export type CategoriesOnProductsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"productId" | "categoryId" | "assignedAt", ExtArgs["result"]["categoriesOnProducts"]>
  export type CategoriesOnProductsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }
  export type CategoriesOnProductsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }
  export type CategoriesOnProductsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }

  export type $CategoriesOnProductsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoriesOnProducts"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      category: Prisma.$ProductCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      productId: string
      categoryId: string
      assignedAt: Date
    }, ExtArgs["result"]["categoriesOnProducts"]>
    composites: {}
  }

  type CategoriesOnProductsGetPayload<S extends boolean | null | undefined | CategoriesOnProductsDefaultArgs> = $Result.GetResult<Prisma.$CategoriesOnProductsPayload, S>

  type CategoriesOnProductsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoriesOnProductsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesOnProductsCountAggregateInputType | true
    }

  export interface CategoriesOnProductsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoriesOnProducts'], meta: { name: 'CategoriesOnProducts' } }
    /**
     * Find zero or one CategoriesOnProducts that matches the filter.
     * @param {CategoriesOnProductsFindUniqueArgs} args - Arguments to find a CategoriesOnProducts
     * @example
     * // Get one CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriesOnProductsFindUniqueArgs>(args: SelectSubset<T, CategoriesOnProductsFindUniqueArgs<ExtArgs>>): Prisma__CategoriesOnProductsClient<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CategoriesOnProducts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoriesOnProductsFindUniqueOrThrowArgs} args - Arguments to find a CategoriesOnProducts
     * @example
     * // Get one CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriesOnProductsFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriesOnProductsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriesOnProductsClient<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoriesOnProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesOnProductsFindFirstArgs} args - Arguments to find a CategoriesOnProducts
     * @example
     * // Get one CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriesOnProductsFindFirstArgs>(args?: SelectSubset<T, CategoriesOnProductsFindFirstArgs<ExtArgs>>): Prisma__CategoriesOnProductsClient<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoriesOnProducts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesOnProductsFindFirstOrThrowArgs} args - Arguments to find a CategoriesOnProducts
     * @example
     * // Get one CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriesOnProductsFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriesOnProductsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriesOnProductsClient<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategoriesOnProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesOnProductsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.findMany()
     * 
     * // Get first 10 CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.findMany({ take: 10 })
     * 
     * // Only select the `productId`
     * const categoriesOnProductsWithProductIdOnly = await prisma.categoriesOnProducts.findMany({ select: { productId: true } })
     * 
     */
    findMany<T extends CategoriesOnProductsFindManyArgs>(args?: SelectSubset<T, CategoriesOnProductsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CategoriesOnProducts.
     * @param {CategoriesOnProductsCreateArgs} args - Arguments to create a CategoriesOnProducts.
     * @example
     * // Create one CategoriesOnProducts
     * const CategoriesOnProducts = await prisma.categoriesOnProducts.create({
     *   data: {
     *     // ... data to create a CategoriesOnProducts
     *   }
     * })
     * 
     */
    create<T extends CategoriesOnProductsCreateArgs>(args: SelectSubset<T, CategoriesOnProductsCreateArgs<ExtArgs>>): Prisma__CategoriesOnProductsClient<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CategoriesOnProducts.
     * @param {CategoriesOnProductsCreateManyArgs} args - Arguments to create many CategoriesOnProducts.
     * @example
     * // Create many CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriesOnProductsCreateManyArgs>(args?: SelectSubset<T, CategoriesOnProductsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategoriesOnProducts and returns the data saved in the database.
     * @param {CategoriesOnProductsCreateManyAndReturnArgs} args - Arguments to create many CategoriesOnProducts.
     * @example
     * // Create many CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategoriesOnProducts and only return the `productId`
     * const categoriesOnProductsWithProductIdOnly = await prisma.categoriesOnProducts.createManyAndReturn({
     *   select: { productId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoriesOnProductsCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoriesOnProductsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CategoriesOnProducts.
     * @param {CategoriesOnProductsDeleteArgs} args - Arguments to delete one CategoriesOnProducts.
     * @example
     * // Delete one CategoriesOnProducts
     * const CategoriesOnProducts = await prisma.categoriesOnProducts.delete({
     *   where: {
     *     // ... filter to delete one CategoriesOnProducts
     *   }
     * })
     * 
     */
    delete<T extends CategoriesOnProductsDeleteArgs>(args: SelectSubset<T, CategoriesOnProductsDeleteArgs<ExtArgs>>): Prisma__CategoriesOnProductsClient<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CategoriesOnProducts.
     * @param {CategoriesOnProductsUpdateArgs} args - Arguments to update one CategoriesOnProducts.
     * @example
     * // Update one CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriesOnProductsUpdateArgs>(args: SelectSubset<T, CategoriesOnProductsUpdateArgs<ExtArgs>>): Prisma__CategoriesOnProductsClient<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CategoriesOnProducts.
     * @param {CategoriesOnProductsDeleteManyArgs} args - Arguments to filter CategoriesOnProducts to delete.
     * @example
     * // Delete a few CategoriesOnProducts
     * const { count } = await prisma.categoriesOnProducts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriesOnProductsDeleteManyArgs>(args?: SelectSubset<T, CategoriesOnProductsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoriesOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesOnProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriesOnProductsUpdateManyArgs>(args: SelectSubset<T, CategoriesOnProductsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoriesOnProducts and returns the data updated in the database.
     * @param {CategoriesOnProductsUpdateManyAndReturnArgs} args - Arguments to update many CategoriesOnProducts.
     * @example
     * // Update many CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CategoriesOnProducts and only return the `productId`
     * const categoriesOnProductsWithProductIdOnly = await prisma.categoriesOnProducts.updateManyAndReturn({
     *   select: { productId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoriesOnProductsUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoriesOnProductsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CategoriesOnProducts.
     * @param {CategoriesOnProductsUpsertArgs} args - Arguments to update or create a CategoriesOnProducts.
     * @example
     * // Update or create a CategoriesOnProducts
     * const categoriesOnProducts = await prisma.categoriesOnProducts.upsert({
     *   create: {
     *     // ... data to create a CategoriesOnProducts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoriesOnProducts we want to update
     *   }
     * })
     */
    upsert<T extends CategoriesOnProductsUpsertArgs>(args: SelectSubset<T, CategoriesOnProductsUpsertArgs<ExtArgs>>): Prisma__CategoriesOnProductsClient<$Result.GetResult<Prisma.$CategoriesOnProductsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CategoriesOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesOnProductsCountArgs} args - Arguments to filter CategoriesOnProducts to count.
     * @example
     * // Count the number of CategoriesOnProducts
     * const count = await prisma.categoriesOnProducts.count({
     *   where: {
     *     // ... the filter for the CategoriesOnProducts we want to count
     *   }
     * })
    **/
    count<T extends CategoriesOnProductsCountArgs>(
      args?: Subset<T, CategoriesOnProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesOnProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoriesOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesOnProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesOnProductsAggregateArgs>(args: Subset<T, CategoriesOnProductsAggregateArgs>): Prisma.PrismaPromise<GetCategoriesOnProductsAggregateType<T>>

    /**
     * Group by CategoriesOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesOnProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriesOnProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriesOnProductsGroupByArgs['orderBy'] }
        : { orderBy?: CategoriesOnProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriesOnProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesOnProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoriesOnProducts model
   */
  readonly fields: CategoriesOnProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoriesOnProducts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriesOnProductsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategoriesOnProducts model
   */
  interface CategoriesOnProductsFieldRefs {
    readonly productId: FieldRef<"CategoriesOnProducts", 'String'>
    readonly categoryId: FieldRef<"CategoriesOnProducts", 'String'>
    readonly assignedAt: FieldRef<"CategoriesOnProducts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CategoriesOnProducts findUnique
   */
  export type CategoriesOnProductsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which CategoriesOnProducts to fetch.
     */
    where: CategoriesOnProductsWhereUniqueInput
  }

  /**
   * CategoriesOnProducts findUniqueOrThrow
   */
  export type CategoriesOnProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which CategoriesOnProducts to fetch.
     */
    where: CategoriesOnProductsWhereUniqueInput
  }

  /**
   * CategoriesOnProducts findFirst
   */
  export type CategoriesOnProductsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which CategoriesOnProducts to fetch.
     */
    where?: CategoriesOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriesOnProducts to fetch.
     */
    orderBy?: CategoriesOnProductsOrderByWithRelationInput | CategoriesOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoriesOnProducts.
     */
    cursor?: CategoriesOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriesOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriesOnProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoriesOnProducts.
     */
    distinct?: CategoriesOnProductsScalarFieldEnum | CategoriesOnProductsScalarFieldEnum[]
  }

  /**
   * CategoriesOnProducts findFirstOrThrow
   */
  export type CategoriesOnProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which CategoriesOnProducts to fetch.
     */
    where?: CategoriesOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriesOnProducts to fetch.
     */
    orderBy?: CategoriesOnProductsOrderByWithRelationInput | CategoriesOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoriesOnProducts.
     */
    cursor?: CategoriesOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriesOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriesOnProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoriesOnProducts.
     */
    distinct?: CategoriesOnProductsScalarFieldEnum | CategoriesOnProductsScalarFieldEnum[]
  }

  /**
   * CategoriesOnProducts findMany
   */
  export type CategoriesOnProductsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which CategoriesOnProducts to fetch.
     */
    where?: CategoriesOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriesOnProducts to fetch.
     */
    orderBy?: CategoriesOnProductsOrderByWithRelationInput | CategoriesOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoriesOnProducts.
     */
    cursor?: CategoriesOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriesOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriesOnProducts.
     */
    skip?: number
    distinct?: CategoriesOnProductsScalarFieldEnum | CategoriesOnProductsScalarFieldEnum[]
  }

  /**
   * CategoriesOnProducts create
   */
  export type CategoriesOnProductsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoriesOnProducts.
     */
    data: XOR<CategoriesOnProductsCreateInput, CategoriesOnProductsUncheckedCreateInput>
  }

  /**
   * CategoriesOnProducts createMany
   */
  export type CategoriesOnProductsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoriesOnProducts.
     */
    data: CategoriesOnProductsCreateManyInput | CategoriesOnProductsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategoriesOnProducts createManyAndReturn
   */
  export type CategoriesOnProductsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * The data used to create many CategoriesOnProducts.
     */
    data: CategoriesOnProductsCreateManyInput | CategoriesOnProductsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoriesOnProducts update
   */
  export type CategoriesOnProductsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoriesOnProducts.
     */
    data: XOR<CategoriesOnProductsUpdateInput, CategoriesOnProductsUncheckedUpdateInput>
    /**
     * Choose, which CategoriesOnProducts to update.
     */
    where: CategoriesOnProductsWhereUniqueInput
  }

  /**
   * CategoriesOnProducts updateMany
   */
  export type CategoriesOnProductsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoriesOnProducts.
     */
    data: XOR<CategoriesOnProductsUpdateManyMutationInput, CategoriesOnProductsUncheckedUpdateManyInput>
    /**
     * Filter which CategoriesOnProducts to update
     */
    where?: CategoriesOnProductsWhereInput
    /**
     * Limit how many CategoriesOnProducts to update.
     */
    limit?: number
  }

  /**
   * CategoriesOnProducts updateManyAndReturn
   */
  export type CategoriesOnProductsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * The data used to update CategoriesOnProducts.
     */
    data: XOR<CategoriesOnProductsUpdateManyMutationInput, CategoriesOnProductsUncheckedUpdateManyInput>
    /**
     * Filter which CategoriesOnProducts to update
     */
    where?: CategoriesOnProductsWhereInput
    /**
     * Limit how many CategoriesOnProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoriesOnProducts upsert
   */
  export type CategoriesOnProductsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoriesOnProducts to update in case it exists.
     */
    where: CategoriesOnProductsWhereUniqueInput
    /**
     * In case the CategoriesOnProducts found by the `where` argument doesn't exist, create a new CategoriesOnProducts with this data.
     */
    create: XOR<CategoriesOnProductsCreateInput, CategoriesOnProductsUncheckedCreateInput>
    /**
     * In case the CategoriesOnProducts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriesOnProductsUpdateInput, CategoriesOnProductsUncheckedUpdateInput>
  }

  /**
   * CategoriesOnProducts delete
   */
  export type CategoriesOnProductsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
    /**
     * Filter which CategoriesOnProducts to delete.
     */
    where: CategoriesOnProductsWhereUniqueInput
  }

  /**
   * CategoriesOnProducts deleteMany
   */
  export type CategoriesOnProductsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoriesOnProducts to delete
     */
    where?: CategoriesOnProductsWhereInput
    /**
     * Limit how many CategoriesOnProducts to delete.
     */
    limit?: number
  }

  /**
   * CategoriesOnProducts without action
   */
  export type CategoriesOnProductsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesOnProducts
     */
    select?: CategoriesOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriesOnProducts
     */
    omit?: CategoriesOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesOnProductsInclude<ExtArgs> | null
  }


  /**
   * Model Offer
   */

  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    priceCents: number | null
    maxInstallments: number | null
    installmentMinCents: number | null
    intervalCount: number | null
    trialDays: number | null
  }

  export type OfferSumAggregateOutputType = {
    priceCents: number | null
    maxInstallments: number | null
    installmentMinCents: number | null
    intervalCount: number | null
    trialDays: number | null
  }

  export type OfferMinAggregateOutputType = {
    id: string | null
    productId: string | null
    name: string | null
    description: string | null
    currency: $Enums.Currency | null
    priceCents: number | null
    preferredProvider: $Enums.PaymentProvider | null
    maxInstallments: number | null
    installmentMinCents: number | null
    active: boolean | null
    isSubscription: boolean | null
    intervalCount: number | null
    intervalUnit: $Enums.SubscriptionInterval | null
    trialDays: number | null
    checkoutUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    name: string | null
    description: string | null
    currency: $Enums.Currency | null
    priceCents: number | null
    preferredProvider: $Enums.PaymentProvider | null
    maxInstallments: number | null
    installmentMinCents: number | null
    active: boolean | null
    isSubscription: boolean | null
    intervalCount: number | null
    intervalUnit: $Enums.SubscriptionInterval | null
    trialDays: number | null
    checkoutUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    productId: number
    name: number
    description: number
    currency: number
    priceCents: number
    preferredProvider: number
    maxInstallments: number
    installmentMinCents: number
    active: number
    isSubscription: number
    intervalCount: number
    intervalUnit: number
    trialDays: number
    checkoutUrl: number
    providerConfig: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    priceCents?: true
    maxInstallments?: true
    installmentMinCents?: true
    intervalCount?: true
    trialDays?: true
  }

  export type OfferSumAggregateInputType = {
    priceCents?: true
    maxInstallments?: true
    installmentMinCents?: true
    intervalCount?: true
    trialDays?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    description?: true
    currency?: true
    priceCents?: true
    preferredProvider?: true
    maxInstallments?: true
    installmentMinCents?: true
    active?: true
    isSubscription?: true
    intervalCount?: true
    intervalUnit?: true
    trialDays?: true
    checkoutUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    description?: true
    currency?: true
    priceCents?: true
    preferredProvider?: true
    maxInstallments?: true
    installmentMinCents?: true
    active?: true
    isSubscription?: true
    intervalCount?: true
    intervalUnit?: true
    trialDays?: true
    checkoutUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    description?: true
    currency?: true
    priceCents?: true
    preferredProvider?: true
    maxInstallments?: true
    installmentMinCents?: true
    active?: true
    isSubscription?: true
    intervalCount?: true
    intervalUnit?: true
    trialDays?: true
    checkoutUrl?: true
    providerConfig?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithAggregationInput | OfferOrderByWithAggregationInput[]
    by: OfferScalarFieldEnum[] | OfferScalarFieldEnum
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }

  export type OfferGroupByOutputType = {
    id: string
    productId: string
    name: string
    description: string | null
    currency: $Enums.Currency
    priceCents: number
    preferredProvider: $Enums.PaymentProvider | null
    maxInstallments: number | null
    installmentMinCents: number | null
    active: boolean
    isSubscription: boolean
    intervalCount: number | null
    intervalUnit: $Enums.SubscriptionInterval | null
    trialDays: number | null
    checkoutUrl: string | null
    providerConfig: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    description?: boolean
    currency?: boolean
    priceCents?: boolean
    preferredProvider?: boolean
    maxInstallments?: boolean
    installmentMinCents?: boolean
    active?: boolean
    isSubscription?: boolean
    intervalCount?: boolean
    intervalUnit?: boolean
    trialDays?: boolean
    checkoutUrl?: boolean
    providerConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    paymentMethods?: boolean | Offer$paymentMethodsArgs<ExtArgs>
    prices?: boolean | Offer$pricesArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    description?: boolean
    currency?: boolean
    priceCents?: boolean
    preferredProvider?: boolean
    maxInstallments?: boolean
    installmentMinCents?: boolean
    active?: boolean
    isSubscription?: boolean
    intervalCount?: boolean
    intervalUnit?: boolean
    trialDays?: boolean
    checkoutUrl?: boolean
    providerConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    description?: boolean
    currency?: boolean
    priceCents?: boolean
    preferredProvider?: boolean
    maxInstallments?: boolean
    installmentMinCents?: boolean
    active?: boolean
    isSubscription?: boolean
    intervalCount?: boolean
    intervalUnit?: boolean
    trialDays?: boolean
    checkoutUrl?: boolean
    providerConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectScalar = {
    id?: boolean
    productId?: boolean
    name?: boolean
    description?: boolean
    currency?: boolean
    priceCents?: boolean
    preferredProvider?: boolean
    maxInstallments?: boolean
    installmentMinCents?: boolean
    active?: boolean
    isSubscription?: boolean
    intervalCount?: boolean
    intervalUnit?: boolean
    trialDays?: boolean
    checkoutUrl?: boolean
    providerConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "name" | "description" | "currency" | "priceCents" | "preferredProvider" | "maxInstallments" | "installmentMinCents" | "active" | "isSubscription" | "intervalCount" | "intervalUnit" | "trialDays" | "checkoutUrl" | "providerConfig" | "createdAt" | "updatedAt", ExtArgs["result"]["offer"]>
  export type OfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    paymentMethods?: boolean | Offer$paymentMethodsArgs<ExtArgs>
    prices?: boolean | Offer$pricesArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OfferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Offer"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      paymentMethods: Prisma.$OfferPaymentMethodPayload<ExtArgs>[]
      prices: Prisma.$OfferPricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      name: string
      description: string | null
      currency: $Enums.Currency
      priceCents: number
      preferredProvider: $Enums.PaymentProvider | null
      maxInstallments: number | null
      installmentMinCents: number | null
      active: boolean
      isSubscription: boolean
      intervalCount: number | null
      intervalUnit: $Enums.SubscriptionInterval | null
      trialDays: number | null
      checkoutUrl: string | null
      providerConfig: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["offer"]>
    composites: {}
  }

  type OfferGetPayload<S extends boolean | null | undefined | OfferDefaultArgs> = $Result.GetResult<Prisma.$OfferPayload, S>

  type OfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferCountAggregateInputType | true
    }

  export interface OfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Offer'], meta: { name: 'Offer' } }
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferFindUniqueArgs>(args: SelectSubset<T, OfferFindUniqueArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Offer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferFindFirstArgs>(args?: SelectSubset<T, OfferFindFirstArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferFindManyArgs>(args?: SelectSubset<T, OfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
     */
    create<T extends OfferCreateArgs>(args: SelectSubset<T, OfferCreateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Offers.
     * @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferCreateManyArgs>(args?: SelectSubset<T, OfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Offers and returns the data saved in the database.
     * @param {OfferCreateManyAndReturnArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
     */
    delete<T extends OfferDeleteArgs>(args: SelectSubset<T, OfferDeleteArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferUpdateArgs>(args: SelectSubset<T, OfferUpdateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferDeleteManyArgs>(args?: SelectSubset<T, OfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferUpdateManyArgs>(args: SelectSubset<T, OfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers and returns the data updated in the database.
     * @param {OfferUpdateManyAndReturnArgs} args - Arguments to update many Offers.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OfferUpdateManyAndReturnArgs>(args: SelectSubset<T, OfferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
     */
    upsert<T extends OfferUpsertArgs>(args: SelectSubset<T, OfferUpsertArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): Prisma.PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Offer model
   */
  readonly fields: OfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethods<T extends Offer$paymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, Offer$paymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prices<T extends Offer$pricesArgs<ExtArgs> = {}>(args?: Subset<T, Offer$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Offer model
   */
  interface OfferFieldRefs {
    readonly id: FieldRef<"Offer", 'String'>
    readonly productId: FieldRef<"Offer", 'String'>
    readonly name: FieldRef<"Offer", 'String'>
    readonly description: FieldRef<"Offer", 'String'>
    readonly currency: FieldRef<"Offer", 'Currency'>
    readonly priceCents: FieldRef<"Offer", 'Int'>
    readonly preferredProvider: FieldRef<"Offer", 'PaymentProvider'>
    readonly maxInstallments: FieldRef<"Offer", 'Int'>
    readonly installmentMinCents: FieldRef<"Offer", 'Int'>
    readonly active: FieldRef<"Offer", 'Boolean'>
    readonly isSubscription: FieldRef<"Offer", 'Boolean'>
    readonly intervalCount: FieldRef<"Offer", 'Int'>
    readonly intervalUnit: FieldRef<"Offer", 'SubscriptionInterval'>
    readonly trialDays: FieldRef<"Offer", 'Int'>
    readonly checkoutUrl: FieldRef<"Offer", 'String'>
    readonly providerConfig: FieldRef<"Offer", 'Json'>
    readonly createdAt: FieldRef<"Offer", 'DateTime'>
    readonly updatedAt: FieldRef<"Offer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Offer findUnique
   */
  export type OfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findFirst
   */
  export type OfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findMany
   */
  export type OfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer create
   */
  export type OfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }

  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Offer createManyAndReturn
   */
  export type OfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offer update
   */
  export type OfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to update.
     */
    limit?: number
  }

  /**
   * Offer updateManyAndReturn
   */
  export type OfferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offer upsert
   */
  export type OfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }

  /**
   * Offer delete
   */
  export type OfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to delete.
     */
    limit?: number
  }

  /**
   * Offer.paymentMethods
   */
  export type Offer$paymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodInclude<ExtArgs> | null
    where?: OfferPaymentMethodWhereInput
    orderBy?: OfferPaymentMethodOrderByWithRelationInput | OfferPaymentMethodOrderByWithRelationInput[]
    cursor?: OfferPaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferPaymentMethodScalarFieldEnum | OfferPaymentMethodScalarFieldEnum[]
  }

  /**
   * Offer.prices
   */
  export type Offer$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceInclude<ExtArgs> | null
    where?: OfferPriceWhereInput
    orderBy?: OfferPriceOrderByWithRelationInput | OfferPriceOrderByWithRelationInput[]
    cursor?: OfferPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferPriceScalarFieldEnum | OfferPriceScalarFieldEnum[]
  }

  /**
   * Offer without action
   */
  export type OfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
  }


  /**
   * Model OfferPrice
   */

  export type AggregateOfferPrice = {
    _count: OfferPriceCountAggregateOutputType | null
    _avg: OfferPriceAvgAggregateOutputType | null
    _sum: OfferPriceSumAggregateOutputType | null
    _min: OfferPriceMinAggregateOutputType | null
    _max: OfferPriceMaxAggregateOutputType | null
  }

  export type OfferPriceAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type OfferPriceSumAggregateOutputType = {
    amountCents: number | null
  }

  export type OfferPriceMinAggregateOutputType = {
    id: string | null
    offerId: string | null
    country: string | null
    currency: $Enums.Currency | null
    provider: $Enums.PaymentProvider | null
    amountCents: number | null
    externalPriceId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferPriceMaxAggregateOutputType = {
    id: string | null
    offerId: string | null
    country: string | null
    currency: $Enums.Currency | null
    provider: $Enums.PaymentProvider | null
    amountCents: number | null
    externalPriceId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferPriceCountAggregateOutputType = {
    id: number
    offerId: number
    country: number
    currency: number
    provider: number
    amountCents: number
    externalPriceId: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfferPriceAvgAggregateInputType = {
    amountCents?: true
  }

  export type OfferPriceSumAggregateInputType = {
    amountCents?: true
  }

  export type OfferPriceMinAggregateInputType = {
    id?: true
    offerId?: true
    country?: true
    currency?: true
    provider?: true
    amountCents?: true
    externalPriceId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferPriceMaxAggregateInputType = {
    id?: true
    offerId?: true
    country?: true
    currency?: true
    provider?: true
    amountCents?: true
    externalPriceId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferPriceCountAggregateInputType = {
    id?: true
    offerId?: true
    country?: true
    currency?: true
    provider?: true
    amountCents?: true
    externalPriceId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfferPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferPrice to aggregate.
     */
    where?: OfferPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPrices to fetch.
     */
    orderBy?: OfferPriceOrderByWithRelationInput | OfferPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferPrices
    **/
    _count?: true | OfferPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferPriceMaxAggregateInputType
  }

  export type GetOfferPriceAggregateType<T extends OfferPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferPrice[P]>
      : GetScalarType<T[P], AggregateOfferPrice[P]>
  }




  export type OfferPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferPriceWhereInput
    orderBy?: OfferPriceOrderByWithAggregationInput | OfferPriceOrderByWithAggregationInput[]
    by: OfferPriceScalarFieldEnum[] | OfferPriceScalarFieldEnum
    having?: OfferPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferPriceCountAggregateInputType | true
    _avg?: OfferPriceAvgAggregateInputType
    _sum?: OfferPriceSumAggregateInputType
    _min?: OfferPriceMinAggregateInputType
    _max?: OfferPriceMaxAggregateInputType
  }

  export type OfferPriceGroupByOutputType = {
    id: string
    offerId: string
    country: string
    currency: $Enums.Currency
    provider: $Enums.PaymentProvider
    amountCents: number
    externalPriceId: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: OfferPriceCountAggregateOutputType | null
    _avg: OfferPriceAvgAggregateOutputType | null
    _sum: OfferPriceSumAggregateOutputType | null
    _min: OfferPriceMinAggregateOutputType | null
    _max: OfferPriceMaxAggregateOutputType | null
  }

  type GetOfferPriceGroupByPayload<T extends OfferPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferPriceGroupByOutputType[P]>
            : GetScalarType<T[P], OfferPriceGroupByOutputType[P]>
        }
      >
    >


  export type OfferPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offerId?: boolean
    country?: boolean
    currency?: boolean
    provider?: boolean
    amountCents?: boolean
    externalPriceId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offerPrice"]>

  export type OfferPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offerId?: boolean
    country?: boolean
    currency?: boolean
    provider?: boolean
    amountCents?: boolean
    externalPriceId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offerPrice"]>

  export type OfferPriceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offerId?: boolean
    country?: boolean
    currency?: boolean
    provider?: boolean
    amountCents?: boolean
    externalPriceId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offerPrice"]>

  export type OfferPriceSelectScalar = {
    id?: boolean
    offerId?: boolean
    country?: boolean
    currency?: boolean
    provider?: boolean
    amountCents?: boolean
    externalPriceId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OfferPriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "offerId" | "country" | "currency" | "provider" | "amountCents" | "externalPriceId" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["offerPrice"]>
  export type OfferPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }
  export type OfferPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }
  export type OfferPriceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }

  export type $OfferPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfferPrice"
    objects: {
      offer: Prisma.$OfferPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      offerId: string
      country: string
      currency: $Enums.Currency
      provider: $Enums.PaymentProvider
      amountCents: number
      externalPriceId: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["offerPrice"]>
    composites: {}
  }

  type OfferPriceGetPayload<S extends boolean | null | undefined | OfferPriceDefaultArgs> = $Result.GetResult<Prisma.$OfferPricePayload, S>

  type OfferPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferPriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferPriceCountAggregateInputType | true
    }

  export interface OfferPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferPrice'], meta: { name: 'OfferPrice' } }
    /**
     * Find zero or one OfferPrice that matches the filter.
     * @param {OfferPriceFindUniqueArgs} args - Arguments to find a OfferPrice
     * @example
     * // Get one OfferPrice
     * const offerPrice = await prisma.offerPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferPriceFindUniqueArgs>(args: SelectSubset<T, OfferPriceFindUniqueArgs<ExtArgs>>): Prisma__OfferPriceClient<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OfferPrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferPriceFindUniqueOrThrowArgs} args - Arguments to find a OfferPrice
     * @example
     * // Get one OfferPrice
     * const offerPrice = await prisma.offerPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferPriceClient<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPriceFindFirstArgs} args - Arguments to find a OfferPrice
     * @example
     * // Get one OfferPrice
     * const offerPrice = await prisma.offerPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferPriceFindFirstArgs>(args?: SelectSubset<T, OfferPriceFindFirstArgs<ExtArgs>>): Prisma__OfferPriceClient<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPriceFindFirstOrThrowArgs} args - Arguments to find a OfferPrice
     * @example
     * // Get one OfferPrice
     * const offerPrice = await prisma.offerPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferPriceClient<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OfferPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferPrices
     * const offerPrices = await prisma.offerPrice.findMany()
     * 
     * // Get first 10 OfferPrices
     * const offerPrices = await prisma.offerPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerPriceWithIdOnly = await prisma.offerPrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferPriceFindManyArgs>(args?: SelectSubset<T, OfferPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OfferPrice.
     * @param {OfferPriceCreateArgs} args - Arguments to create a OfferPrice.
     * @example
     * // Create one OfferPrice
     * const OfferPrice = await prisma.offerPrice.create({
     *   data: {
     *     // ... data to create a OfferPrice
     *   }
     * })
     * 
     */
    create<T extends OfferPriceCreateArgs>(args: SelectSubset<T, OfferPriceCreateArgs<ExtArgs>>): Prisma__OfferPriceClient<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OfferPrices.
     * @param {OfferPriceCreateManyArgs} args - Arguments to create many OfferPrices.
     * @example
     * // Create many OfferPrices
     * const offerPrice = await prisma.offerPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferPriceCreateManyArgs>(args?: SelectSubset<T, OfferPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OfferPrices and returns the data saved in the database.
     * @param {OfferPriceCreateManyAndReturnArgs} args - Arguments to create many OfferPrices.
     * @example
     * // Create many OfferPrices
     * const offerPrice = await prisma.offerPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OfferPrices and only return the `id`
     * const offerPriceWithIdOnly = await prisma.offerPrice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OfferPrice.
     * @param {OfferPriceDeleteArgs} args - Arguments to delete one OfferPrice.
     * @example
     * // Delete one OfferPrice
     * const OfferPrice = await prisma.offerPrice.delete({
     *   where: {
     *     // ... filter to delete one OfferPrice
     *   }
     * })
     * 
     */
    delete<T extends OfferPriceDeleteArgs>(args: SelectSubset<T, OfferPriceDeleteArgs<ExtArgs>>): Prisma__OfferPriceClient<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OfferPrice.
     * @param {OfferPriceUpdateArgs} args - Arguments to update one OfferPrice.
     * @example
     * // Update one OfferPrice
     * const offerPrice = await prisma.offerPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferPriceUpdateArgs>(args: SelectSubset<T, OfferPriceUpdateArgs<ExtArgs>>): Prisma__OfferPriceClient<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OfferPrices.
     * @param {OfferPriceDeleteManyArgs} args - Arguments to filter OfferPrices to delete.
     * @example
     * // Delete a few OfferPrices
     * const { count } = await prisma.offerPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferPriceDeleteManyArgs>(args?: SelectSubset<T, OfferPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferPrices
     * const offerPrice = await prisma.offerPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferPriceUpdateManyArgs>(args: SelectSubset<T, OfferPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferPrices and returns the data updated in the database.
     * @param {OfferPriceUpdateManyAndReturnArgs} args - Arguments to update many OfferPrices.
     * @example
     * // Update many OfferPrices
     * const offerPrice = await prisma.offerPrice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OfferPrices and only return the `id`
     * const offerPriceWithIdOnly = await prisma.offerPrice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OfferPriceUpdateManyAndReturnArgs>(args: SelectSubset<T, OfferPriceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OfferPrice.
     * @param {OfferPriceUpsertArgs} args - Arguments to update or create a OfferPrice.
     * @example
     * // Update or create a OfferPrice
     * const offerPrice = await prisma.offerPrice.upsert({
     *   create: {
     *     // ... data to create a OfferPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferPrice we want to update
     *   }
     * })
     */
    upsert<T extends OfferPriceUpsertArgs>(args: SelectSubset<T, OfferPriceUpsertArgs<ExtArgs>>): Prisma__OfferPriceClient<$Result.GetResult<Prisma.$OfferPricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OfferPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPriceCountArgs} args - Arguments to filter OfferPrices to count.
     * @example
     * // Count the number of OfferPrices
     * const count = await prisma.offerPrice.count({
     *   where: {
     *     // ... the filter for the OfferPrices we want to count
     *   }
     * })
    **/
    count<T extends OfferPriceCountArgs>(
      args?: Subset<T, OfferPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferPriceAggregateArgs>(args: Subset<T, OfferPriceAggregateArgs>): Prisma.PrismaPromise<GetOfferPriceAggregateType<T>>

    /**
     * Group by OfferPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferPriceGroupByArgs['orderBy'] }
        : { orderBy?: OfferPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferPrice model
   */
  readonly fields: OfferPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offer<T extends OfferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferDefaultArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfferPrice model
   */
  interface OfferPriceFieldRefs {
    readonly id: FieldRef<"OfferPrice", 'String'>
    readonly offerId: FieldRef<"OfferPrice", 'String'>
    readonly country: FieldRef<"OfferPrice", 'String'>
    readonly currency: FieldRef<"OfferPrice", 'Currency'>
    readonly provider: FieldRef<"OfferPrice", 'PaymentProvider'>
    readonly amountCents: FieldRef<"OfferPrice", 'Int'>
    readonly externalPriceId: FieldRef<"OfferPrice", 'String'>
    readonly active: FieldRef<"OfferPrice", 'Boolean'>
    readonly createdAt: FieldRef<"OfferPrice", 'DateTime'>
    readonly updatedAt: FieldRef<"OfferPrice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OfferPrice findUnique
   */
  export type OfferPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceInclude<ExtArgs> | null
    /**
     * Filter, which OfferPrice to fetch.
     */
    where: OfferPriceWhereUniqueInput
  }

  /**
   * OfferPrice findUniqueOrThrow
   */
  export type OfferPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceInclude<ExtArgs> | null
    /**
     * Filter, which OfferPrice to fetch.
     */
    where: OfferPriceWhereUniqueInput
  }

  /**
   * OfferPrice findFirst
   */
  export type OfferPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceInclude<ExtArgs> | null
    /**
     * Filter, which OfferPrice to fetch.
     */
    where?: OfferPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPrices to fetch.
     */
    orderBy?: OfferPriceOrderByWithRelationInput | OfferPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferPrices.
     */
    cursor?: OfferPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferPrices.
     */
    distinct?: OfferPriceScalarFieldEnum | OfferPriceScalarFieldEnum[]
  }

  /**
   * OfferPrice findFirstOrThrow
   */
  export type OfferPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceInclude<ExtArgs> | null
    /**
     * Filter, which OfferPrice to fetch.
     */
    where?: OfferPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPrices to fetch.
     */
    orderBy?: OfferPriceOrderByWithRelationInput | OfferPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferPrices.
     */
    cursor?: OfferPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferPrices.
     */
    distinct?: OfferPriceScalarFieldEnum | OfferPriceScalarFieldEnum[]
  }

  /**
   * OfferPrice findMany
   */
  export type OfferPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceInclude<ExtArgs> | null
    /**
     * Filter, which OfferPrices to fetch.
     */
    where?: OfferPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPrices to fetch.
     */
    orderBy?: OfferPriceOrderByWithRelationInput | OfferPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferPrices.
     */
    cursor?: OfferPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPrices.
     */
    skip?: number
    distinct?: OfferPriceScalarFieldEnum | OfferPriceScalarFieldEnum[]
  }

  /**
   * OfferPrice create
   */
  export type OfferPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferPrice.
     */
    data: XOR<OfferPriceCreateInput, OfferPriceUncheckedCreateInput>
  }

  /**
   * OfferPrice createMany
   */
  export type OfferPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferPrices.
     */
    data: OfferPriceCreateManyInput | OfferPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OfferPrice createManyAndReturn
   */
  export type OfferPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * The data used to create many OfferPrices.
     */
    data: OfferPriceCreateManyInput | OfferPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OfferPrice update
   */
  export type OfferPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferPrice.
     */
    data: XOR<OfferPriceUpdateInput, OfferPriceUncheckedUpdateInput>
    /**
     * Choose, which OfferPrice to update.
     */
    where: OfferPriceWhereUniqueInput
  }

  /**
   * OfferPrice updateMany
   */
  export type OfferPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferPrices.
     */
    data: XOR<OfferPriceUpdateManyMutationInput, OfferPriceUncheckedUpdateManyInput>
    /**
     * Filter which OfferPrices to update
     */
    where?: OfferPriceWhereInput
    /**
     * Limit how many OfferPrices to update.
     */
    limit?: number
  }

  /**
   * OfferPrice updateManyAndReturn
   */
  export type OfferPriceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * The data used to update OfferPrices.
     */
    data: XOR<OfferPriceUpdateManyMutationInput, OfferPriceUncheckedUpdateManyInput>
    /**
     * Filter which OfferPrices to update
     */
    where?: OfferPriceWhereInput
    /**
     * Limit how many OfferPrices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OfferPrice upsert
   */
  export type OfferPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferPrice to update in case it exists.
     */
    where: OfferPriceWhereUniqueInput
    /**
     * In case the OfferPrice found by the `where` argument doesn't exist, create a new OfferPrice with this data.
     */
    create: XOR<OfferPriceCreateInput, OfferPriceUncheckedCreateInput>
    /**
     * In case the OfferPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferPriceUpdateInput, OfferPriceUncheckedUpdateInput>
  }

  /**
   * OfferPrice delete
   */
  export type OfferPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceInclude<ExtArgs> | null
    /**
     * Filter which OfferPrice to delete.
     */
    where: OfferPriceWhereUniqueInput
  }

  /**
   * OfferPrice deleteMany
   */
  export type OfferPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferPrices to delete
     */
    where?: OfferPriceWhereInput
    /**
     * Limit how many OfferPrices to delete.
     */
    limit?: number
  }

  /**
   * OfferPrice without action
   */
  export type OfferPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPrice
     */
    select?: OfferPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPrice
     */
    omit?: OfferPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPriceInclude<ExtArgs> | null
  }


  /**
   * Model OfferPaymentMethod
   */

  export type AggregateOfferPaymentMethod = {
    _count: OfferPaymentMethodCountAggregateOutputType | null
    _avg: OfferPaymentMethodAvgAggregateOutputType | null
    _sum: OfferPaymentMethodSumAggregateOutputType | null
    _min: OfferPaymentMethodMinAggregateOutputType | null
    _max: OfferPaymentMethodMaxAggregateOutputType | null
  }

  export type OfferPaymentMethodAvgAggregateOutputType = {
    feePercent: number | null
  }

  export type OfferPaymentMethodSumAggregateOutputType = {
    feePercent: number | null
  }

  export type OfferPaymentMethodMinAggregateOutputType = {
    id: string | null
    offerId: string | null
    method: $Enums.PaymentMethod | null
    active: boolean | null
    feePercent: number | null
  }

  export type OfferPaymentMethodMaxAggregateOutputType = {
    id: string | null
    offerId: string | null
    method: $Enums.PaymentMethod | null
    active: boolean | null
    feePercent: number | null
  }

  export type OfferPaymentMethodCountAggregateOutputType = {
    id: number
    offerId: number
    method: number
    active: number
    feePercent: number
    _all: number
  }


  export type OfferPaymentMethodAvgAggregateInputType = {
    feePercent?: true
  }

  export type OfferPaymentMethodSumAggregateInputType = {
    feePercent?: true
  }

  export type OfferPaymentMethodMinAggregateInputType = {
    id?: true
    offerId?: true
    method?: true
    active?: true
    feePercent?: true
  }

  export type OfferPaymentMethodMaxAggregateInputType = {
    id?: true
    offerId?: true
    method?: true
    active?: true
    feePercent?: true
  }

  export type OfferPaymentMethodCountAggregateInputType = {
    id?: true
    offerId?: true
    method?: true
    active?: true
    feePercent?: true
    _all?: true
  }

  export type OfferPaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferPaymentMethod to aggregate.
     */
    where?: OfferPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPaymentMethods to fetch.
     */
    orderBy?: OfferPaymentMethodOrderByWithRelationInput | OfferPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferPaymentMethods
    **/
    _count?: true | OfferPaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferPaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferPaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferPaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferPaymentMethodMaxAggregateInputType
  }

  export type GetOfferPaymentMethodAggregateType<T extends OfferPaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferPaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferPaymentMethod[P]>
      : GetScalarType<T[P], AggregateOfferPaymentMethod[P]>
  }




  export type OfferPaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferPaymentMethodWhereInput
    orderBy?: OfferPaymentMethodOrderByWithAggregationInput | OfferPaymentMethodOrderByWithAggregationInput[]
    by: OfferPaymentMethodScalarFieldEnum[] | OfferPaymentMethodScalarFieldEnum
    having?: OfferPaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferPaymentMethodCountAggregateInputType | true
    _avg?: OfferPaymentMethodAvgAggregateInputType
    _sum?: OfferPaymentMethodSumAggregateInputType
    _min?: OfferPaymentMethodMinAggregateInputType
    _max?: OfferPaymentMethodMaxAggregateInputType
  }

  export type OfferPaymentMethodGroupByOutputType = {
    id: string
    offerId: string
    method: $Enums.PaymentMethod
    active: boolean
    feePercent: number | null
    _count: OfferPaymentMethodCountAggregateOutputType | null
    _avg: OfferPaymentMethodAvgAggregateOutputType | null
    _sum: OfferPaymentMethodSumAggregateOutputType | null
    _min: OfferPaymentMethodMinAggregateOutputType | null
    _max: OfferPaymentMethodMaxAggregateOutputType | null
  }

  type GetOfferPaymentMethodGroupByPayload<T extends OfferPaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferPaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferPaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferPaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], OfferPaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type OfferPaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offerId?: boolean
    method?: boolean
    active?: boolean
    feePercent?: boolean
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offerPaymentMethod"]>

  export type OfferPaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offerId?: boolean
    method?: boolean
    active?: boolean
    feePercent?: boolean
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offerPaymentMethod"]>

  export type OfferPaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offerId?: boolean
    method?: boolean
    active?: boolean
    feePercent?: boolean
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offerPaymentMethod"]>

  export type OfferPaymentMethodSelectScalar = {
    id?: boolean
    offerId?: boolean
    method?: boolean
    active?: boolean
    feePercent?: boolean
  }

  export type OfferPaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "offerId" | "method" | "active" | "feePercent", ExtArgs["result"]["offerPaymentMethod"]>
  export type OfferPaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }
  export type OfferPaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }
  export type OfferPaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }

  export type $OfferPaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfferPaymentMethod"
    objects: {
      offer: Prisma.$OfferPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      offerId: string
      method: $Enums.PaymentMethod
      active: boolean
      feePercent: number | null
    }, ExtArgs["result"]["offerPaymentMethod"]>
    composites: {}
  }

  type OfferPaymentMethodGetPayload<S extends boolean | null | undefined | OfferPaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$OfferPaymentMethodPayload, S>

  type OfferPaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferPaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferPaymentMethodCountAggregateInputType | true
    }

  export interface OfferPaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferPaymentMethod'], meta: { name: 'OfferPaymentMethod' } }
    /**
     * Find zero or one OfferPaymentMethod that matches the filter.
     * @param {OfferPaymentMethodFindUniqueArgs} args - Arguments to find a OfferPaymentMethod
     * @example
     * // Get one OfferPaymentMethod
     * const offerPaymentMethod = await prisma.offerPaymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferPaymentMethodFindUniqueArgs>(args: SelectSubset<T, OfferPaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__OfferPaymentMethodClient<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OfferPaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferPaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a OfferPaymentMethod
     * @example
     * // Get one OfferPaymentMethod
     * const offerPaymentMethod = await prisma.offerPaymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferPaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferPaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferPaymentMethodClient<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferPaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPaymentMethodFindFirstArgs} args - Arguments to find a OfferPaymentMethod
     * @example
     * // Get one OfferPaymentMethod
     * const offerPaymentMethod = await prisma.offerPaymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferPaymentMethodFindFirstArgs>(args?: SelectSubset<T, OfferPaymentMethodFindFirstArgs<ExtArgs>>): Prisma__OfferPaymentMethodClient<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferPaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPaymentMethodFindFirstOrThrowArgs} args - Arguments to find a OfferPaymentMethod
     * @example
     * // Get one OfferPaymentMethod
     * const offerPaymentMethod = await prisma.offerPaymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferPaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferPaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferPaymentMethodClient<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OfferPaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferPaymentMethods
     * const offerPaymentMethods = await prisma.offerPaymentMethod.findMany()
     * 
     * // Get first 10 OfferPaymentMethods
     * const offerPaymentMethods = await prisma.offerPaymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerPaymentMethodWithIdOnly = await prisma.offerPaymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferPaymentMethodFindManyArgs>(args?: SelectSubset<T, OfferPaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OfferPaymentMethod.
     * @param {OfferPaymentMethodCreateArgs} args - Arguments to create a OfferPaymentMethod.
     * @example
     * // Create one OfferPaymentMethod
     * const OfferPaymentMethod = await prisma.offerPaymentMethod.create({
     *   data: {
     *     // ... data to create a OfferPaymentMethod
     *   }
     * })
     * 
     */
    create<T extends OfferPaymentMethodCreateArgs>(args: SelectSubset<T, OfferPaymentMethodCreateArgs<ExtArgs>>): Prisma__OfferPaymentMethodClient<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OfferPaymentMethods.
     * @param {OfferPaymentMethodCreateManyArgs} args - Arguments to create many OfferPaymentMethods.
     * @example
     * // Create many OfferPaymentMethods
     * const offerPaymentMethod = await prisma.offerPaymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferPaymentMethodCreateManyArgs>(args?: SelectSubset<T, OfferPaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OfferPaymentMethods and returns the data saved in the database.
     * @param {OfferPaymentMethodCreateManyAndReturnArgs} args - Arguments to create many OfferPaymentMethods.
     * @example
     * // Create many OfferPaymentMethods
     * const offerPaymentMethod = await prisma.offerPaymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OfferPaymentMethods and only return the `id`
     * const offerPaymentMethodWithIdOnly = await prisma.offerPaymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferPaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferPaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OfferPaymentMethod.
     * @param {OfferPaymentMethodDeleteArgs} args - Arguments to delete one OfferPaymentMethod.
     * @example
     * // Delete one OfferPaymentMethod
     * const OfferPaymentMethod = await prisma.offerPaymentMethod.delete({
     *   where: {
     *     // ... filter to delete one OfferPaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends OfferPaymentMethodDeleteArgs>(args: SelectSubset<T, OfferPaymentMethodDeleteArgs<ExtArgs>>): Prisma__OfferPaymentMethodClient<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OfferPaymentMethod.
     * @param {OfferPaymentMethodUpdateArgs} args - Arguments to update one OfferPaymentMethod.
     * @example
     * // Update one OfferPaymentMethod
     * const offerPaymentMethod = await prisma.offerPaymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferPaymentMethodUpdateArgs>(args: SelectSubset<T, OfferPaymentMethodUpdateArgs<ExtArgs>>): Prisma__OfferPaymentMethodClient<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OfferPaymentMethods.
     * @param {OfferPaymentMethodDeleteManyArgs} args - Arguments to filter OfferPaymentMethods to delete.
     * @example
     * // Delete a few OfferPaymentMethods
     * const { count } = await prisma.offerPaymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferPaymentMethodDeleteManyArgs>(args?: SelectSubset<T, OfferPaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferPaymentMethods
     * const offerPaymentMethod = await prisma.offerPaymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferPaymentMethodUpdateManyArgs>(args: SelectSubset<T, OfferPaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferPaymentMethods and returns the data updated in the database.
     * @param {OfferPaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many OfferPaymentMethods.
     * @example
     * // Update many OfferPaymentMethods
     * const offerPaymentMethod = await prisma.offerPaymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OfferPaymentMethods and only return the `id`
     * const offerPaymentMethodWithIdOnly = await prisma.offerPaymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OfferPaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, OfferPaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OfferPaymentMethod.
     * @param {OfferPaymentMethodUpsertArgs} args - Arguments to update or create a OfferPaymentMethod.
     * @example
     * // Update or create a OfferPaymentMethod
     * const offerPaymentMethod = await prisma.offerPaymentMethod.upsert({
     *   create: {
     *     // ... data to create a OfferPaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferPaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends OfferPaymentMethodUpsertArgs>(args: SelectSubset<T, OfferPaymentMethodUpsertArgs<ExtArgs>>): Prisma__OfferPaymentMethodClient<$Result.GetResult<Prisma.$OfferPaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OfferPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPaymentMethodCountArgs} args - Arguments to filter OfferPaymentMethods to count.
     * @example
     * // Count the number of OfferPaymentMethods
     * const count = await prisma.offerPaymentMethod.count({
     *   where: {
     *     // ... the filter for the OfferPaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends OfferPaymentMethodCountArgs>(
      args?: Subset<T, OfferPaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferPaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferPaymentMethodAggregateArgs>(args: Subset<T, OfferPaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetOfferPaymentMethodAggregateType<T>>

    /**
     * Group by OfferPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferPaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferPaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: OfferPaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferPaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferPaymentMethod model
   */
  readonly fields: OfferPaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferPaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferPaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offer<T extends OfferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferDefaultArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfferPaymentMethod model
   */
  interface OfferPaymentMethodFieldRefs {
    readonly id: FieldRef<"OfferPaymentMethod", 'String'>
    readonly offerId: FieldRef<"OfferPaymentMethod", 'String'>
    readonly method: FieldRef<"OfferPaymentMethod", 'PaymentMethod'>
    readonly active: FieldRef<"OfferPaymentMethod", 'Boolean'>
    readonly feePercent: FieldRef<"OfferPaymentMethod", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OfferPaymentMethod findUnique
   */
  export type OfferPaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which OfferPaymentMethod to fetch.
     */
    where: OfferPaymentMethodWhereUniqueInput
  }

  /**
   * OfferPaymentMethod findUniqueOrThrow
   */
  export type OfferPaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which OfferPaymentMethod to fetch.
     */
    where: OfferPaymentMethodWhereUniqueInput
  }

  /**
   * OfferPaymentMethod findFirst
   */
  export type OfferPaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which OfferPaymentMethod to fetch.
     */
    where?: OfferPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPaymentMethods to fetch.
     */
    orderBy?: OfferPaymentMethodOrderByWithRelationInput | OfferPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferPaymentMethods.
     */
    cursor?: OfferPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferPaymentMethods.
     */
    distinct?: OfferPaymentMethodScalarFieldEnum | OfferPaymentMethodScalarFieldEnum[]
  }

  /**
   * OfferPaymentMethod findFirstOrThrow
   */
  export type OfferPaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which OfferPaymentMethod to fetch.
     */
    where?: OfferPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPaymentMethods to fetch.
     */
    orderBy?: OfferPaymentMethodOrderByWithRelationInput | OfferPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferPaymentMethods.
     */
    cursor?: OfferPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferPaymentMethods.
     */
    distinct?: OfferPaymentMethodScalarFieldEnum | OfferPaymentMethodScalarFieldEnum[]
  }

  /**
   * OfferPaymentMethod findMany
   */
  export type OfferPaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which OfferPaymentMethods to fetch.
     */
    where?: OfferPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPaymentMethods to fetch.
     */
    orderBy?: OfferPaymentMethodOrderByWithRelationInput | OfferPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferPaymentMethods.
     */
    cursor?: OfferPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPaymentMethods.
     */
    skip?: number
    distinct?: OfferPaymentMethodScalarFieldEnum | OfferPaymentMethodScalarFieldEnum[]
  }

  /**
   * OfferPaymentMethod create
   */
  export type OfferPaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferPaymentMethod.
     */
    data: XOR<OfferPaymentMethodCreateInput, OfferPaymentMethodUncheckedCreateInput>
  }

  /**
   * OfferPaymentMethod createMany
   */
  export type OfferPaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferPaymentMethods.
     */
    data: OfferPaymentMethodCreateManyInput | OfferPaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OfferPaymentMethod createManyAndReturn
   */
  export type OfferPaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many OfferPaymentMethods.
     */
    data: OfferPaymentMethodCreateManyInput | OfferPaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OfferPaymentMethod update
   */
  export type OfferPaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferPaymentMethod.
     */
    data: XOR<OfferPaymentMethodUpdateInput, OfferPaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which OfferPaymentMethod to update.
     */
    where: OfferPaymentMethodWhereUniqueInput
  }

  /**
   * OfferPaymentMethod updateMany
   */
  export type OfferPaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferPaymentMethods.
     */
    data: XOR<OfferPaymentMethodUpdateManyMutationInput, OfferPaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which OfferPaymentMethods to update
     */
    where?: OfferPaymentMethodWhereInput
    /**
     * Limit how many OfferPaymentMethods to update.
     */
    limit?: number
  }

  /**
   * OfferPaymentMethod updateManyAndReturn
   */
  export type OfferPaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update OfferPaymentMethods.
     */
    data: XOR<OfferPaymentMethodUpdateManyMutationInput, OfferPaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which OfferPaymentMethods to update
     */
    where?: OfferPaymentMethodWhereInput
    /**
     * Limit how many OfferPaymentMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OfferPaymentMethod upsert
   */
  export type OfferPaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferPaymentMethod to update in case it exists.
     */
    where: OfferPaymentMethodWhereUniqueInput
    /**
     * In case the OfferPaymentMethod found by the `where` argument doesn't exist, create a new OfferPaymentMethod with this data.
     */
    create: XOR<OfferPaymentMethodCreateInput, OfferPaymentMethodUncheckedCreateInput>
    /**
     * In case the OfferPaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferPaymentMethodUpdateInput, OfferPaymentMethodUncheckedUpdateInput>
  }

  /**
   * OfferPaymentMethod delete
   */
  export type OfferPaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which OfferPaymentMethod to delete.
     */
    where: OfferPaymentMethodWhereUniqueInput
  }

  /**
   * OfferPaymentMethod deleteMany
   */
  export type OfferPaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferPaymentMethods to delete
     */
    where?: OfferPaymentMethodWhereInput
    /**
     * Limit how many OfferPaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * OfferPaymentMethod without action
   */
  export type OfferPaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPaymentMethod
     */
    select?: OfferPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferPaymentMethod
     */
    omit?: OfferPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferPaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model ProductIntegration
   */

  export type AggregateProductIntegration = {
    _count: ProductIntegrationCountAggregateOutputType | null
    _min: ProductIntegrationMinAggregateOutputType | null
    _max: ProductIntegrationMaxAggregateOutputType | null
  }

  export type ProductIntegrationMinAggregateOutputType = {
    id: string | null
    productId: string | null
    provider: $Enums.PaymentProvider | null
    externalProductId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductIntegrationMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    provider: $Enums.PaymentProvider | null
    externalProductId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductIntegrationCountAggregateOutputType = {
    id: number
    productId: number
    provider: number
    externalProductId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductIntegrationMinAggregateInputType = {
    id?: true
    productId?: true
    provider?: true
    externalProductId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductIntegrationMaxAggregateInputType = {
    id?: true
    productId?: true
    provider?: true
    externalProductId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductIntegrationCountAggregateInputType = {
    id?: true
    productId?: true
    provider?: true
    externalProductId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductIntegration to aggregate.
     */
    where?: ProductIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductIntegrations to fetch.
     */
    orderBy?: ProductIntegrationOrderByWithRelationInput | ProductIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductIntegrations
    **/
    _count?: true | ProductIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductIntegrationMaxAggregateInputType
  }

  export type GetProductIntegrationAggregateType<T extends ProductIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateProductIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductIntegration[P]>
      : GetScalarType<T[P], AggregateProductIntegration[P]>
  }




  export type ProductIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductIntegrationWhereInput
    orderBy?: ProductIntegrationOrderByWithAggregationInput | ProductIntegrationOrderByWithAggregationInput[]
    by: ProductIntegrationScalarFieldEnum[] | ProductIntegrationScalarFieldEnum
    having?: ProductIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductIntegrationCountAggregateInputType | true
    _min?: ProductIntegrationMinAggregateInputType
    _max?: ProductIntegrationMaxAggregateInputType
  }

  export type ProductIntegrationGroupByOutputType = {
    id: string
    productId: string
    provider: $Enums.PaymentProvider
    externalProductId: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProductIntegrationCountAggregateOutputType | null
    _min: ProductIntegrationMinAggregateOutputType | null
    _max: ProductIntegrationMaxAggregateOutputType | null
  }

  type GetProductIntegrationGroupByPayload<T extends ProductIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type ProductIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    provider?: boolean
    externalProductId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productIntegration"]>

  export type ProductIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    provider?: boolean
    externalProductId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productIntegration"]>

  export type ProductIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    provider?: boolean
    externalProductId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productIntegration"]>

  export type ProductIntegrationSelectScalar = {
    id?: boolean
    productId?: boolean
    provider?: boolean
    externalProductId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "provider" | "externalProductId" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["productIntegration"]>
  export type ProductIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductIntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductIntegration"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      provider: $Enums.PaymentProvider
      externalProductId: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productIntegration"]>
    composites: {}
  }

  type ProductIntegrationGetPayload<S extends boolean | null | undefined | ProductIntegrationDefaultArgs> = $Result.GetResult<Prisma.$ProductIntegrationPayload, S>

  type ProductIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductIntegrationCountAggregateInputType | true
    }

  export interface ProductIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductIntegration'], meta: { name: 'ProductIntegration' } }
    /**
     * Find zero or one ProductIntegration that matches the filter.
     * @param {ProductIntegrationFindUniqueArgs} args - Arguments to find a ProductIntegration
     * @example
     * // Get one ProductIntegration
     * const productIntegration = await prisma.productIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductIntegrationFindUniqueArgs>(args: SelectSubset<T, ProductIntegrationFindUniqueArgs<ExtArgs>>): Prisma__ProductIntegrationClient<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductIntegrationFindUniqueOrThrowArgs} args - Arguments to find a ProductIntegration
     * @example
     * // Get one ProductIntegration
     * const productIntegration = await prisma.productIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductIntegrationClient<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIntegrationFindFirstArgs} args - Arguments to find a ProductIntegration
     * @example
     * // Get one ProductIntegration
     * const productIntegration = await prisma.productIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductIntegrationFindFirstArgs>(args?: SelectSubset<T, ProductIntegrationFindFirstArgs<ExtArgs>>): Prisma__ProductIntegrationClient<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIntegrationFindFirstOrThrowArgs} args - Arguments to find a ProductIntegration
     * @example
     * // Get one ProductIntegration
     * const productIntegration = await prisma.productIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductIntegrationClient<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductIntegrations
     * const productIntegrations = await prisma.productIntegration.findMany()
     * 
     * // Get first 10 ProductIntegrations
     * const productIntegrations = await prisma.productIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productIntegrationWithIdOnly = await prisma.productIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductIntegrationFindManyArgs>(args?: SelectSubset<T, ProductIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductIntegration.
     * @param {ProductIntegrationCreateArgs} args - Arguments to create a ProductIntegration.
     * @example
     * // Create one ProductIntegration
     * const ProductIntegration = await prisma.productIntegration.create({
     *   data: {
     *     // ... data to create a ProductIntegration
     *   }
     * })
     * 
     */
    create<T extends ProductIntegrationCreateArgs>(args: SelectSubset<T, ProductIntegrationCreateArgs<ExtArgs>>): Prisma__ProductIntegrationClient<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductIntegrations.
     * @param {ProductIntegrationCreateManyArgs} args - Arguments to create many ProductIntegrations.
     * @example
     * // Create many ProductIntegrations
     * const productIntegration = await prisma.productIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductIntegrationCreateManyArgs>(args?: SelectSubset<T, ProductIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductIntegrations and returns the data saved in the database.
     * @param {ProductIntegrationCreateManyAndReturnArgs} args - Arguments to create many ProductIntegrations.
     * @example
     * // Create many ProductIntegrations
     * const productIntegration = await prisma.productIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductIntegrations and only return the `id`
     * const productIntegrationWithIdOnly = await prisma.productIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductIntegration.
     * @param {ProductIntegrationDeleteArgs} args - Arguments to delete one ProductIntegration.
     * @example
     * // Delete one ProductIntegration
     * const ProductIntegration = await prisma.productIntegration.delete({
     *   where: {
     *     // ... filter to delete one ProductIntegration
     *   }
     * })
     * 
     */
    delete<T extends ProductIntegrationDeleteArgs>(args: SelectSubset<T, ProductIntegrationDeleteArgs<ExtArgs>>): Prisma__ProductIntegrationClient<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductIntegration.
     * @param {ProductIntegrationUpdateArgs} args - Arguments to update one ProductIntegration.
     * @example
     * // Update one ProductIntegration
     * const productIntegration = await prisma.productIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductIntegrationUpdateArgs>(args: SelectSubset<T, ProductIntegrationUpdateArgs<ExtArgs>>): Prisma__ProductIntegrationClient<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductIntegrations.
     * @param {ProductIntegrationDeleteManyArgs} args - Arguments to filter ProductIntegrations to delete.
     * @example
     * // Delete a few ProductIntegrations
     * const { count } = await prisma.productIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductIntegrationDeleteManyArgs>(args?: SelectSubset<T, ProductIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductIntegrations
     * const productIntegration = await prisma.productIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductIntegrationUpdateManyArgs>(args: SelectSubset<T, ProductIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductIntegrations and returns the data updated in the database.
     * @param {ProductIntegrationUpdateManyAndReturnArgs} args - Arguments to update many ProductIntegrations.
     * @example
     * // Update many ProductIntegrations
     * const productIntegration = await prisma.productIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductIntegrations and only return the `id`
     * const productIntegrationWithIdOnly = await prisma.productIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductIntegration.
     * @param {ProductIntegrationUpsertArgs} args - Arguments to update or create a ProductIntegration.
     * @example
     * // Update or create a ProductIntegration
     * const productIntegration = await prisma.productIntegration.upsert({
     *   create: {
     *     // ... data to create a ProductIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductIntegration we want to update
     *   }
     * })
     */
    upsert<T extends ProductIntegrationUpsertArgs>(args: SelectSubset<T, ProductIntegrationUpsertArgs<ExtArgs>>): Prisma__ProductIntegrationClient<$Result.GetResult<Prisma.$ProductIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIntegrationCountArgs} args - Arguments to filter ProductIntegrations to count.
     * @example
     * // Count the number of ProductIntegrations
     * const count = await prisma.productIntegration.count({
     *   where: {
     *     // ... the filter for the ProductIntegrations we want to count
     *   }
     * })
    **/
    count<T extends ProductIntegrationCountArgs>(
      args?: Subset<T, ProductIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductIntegrationAggregateArgs>(args: Subset<T, ProductIntegrationAggregateArgs>): Prisma.PrismaPromise<GetProductIntegrationAggregateType<T>>

    /**
     * Group by ProductIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: ProductIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductIntegration model
   */
  readonly fields: ProductIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductIntegration model
   */
  interface ProductIntegrationFieldRefs {
    readonly id: FieldRef<"ProductIntegration", 'String'>
    readonly productId: FieldRef<"ProductIntegration", 'String'>
    readonly provider: FieldRef<"ProductIntegration", 'PaymentProvider'>
    readonly externalProductId: FieldRef<"ProductIntegration", 'String'>
    readonly metadata: FieldRef<"ProductIntegration", 'Json'>
    readonly createdAt: FieldRef<"ProductIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductIntegration findUnique
   */
  export type ProductIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which ProductIntegration to fetch.
     */
    where: ProductIntegrationWhereUniqueInput
  }

  /**
   * ProductIntegration findUniqueOrThrow
   */
  export type ProductIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which ProductIntegration to fetch.
     */
    where: ProductIntegrationWhereUniqueInput
  }

  /**
   * ProductIntegration findFirst
   */
  export type ProductIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which ProductIntegration to fetch.
     */
    where?: ProductIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductIntegrations to fetch.
     */
    orderBy?: ProductIntegrationOrderByWithRelationInput | ProductIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductIntegrations.
     */
    cursor?: ProductIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductIntegrations.
     */
    distinct?: ProductIntegrationScalarFieldEnum | ProductIntegrationScalarFieldEnum[]
  }

  /**
   * ProductIntegration findFirstOrThrow
   */
  export type ProductIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which ProductIntegration to fetch.
     */
    where?: ProductIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductIntegrations to fetch.
     */
    orderBy?: ProductIntegrationOrderByWithRelationInput | ProductIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductIntegrations.
     */
    cursor?: ProductIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductIntegrations.
     */
    distinct?: ProductIntegrationScalarFieldEnum | ProductIntegrationScalarFieldEnum[]
  }

  /**
   * ProductIntegration findMany
   */
  export type ProductIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which ProductIntegrations to fetch.
     */
    where?: ProductIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductIntegrations to fetch.
     */
    orderBy?: ProductIntegrationOrderByWithRelationInput | ProductIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductIntegrations.
     */
    cursor?: ProductIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductIntegrations.
     */
    skip?: number
    distinct?: ProductIntegrationScalarFieldEnum | ProductIntegrationScalarFieldEnum[]
  }

  /**
   * ProductIntegration create
   */
  export type ProductIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductIntegration.
     */
    data: XOR<ProductIntegrationCreateInput, ProductIntegrationUncheckedCreateInput>
  }

  /**
   * ProductIntegration createMany
   */
  export type ProductIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductIntegrations.
     */
    data: ProductIntegrationCreateManyInput | ProductIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductIntegration createManyAndReturn
   */
  export type ProductIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many ProductIntegrations.
     */
    data: ProductIntegrationCreateManyInput | ProductIntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductIntegration update
   */
  export type ProductIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductIntegration.
     */
    data: XOR<ProductIntegrationUpdateInput, ProductIntegrationUncheckedUpdateInput>
    /**
     * Choose, which ProductIntegration to update.
     */
    where: ProductIntegrationWhereUniqueInput
  }

  /**
   * ProductIntegration updateMany
   */
  export type ProductIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductIntegrations.
     */
    data: XOR<ProductIntegrationUpdateManyMutationInput, ProductIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which ProductIntegrations to update
     */
    where?: ProductIntegrationWhereInput
    /**
     * Limit how many ProductIntegrations to update.
     */
    limit?: number
  }

  /**
   * ProductIntegration updateManyAndReturn
   */
  export type ProductIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update ProductIntegrations.
     */
    data: XOR<ProductIntegrationUpdateManyMutationInput, ProductIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which ProductIntegrations to update
     */
    where?: ProductIntegrationWhereInput
    /**
     * Limit how many ProductIntegrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductIntegration upsert
   */
  export type ProductIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductIntegration to update in case it exists.
     */
    where: ProductIntegrationWhereUniqueInput
    /**
     * In case the ProductIntegration found by the `where` argument doesn't exist, create a new ProductIntegration with this data.
     */
    create: XOR<ProductIntegrationCreateInput, ProductIntegrationUncheckedCreateInput>
    /**
     * In case the ProductIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductIntegrationUpdateInput, ProductIntegrationUncheckedUpdateInput>
  }

  /**
   * ProductIntegration delete
   */
  export type ProductIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationInclude<ExtArgs> | null
    /**
     * Filter which ProductIntegration to delete.
     */
    where: ProductIntegrationWhereUniqueInput
  }

  /**
   * ProductIntegration deleteMany
   */
  export type ProductIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductIntegrations to delete
     */
    where?: ProductIntegrationWhereInput
    /**
     * Limit how many ProductIntegrations to delete.
     */
    limit?: number
  }

  /**
   * ProductIntegration without action
   */
  export type ProductIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIntegration
     */
    select?: ProductIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductIntegration
     */
    omit?: ProductIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIntegrationInclude<ExtArgs> | null
  }


  /**
   * Model CheckoutSession
   */

  export type AggregateCheckoutSession = {
    _count: CheckoutSessionCountAggregateOutputType | null
    _avg: CheckoutSessionAvgAggregateOutputType | null
    _sum: CheckoutSessionSumAggregateOutputType | null
    _min: CheckoutSessionMinAggregateOutputType | null
    _max: CheckoutSessionMaxAggregateOutputType | null
  }

  export type CheckoutSessionAvgAggregateOutputType = {
    selectedInstallments: number | null
    conversionLikelihood: number | null
  }

  export type CheckoutSessionSumAggregateOutputType = {
    selectedInstallments: number | null
    conversionLikelihood: number | null
  }

  export type CheckoutSessionMinAggregateOutputType = {
    id: string | null
    resumeToken: string | null
    clinicId: string | null
    productId: string | null
    offerId: string | null
    slug: string | null
    provider: $Enums.PaymentProvider | null
    country: string | null
    locale: string | null
    status: $Enums.CheckoutSessionStatus | null
    paymentMethod: $Enums.CheckoutPaymentMethod | null
    orderId: string | null
    pixOrderId: string | null
    pixExpiresAt: Date | null
    paymentTransactionId: string | null
    email: string | null
    phone: string | null
    document: string | null
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    utmTerm: string | null
    utmContent: string | null
    referrer: string | null
    ip: string | null
    userAgent: string | null
    selectedInstallments: number | null
    selectedBank: string | null
    startedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastHeartbeatAt: Date | null
    lastStep: string | null
    reminderExpiringSentAt: Date | null
    reminderExpiredSentAt: Date | null
    conversionLikelihood: number | null
    origin: string | null
    createdBy: string | null
  }

  export type CheckoutSessionMaxAggregateOutputType = {
    id: string | null
    resumeToken: string | null
    clinicId: string | null
    productId: string | null
    offerId: string | null
    slug: string | null
    provider: $Enums.PaymentProvider | null
    country: string | null
    locale: string | null
    status: $Enums.CheckoutSessionStatus | null
    paymentMethod: $Enums.CheckoutPaymentMethod | null
    orderId: string | null
    pixOrderId: string | null
    pixExpiresAt: Date | null
    paymentTransactionId: string | null
    email: string | null
    phone: string | null
    document: string | null
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    utmTerm: string | null
    utmContent: string | null
    referrer: string | null
    ip: string | null
    userAgent: string | null
    selectedInstallments: number | null
    selectedBank: string | null
    startedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastHeartbeatAt: Date | null
    lastStep: string | null
    reminderExpiringSentAt: Date | null
    reminderExpiredSentAt: Date | null
    conversionLikelihood: number | null
    origin: string | null
    createdBy: string | null
  }

  export type CheckoutSessionCountAggregateOutputType = {
    id: number
    resumeToken: number
    clinicId: number
    productId: number
    offerId: number
    slug: number
    provider: number
    country: number
    locale: number
    status: number
    paymentMethod: number
    orderId: number
    pixOrderId: number
    pixExpiresAt: number
    paymentTransactionId: number
    email: number
    phone: number
    document: number
    utmSource: number
    utmMedium: number
    utmCampaign: number
    utmTerm: number
    utmContent: number
    referrer: number
    ip: number
    userAgent: number
    selectedInstallments: number
    selectedBank: number
    paymentMethodsAllowed: number
    metadata: number
    startedAt: number
    createdAt: number
    updatedAt: number
    lastHeartbeatAt: number
    lastStep: number
    reminders: number
    reminderExpiringSentAt: number
    reminderExpiredSentAt: number
    conversionLikelihood: number
    origin: number
    createdBy: number
    _all: number
  }


  export type CheckoutSessionAvgAggregateInputType = {
    selectedInstallments?: true
    conversionLikelihood?: true
  }

  export type CheckoutSessionSumAggregateInputType = {
    selectedInstallments?: true
    conversionLikelihood?: true
  }

  export type CheckoutSessionMinAggregateInputType = {
    id?: true
    resumeToken?: true
    clinicId?: true
    productId?: true
    offerId?: true
    slug?: true
    provider?: true
    country?: true
    locale?: true
    status?: true
    paymentMethod?: true
    orderId?: true
    pixOrderId?: true
    pixExpiresAt?: true
    paymentTransactionId?: true
    email?: true
    phone?: true
    document?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    utmTerm?: true
    utmContent?: true
    referrer?: true
    ip?: true
    userAgent?: true
    selectedInstallments?: true
    selectedBank?: true
    startedAt?: true
    createdAt?: true
    updatedAt?: true
    lastHeartbeatAt?: true
    lastStep?: true
    reminderExpiringSentAt?: true
    reminderExpiredSentAt?: true
    conversionLikelihood?: true
    origin?: true
    createdBy?: true
  }

  export type CheckoutSessionMaxAggregateInputType = {
    id?: true
    resumeToken?: true
    clinicId?: true
    productId?: true
    offerId?: true
    slug?: true
    provider?: true
    country?: true
    locale?: true
    status?: true
    paymentMethod?: true
    orderId?: true
    pixOrderId?: true
    pixExpiresAt?: true
    paymentTransactionId?: true
    email?: true
    phone?: true
    document?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    utmTerm?: true
    utmContent?: true
    referrer?: true
    ip?: true
    userAgent?: true
    selectedInstallments?: true
    selectedBank?: true
    startedAt?: true
    createdAt?: true
    updatedAt?: true
    lastHeartbeatAt?: true
    lastStep?: true
    reminderExpiringSentAt?: true
    reminderExpiredSentAt?: true
    conversionLikelihood?: true
    origin?: true
    createdBy?: true
  }

  export type CheckoutSessionCountAggregateInputType = {
    id?: true
    resumeToken?: true
    clinicId?: true
    productId?: true
    offerId?: true
    slug?: true
    provider?: true
    country?: true
    locale?: true
    status?: true
    paymentMethod?: true
    orderId?: true
    pixOrderId?: true
    pixExpiresAt?: true
    paymentTransactionId?: true
    email?: true
    phone?: true
    document?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    utmTerm?: true
    utmContent?: true
    referrer?: true
    ip?: true
    userAgent?: true
    selectedInstallments?: true
    selectedBank?: true
    paymentMethodsAllowed?: true
    metadata?: true
    startedAt?: true
    createdAt?: true
    updatedAt?: true
    lastHeartbeatAt?: true
    lastStep?: true
    reminders?: true
    reminderExpiringSentAt?: true
    reminderExpiredSentAt?: true
    conversionLikelihood?: true
    origin?: true
    createdBy?: true
    _all?: true
  }

  export type CheckoutSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckoutSession to aggregate.
     */
    where?: CheckoutSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckoutSessions to fetch.
     */
    orderBy?: CheckoutSessionOrderByWithRelationInput | CheckoutSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckoutSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckoutSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckoutSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckoutSessions
    **/
    _count?: true | CheckoutSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckoutSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckoutSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckoutSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckoutSessionMaxAggregateInputType
  }

  export type GetCheckoutSessionAggregateType<T extends CheckoutSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckoutSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckoutSession[P]>
      : GetScalarType<T[P], AggregateCheckoutSession[P]>
  }




  export type CheckoutSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckoutSessionWhereInput
    orderBy?: CheckoutSessionOrderByWithAggregationInput | CheckoutSessionOrderByWithAggregationInput[]
    by: CheckoutSessionScalarFieldEnum[] | CheckoutSessionScalarFieldEnum
    having?: CheckoutSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckoutSessionCountAggregateInputType | true
    _avg?: CheckoutSessionAvgAggregateInputType
    _sum?: CheckoutSessionSumAggregateInputType
    _min?: CheckoutSessionMinAggregateInputType
    _max?: CheckoutSessionMaxAggregateInputType
  }

  export type CheckoutSessionGroupByOutputType = {
    id: string
    resumeToken: string
    clinicId: string | null
    productId: string | null
    offerId: string | null
    slug: string | null
    provider: $Enums.PaymentProvider | null
    country: string | null
    locale: string | null
    status: $Enums.CheckoutSessionStatus
    paymentMethod: $Enums.CheckoutPaymentMethod | null
    orderId: string | null
    pixOrderId: string | null
    pixExpiresAt: Date | null
    paymentTransactionId: string | null
    email: string | null
    phone: string | null
    document: string | null
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    utmTerm: string | null
    utmContent: string | null
    referrer: string | null
    ip: string | null
    userAgent: string | null
    selectedInstallments: number | null
    selectedBank: string | null
    paymentMethodsAllowed: JsonValue | null
    metadata: JsonValue | null
    startedAt: Date
    createdAt: Date
    updatedAt: Date
    lastHeartbeatAt: Date | null
    lastStep: string | null
    reminders: JsonValue | null
    reminderExpiringSentAt: Date | null
    reminderExpiredSentAt: Date | null
    conversionLikelihood: number | null
    origin: string | null
    createdBy: string | null
    _count: CheckoutSessionCountAggregateOutputType | null
    _avg: CheckoutSessionAvgAggregateOutputType | null
    _sum: CheckoutSessionSumAggregateOutputType | null
    _min: CheckoutSessionMinAggregateOutputType | null
    _max: CheckoutSessionMaxAggregateOutputType | null
  }

  type GetCheckoutSessionGroupByPayload<T extends CheckoutSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckoutSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckoutSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckoutSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CheckoutSessionGroupByOutputType[P]>
        }
      >
    >


  export type CheckoutSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeToken?: boolean
    clinicId?: boolean
    productId?: boolean
    offerId?: boolean
    slug?: boolean
    provider?: boolean
    country?: boolean
    locale?: boolean
    status?: boolean
    paymentMethod?: boolean
    orderId?: boolean
    pixOrderId?: boolean
    pixExpiresAt?: boolean
    paymentTransactionId?: boolean
    email?: boolean
    phone?: boolean
    document?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    utmTerm?: boolean
    utmContent?: boolean
    referrer?: boolean
    ip?: boolean
    userAgent?: boolean
    selectedInstallments?: boolean
    selectedBank?: boolean
    paymentMethodsAllowed?: boolean
    metadata?: boolean
    startedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastHeartbeatAt?: boolean
    lastStep?: boolean
    reminders?: boolean
    reminderExpiringSentAt?: boolean
    reminderExpiredSentAt?: boolean
    conversionLikelihood?: boolean
    origin?: boolean
    createdBy?: boolean
    paymentTransaction?: boolean | CheckoutSession$paymentTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["checkoutSession"]>

  export type CheckoutSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeToken?: boolean
    clinicId?: boolean
    productId?: boolean
    offerId?: boolean
    slug?: boolean
    provider?: boolean
    country?: boolean
    locale?: boolean
    status?: boolean
    paymentMethod?: boolean
    orderId?: boolean
    pixOrderId?: boolean
    pixExpiresAt?: boolean
    paymentTransactionId?: boolean
    email?: boolean
    phone?: boolean
    document?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    utmTerm?: boolean
    utmContent?: boolean
    referrer?: boolean
    ip?: boolean
    userAgent?: boolean
    selectedInstallments?: boolean
    selectedBank?: boolean
    paymentMethodsAllowed?: boolean
    metadata?: boolean
    startedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastHeartbeatAt?: boolean
    lastStep?: boolean
    reminders?: boolean
    reminderExpiringSentAt?: boolean
    reminderExpiredSentAt?: boolean
    conversionLikelihood?: boolean
    origin?: boolean
    createdBy?: boolean
    paymentTransaction?: boolean | CheckoutSession$paymentTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["checkoutSession"]>

  export type CheckoutSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeToken?: boolean
    clinicId?: boolean
    productId?: boolean
    offerId?: boolean
    slug?: boolean
    provider?: boolean
    country?: boolean
    locale?: boolean
    status?: boolean
    paymentMethod?: boolean
    orderId?: boolean
    pixOrderId?: boolean
    pixExpiresAt?: boolean
    paymentTransactionId?: boolean
    email?: boolean
    phone?: boolean
    document?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    utmTerm?: boolean
    utmContent?: boolean
    referrer?: boolean
    ip?: boolean
    userAgent?: boolean
    selectedInstallments?: boolean
    selectedBank?: boolean
    paymentMethodsAllowed?: boolean
    metadata?: boolean
    startedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastHeartbeatAt?: boolean
    lastStep?: boolean
    reminders?: boolean
    reminderExpiringSentAt?: boolean
    reminderExpiredSentAt?: boolean
    conversionLikelihood?: boolean
    origin?: boolean
    createdBy?: boolean
    paymentTransaction?: boolean | CheckoutSession$paymentTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["checkoutSession"]>

  export type CheckoutSessionSelectScalar = {
    id?: boolean
    resumeToken?: boolean
    clinicId?: boolean
    productId?: boolean
    offerId?: boolean
    slug?: boolean
    provider?: boolean
    country?: boolean
    locale?: boolean
    status?: boolean
    paymentMethod?: boolean
    orderId?: boolean
    pixOrderId?: boolean
    pixExpiresAt?: boolean
    paymentTransactionId?: boolean
    email?: boolean
    phone?: boolean
    document?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    utmTerm?: boolean
    utmContent?: boolean
    referrer?: boolean
    ip?: boolean
    userAgent?: boolean
    selectedInstallments?: boolean
    selectedBank?: boolean
    paymentMethodsAllowed?: boolean
    metadata?: boolean
    startedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastHeartbeatAt?: boolean
    lastStep?: boolean
    reminders?: boolean
    reminderExpiringSentAt?: boolean
    reminderExpiredSentAt?: boolean
    conversionLikelihood?: boolean
    origin?: boolean
    createdBy?: boolean
  }

  export type CheckoutSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resumeToken" | "clinicId" | "productId" | "offerId" | "slug" | "provider" | "country" | "locale" | "status" | "paymentMethod" | "orderId" | "pixOrderId" | "pixExpiresAt" | "paymentTransactionId" | "email" | "phone" | "document" | "utmSource" | "utmMedium" | "utmCampaign" | "utmTerm" | "utmContent" | "referrer" | "ip" | "userAgent" | "selectedInstallments" | "selectedBank" | "paymentMethodsAllowed" | "metadata" | "startedAt" | "createdAt" | "updatedAt" | "lastHeartbeatAt" | "lastStep" | "reminders" | "reminderExpiringSentAt" | "reminderExpiredSentAt" | "conversionLikelihood" | "origin" | "createdBy", ExtArgs["result"]["checkoutSession"]>
  export type CheckoutSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentTransaction?: boolean | CheckoutSession$paymentTransactionArgs<ExtArgs>
  }
  export type CheckoutSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentTransaction?: boolean | CheckoutSession$paymentTransactionArgs<ExtArgs>
  }
  export type CheckoutSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentTransaction?: boolean | CheckoutSession$paymentTransactionArgs<ExtArgs>
  }

  export type $CheckoutSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheckoutSession"
    objects: {
      paymentTransaction: Prisma.$PaymentTransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resumeToken: string
      clinicId: string | null
      productId: string | null
      offerId: string | null
      slug: string | null
      provider: $Enums.PaymentProvider | null
      country: string | null
      locale: string | null
      status: $Enums.CheckoutSessionStatus
      paymentMethod: $Enums.CheckoutPaymentMethod | null
      orderId: string | null
      pixOrderId: string | null
      pixExpiresAt: Date | null
      paymentTransactionId: string | null
      email: string | null
      phone: string | null
      document: string | null
      utmSource: string | null
      utmMedium: string | null
      utmCampaign: string | null
      utmTerm: string | null
      utmContent: string | null
      referrer: string | null
      ip: string | null
      userAgent: string | null
      selectedInstallments: number | null
      selectedBank: string | null
      paymentMethodsAllowed: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      startedAt: Date
      createdAt: Date
      updatedAt: Date
      lastHeartbeatAt: Date | null
      lastStep: string | null
      reminders: Prisma.JsonValue | null
      reminderExpiringSentAt: Date | null
      reminderExpiredSentAt: Date | null
      conversionLikelihood: number | null
      origin: string | null
      createdBy: string | null
    }, ExtArgs["result"]["checkoutSession"]>
    composites: {}
  }

  type CheckoutSessionGetPayload<S extends boolean | null | undefined | CheckoutSessionDefaultArgs> = $Result.GetResult<Prisma.$CheckoutSessionPayload, S>

  type CheckoutSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CheckoutSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CheckoutSessionCountAggregateInputType | true
    }

  export interface CheckoutSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckoutSession'], meta: { name: 'CheckoutSession' } }
    /**
     * Find zero or one CheckoutSession that matches the filter.
     * @param {CheckoutSessionFindUniqueArgs} args - Arguments to find a CheckoutSession
     * @example
     * // Get one CheckoutSession
     * const checkoutSession = await prisma.checkoutSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckoutSessionFindUniqueArgs>(args: SelectSubset<T, CheckoutSessionFindUniqueArgs<ExtArgs>>): Prisma__CheckoutSessionClient<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CheckoutSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CheckoutSessionFindUniqueOrThrowArgs} args - Arguments to find a CheckoutSession
     * @example
     * // Get one CheckoutSession
     * const checkoutSession = await prisma.checkoutSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckoutSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckoutSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckoutSessionClient<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CheckoutSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutSessionFindFirstArgs} args - Arguments to find a CheckoutSession
     * @example
     * // Get one CheckoutSession
     * const checkoutSession = await prisma.checkoutSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckoutSessionFindFirstArgs>(args?: SelectSubset<T, CheckoutSessionFindFirstArgs<ExtArgs>>): Prisma__CheckoutSessionClient<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CheckoutSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutSessionFindFirstOrThrowArgs} args - Arguments to find a CheckoutSession
     * @example
     * // Get one CheckoutSession
     * const checkoutSession = await prisma.checkoutSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckoutSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckoutSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckoutSessionClient<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CheckoutSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckoutSessions
     * const checkoutSessions = await prisma.checkoutSession.findMany()
     * 
     * // Get first 10 CheckoutSessions
     * const checkoutSessions = await prisma.checkoutSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkoutSessionWithIdOnly = await prisma.checkoutSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheckoutSessionFindManyArgs>(args?: SelectSubset<T, CheckoutSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CheckoutSession.
     * @param {CheckoutSessionCreateArgs} args - Arguments to create a CheckoutSession.
     * @example
     * // Create one CheckoutSession
     * const CheckoutSession = await prisma.checkoutSession.create({
     *   data: {
     *     // ... data to create a CheckoutSession
     *   }
     * })
     * 
     */
    create<T extends CheckoutSessionCreateArgs>(args: SelectSubset<T, CheckoutSessionCreateArgs<ExtArgs>>): Prisma__CheckoutSessionClient<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CheckoutSessions.
     * @param {CheckoutSessionCreateManyArgs} args - Arguments to create many CheckoutSessions.
     * @example
     * // Create many CheckoutSessions
     * const checkoutSession = await prisma.checkoutSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckoutSessionCreateManyArgs>(args?: SelectSubset<T, CheckoutSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CheckoutSessions and returns the data saved in the database.
     * @param {CheckoutSessionCreateManyAndReturnArgs} args - Arguments to create many CheckoutSessions.
     * @example
     * // Create many CheckoutSessions
     * const checkoutSession = await prisma.checkoutSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CheckoutSessions and only return the `id`
     * const checkoutSessionWithIdOnly = await prisma.checkoutSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheckoutSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CheckoutSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CheckoutSession.
     * @param {CheckoutSessionDeleteArgs} args - Arguments to delete one CheckoutSession.
     * @example
     * // Delete one CheckoutSession
     * const CheckoutSession = await prisma.checkoutSession.delete({
     *   where: {
     *     // ... filter to delete one CheckoutSession
     *   }
     * })
     * 
     */
    delete<T extends CheckoutSessionDeleteArgs>(args: SelectSubset<T, CheckoutSessionDeleteArgs<ExtArgs>>): Prisma__CheckoutSessionClient<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CheckoutSession.
     * @param {CheckoutSessionUpdateArgs} args - Arguments to update one CheckoutSession.
     * @example
     * // Update one CheckoutSession
     * const checkoutSession = await prisma.checkoutSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckoutSessionUpdateArgs>(args: SelectSubset<T, CheckoutSessionUpdateArgs<ExtArgs>>): Prisma__CheckoutSessionClient<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CheckoutSessions.
     * @param {CheckoutSessionDeleteManyArgs} args - Arguments to filter CheckoutSessions to delete.
     * @example
     * // Delete a few CheckoutSessions
     * const { count } = await prisma.checkoutSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckoutSessionDeleteManyArgs>(args?: SelectSubset<T, CheckoutSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckoutSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckoutSessions
     * const checkoutSession = await prisma.checkoutSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckoutSessionUpdateManyArgs>(args: SelectSubset<T, CheckoutSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckoutSessions and returns the data updated in the database.
     * @param {CheckoutSessionUpdateManyAndReturnArgs} args - Arguments to update many CheckoutSessions.
     * @example
     * // Update many CheckoutSessions
     * const checkoutSession = await prisma.checkoutSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CheckoutSessions and only return the `id`
     * const checkoutSessionWithIdOnly = await prisma.checkoutSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CheckoutSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, CheckoutSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CheckoutSession.
     * @param {CheckoutSessionUpsertArgs} args - Arguments to update or create a CheckoutSession.
     * @example
     * // Update or create a CheckoutSession
     * const checkoutSession = await prisma.checkoutSession.upsert({
     *   create: {
     *     // ... data to create a CheckoutSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckoutSession we want to update
     *   }
     * })
     */
    upsert<T extends CheckoutSessionUpsertArgs>(args: SelectSubset<T, CheckoutSessionUpsertArgs<ExtArgs>>): Prisma__CheckoutSessionClient<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CheckoutSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutSessionCountArgs} args - Arguments to filter CheckoutSessions to count.
     * @example
     * // Count the number of CheckoutSessions
     * const count = await prisma.checkoutSession.count({
     *   where: {
     *     // ... the filter for the CheckoutSessions we want to count
     *   }
     * })
    **/
    count<T extends CheckoutSessionCountArgs>(
      args?: Subset<T, CheckoutSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckoutSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckoutSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckoutSessionAggregateArgs>(args: Subset<T, CheckoutSessionAggregateArgs>): Prisma.PrismaPromise<GetCheckoutSessionAggregateType<T>>

    /**
     * Group by CheckoutSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckoutSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckoutSessionGroupByArgs['orderBy'] }
        : { orderBy?: CheckoutSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckoutSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckoutSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheckoutSession model
   */
  readonly fields: CheckoutSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckoutSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckoutSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paymentTransaction<T extends CheckoutSession$paymentTransactionArgs<ExtArgs> = {}>(args?: Subset<T, CheckoutSession$paymentTransactionArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CheckoutSession model
   */
  interface CheckoutSessionFieldRefs {
    readonly id: FieldRef<"CheckoutSession", 'String'>
    readonly resumeToken: FieldRef<"CheckoutSession", 'String'>
    readonly clinicId: FieldRef<"CheckoutSession", 'String'>
    readonly productId: FieldRef<"CheckoutSession", 'String'>
    readonly offerId: FieldRef<"CheckoutSession", 'String'>
    readonly slug: FieldRef<"CheckoutSession", 'String'>
    readonly provider: FieldRef<"CheckoutSession", 'PaymentProvider'>
    readonly country: FieldRef<"CheckoutSession", 'String'>
    readonly locale: FieldRef<"CheckoutSession", 'String'>
    readonly status: FieldRef<"CheckoutSession", 'CheckoutSessionStatus'>
    readonly paymentMethod: FieldRef<"CheckoutSession", 'CheckoutPaymentMethod'>
    readonly orderId: FieldRef<"CheckoutSession", 'String'>
    readonly pixOrderId: FieldRef<"CheckoutSession", 'String'>
    readonly pixExpiresAt: FieldRef<"CheckoutSession", 'DateTime'>
    readonly paymentTransactionId: FieldRef<"CheckoutSession", 'String'>
    readonly email: FieldRef<"CheckoutSession", 'String'>
    readonly phone: FieldRef<"CheckoutSession", 'String'>
    readonly document: FieldRef<"CheckoutSession", 'String'>
    readonly utmSource: FieldRef<"CheckoutSession", 'String'>
    readonly utmMedium: FieldRef<"CheckoutSession", 'String'>
    readonly utmCampaign: FieldRef<"CheckoutSession", 'String'>
    readonly utmTerm: FieldRef<"CheckoutSession", 'String'>
    readonly utmContent: FieldRef<"CheckoutSession", 'String'>
    readonly referrer: FieldRef<"CheckoutSession", 'String'>
    readonly ip: FieldRef<"CheckoutSession", 'String'>
    readonly userAgent: FieldRef<"CheckoutSession", 'String'>
    readonly selectedInstallments: FieldRef<"CheckoutSession", 'Int'>
    readonly selectedBank: FieldRef<"CheckoutSession", 'String'>
    readonly paymentMethodsAllowed: FieldRef<"CheckoutSession", 'Json'>
    readonly metadata: FieldRef<"CheckoutSession", 'Json'>
    readonly startedAt: FieldRef<"CheckoutSession", 'DateTime'>
    readonly createdAt: FieldRef<"CheckoutSession", 'DateTime'>
    readonly updatedAt: FieldRef<"CheckoutSession", 'DateTime'>
    readonly lastHeartbeatAt: FieldRef<"CheckoutSession", 'DateTime'>
    readonly lastStep: FieldRef<"CheckoutSession", 'String'>
    readonly reminders: FieldRef<"CheckoutSession", 'Json'>
    readonly reminderExpiringSentAt: FieldRef<"CheckoutSession", 'DateTime'>
    readonly reminderExpiredSentAt: FieldRef<"CheckoutSession", 'DateTime'>
    readonly conversionLikelihood: FieldRef<"CheckoutSession", 'Float'>
    readonly origin: FieldRef<"CheckoutSession", 'String'>
    readonly createdBy: FieldRef<"CheckoutSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CheckoutSession findUnique
   */
  export type CheckoutSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionInclude<ExtArgs> | null
    /**
     * Filter, which CheckoutSession to fetch.
     */
    where: CheckoutSessionWhereUniqueInput
  }

  /**
   * CheckoutSession findUniqueOrThrow
   */
  export type CheckoutSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionInclude<ExtArgs> | null
    /**
     * Filter, which CheckoutSession to fetch.
     */
    where: CheckoutSessionWhereUniqueInput
  }

  /**
   * CheckoutSession findFirst
   */
  export type CheckoutSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionInclude<ExtArgs> | null
    /**
     * Filter, which CheckoutSession to fetch.
     */
    where?: CheckoutSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckoutSessions to fetch.
     */
    orderBy?: CheckoutSessionOrderByWithRelationInput | CheckoutSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckoutSessions.
     */
    cursor?: CheckoutSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckoutSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckoutSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckoutSessions.
     */
    distinct?: CheckoutSessionScalarFieldEnum | CheckoutSessionScalarFieldEnum[]
  }

  /**
   * CheckoutSession findFirstOrThrow
   */
  export type CheckoutSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionInclude<ExtArgs> | null
    /**
     * Filter, which CheckoutSession to fetch.
     */
    where?: CheckoutSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckoutSessions to fetch.
     */
    orderBy?: CheckoutSessionOrderByWithRelationInput | CheckoutSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckoutSessions.
     */
    cursor?: CheckoutSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckoutSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckoutSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckoutSessions.
     */
    distinct?: CheckoutSessionScalarFieldEnum | CheckoutSessionScalarFieldEnum[]
  }

  /**
   * CheckoutSession findMany
   */
  export type CheckoutSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionInclude<ExtArgs> | null
    /**
     * Filter, which CheckoutSessions to fetch.
     */
    where?: CheckoutSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckoutSessions to fetch.
     */
    orderBy?: CheckoutSessionOrderByWithRelationInput | CheckoutSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckoutSessions.
     */
    cursor?: CheckoutSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckoutSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckoutSessions.
     */
    skip?: number
    distinct?: CheckoutSessionScalarFieldEnum | CheckoutSessionScalarFieldEnum[]
  }

  /**
   * CheckoutSession create
   */
  export type CheckoutSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckoutSession.
     */
    data: XOR<CheckoutSessionCreateInput, CheckoutSessionUncheckedCreateInput>
  }

  /**
   * CheckoutSession createMany
   */
  export type CheckoutSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckoutSessions.
     */
    data: CheckoutSessionCreateManyInput | CheckoutSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CheckoutSession createManyAndReturn
   */
  export type CheckoutSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * The data used to create many CheckoutSessions.
     */
    data: CheckoutSessionCreateManyInput | CheckoutSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheckoutSession update
   */
  export type CheckoutSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckoutSession.
     */
    data: XOR<CheckoutSessionUpdateInput, CheckoutSessionUncheckedUpdateInput>
    /**
     * Choose, which CheckoutSession to update.
     */
    where: CheckoutSessionWhereUniqueInput
  }

  /**
   * CheckoutSession updateMany
   */
  export type CheckoutSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckoutSessions.
     */
    data: XOR<CheckoutSessionUpdateManyMutationInput, CheckoutSessionUncheckedUpdateManyInput>
    /**
     * Filter which CheckoutSessions to update
     */
    where?: CheckoutSessionWhereInput
    /**
     * Limit how many CheckoutSessions to update.
     */
    limit?: number
  }

  /**
   * CheckoutSession updateManyAndReturn
   */
  export type CheckoutSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * The data used to update CheckoutSessions.
     */
    data: XOR<CheckoutSessionUpdateManyMutationInput, CheckoutSessionUncheckedUpdateManyInput>
    /**
     * Filter which CheckoutSessions to update
     */
    where?: CheckoutSessionWhereInput
    /**
     * Limit how many CheckoutSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheckoutSession upsert
   */
  export type CheckoutSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckoutSession to update in case it exists.
     */
    where: CheckoutSessionWhereUniqueInput
    /**
     * In case the CheckoutSession found by the `where` argument doesn't exist, create a new CheckoutSession with this data.
     */
    create: XOR<CheckoutSessionCreateInput, CheckoutSessionUncheckedCreateInput>
    /**
     * In case the CheckoutSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckoutSessionUpdateInput, CheckoutSessionUncheckedUpdateInput>
  }

  /**
   * CheckoutSession delete
   */
  export type CheckoutSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionInclude<ExtArgs> | null
    /**
     * Filter which CheckoutSession to delete.
     */
    where: CheckoutSessionWhereUniqueInput
  }

  /**
   * CheckoutSession deleteMany
   */
  export type CheckoutSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckoutSessions to delete
     */
    where?: CheckoutSessionWhereInput
    /**
     * Limit how many CheckoutSessions to delete.
     */
    limit?: number
  }

  /**
   * CheckoutSession.paymentTransaction
   */
  export type CheckoutSession$paymentTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
  }

  /**
   * CheckoutSession without action
   */
  export type CheckoutSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionInclude<ExtArgs> | null
  }


  /**
   * Model PaymentTransaction
   */

  export type AggregatePaymentTransaction = {
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  export type PaymentTransactionAvgAggregateOutputType = {
    amountCents: number | null
    installments: number | null
  }

  export type PaymentTransactionSumAggregateOutputType = {
    amountCents: number | null
    installments: number | null
  }

  export type PaymentTransactionMinAggregateOutputType = {
    id: string | null
    provider: string | null
    providerOrderId: string | null
    providerChargeId: string | null
    doctorId: string | null
    patientProfileId: string | null
    clinicId: string | null
    merchantId: string | null
    productId: string | null
    amountCents: number | null
    currency: string | null
    installments: number | null
    paymentMethodType: string | null
    status: string | null
    status_v2: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    paidAt: Date | null
    capturedAt: Date | null
    refundStatus: string | null
    refundedAt: Date | null
    routedProvider: string | null
    customerId: string | null
    customerProviderId: string | null
    customerPaymentMethodId: string | null
    customerSubscriptionId: string | null
    billingPeriodStart: Date | null
    billingPeriodEnd: Date | null
    provider_v2: $Enums.PaymentProvider | null
  }

  export type PaymentTransactionMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    providerOrderId: string | null
    providerChargeId: string | null
    doctorId: string | null
    patientProfileId: string | null
    clinicId: string | null
    merchantId: string | null
    productId: string | null
    amountCents: number | null
    currency: string | null
    installments: number | null
    paymentMethodType: string | null
    status: string | null
    status_v2: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    paidAt: Date | null
    capturedAt: Date | null
    refundStatus: string | null
    refundedAt: Date | null
    routedProvider: string | null
    customerId: string | null
    customerProviderId: string | null
    customerPaymentMethodId: string | null
    customerSubscriptionId: string | null
    billingPeriodStart: Date | null
    billingPeriodEnd: Date | null
    provider_v2: $Enums.PaymentProvider | null
  }

  export type PaymentTransactionCountAggregateOutputType = {
    id: number
    provider: number
    providerOrderId: number
    providerChargeId: number
    doctorId: number
    patientProfileId: number
    clinicId: number
    merchantId: number
    productId: number
    amountCents: number
    currency: number
    installments: number
    paymentMethodType: number
    status: number
    status_v2: number
    rawPayload: number
    createdAt: number
    updatedAt: number
    paidAt: number
    capturedAt: number
    refundStatus: number
    refundedAt: number
    routedProvider: number
    customerId: number
    customerProviderId: number
    customerPaymentMethodId: number
    customerSubscriptionId: number
    billingPeriodStart: number
    billingPeriodEnd: number
    provider_v2: number
    _all: number
  }


  export type PaymentTransactionAvgAggregateInputType = {
    amountCents?: true
    installments?: true
  }

  export type PaymentTransactionSumAggregateInputType = {
    amountCents?: true
    installments?: true
  }

  export type PaymentTransactionMinAggregateInputType = {
    id?: true
    provider?: true
    providerOrderId?: true
    providerChargeId?: true
    doctorId?: true
    patientProfileId?: true
    clinicId?: true
    merchantId?: true
    productId?: true
    amountCents?: true
    currency?: true
    installments?: true
    paymentMethodType?: true
    status?: true
    status_v2?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
    capturedAt?: true
    refundStatus?: true
    refundedAt?: true
    routedProvider?: true
    customerId?: true
    customerProviderId?: true
    customerPaymentMethodId?: true
    customerSubscriptionId?: true
    billingPeriodStart?: true
    billingPeriodEnd?: true
    provider_v2?: true
  }

  export type PaymentTransactionMaxAggregateInputType = {
    id?: true
    provider?: true
    providerOrderId?: true
    providerChargeId?: true
    doctorId?: true
    patientProfileId?: true
    clinicId?: true
    merchantId?: true
    productId?: true
    amountCents?: true
    currency?: true
    installments?: true
    paymentMethodType?: true
    status?: true
    status_v2?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
    capturedAt?: true
    refundStatus?: true
    refundedAt?: true
    routedProvider?: true
    customerId?: true
    customerProviderId?: true
    customerPaymentMethodId?: true
    customerSubscriptionId?: true
    billingPeriodStart?: true
    billingPeriodEnd?: true
    provider_v2?: true
  }

  export type PaymentTransactionCountAggregateInputType = {
    id?: true
    provider?: true
    providerOrderId?: true
    providerChargeId?: true
    doctorId?: true
    patientProfileId?: true
    clinicId?: true
    merchantId?: true
    productId?: true
    amountCents?: true
    currency?: true
    installments?: true
    paymentMethodType?: true
    status?: true
    status_v2?: true
    rawPayload?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
    capturedAt?: true
    refundStatus?: true
    refundedAt?: true
    routedProvider?: true
    customerId?: true
    customerProviderId?: true
    customerPaymentMethodId?: true
    customerSubscriptionId?: true
    billingPeriodStart?: true
    billingPeriodEnd?: true
    provider_v2?: true
    _all?: true
  }

  export type PaymentTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransaction to aggregate.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentTransactions
    **/
    _count?: true | PaymentTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type GetPaymentTransactionAggregateType<T extends PaymentTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentTransaction[P]>
      : GetScalarType<T[P], AggregatePaymentTransaction[P]>
  }




  export type PaymentTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithAggregationInput | PaymentTransactionOrderByWithAggregationInput[]
    by: PaymentTransactionScalarFieldEnum[] | PaymentTransactionScalarFieldEnum
    having?: PaymentTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentTransactionCountAggregateInputType | true
    _avg?: PaymentTransactionAvgAggregateInputType
    _sum?: PaymentTransactionSumAggregateInputType
    _min?: PaymentTransactionMinAggregateInputType
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type PaymentTransactionGroupByOutputType = {
    id: string
    provider: string
    providerOrderId: string | null
    providerChargeId: string | null
    doctorId: string | null
    patientProfileId: string | null
    clinicId: string | null
    merchantId: string | null
    productId: string | null
    amountCents: number
    currency: string
    installments: number | null
    paymentMethodType: string | null
    status: string
    status_v2: $Enums.PaymentStatus | null
    rawPayload: JsonValue | null
    createdAt: Date
    updatedAt: Date
    paidAt: Date | null
    capturedAt: Date | null
    refundStatus: string | null
    refundedAt: Date | null
    routedProvider: string | null
    customerId: string | null
    customerProviderId: string | null
    customerPaymentMethodId: string | null
    customerSubscriptionId: string | null
    billingPeriodStart: Date | null
    billingPeriodEnd: Date | null
    provider_v2: $Enums.PaymentProvider | null
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  type GetPaymentTransactionGroupByPayload<T extends PaymentTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PaymentTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    providerOrderId?: boolean
    providerChargeId?: boolean
    doctorId?: boolean
    patientProfileId?: boolean
    clinicId?: boolean
    merchantId?: boolean
    productId?: boolean
    amountCents?: boolean
    currency?: boolean
    installments?: boolean
    paymentMethodType?: boolean
    status?: boolean
    status_v2?: boolean
    rawPayload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    capturedAt?: boolean
    refundStatus?: boolean
    refundedAt?: boolean
    routedProvider?: boolean
    customerId?: boolean
    customerProviderId?: boolean
    customerPaymentMethodId?: boolean
    customerSubscriptionId?: boolean
    billingPeriodStart?: boolean
    billingPeriodEnd?: boolean
    provider_v2?: boolean
    checkoutSession?: boolean | PaymentTransaction$checkoutSessionArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    providerOrderId?: boolean
    providerChargeId?: boolean
    doctorId?: boolean
    patientProfileId?: boolean
    clinicId?: boolean
    merchantId?: boolean
    productId?: boolean
    amountCents?: boolean
    currency?: boolean
    installments?: boolean
    paymentMethodType?: boolean
    status?: boolean
    status_v2?: boolean
    rawPayload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    capturedAt?: boolean
    refundStatus?: boolean
    refundedAt?: boolean
    routedProvider?: boolean
    customerId?: boolean
    customerProviderId?: boolean
    customerPaymentMethodId?: boolean
    customerSubscriptionId?: boolean
    billingPeriodStart?: boolean
    billingPeriodEnd?: boolean
    provider_v2?: boolean
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    providerOrderId?: boolean
    providerChargeId?: boolean
    doctorId?: boolean
    patientProfileId?: boolean
    clinicId?: boolean
    merchantId?: boolean
    productId?: boolean
    amountCents?: boolean
    currency?: boolean
    installments?: boolean
    paymentMethodType?: boolean
    status?: boolean
    status_v2?: boolean
    rawPayload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    capturedAt?: boolean
    refundStatus?: boolean
    refundedAt?: boolean
    routedProvider?: boolean
    customerId?: boolean
    customerProviderId?: boolean
    customerPaymentMethodId?: boolean
    customerSubscriptionId?: boolean
    billingPeriodStart?: boolean
    billingPeriodEnd?: boolean
    provider_v2?: boolean
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectScalar = {
    id?: boolean
    provider?: boolean
    providerOrderId?: boolean
    providerChargeId?: boolean
    doctorId?: boolean
    patientProfileId?: boolean
    clinicId?: boolean
    merchantId?: boolean
    productId?: boolean
    amountCents?: boolean
    currency?: boolean
    installments?: boolean
    paymentMethodType?: boolean
    status?: boolean
    status_v2?: boolean
    rawPayload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    capturedAt?: boolean
    refundStatus?: boolean
    refundedAt?: boolean
    routedProvider?: boolean
    customerId?: boolean
    customerProviderId?: boolean
    customerPaymentMethodId?: boolean
    customerSubscriptionId?: boolean
    billingPeriodStart?: boolean
    billingPeriodEnd?: boolean
    provider_v2?: boolean
  }

  export type PaymentTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "providerOrderId" | "providerChargeId" | "doctorId" | "patientProfileId" | "clinicId" | "merchantId" | "productId" | "amountCents" | "currency" | "installments" | "paymentMethodType" | "status" | "status_v2" | "rawPayload" | "createdAt" | "updatedAt" | "paidAt" | "capturedAt" | "refundStatus" | "refundedAt" | "routedProvider" | "customerId" | "customerProviderId" | "customerPaymentMethodId" | "customerSubscriptionId" | "billingPeriodStart" | "billingPeriodEnd" | "provider_v2", ExtArgs["result"]["paymentTransaction"]>
  export type PaymentTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkoutSession?: boolean | PaymentTransaction$checkoutSessionArgs<ExtArgs>
  }
  export type PaymentTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PaymentTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentTransaction"
    objects: {
      checkoutSession: Prisma.$CheckoutSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      providerOrderId: string | null
      providerChargeId: string | null
      doctorId: string | null
      patientProfileId: string | null
      clinicId: string | null
      merchantId: string | null
      productId: string | null
      amountCents: number
      currency: string
      installments: number | null
      paymentMethodType: string | null
      status: string
      status_v2: $Enums.PaymentStatus | null
      rawPayload: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      paidAt: Date | null
      capturedAt: Date | null
      refundStatus: string | null
      refundedAt: Date | null
      routedProvider: string | null
      customerId: string | null
      customerProviderId: string | null
      customerPaymentMethodId: string | null
      customerSubscriptionId: string | null
      billingPeriodStart: Date | null
      billingPeriodEnd: Date | null
      provider_v2: $Enums.PaymentProvider | null
    }, ExtArgs["result"]["paymentTransaction"]>
    composites: {}
  }

  type PaymentTransactionGetPayload<S extends boolean | null | undefined | PaymentTransactionDefaultArgs> = $Result.GetResult<Prisma.$PaymentTransactionPayload, S>

  type PaymentTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentTransactionCountAggregateInputType | true
    }

  export interface PaymentTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentTransaction'], meta: { name: 'PaymentTransaction' } }
    /**
     * Find zero or one PaymentTransaction that matches the filter.
     * @param {PaymentTransactionFindUniqueArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentTransactionFindUniqueArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentTransactionFindUniqueOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentTransactionFindFirstArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany()
     * 
     * // Get first 10 PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentTransactionFindManyArgs>(args?: SelectSubset<T, PaymentTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentTransaction.
     * @param {PaymentTransactionCreateArgs} args - Arguments to create a PaymentTransaction.
     * @example
     * // Create one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.create({
     *   data: {
     *     // ... data to create a PaymentTransaction
     *   }
     * })
     * 
     */
    create<T extends PaymentTransactionCreateArgs>(args: SelectSubset<T, PaymentTransactionCreateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentTransactions.
     * @param {PaymentTransactionCreateManyArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentTransactionCreateManyArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentTransactions and returns the data saved in the database.
     * @param {PaymentTransactionCreateManyAndReturnArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentTransactions and only return the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentTransaction.
     * @param {PaymentTransactionDeleteArgs} args - Arguments to delete one PaymentTransaction.
     * @example
     * // Delete one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.delete({
     *   where: {
     *     // ... filter to delete one PaymentTransaction
     *   }
     * })
     * 
     */
    delete<T extends PaymentTransactionDeleteArgs>(args: SelectSubset<T, PaymentTransactionDeleteArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentTransaction.
     * @param {PaymentTransactionUpdateArgs} args - Arguments to update one PaymentTransaction.
     * @example
     * // Update one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentTransactionUpdateArgs>(args: SelectSubset<T, PaymentTransactionUpdateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentTransactions.
     * @param {PaymentTransactionDeleteManyArgs} args - Arguments to filter PaymentTransactions to delete.
     * @example
     * // Delete a few PaymentTransactions
     * const { count } = await prisma.paymentTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentTransactionDeleteManyArgs>(args?: SelectSubset<T, PaymentTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentTransactionUpdateManyArgs>(args: SelectSubset<T, PaymentTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions and returns the data updated in the database.
     * @param {PaymentTransactionUpdateManyAndReturnArgs} args - Arguments to update many PaymentTransactions.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentTransactions and only return the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentTransaction.
     * @param {PaymentTransactionUpsertArgs} args - Arguments to update or create a PaymentTransaction.
     * @example
     * // Update or create a PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.upsert({
     *   create: {
     *     // ... data to create a PaymentTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentTransaction we want to update
     *   }
     * })
     */
    upsert<T extends PaymentTransactionUpsertArgs>(args: SelectSubset<T, PaymentTransactionUpsertArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionCountArgs} args - Arguments to filter PaymentTransactions to count.
     * @example
     * // Count the number of PaymentTransactions
     * const count = await prisma.paymentTransaction.count({
     *   where: {
     *     // ... the filter for the PaymentTransactions we want to count
     *   }
     * })
    **/
    count<T extends PaymentTransactionCountArgs>(
      args?: Subset<T, PaymentTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentTransactionAggregateArgs>(args: Subset<T, PaymentTransactionAggregateArgs>): Prisma.PrismaPromise<GetPaymentTransactionAggregateType<T>>

    /**
     * Group by PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PaymentTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentTransaction model
   */
  readonly fields: PaymentTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checkoutSession<T extends PaymentTransaction$checkoutSessionArgs<ExtArgs> = {}>(args?: Subset<T, PaymentTransaction$checkoutSessionArgs<ExtArgs>>): Prisma__CheckoutSessionClient<$Result.GetResult<Prisma.$CheckoutSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentTransaction model
   */
  interface PaymentTransactionFieldRefs {
    readonly id: FieldRef<"PaymentTransaction", 'String'>
    readonly provider: FieldRef<"PaymentTransaction", 'String'>
    readonly providerOrderId: FieldRef<"PaymentTransaction", 'String'>
    readonly providerChargeId: FieldRef<"PaymentTransaction", 'String'>
    readonly doctorId: FieldRef<"PaymentTransaction", 'String'>
    readonly patientProfileId: FieldRef<"PaymentTransaction", 'String'>
    readonly clinicId: FieldRef<"PaymentTransaction", 'String'>
    readonly merchantId: FieldRef<"PaymentTransaction", 'String'>
    readonly productId: FieldRef<"PaymentTransaction", 'String'>
    readonly amountCents: FieldRef<"PaymentTransaction", 'Int'>
    readonly currency: FieldRef<"PaymentTransaction", 'String'>
    readonly installments: FieldRef<"PaymentTransaction", 'Int'>
    readonly paymentMethodType: FieldRef<"PaymentTransaction", 'String'>
    readonly status: FieldRef<"PaymentTransaction", 'String'>
    readonly status_v2: FieldRef<"PaymentTransaction", 'PaymentStatus'>
    readonly rawPayload: FieldRef<"PaymentTransaction", 'Json'>
    readonly createdAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly paidAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly capturedAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly refundStatus: FieldRef<"PaymentTransaction", 'String'>
    readonly refundedAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly routedProvider: FieldRef<"PaymentTransaction", 'String'>
    readonly customerId: FieldRef<"PaymentTransaction", 'String'>
    readonly customerProviderId: FieldRef<"PaymentTransaction", 'String'>
    readonly customerPaymentMethodId: FieldRef<"PaymentTransaction", 'String'>
    readonly customerSubscriptionId: FieldRef<"PaymentTransaction", 'String'>
    readonly billingPeriodStart: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly billingPeriodEnd: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly provider_v2: FieldRef<"PaymentTransaction", 'PaymentProvider'>
  }
    

  // Custom InputTypes
  /**
   * PaymentTransaction findUnique
   */
  export type PaymentTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findUniqueOrThrow
   */
  export type PaymentTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findFirst
   */
  export type PaymentTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findFirstOrThrow
   */
  export type PaymentTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findMany
   */
  export type PaymentTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransactions to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction create
   */
  export type PaymentTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentTransaction.
     */
    data: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
  }

  /**
   * PaymentTransaction createMany
   */
  export type PaymentTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentTransaction createManyAndReturn
   */
  export type PaymentTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentTransaction update
   */
  export type PaymentTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentTransaction.
     */
    data: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
    /**
     * Choose, which PaymentTransaction to update.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction updateMany
   */
  export type PaymentTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to update.
     */
    limit?: number
  }

  /**
   * PaymentTransaction updateManyAndReturn
   */
  export type PaymentTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to update.
     */
    limit?: number
  }

  /**
   * PaymentTransaction upsert
   */
  export type PaymentTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentTransaction to update in case it exists.
     */
    where: PaymentTransactionWhereUniqueInput
    /**
     * In case the PaymentTransaction found by the `where` argument doesn't exist, create a new PaymentTransaction with this data.
     */
    create: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
    /**
     * In case the PaymentTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
  }

  /**
   * PaymentTransaction delete
   */
  export type PaymentTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter which PaymentTransaction to delete.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction deleteMany
   */
  export type PaymentTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransactions to delete
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to delete.
     */
    limit?: number
  }

  /**
   * PaymentTransaction.checkoutSession
   */
  export type PaymentTransaction$checkoutSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutSession
     */
    select?: CheckoutSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutSession
     */
    omit?: CheckoutSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutSessionInclude<ExtArgs> | null
    where?: CheckoutSessionWhereInput
  }

  /**
   * PaymentTransaction without action
   */
  export type PaymentTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    pointsAwarded: Decimal | null
  }

  export type PurchaseSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    pointsAwarded: Decimal | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    doctorId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    pointsAwarded: Decimal | null
    status: string | null
    externalIdempotencyKey: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    doctorId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    pointsAwarded: Decimal | null
    status: string | null
    externalIdempotencyKey: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    userId: number
    doctorId: number
    productId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    pointsAwarded: number
    status: number
    externalIdempotencyKey: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    pointsAwarded?: true
  }

  export type PurchaseSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    pointsAwarded?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    userId?: true
    doctorId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    pointsAwarded?: true
    status?: true
    externalIdempotencyKey?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    userId?: true
    doctorId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    pointsAwarded?: true
    status?: true
    externalIdempotencyKey?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    userId?: true
    doctorId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    pointsAwarded?: true
    status?: true
    externalIdempotencyKey?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    userId: string
    doctorId: string
    productId: string
    quantity: number
    unitPrice: Decimal
    totalPrice: Decimal
    pointsAwarded: Decimal
    status: string
    externalIdempotencyKey: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    doctorId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    pointsAwarded?: boolean
    status?: boolean
    externalIdempotencyKey?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    doctorId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    pointsAwarded?: boolean
    status?: boolean
    externalIdempotencyKey?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    doctorId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    pointsAwarded?: boolean
    status?: boolean
    externalIdempotencyKey?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    userId?: boolean
    doctorId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    pointsAwarded?: boolean
    status?: boolean
    externalIdempotencyKey?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "doctorId" | "productId" | "quantity" | "unitPrice" | "totalPrice" | "pointsAwarded" | "status" | "externalIdempotencyKey" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["purchase"]>
  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      doctorId: string
      productId: string
      quantity: number
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
      pointsAwarded: Prisma.Decimal
      status: string
      externalIdempotencyKey: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases and returns the data updated in the database.
     * @param {PurchaseUpdateManyAndReturnArgs} args - Arguments to update many Purchases.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly userId: FieldRef<"Purchase", 'String'>
    readonly doctorId: FieldRef<"Purchase", 'String'>
    readonly productId: FieldRef<"Purchase", 'String'>
    readonly quantity: FieldRef<"Purchase", 'Int'>
    readonly unitPrice: FieldRef<"Purchase", 'Decimal'>
    readonly totalPrice: FieldRef<"Purchase", 'Decimal'>
    readonly pointsAwarded: FieldRef<"Purchase", 'Decimal'>
    readonly status: FieldRef<"Purchase", 'String'>
    readonly externalIdempotencyKey: FieldRef<"Purchase", 'String'>
    readonly notes: FieldRef<"Purchase", 'String'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
  }

  /**
   * Purchase updateManyAndReturn
   */
  export type PurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to delete.
     */
    limit?: number
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    merchantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    document: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    merchantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    document: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    merchantId: number
    name: number
    email: number
    phone: number
    document: number
    address: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    merchantId?: true
    name?: true
    email?: true
    phone?: true
    document?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    merchantId?: true
    name?: true
    email?: true
    phone?: true
    document?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    merchantId?: true
    name?: true
    email?: true
    phone?: true
    document?: true
    address?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    merchantId: string
    name: string | null
    email: string | null
    phone: string | null
    document: string | null
    address: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    document?: boolean
    address?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    providers?: boolean | Customer$providersArgs<ExtArgs>
    paymentMethods?: boolean | Customer$paymentMethodsArgs<ExtArgs>
    subscriptions?: boolean | Customer$subscriptionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    document?: boolean
    address?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    document?: boolean
    address?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    merchantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    document?: boolean
    address?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "merchantId" | "name" | "email" | "phone" | "document" | "address" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | Customer$providersArgs<ExtArgs>
    paymentMethods?: boolean | Customer$paymentMethodsArgs<ExtArgs>
    subscriptions?: boolean | Customer$subscriptionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      providers: Prisma.$CustomerProviderPayload<ExtArgs>[]
      paymentMethods: Prisma.$CustomerPaymentMethodPayload<ExtArgs>[]
      subscriptions: Prisma.$CustomerSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchantId: string
      name: string | null
      email: string | null
      phone: string | null
      document: string | null
      address: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    providers<T extends Customer$providersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$providersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentMethods<T extends Customer$paymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$paymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Customer$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly merchantId: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly document: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'Json'>
    readonly metadata: FieldRef<"Customer", 'Json'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.providers
   */
  export type Customer$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    where?: CustomerProviderWhereInput
    orderBy?: CustomerProviderOrderByWithRelationInput | CustomerProviderOrderByWithRelationInput[]
    cursor?: CustomerProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerProviderScalarFieldEnum | CustomerProviderScalarFieldEnum[]
  }

  /**
   * Customer.paymentMethods
   */
  export type Customer$paymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
    where?: CustomerPaymentMethodWhereInput
    orderBy?: CustomerPaymentMethodOrderByWithRelationInput | CustomerPaymentMethodOrderByWithRelationInput[]
    cursor?: CustomerPaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPaymentMethodScalarFieldEnum | CustomerPaymentMethodScalarFieldEnum[]
  }

  /**
   * Customer.subscriptions
   */
  export type Customer$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
    where?: CustomerSubscriptionWhereInput
    orderBy?: CustomerSubscriptionOrderByWithRelationInput | CustomerSubscriptionOrderByWithRelationInput[]
    cursor?: CustomerSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerSubscriptionScalarFieldEnum | CustomerSubscriptionScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerProvider
   */

  export type AggregateCustomerProvider = {
    _count: CustomerProviderCountAggregateOutputType | null
    _min: CustomerProviderMinAggregateOutputType | null
    _max: CustomerProviderMaxAggregateOutputType | null
  }

  export type CustomerProviderMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    provider: $Enums.PaymentProvider | null
    accountId: string | null
    providerCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerProviderMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    provider: $Enums.PaymentProvider | null
    accountId: string | null
    providerCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerProviderCountAggregateOutputType = {
    id: number
    customerId: number
    provider: number
    accountId: number
    providerCustomerId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerProviderMinAggregateInputType = {
    id?: true
    customerId?: true
    provider?: true
    accountId?: true
    providerCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerProviderMaxAggregateInputType = {
    id?: true
    customerId?: true
    provider?: true
    accountId?: true
    providerCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerProviderCountAggregateInputType = {
    id?: true
    customerId?: true
    provider?: true
    accountId?: true
    providerCustomerId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerProvider to aggregate.
     */
    where?: CustomerProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProviders to fetch.
     */
    orderBy?: CustomerProviderOrderByWithRelationInput | CustomerProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerProviders
    **/
    _count?: true | CustomerProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerProviderMaxAggregateInputType
  }

  export type GetCustomerProviderAggregateType<T extends CustomerProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerProvider[P]>
      : GetScalarType<T[P], AggregateCustomerProvider[P]>
  }




  export type CustomerProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerProviderWhereInput
    orderBy?: CustomerProviderOrderByWithAggregationInput | CustomerProviderOrderByWithAggregationInput[]
    by: CustomerProviderScalarFieldEnum[] | CustomerProviderScalarFieldEnum
    having?: CustomerProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerProviderCountAggregateInputType | true
    _min?: CustomerProviderMinAggregateInputType
    _max?: CustomerProviderMaxAggregateInputType
  }

  export type CustomerProviderGroupByOutputType = {
    id: string
    customerId: string
    provider: $Enums.PaymentProvider
    accountId: string | null
    providerCustomerId: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerProviderCountAggregateOutputType | null
    _min: CustomerProviderMinAggregateOutputType | null
    _max: CustomerProviderMaxAggregateOutputType | null
  }

  type GetCustomerProviderGroupByPayload<T extends CustomerProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerProviderGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerProviderGroupByOutputType[P]>
        }
      >
    >


  export type CustomerProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    provider?: boolean
    accountId?: boolean
    providerCustomerId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    paymentMethods?: boolean | CustomerProvider$paymentMethodsArgs<ExtArgs>
    subscriptions?: boolean | CustomerProvider$subscriptionsArgs<ExtArgs>
    _count?: boolean | CustomerProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerProvider"]>

  export type CustomerProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    provider?: boolean
    accountId?: boolean
    providerCustomerId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerProvider"]>

  export type CustomerProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    provider?: boolean
    accountId?: boolean
    providerCustomerId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerProvider"]>

  export type CustomerProviderSelectScalar = {
    id?: boolean
    customerId?: boolean
    provider?: boolean
    accountId?: boolean
    providerCustomerId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "provider" | "accountId" | "providerCustomerId" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["customerProvider"]>
  export type CustomerProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    paymentMethods?: boolean | CustomerProvider$paymentMethodsArgs<ExtArgs>
    subscriptions?: boolean | CustomerProvider$subscriptionsArgs<ExtArgs>
    _count?: boolean | CustomerProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerProvider"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      paymentMethods: Prisma.$CustomerPaymentMethodPayload<ExtArgs>[]
      subscriptions: Prisma.$CustomerSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      provider: $Enums.PaymentProvider
      accountId: string | null
      providerCustomerId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerProvider"]>
    composites: {}
  }

  type CustomerProviderGetPayload<S extends boolean | null | undefined | CustomerProviderDefaultArgs> = $Result.GetResult<Prisma.$CustomerProviderPayload, S>

  type CustomerProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerProviderCountAggregateInputType | true
    }

  export interface CustomerProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerProvider'], meta: { name: 'CustomerProvider' } }
    /**
     * Find zero or one CustomerProvider that matches the filter.
     * @param {CustomerProviderFindUniqueArgs} args - Arguments to find a CustomerProvider
     * @example
     * // Get one CustomerProvider
     * const customerProvider = await prisma.customerProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerProviderFindUniqueArgs>(args: SelectSubset<T, CustomerProviderFindUniqueArgs<ExtArgs>>): Prisma__CustomerProviderClient<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerProvider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerProviderFindUniqueOrThrowArgs} args - Arguments to find a CustomerProvider
     * @example
     * // Get one CustomerProvider
     * const customerProvider = await prisma.customerProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerProviderClient<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProviderFindFirstArgs} args - Arguments to find a CustomerProvider
     * @example
     * // Get one CustomerProvider
     * const customerProvider = await prisma.customerProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerProviderFindFirstArgs>(args?: SelectSubset<T, CustomerProviderFindFirstArgs<ExtArgs>>): Prisma__CustomerProviderClient<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProviderFindFirstOrThrowArgs} args - Arguments to find a CustomerProvider
     * @example
     * // Get one CustomerProvider
     * const customerProvider = await prisma.customerProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerProviderClient<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerProviders
     * const customerProviders = await prisma.customerProvider.findMany()
     * 
     * // Get first 10 CustomerProviders
     * const customerProviders = await prisma.customerProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerProviderWithIdOnly = await prisma.customerProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerProviderFindManyArgs>(args?: SelectSubset<T, CustomerProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerProvider.
     * @param {CustomerProviderCreateArgs} args - Arguments to create a CustomerProvider.
     * @example
     * // Create one CustomerProvider
     * const CustomerProvider = await prisma.customerProvider.create({
     *   data: {
     *     // ... data to create a CustomerProvider
     *   }
     * })
     * 
     */
    create<T extends CustomerProviderCreateArgs>(args: SelectSubset<T, CustomerProviderCreateArgs<ExtArgs>>): Prisma__CustomerProviderClient<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerProviders.
     * @param {CustomerProviderCreateManyArgs} args - Arguments to create many CustomerProviders.
     * @example
     * // Create many CustomerProviders
     * const customerProvider = await prisma.customerProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerProviderCreateManyArgs>(args?: SelectSubset<T, CustomerProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerProviders and returns the data saved in the database.
     * @param {CustomerProviderCreateManyAndReturnArgs} args - Arguments to create many CustomerProviders.
     * @example
     * // Create many CustomerProviders
     * const customerProvider = await prisma.customerProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerProviders and only return the `id`
     * const customerProviderWithIdOnly = await prisma.customerProvider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerProvider.
     * @param {CustomerProviderDeleteArgs} args - Arguments to delete one CustomerProvider.
     * @example
     * // Delete one CustomerProvider
     * const CustomerProvider = await prisma.customerProvider.delete({
     *   where: {
     *     // ... filter to delete one CustomerProvider
     *   }
     * })
     * 
     */
    delete<T extends CustomerProviderDeleteArgs>(args: SelectSubset<T, CustomerProviderDeleteArgs<ExtArgs>>): Prisma__CustomerProviderClient<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerProvider.
     * @param {CustomerProviderUpdateArgs} args - Arguments to update one CustomerProvider.
     * @example
     * // Update one CustomerProvider
     * const customerProvider = await prisma.customerProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerProviderUpdateArgs>(args: SelectSubset<T, CustomerProviderUpdateArgs<ExtArgs>>): Prisma__CustomerProviderClient<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerProviders.
     * @param {CustomerProviderDeleteManyArgs} args - Arguments to filter CustomerProviders to delete.
     * @example
     * // Delete a few CustomerProviders
     * const { count } = await prisma.customerProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerProviderDeleteManyArgs>(args?: SelectSubset<T, CustomerProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerProviders
     * const customerProvider = await prisma.customerProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerProviderUpdateManyArgs>(args: SelectSubset<T, CustomerProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerProviders and returns the data updated in the database.
     * @param {CustomerProviderUpdateManyAndReturnArgs} args - Arguments to update many CustomerProviders.
     * @example
     * // Update many CustomerProviders
     * const customerProvider = await prisma.customerProvider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerProviders and only return the `id`
     * const customerProviderWithIdOnly = await prisma.customerProvider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerProvider.
     * @param {CustomerProviderUpsertArgs} args - Arguments to update or create a CustomerProvider.
     * @example
     * // Update or create a CustomerProvider
     * const customerProvider = await prisma.customerProvider.upsert({
     *   create: {
     *     // ... data to create a CustomerProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerProvider we want to update
     *   }
     * })
     */
    upsert<T extends CustomerProviderUpsertArgs>(args: SelectSubset<T, CustomerProviderUpsertArgs<ExtArgs>>): Prisma__CustomerProviderClient<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProviderCountArgs} args - Arguments to filter CustomerProviders to count.
     * @example
     * // Count the number of CustomerProviders
     * const count = await prisma.customerProvider.count({
     *   where: {
     *     // ... the filter for the CustomerProviders we want to count
     *   }
     * })
    **/
    count<T extends CustomerProviderCountArgs>(
      args?: Subset<T, CustomerProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerProviderAggregateArgs>(args: Subset<T, CustomerProviderAggregateArgs>): Prisma.PrismaPromise<GetCustomerProviderAggregateType<T>>

    /**
     * Group by CustomerProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerProviderGroupByArgs['orderBy'] }
        : { orderBy?: CustomerProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerProvider model
   */
  readonly fields: CustomerProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethods<T extends CustomerProvider$paymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerProvider$paymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends CustomerProvider$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerProvider$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerProvider model
   */
  interface CustomerProviderFieldRefs {
    readonly id: FieldRef<"CustomerProvider", 'String'>
    readonly customerId: FieldRef<"CustomerProvider", 'String'>
    readonly provider: FieldRef<"CustomerProvider", 'PaymentProvider'>
    readonly accountId: FieldRef<"CustomerProvider", 'String'>
    readonly providerCustomerId: FieldRef<"CustomerProvider", 'String'>
    readonly metadata: FieldRef<"CustomerProvider", 'Json'>
    readonly createdAt: FieldRef<"CustomerProvider", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerProvider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerProvider findUnique
   */
  export type CustomerProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProvider to fetch.
     */
    where: CustomerProviderWhereUniqueInput
  }

  /**
   * CustomerProvider findUniqueOrThrow
   */
  export type CustomerProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProvider to fetch.
     */
    where: CustomerProviderWhereUniqueInput
  }

  /**
   * CustomerProvider findFirst
   */
  export type CustomerProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProvider to fetch.
     */
    where?: CustomerProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProviders to fetch.
     */
    orderBy?: CustomerProviderOrderByWithRelationInput | CustomerProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerProviders.
     */
    cursor?: CustomerProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerProviders.
     */
    distinct?: CustomerProviderScalarFieldEnum | CustomerProviderScalarFieldEnum[]
  }

  /**
   * CustomerProvider findFirstOrThrow
   */
  export type CustomerProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProvider to fetch.
     */
    where?: CustomerProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProviders to fetch.
     */
    orderBy?: CustomerProviderOrderByWithRelationInput | CustomerProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerProviders.
     */
    cursor?: CustomerProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerProviders.
     */
    distinct?: CustomerProviderScalarFieldEnum | CustomerProviderScalarFieldEnum[]
  }

  /**
   * CustomerProvider findMany
   */
  export type CustomerProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProviders to fetch.
     */
    where?: CustomerProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProviders to fetch.
     */
    orderBy?: CustomerProviderOrderByWithRelationInput | CustomerProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerProviders.
     */
    cursor?: CustomerProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProviders.
     */
    skip?: number
    distinct?: CustomerProviderScalarFieldEnum | CustomerProviderScalarFieldEnum[]
  }

  /**
   * CustomerProvider create
   */
  export type CustomerProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerProvider.
     */
    data: XOR<CustomerProviderCreateInput, CustomerProviderUncheckedCreateInput>
  }

  /**
   * CustomerProvider createMany
   */
  export type CustomerProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerProviders.
     */
    data: CustomerProviderCreateManyInput | CustomerProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerProvider createManyAndReturn
   */
  export type CustomerProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerProviders.
     */
    data: CustomerProviderCreateManyInput | CustomerProviderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerProvider update
   */
  export type CustomerProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerProvider.
     */
    data: XOR<CustomerProviderUpdateInput, CustomerProviderUncheckedUpdateInput>
    /**
     * Choose, which CustomerProvider to update.
     */
    where: CustomerProviderWhereUniqueInput
  }

  /**
   * CustomerProvider updateMany
   */
  export type CustomerProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerProviders.
     */
    data: XOR<CustomerProviderUpdateManyMutationInput, CustomerProviderUncheckedUpdateManyInput>
    /**
     * Filter which CustomerProviders to update
     */
    where?: CustomerProviderWhereInput
    /**
     * Limit how many CustomerProviders to update.
     */
    limit?: number
  }

  /**
   * CustomerProvider updateManyAndReturn
   */
  export type CustomerProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * The data used to update CustomerProviders.
     */
    data: XOR<CustomerProviderUpdateManyMutationInput, CustomerProviderUncheckedUpdateManyInput>
    /**
     * Filter which CustomerProviders to update
     */
    where?: CustomerProviderWhereInput
    /**
     * Limit how many CustomerProviders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerProvider upsert
   */
  export type CustomerProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerProvider to update in case it exists.
     */
    where: CustomerProviderWhereUniqueInput
    /**
     * In case the CustomerProvider found by the `where` argument doesn't exist, create a new CustomerProvider with this data.
     */
    create: XOR<CustomerProviderCreateInput, CustomerProviderUncheckedCreateInput>
    /**
     * In case the CustomerProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerProviderUpdateInput, CustomerProviderUncheckedUpdateInput>
  }

  /**
   * CustomerProvider delete
   */
  export type CustomerProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    /**
     * Filter which CustomerProvider to delete.
     */
    where: CustomerProviderWhereUniqueInput
  }

  /**
   * CustomerProvider deleteMany
   */
  export type CustomerProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerProviders to delete
     */
    where?: CustomerProviderWhereInput
    /**
     * Limit how many CustomerProviders to delete.
     */
    limit?: number
  }

  /**
   * CustomerProvider.paymentMethods
   */
  export type CustomerProvider$paymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
    where?: CustomerPaymentMethodWhereInput
    orderBy?: CustomerPaymentMethodOrderByWithRelationInput | CustomerPaymentMethodOrderByWithRelationInput[]
    cursor?: CustomerPaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPaymentMethodScalarFieldEnum | CustomerPaymentMethodScalarFieldEnum[]
  }

  /**
   * CustomerProvider.subscriptions
   */
  export type CustomerProvider$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
    where?: CustomerSubscriptionWhereInput
    orderBy?: CustomerSubscriptionOrderByWithRelationInput | CustomerSubscriptionOrderByWithRelationInput[]
    cursor?: CustomerSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerSubscriptionScalarFieldEnum | CustomerSubscriptionScalarFieldEnum[]
  }

  /**
   * CustomerProvider without action
   */
  export type CustomerProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
  }


  /**
   * Model CustomerPaymentMethod
   */

  export type AggregateCustomerPaymentMethod = {
    _count: CustomerPaymentMethodCountAggregateOutputType | null
    _avg: CustomerPaymentMethodAvgAggregateOutputType | null
    _sum: CustomerPaymentMethodSumAggregateOutputType | null
    _min: CustomerPaymentMethodMinAggregateOutputType | null
    _max: CustomerPaymentMethodMaxAggregateOutputType | null
  }

  export type CustomerPaymentMethodAvgAggregateOutputType = {
    expMonth: number | null
    expYear: number | null
  }

  export type CustomerPaymentMethodSumAggregateOutputType = {
    expMonth: number | null
    expYear: number | null
  }

  export type CustomerPaymentMethodMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    customerProviderId: string | null
    provider: $Enums.PaymentProvider | null
    accountId: string | null
    providerPaymentMethodId: string | null
    brand: string | null
    last4: string | null
    expMonth: number | null
    expYear: number | null
    isDefault: boolean | null
    status: string | null
    fingerprint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerPaymentMethodMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    customerProviderId: string | null
    provider: $Enums.PaymentProvider | null
    accountId: string | null
    providerPaymentMethodId: string | null
    brand: string | null
    last4: string | null
    expMonth: number | null
    expYear: number | null
    isDefault: boolean | null
    status: string | null
    fingerprint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerPaymentMethodCountAggregateOutputType = {
    id: number
    customerId: number
    customerProviderId: number
    provider: number
    accountId: number
    providerPaymentMethodId: number
    brand: number
    last4: number
    expMonth: number
    expYear: number
    isDefault: number
    status: number
    fingerprint: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerPaymentMethodAvgAggregateInputType = {
    expMonth?: true
    expYear?: true
  }

  export type CustomerPaymentMethodSumAggregateInputType = {
    expMonth?: true
    expYear?: true
  }

  export type CustomerPaymentMethodMinAggregateInputType = {
    id?: true
    customerId?: true
    customerProviderId?: true
    provider?: true
    accountId?: true
    providerPaymentMethodId?: true
    brand?: true
    last4?: true
    expMonth?: true
    expYear?: true
    isDefault?: true
    status?: true
    fingerprint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerPaymentMethodMaxAggregateInputType = {
    id?: true
    customerId?: true
    customerProviderId?: true
    provider?: true
    accountId?: true
    providerPaymentMethodId?: true
    brand?: true
    last4?: true
    expMonth?: true
    expYear?: true
    isDefault?: true
    status?: true
    fingerprint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerPaymentMethodCountAggregateInputType = {
    id?: true
    customerId?: true
    customerProviderId?: true
    provider?: true
    accountId?: true
    providerPaymentMethodId?: true
    brand?: true
    last4?: true
    expMonth?: true
    expYear?: true
    isDefault?: true
    status?: true
    fingerprint?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerPaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPaymentMethod to aggregate.
     */
    where?: CustomerPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPaymentMethods to fetch.
     */
    orderBy?: CustomerPaymentMethodOrderByWithRelationInput | CustomerPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerPaymentMethods
    **/
    _count?: true | CustomerPaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerPaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerPaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerPaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerPaymentMethodMaxAggregateInputType
  }

  export type GetCustomerPaymentMethodAggregateType<T extends CustomerPaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerPaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerPaymentMethod[P]>
      : GetScalarType<T[P], AggregateCustomerPaymentMethod[P]>
  }




  export type CustomerPaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPaymentMethodWhereInput
    orderBy?: CustomerPaymentMethodOrderByWithAggregationInput | CustomerPaymentMethodOrderByWithAggregationInput[]
    by: CustomerPaymentMethodScalarFieldEnum[] | CustomerPaymentMethodScalarFieldEnum
    having?: CustomerPaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerPaymentMethodCountAggregateInputType | true
    _avg?: CustomerPaymentMethodAvgAggregateInputType
    _sum?: CustomerPaymentMethodSumAggregateInputType
    _min?: CustomerPaymentMethodMinAggregateInputType
    _max?: CustomerPaymentMethodMaxAggregateInputType
  }

  export type CustomerPaymentMethodGroupByOutputType = {
    id: string
    customerId: string
    customerProviderId: string | null
    provider: $Enums.PaymentProvider
    accountId: string | null
    providerPaymentMethodId: string | null
    brand: string | null
    last4: string | null
    expMonth: number | null
    expYear: number | null
    isDefault: boolean
    status: string | null
    fingerprint: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerPaymentMethodCountAggregateOutputType | null
    _avg: CustomerPaymentMethodAvgAggregateOutputType | null
    _sum: CustomerPaymentMethodSumAggregateOutputType | null
    _min: CustomerPaymentMethodMinAggregateOutputType | null
    _max: CustomerPaymentMethodMaxAggregateOutputType | null
  }

  type GetCustomerPaymentMethodGroupByPayload<T extends CustomerPaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerPaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerPaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerPaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerPaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type CustomerPaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    customerProviderId?: boolean
    provider?: boolean
    accountId?: boolean
    providerPaymentMethodId?: boolean
    brand?: boolean
    last4?: boolean
    expMonth?: boolean
    expYear?: boolean
    isDefault?: boolean
    status?: boolean
    fingerprint?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerPaymentMethod$customerProviderArgs<ExtArgs>
  }, ExtArgs["result"]["customerPaymentMethod"]>

  export type CustomerPaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    customerProviderId?: boolean
    provider?: boolean
    accountId?: boolean
    providerPaymentMethodId?: boolean
    brand?: boolean
    last4?: boolean
    expMonth?: boolean
    expYear?: boolean
    isDefault?: boolean
    status?: boolean
    fingerprint?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerPaymentMethod$customerProviderArgs<ExtArgs>
  }, ExtArgs["result"]["customerPaymentMethod"]>

  export type CustomerPaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    customerProviderId?: boolean
    provider?: boolean
    accountId?: boolean
    providerPaymentMethodId?: boolean
    brand?: boolean
    last4?: boolean
    expMonth?: boolean
    expYear?: boolean
    isDefault?: boolean
    status?: boolean
    fingerprint?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerPaymentMethod$customerProviderArgs<ExtArgs>
  }, ExtArgs["result"]["customerPaymentMethod"]>

  export type CustomerPaymentMethodSelectScalar = {
    id?: boolean
    customerId?: boolean
    customerProviderId?: boolean
    provider?: boolean
    accountId?: boolean
    providerPaymentMethodId?: boolean
    brand?: boolean
    last4?: boolean
    expMonth?: boolean
    expYear?: boolean
    isDefault?: boolean
    status?: boolean
    fingerprint?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerPaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "customerProviderId" | "provider" | "accountId" | "providerPaymentMethodId" | "brand" | "last4" | "expMonth" | "expYear" | "isDefault" | "status" | "fingerprint" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["customerPaymentMethod"]>
  export type CustomerPaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerPaymentMethod$customerProviderArgs<ExtArgs>
  }
  export type CustomerPaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerPaymentMethod$customerProviderArgs<ExtArgs>
  }
  export type CustomerPaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerPaymentMethod$customerProviderArgs<ExtArgs>
  }

  export type $CustomerPaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerPaymentMethod"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      customerProvider: Prisma.$CustomerProviderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      customerProviderId: string | null
      provider: $Enums.PaymentProvider
      accountId: string | null
      providerPaymentMethodId: string | null
      brand: string | null
      last4: string | null
      expMonth: number | null
      expYear: number | null
      isDefault: boolean
      status: string | null
      fingerprint: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerPaymentMethod"]>
    composites: {}
  }

  type CustomerPaymentMethodGetPayload<S extends boolean | null | undefined | CustomerPaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$CustomerPaymentMethodPayload, S>

  type CustomerPaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerPaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerPaymentMethodCountAggregateInputType | true
    }

  export interface CustomerPaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerPaymentMethod'], meta: { name: 'CustomerPaymentMethod' } }
    /**
     * Find zero or one CustomerPaymentMethod that matches the filter.
     * @param {CustomerPaymentMethodFindUniqueArgs} args - Arguments to find a CustomerPaymentMethod
     * @example
     * // Get one CustomerPaymentMethod
     * const customerPaymentMethod = await prisma.customerPaymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerPaymentMethodFindUniqueArgs>(args: SelectSubset<T, CustomerPaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__CustomerPaymentMethodClient<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerPaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerPaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a CustomerPaymentMethod
     * @example
     * // Get one CustomerPaymentMethod
     * const customerPaymentMethod = await prisma.customerPaymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerPaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerPaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerPaymentMethodClient<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentMethodFindFirstArgs} args - Arguments to find a CustomerPaymentMethod
     * @example
     * // Get one CustomerPaymentMethod
     * const customerPaymentMethod = await prisma.customerPaymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerPaymentMethodFindFirstArgs>(args?: SelectSubset<T, CustomerPaymentMethodFindFirstArgs<ExtArgs>>): Prisma__CustomerPaymentMethodClient<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentMethodFindFirstOrThrowArgs} args - Arguments to find a CustomerPaymentMethod
     * @example
     * // Get one CustomerPaymentMethod
     * const customerPaymentMethod = await prisma.customerPaymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerPaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerPaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerPaymentMethodClient<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerPaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerPaymentMethods
     * const customerPaymentMethods = await prisma.customerPaymentMethod.findMany()
     * 
     * // Get first 10 CustomerPaymentMethods
     * const customerPaymentMethods = await prisma.customerPaymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerPaymentMethodWithIdOnly = await prisma.customerPaymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerPaymentMethodFindManyArgs>(args?: SelectSubset<T, CustomerPaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerPaymentMethod.
     * @param {CustomerPaymentMethodCreateArgs} args - Arguments to create a CustomerPaymentMethod.
     * @example
     * // Create one CustomerPaymentMethod
     * const CustomerPaymentMethod = await prisma.customerPaymentMethod.create({
     *   data: {
     *     // ... data to create a CustomerPaymentMethod
     *   }
     * })
     * 
     */
    create<T extends CustomerPaymentMethodCreateArgs>(args: SelectSubset<T, CustomerPaymentMethodCreateArgs<ExtArgs>>): Prisma__CustomerPaymentMethodClient<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerPaymentMethods.
     * @param {CustomerPaymentMethodCreateManyArgs} args - Arguments to create many CustomerPaymentMethods.
     * @example
     * // Create many CustomerPaymentMethods
     * const customerPaymentMethod = await prisma.customerPaymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerPaymentMethodCreateManyArgs>(args?: SelectSubset<T, CustomerPaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerPaymentMethods and returns the data saved in the database.
     * @param {CustomerPaymentMethodCreateManyAndReturnArgs} args - Arguments to create many CustomerPaymentMethods.
     * @example
     * // Create many CustomerPaymentMethods
     * const customerPaymentMethod = await prisma.customerPaymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerPaymentMethods and only return the `id`
     * const customerPaymentMethodWithIdOnly = await prisma.customerPaymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerPaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerPaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerPaymentMethod.
     * @param {CustomerPaymentMethodDeleteArgs} args - Arguments to delete one CustomerPaymentMethod.
     * @example
     * // Delete one CustomerPaymentMethod
     * const CustomerPaymentMethod = await prisma.customerPaymentMethod.delete({
     *   where: {
     *     // ... filter to delete one CustomerPaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends CustomerPaymentMethodDeleteArgs>(args: SelectSubset<T, CustomerPaymentMethodDeleteArgs<ExtArgs>>): Prisma__CustomerPaymentMethodClient<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerPaymentMethod.
     * @param {CustomerPaymentMethodUpdateArgs} args - Arguments to update one CustomerPaymentMethod.
     * @example
     * // Update one CustomerPaymentMethod
     * const customerPaymentMethod = await prisma.customerPaymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerPaymentMethodUpdateArgs>(args: SelectSubset<T, CustomerPaymentMethodUpdateArgs<ExtArgs>>): Prisma__CustomerPaymentMethodClient<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerPaymentMethods.
     * @param {CustomerPaymentMethodDeleteManyArgs} args - Arguments to filter CustomerPaymentMethods to delete.
     * @example
     * // Delete a few CustomerPaymentMethods
     * const { count } = await prisma.customerPaymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerPaymentMethodDeleteManyArgs>(args?: SelectSubset<T, CustomerPaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerPaymentMethods
     * const customerPaymentMethod = await prisma.customerPaymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerPaymentMethodUpdateManyArgs>(args: SelectSubset<T, CustomerPaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPaymentMethods and returns the data updated in the database.
     * @param {CustomerPaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many CustomerPaymentMethods.
     * @example
     * // Update many CustomerPaymentMethods
     * const customerPaymentMethod = await prisma.customerPaymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerPaymentMethods and only return the `id`
     * const customerPaymentMethodWithIdOnly = await prisma.customerPaymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerPaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerPaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerPaymentMethod.
     * @param {CustomerPaymentMethodUpsertArgs} args - Arguments to update or create a CustomerPaymentMethod.
     * @example
     * // Update or create a CustomerPaymentMethod
     * const customerPaymentMethod = await prisma.customerPaymentMethod.upsert({
     *   create: {
     *     // ... data to create a CustomerPaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerPaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends CustomerPaymentMethodUpsertArgs>(args: SelectSubset<T, CustomerPaymentMethodUpsertArgs<ExtArgs>>): Prisma__CustomerPaymentMethodClient<$Result.GetResult<Prisma.$CustomerPaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentMethodCountArgs} args - Arguments to filter CustomerPaymentMethods to count.
     * @example
     * // Count the number of CustomerPaymentMethods
     * const count = await prisma.customerPaymentMethod.count({
     *   where: {
     *     // ... the filter for the CustomerPaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends CustomerPaymentMethodCountArgs>(
      args?: Subset<T, CustomerPaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerPaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerPaymentMethodAggregateArgs>(args: Subset<T, CustomerPaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetCustomerPaymentMethodAggregateType<T>>

    /**
     * Group by CustomerPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerPaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerPaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: CustomerPaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerPaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerPaymentMethod model
   */
  readonly fields: CustomerPaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerPaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerPaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customerProvider<T extends CustomerPaymentMethod$customerProviderArgs<ExtArgs> = {}>(args?: Subset<T, CustomerPaymentMethod$customerProviderArgs<ExtArgs>>): Prisma__CustomerProviderClient<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerPaymentMethod model
   */
  interface CustomerPaymentMethodFieldRefs {
    readonly id: FieldRef<"CustomerPaymentMethod", 'String'>
    readonly customerId: FieldRef<"CustomerPaymentMethod", 'String'>
    readonly customerProviderId: FieldRef<"CustomerPaymentMethod", 'String'>
    readonly provider: FieldRef<"CustomerPaymentMethod", 'PaymentProvider'>
    readonly accountId: FieldRef<"CustomerPaymentMethod", 'String'>
    readonly providerPaymentMethodId: FieldRef<"CustomerPaymentMethod", 'String'>
    readonly brand: FieldRef<"CustomerPaymentMethod", 'String'>
    readonly last4: FieldRef<"CustomerPaymentMethod", 'String'>
    readonly expMonth: FieldRef<"CustomerPaymentMethod", 'Int'>
    readonly expYear: FieldRef<"CustomerPaymentMethod", 'Int'>
    readonly isDefault: FieldRef<"CustomerPaymentMethod", 'Boolean'>
    readonly status: FieldRef<"CustomerPaymentMethod", 'String'>
    readonly fingerprint: FieldRef<"CustomerPaymentMethod", 'String'>
    readonly metadata: FieldRef<"CustomerPaymentMethod", 'Json'>
    readonly createdAt: FieldRef<"CustomerPaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerPaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerPaymentMethod findUnique
   */
  export type CustomerPaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPaymentMethod to fetch.
     */
    where: CustomerPaymentMethodWhereUniqueInput
  }

  /**
   * CustomerPaymentMethod findUniqueOrThrow
   */
  export type CustomerPaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPaymentMethod to fetch.
     */
    where: CustomerPaymentMethodWhereUniqueInput
  }

  /**
   * CustomerPaymentMethod findFirst
   */
  export type CustomerPaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPaymentMethod to fetch.
     */
    where?: CustomerPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPaymentMethods to fetch.
     */
    orderBy?: CustomerPaymentMethodOrderByWithRelationInput | CustomerPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPaymentMethods.
     */
    cursor?: CustomerPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPaymentMethods.
     */
    distinct?: CustomerPaymentMethodScalarFieldEnum | CustomerPaymentMethodScalarFieldEnum[]
  }

  /**
   * CustomerPaymentMethod findFirstOrThrow
   */
  export type CustomerPaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPaymentMethod to fetch.
     */
    where?: CustomerPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPaymentMethods to fetch.
     */
    orderBy?: CustomerPaymentMethodOrderByWithRelationInput | CustomerPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPaymentMethods.
     */
    cursor?: CustomerPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPaymentMethods.
     */
    distinct?: CustomerPaymentMethodScalarFieldEnum | CustomerPaymentMethodScalarFieldEnum[]
  }

  /**
   * CustomerPaymentMethod findMany
   */
  export type CustomerPaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPaymentMethods to fetch.
     */
    where?: CustomerPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPaymentMethods to fetch.
     */
    orderBy?: CustomerPaymentMethodOrderByWithRelationInput | CustomerPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerPaymentMethods.
     */
    cursor?: CustomerPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPaymentMethods.
     */
    skip?: number
    distinct?: CustomerPaymentMethodScalarFieldEnum | CustomerPaymentMethodScalarFieldEnum[]
  }

  /**
   * CustomerPaymentMethod create
   */
  export type CustomerPaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerPaymentMethod.
     */
    data: XOR<CustomerPaymentMethodCreateInput, CustomerPaymentMethodUncheckedCreateInput>
  }

  /**
   * CustomerPaymentMethod createMany
   */
  export type CustomerPaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerPaymentMethods.
     */
    data: CustomerPaymentMethodCreateManyInput | CustomerPaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerPaymentMethod createManyAndReturn
   */
  export type CustomerPaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerPaymentMethods.
     */
    data: CustomerPaymentMethodCreateManyInput | CustomerPaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPaymentMethod update
   */
  export type CustomerPaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerPaymentMethod.
     */
    data: XOR<CustomerPaymentMethodUpdateInput, CustomerPaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which CustomerPaymentMethod to update.
     */
    where: CustomerPaymentMethodWhereUniqueInput
  }

  /**
   * CustomerPaymentMethod updateMany
   */
  export type CustomerPaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerPaymentMethods.
     */
    data: XOR<CustomerPaymentMethodUpdateManyMutationInput, CustomerPaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPaymentMethods to update
     */
    where?: CustomerPaymentMethodWhereInput
    /**
     * Limit how many CustomerPaymentMethods to update.
     */
    limit?: number
  }

  /**
   * CustomerPaymentMethod updateManyAndReturn
   */
  export type CustomerPaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update CustomerPaymentMethods.
     */
    data: XOR<CustomerPaymentMethodUpdateManyMutationInput, CustomerPaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPaymentMethods to update
     */
    where?: CustomerPaymentMethodWhereInput
    /**
     * Limit how many CustomerPaymentMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPaymentMethod upsert
   */
  export type CustomerPaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerPaymentMethod to update in case it exists.
     */
    where: CustomerPaymentMethodWhereUniqueInput
    /**
     * In case the CustomerPaymentMethod found by the `where` argument doesn't exist, create a new CustomerPaymentMethod with this data.
     */
    create: XOR<CustomerPaymentMethodCreateInput, CustomerPaymentMethodUncheckedCreateInput>
    /**
     * In case the CustomerPaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerPaymentMethodUpdateInput, CustomerPaymentMethodUncheckedUpdateInput>
  }

  /**
   * CustomerPaymentMethod delete
   */
  export type CustomerPaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which CustomerPaymentMethod to delete.
     */
    where: CustomerPaymentMethodWhereUniqueInput
  }

  /**
   * CustomerPaymentMethod deleteMany
   */
  export type CustomerPaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPaymentMethods to delete
     */
    where?: CustomerPaymentMethodWhereInput
    /**
     * Limit how many CustomerPaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * CustomerPaymentMethod.customerProvider
   */
  export type CustomerPaymentMethod$customerProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    where?: CustomerProviderWhereInput
  }

  /**
   * CustomerPaymentMethod without action
   */
  export type CustomerPaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentMethod
     */
    select?: CustomerPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentMethod
     */
    omit?: CustomerPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model CustomerSubscription
   */

  export type AggregateCustomerSubscription = {
    _count: CustomerSubscriptionCountAggregateOutputType | null
    _avg: CustomerSubscriptionAvgAggregateOutputType | null
    _sum: CustomerSubscriptionSumAggregateOutputType | null
    _min: CustomerSubscriptionMinAggregateOutputType | null
    _max: CustomerSubscriptionMaxAggregateOutputType | null
  }

  export type CustomerSubscriptionAvgAggregateOutputType = {
    priceCents: number | null
  }

  export type CustomerSubscriptionSumAggregateOutputType = {
    priceCents: number | null
  }

  export type CustomerSubscriptionMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    merchantId: string | null
    productId: string | null
    offerId: string | null
    provider: $Enums.PaymentProvider | null
    accountId: string | null
    isNative: boolean | null
    customerProviderId: string | null
    providerSubscriptionId: string | null
    vaultPaymentMethodId: string | null
    status: $Enums.SubscriptionStatus | null
    startAt: Date | null
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAt: Date | null
    canceledAt: Date | null
    priceCents: number | null
    currency: $Enums.Currency | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerSubscriptionMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    merchantId: string | null
    productId: string | null
    offerId: string | null
    provider: $Enums.PaymentProvider | null
    accountId: string | null
    isNative: boolean | null
    customerProviderId: string | null
    providerSubscriptionId: string | null
    vaultPaymentMethodId: string | null
    status: $Enums.SubscriptionStatus | null
    startAt: Date | null
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAt: Date | null
    canceledAt: Date | null
    priceCents: number | null
    currency: $Enums.Currency | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerSubscriptionCountAggregateOutputType = {
    id: number
    customerId: number
    merchantId: number
    productId: number
    offerId: number
    provider: number
    accountId: number
    isNative: number
    customerProviderId: number
    providerSubscriptionId: number
    vaultPaymentMethodId: number
    status: number
    startAt: number
    trialEndsAt: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAt: number
    canceledAt: number
    priceCents: number
    currency: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerSubscriptionAvgAggregateInputType = {
    priceCents?: true
  }

  export type CustomerSubscriptionSumAggregateInputType = {
    priceCents?: true
  }

  export type CustomerSubscriptionMinAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    productId?: true
    offerId?: true
    provider?: true
    accountId?: true
    isNative?: true
    customerProviderId?: true
    providerSubscriptionId?: true
    vaultPaymentMethodId?: true
    status?: true
    startAt?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAt?: true
    canceledAt?: true
    priceCents?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerSubscriptionMaxAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    productId?: true
    offerId?: true
    provider?: true
    accountId?: true
    isNative?: true
    customerProviderId?: true
    providerSubscriptionId?: true
    vaultPaymentMethodId?: true
    status?: true
    startAt?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAt?: true
    canceledAt?: true
    priceCents?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerSubscriptionCountAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    productId?: true
    offerId?: true
    provider?: true
    accountId?: true
    isNative?: true
    customerProviderId?: true
    providerSubscriptionId?: true
    vaultPaymentMethodId?: true
    status?: true
    startAt?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAt?: true
    canceledAt?: true
    priceCents?: true
    currency?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerSubscription to aggregate.
     */
    where?: CustomerSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSubscriptions to fetch.
     */
    orderBy?: CustomerSubscriptionOrderByWithRelationInput | CustomerSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerSubscriptions
    **/
    _count?: true | CustomerSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerSubscriptionMaxAggregateInputType
  }

  export type GetCustomerSubscriptionAggregateType<T extends CustomerSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerSubscription[P]>
      : GetScalarType<T[P], AggregateCustomerSubscription[P]>
  }




  export type CustomerSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerSubscriptionWhereInput
    orderBy?: CustomerSubscriptionOrderByWithAggregationInput | CustomerSubscriptionOrderByWithAggregationInput[]
    by: CustomerSubscriptionScalarFieldEnum[] | CustomerSubscriptionScalarFieldEnum
    having?: CustomerSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerSubscriptionCountAggregateInputType | true
    _avg?: CustomerSubscriptionAvgAggregateInputType
    _sum?: CustomerSubscriptionSumAggregateInputType
    _min?: CustomerSubscriptionMinAggregateInputType
    _max?: CustomerSubscriptionMaxAggregateInputType
  }

  export type CustomerSubscriptionGroupByOutputType = {
    id: string
    customerId: string
    merchantId: string
    productId: string
    offerId: string | null
    provider: $Enums.PaymentProvider
    accountId: string | null
    isNative: boolean
    customerProviderId: string | null
    providerSubscriptionId: string | null
    vaultPaymentMethodId: string | null
    status: $Enums.SubscriptionStatus
    startAt: Date
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAt: Date | null
    canceledAt: Date | null
    priceCents: number
    currency: $Enums.Currency
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerSubscriptionCountAggregateOutputType | null
    _avg: CustomerSubscriptionAvgAggregateOutputType | null
    _sum: CustomerSubscriptionSumAggregateOutputType | null
    _min: CustomerSubscriptionMinAggregateOutputType | null
    _max: CustomerSubscriptionMaxAggregateOutputType | null
  }

  type GetCustomerSubscriptionGroupByPayload<T extends CustomerSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    productId?: boolean
    offerId?: boolean
    provider?: boolean
    accountId?: boolean
    isNative?: boolean
    customerProviderId?: boolean
    providerSubscriptionId?: boolean
    vaultPaymentMethodId?: boolean
    status?: boolean
    startAt?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAt?: boolean
    canceledAt?: boolean
    priceCents?: boolean
    currency?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerSubscription$customerProviderArgs<ExtArgs>
  }, ExtArgs["result"]["customerSubscription"]>

  export type CustomerSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    productId?: boolean
    offerId?: boolean
    provider?: boolean
    accountId?: boolean
    isNative?: boolean
    customerProviderId?: boolean
    providerSubscriptionId?: boolean
    vaultPaymentMethodId?: boolean
    status?: boolean
    startAt?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAt?: boolean
    canceledAt?: boolean
    priceCents?: boolean
    currency?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerSubscription$customerProviderArgs<ExtArgs>
  }, ExtArgs["result"]["customerSubscription"]>

  export type CustomerSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    productId?: boolean
    offerId?: boolean
    provider?: boolean
    accountId?: boolean
    isNative?: boolean
    customerProviderId?: boolean
    providerSubscriptionId?: boolean
    vaultPaymentMethodId?: boolean
    status?: boolean
    startAt?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAt?: boolean
    canceledAt?: boolean
    priceCents?: boolean
    currency?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerSubscription$customerProviderArgs<ExtArgs>
  }, ExtArgs["result"]["customerSubscription"]>

  export type CustomerSubscriptionSelectScalar = {
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    productId?: boolean
    offerId?: boolean
    provider?: boolean
    accountId?: boolean
    isNative?: boolean
    customerProviderId?: boolean
    providerSubscriptionId?: boolean
    vaultPaymentMethodId?: boolean
    status?: boolean
    startAt?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAt?: boolean
    canceledAt?: boolean
    priceCents?: boolean
    currency?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "merchantId" | "productId" | "offerId" | "provider" | "accountId" | "isNative" | "customerProviderId" | "providerSubscriptionId" | "vaultPaymentMethodId" | "status" | "startAt" | "trialEndsAt" | "currentPeriodStart" | "currentPeriodEnd" | "cancelAt" | "canceledAt" | "priceCents" | "currency" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["customerSubscription"]>
  export type CustomerSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerSubscription$customerProviderArgs<ExtArgs>
  }
  export type CustomerSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerSubscription$customerProviderArgs<ExtArgs>
  }
  export type CustomerSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerProvider?: boolean | CustomerSubscription$customerProviderArgs<ExtArgs>
  }

  export type $CustomerSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerSubscription"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      customerProvider: Prisma.$CustomerProviderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      merchantId: string
      productId: string
      offerId: string | null
      provider: $Enums.PaymentProvider
      accountId: string | null
      isNative: boolean
      customerProviderId: string | null
      providerSubscriptionId: string | null
      vaultPaymentMethodId: string | null
      status: $Enums.SubscriptionStatus
      startAt: Date
      trialEndsAt: Date | null
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      cancelAt: Date | null
      canceledAt: Date | null
      priceCents: number
      currency: $Enums.Currency
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerSubscription"]>
    composites: {}
  }

  type CustomerSubscriptionGetPayload<S extends boolean | null | undefined | CustomerSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$CustomerSubscriptionPayload, S>

  type CustomerSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerSubscriptionCountAggregateInputType | true
    }

  export interface CustomerSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerSubscription'], meta: { name: 'CustomerSubscription' } }
    /**
     * Find zero or one CustomerSubscription that matches the filter.
     * @param {CustomerSubscriptionFindUniqueArgs} args - Arguments to find a CustomerSubscription
     * @example
     * // Get one CustomerSubscription
     * const customerSubscription = await prisma.customerSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerSubscriptionFindUniqueArgs>(args: SelectSubset<T, CustomerSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__CustomerSubscriptionClient<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a CustomerSubscription
     * @example
     * // Get one CustomerSubscription
     * const customerSubscription = await prisma.customerSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerSubscriptionClient<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubscriptionFindFirstArgs} args - Arguments to find a CustomerSubscription
     * @example
     * // Get one CustomerSubscription
     * const customerSubscription = await prisma.customerSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerSubscriptionFindFirstArgs>(args?: SelectSubset<T, CustomerSubscriptionFindFirstArgs<ExtArgs>>): Prisma__CustomerSubscriptionClient<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubscriptionFindFirstOrThrowArgs} args - Arguments to find a CustomerSubscription
     * @example
     * // Get one CustomerSubscription
     * const customerSubscription = await prisma.customerSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerSubscriptionClient<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerSubscriptions
     * const customerSubscriptions = await prisma.customerSubscription.findMany()
     * 
     * // Get first 10 CustomerSubscriptions
     * const customerSubscriptions = await prisma.customerSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerSubscriptionWithIdOnly = await prisma.customerSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerSubscriptionFindManyArgs>(args?: SelectSubset<T, CustomerSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerSubscription.
     * @param {CustomerSubscriptionCreateArgs} args - Arguments to create a CustomerSubscription.
     * @example
     * // Create one CustomerSubscription
     * const CustomerSubscription = await prisma.customerSubscription.create({
     *   data: {
     *     // ... data to create a CustomerSubscription
     *   }
     * })
     * 
     */
    create<T extends CustomerSubscriptionCreateArgs>(args: SelectSubset<T, CustomerSubscriptionCreateArgs<ExtArgs>>): Prisma__CustomerSubscriptionClient<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerSubscriptions.
     * @param {CustomerSubscriptionCreateManyArgs} args - Arguments to create many CustomerSubscriptions.
     * @example
     * // Create many CustomerSubscriptions
     * const customerSubscription = await prisma.customerSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerSubscriptionCreateManyArgs>(args?: SelectSubset<T, CustomerSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerSubscriptions and returns the data saved in the database.
     * @param {CustomerSubscriptionCreateManyAndReturnArgs} args - Arguments to create many CustomerSubscriptions.
     * @example
     * // Create many CustomerSubscriptions
     * const customerSubscription = await prisma.customerSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerSubscriptions and only return the `id`
     * const customerSubscriptionWithIdOnly = await prisma.customerSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerSubscription.
     * @param {CustomerSubscriptionDeleteArgs} args - Arguments to delete one CustomerSubscription.
     * @example
     * // Delete one CustomerSubscription
     * const CustomerSubscription = await prisma.customerSubscription.delete({
     *   where: {
     *     // ... filter to delete one CustomerSubscription
     *   }
     * })
     * 
     */
    delete<T extends CustomerSubscriptionDeleteArgs>(args: SelectSubset<T, CustomerSubscriptionDeleteArgs<ExtArgs>>): Prisma__CustomerSubscriptionClient<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerSubscription.
     * @param {CustomerSubscriptionUpdateArgs} args - Arguments to update one CustomerSubscription.
     * @example
     * // Update one CustomerSubscription
     * const customerSubscription = await prisma.customerSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerSubscriptionUpdateArgs>(args: SelectSubset<T, CustomerSubscriptionUpdateArgs<ExtArgs>>): Prisma__CustomerSubscriptionClient<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerSubscriptions.
     * @param {CustomerSubscriptionDeleteManyArgs} args - Arguments to filter CustomerSubscriptions to delete.
     * @example
     * // Delete a few CustomerSubscriptions
     * const { count } = await prisma.customerSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerSubscriptionDeleteManyArgs>(args?: SelectSubset<T, CustomerSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerSubscriptions
     * const customerSubscription = await prisma.customerSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerSubscriptionUpdateManyArgs>(args: SelectSubset<T, CustomerSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerSubscriptions and returns the data updated in the database.
     * @param {CustomerSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many CustomerSubscriptions.
     * @example
     * // Update many CustomerSubscriptions
     * const customerSubscription = await prisma.customerSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerSubscriptions and only return the `id`
     * const customerSubscriptionWithIdOnly = await prisma.customerSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerSubscription.
     * @param {CustomerSubscriptionUpsertArgs} args - Arguments to update or create a CustomerSubscription.
     * @example
     * // Update or create a CustomerSubscription
     * const customerSubscription = await prisma.customerSubscription.upsert({
     *   create: {
     *     // ... data to create a CustomerSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerSubscription we want to update
     *   }
     * })
     */
    upsert<T extends CustomerSubscriptionUpsertArgs>(args: SelectSubset<T, CustomerSubscriptionUpsertArgs<ExtArgs>>): Prisma__CustomerSubscriptionClient<$Result.GetResult<Prisma.$CustomerSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubscriptionCountArgs} args - Arguments to filter CustomerSubscriptions to count.
     * @example
     * // Count the number of CustomerSubscriptions
     * const count = await prisma.customerSubscription.count({
     *   where: {
     *     // ... the filter for the CustomerSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends CustomerSubscriptionCountArgs>(
      args?: Subset<T, CustomerSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerSubscriptionAggregateArgs>(args: Subset<T, CustomerSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetCustomerSubscriptionAggregateType<T>>

    /**
     * Group by CustomerSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: CustomerSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerSubscription model
   */
  readonly fields: CustomerSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customerProvider<T extends CustomerSubscription$customerProviderArgs<ExtArgs> = {}>(args?: Subset<T, CustomerSubscription$customerProviderArgs<ExtArgs>>): Prisma__CustomerProviderClient<$Result.GetResult<Prisma.$CustomerProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerSubscription model
   */
  interface CustomerSubscriptionFieldRefs {
    readonly id: FieldRef<"CustomerSubscription", 'String'>
    readonly customerId: FieldRef<"CustomerSubscription", 'String'>
    readonly merchantId: FieldRef<"CustomerSubscription", 'String'>
    readonly productId: FieldRef<"CustomerSubscription", 'String'>
    readonly offerId: FieldRef<"CustomerSubscription", 'String'>
    readonly provider: FieldRef<"CustomerSubscription", 'PaymentProvider'>
    readonly accountId: FieldRef<"CustomerSubscription", 'String'>
    readonly isNative: FieldRef<"CustomerSubscription", 'Boolean'>
    readonly customerProviderId: FieldRef<"CustomerSubscription", 'String'>
    readonly providerSubscriptionId: FieldRef<"CustomerSubscription", 'String'>
    readonly vaultPaymentMethodId: FieldRef<"CustomerSubscription", 'String'>
    readonly status: FieldRef<"CustomerSubscription", 'SubscriptionStatus'>
    readonly startAt: FieldRef<"CustomerSubscription", 'DateTime'>
    readonly trialEndsAt: FieldRef<"CustomerSubscription", 'DateTime'>
    readonly currentPeriodStart: FieldRef<"CustomerSubscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"CustomerSubscription", 'DateTime'>
    readonly cancelAt: FieldRef<"CustomerSubscription", 'DateTime'>
    readonly canceledAt: FieldRef<"CustomerSubscription", 'DateTime'>
    readonly priceCents: FieldRef<"CustomerSubscription", 'Int'>
    readonly currency: FieldRef<"CustomerSubscription", 'Currency'>
    readonly metadata: FieldRef<"CustomerSubscription", 'Json'>
    readonly createdAt: FieldRef<"CustomerSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerSubscription findUnique
   */
  export type CustomerSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSubscription to fetch.
     */
    where: CustomerSubscriptionWhereUniqueInput
  }

  /**
   * CustomerSubscription findUniqueOrThrow
   */
  export type CustomerSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSubscription to fetch.
     */
    where: CustomerSubscriptionWhereUniqueInput
  }

  /**
   * CustomerSubscription findFirst
   */
  export type CustomerSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSubscription to fetch.
     */
    where?: CustomerSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSubscriptions to fetch.
     */
    orderBy?: CustomerSubscriptionOrderByWithRelationInput | CustomerSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerSubscriptions.
     */
    cursor?: CustomerSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerSubscriptions.
     */
    distinct?: CustomerSubscriptionScalarFieldEnum | CustomerSubscriptionScalarFieldEnum[]
  }

  /**
   * CustomerSubscription findFirstOrThrow
   */
  export type CustomerSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSubscription to fetch.
     */
    where?: CustomerSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSubscriptions to fetch.
     */
    orderBy?: CustomerSubscriptionOrderByWithRelationInput | CustomerSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerSubscriptions.
     */
    cursor?: CustomerSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerSubscriptions.
     */
    distinct?: CustomerSubscriptionScalarFieldEnum | CustomerSubscriptionScalarFieldEnum[]
  }

  /**
   * CustomerSubscription findMany
   */
  export type CustomerSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSubscriptions to fetch.
     */
    where?: CustomerSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSubscriptions to fetch.
     */
    orderBy?: CustomerSubscriptionOrderByWithRelationInput | CustomerSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerSubscriptions.
     */
    cursor?: CustomerSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSubscriptions.
     */
    skip?: number
    distinct?: CustomerSubscriptionScalarFieldEnum | CustomerSubscriptionScalarFieldEnum[]
  }

  /**
   * CustomerSubscription create
   */
  export type CustomerSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerSubscription.
     */
    data: XOR<CustomerSubscriptionCreateInput, CustomerSubscriptionUncheckedCreateInput>
  }

  /**
   * CustomerSubscription createMany
   */
  export type CustomerSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerSubscriptions.
     */
    data: CustomerSubscriptionCreateManyInput | CustomerSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerSubscription createManyAndReturn
   */
  export type CustomerSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerSubscriptions.
     */
    data: CustomerSubscriptionCreateManyInput | CustomerSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerSubscription update
   */
  export type CustomerSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerSubscription.
     */
    data: XOR<CustomerSubscriptionUpdateInput, CustomerSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which CustomerSubscription to update.
     */
    where: CustomerSubscriptionWhereUniqueInput
  }

  /**
   * CustomerSubscription updateMany
   */
  export type CustomerSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerSubscriptions.
     */
    data: XOR<CustomerSubscriptionUpdateManyMutationInput, CustomerSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which CustomerSubscriptions to update
     */
    where?: CustomerSubscriptionWhereInput
    /**
     * Limit how many CustomerSubscriptions to update.
     */
    limit?: number
  }

  /**
   * CustomerSubscription updateManyAndReturn
   */
  export type CustomerSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update CustomerSubscriptions.
     */
    data: XOR<CustomerSubscriptionUpdateManyMutationInput, CustomerSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which CustomerSubscriptions to update
     */
    where?: CustomerSubscriptionWhereInput
    /**
     * Limit how many CustomerSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerSubscription upsert
   */
  export type CustomerSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerSubscription to update in case it exists.
     */
    where: CustomerSubscriptionWhereUniqueInput
    /**
     * In case the CustomerSubscription found by the `where` argument doesn't exist, create a new CustomerSubscription with this data.
     */
    create: XOR<CustomerSubscriptionCreateInput, CustomerSubscriptionUncheckedCreateInput>
    /**
     * In case the CustomerSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerSubscriptionUpdateInput, CustomerSubscriptionUncheckedUpdateInput>
  }

  /**
   * CustomerSubscription delete
   */
  export type CustomerSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which CustomerSubscription to delete.
     */
    where: CustomerSubscriptionWhereUniqueInput
  }

  /**
   * CustomerSubscription deleteMany
   */
  export type CustomerSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerSubscriptions to delete
     */
    where?: CustomerSubscriptionWhereInput
    /**
     * Limit how many CustomerSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * CustomerSubscription.customerProvider
   */
  export type CustomerSubscription$customerProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProvider
     */
    select?: CustomerProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProvider
     */
    omit?: CustomerProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProviderInclude<ExtArgs> | null
    where?: CustomerProviderWhereInput
  }

  /**
   * CustomerSubscription without action
   */
  export type CustomerSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubscription
     */
    select?: CustomerSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubscription
     */
    omit?: CustomerSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model PaymentCustomer
   */

  export type AggregatePaymentCustomer = {
    _count: PaymentCustomerCountAggregateOutputType | null
    _min: PaymentCustomerMinAggregateOutputType | null
    _max: PaymentCustomerMaxAggregateOutputType | null
  }

  export type PaymentCustomerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    clinicId: string | null
    email: string | null
    document: string | null
    fullName: string | null
    phones: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCustomerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    clinicId: string | null
    email: string | null
    document: string | null
    fullName: string | null
    phones: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCustomerCountAggregateOutputType = {
    id: number
    userId: number
    clinicId: number
    email: number
    document: number
    fullName: number
    phones: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentCustomerMinAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    email?: true
    document?: true
    fullName?: true
    phones?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCustomerMaxAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    email?: true
    document?: true
    fullName?: true
    phones?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCustomerCountAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    email?: true
    document?: true
    fullName?: true
    phones?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentCustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentCustomer to aggregate.
     */
    where?: PaymentCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentCustomers to fetch.
     */
    orderBy?: PaymentCustomerOrderByWithRelationInput | PaymentCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentCustomers
    **/
    _count?: true | PaymentCustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentCustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentCustomerMaxAggregateInputType
  }

  export type GetPaymentCustomerAggregateType<T extends PaymentCustomerAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentCustomer[P]>
      : GetScalarType<T[P], AggregatePaymentCustomer[P]>
  }




  export type PaymentCustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentCustomerWhereInput
    orderBy?: PaymentCustomerOrderByWithAggregationInput | PaymentCustomerOrderByWithAggregationInput[]
    by: PaymentCustomerScalarFieldEnum[] | PaymentCustomerScalarFieldEnum
    having?: PaymentCustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCustomerCountAggregateInputType | true
    _min?: PaymentCustomerMinAggregateInputType
    _max?: PaymentCustomerMaxAggregateInputType
  }

  export type PaymentCustomerGroupByOutputType = {
    id: string
    userId: string | null
    clinicId: string | null
    email: string | null
    document: string | null
    fullName: string | null
    phones: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCustomerCountAggregateOutputType | null
    _min: PaymentCustomerMinAggregateOutputType | null
    _max: PaymentCustomerMaxAggregateOutputType | null
  }

  type GetPaymentCustomerGroupByPayload<T extends PaymentCustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentCustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentCustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentCustomerGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentCustomerGroupByOutputType[P]>
        }
      >
    >


  export type PaymentCustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    email?: boolean
    document?: boolean
    fullName?: boolean
    phones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentCustomer"]>

  export type PaymentCustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    email?: boolean
    document?: boolean
    fullName?: boolean
    phones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentCustomer"]>

  export type PaymentCustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    email?: boolean
    document?: boolean
    fullName?: boolean
    phones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentCustomer"]>

  export type PaymentCustomerSelectScalar = {
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    email?: boolean
    document?: boolean
    fullName?: boolean
    phones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentCustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "clinicId" | "email" | "document" | "fullName" | "phones" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentCustomer"]>

  export type $PaymentCustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentCustomer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      clinicId: string | null
      email: string | null
      document: string | null
      fullName: string | null
      phones: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentCustomer"]>
    composites: {}
  }

  type PaymentCustomerGetPayload<S extends boolean | null | undefined | PaymentCustomerDefaultArgs> = $Result.GetResult<Prisma.$PaymentCustomerPayload, S>

  type PaymentCustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentCustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCustomerCountAggregateInputType | true
    }

  export interface PaymentCustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentCustomer'], meta: { name: 'PaymentCustomer' } }
    /**
     * Find zero or one PaymentCustomer that matches the filter.
     * @param {PaymentCustomerFindUniqueArgs} args - Arguments to find a PaymentCustomer
     * @example
     * // Get one PaymentCustomer
     * const paymentCustomer = await prisma.paymentCustomer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentCustomerFindUniqueArgs>(args: SelectSubset<T, PaymentCustomerFindUniqueArgs<ExtArgs>>): Prisma__PaymentCustomerClient<$Result.GetResult<Prisma.$PaymentCustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentCustomer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentCustomerFindUniqueOrThrowArgs} args - Arguments to find a PaymentCustomer
     * @example
     * // Get one PaymentCustomer
     * const paymentCustomer = await prisma.paymentCustomer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentCustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentCustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentCustomerClient<$Result.GetResult<Prisma.$PaymentCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentCustomer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCustomerFindFirstArgs} args - Arguments to find a PaymentCustomer
     * @example
     * // Get one PaymentCustomer
     * const paymentCustomer = await prisma.paymentCustomer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentCustomerFindFirstArgs>(args?: SelectSubset<T, PaymentCustomerFindFirstArgs<ExtArgs>>): Prisma__PaymentCustomerClient<$Result.GetResult<Prisma.$PaymentCustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentCustomer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCustomerFindFirstOrThrowArgs} args - Arguments to find a PaymentCustomer
     * @example
     * // Get one PaymentCustomer
     * const paymentCustomer = await prisma.paymentCustomer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentCustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentCustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentCustomerClient<$Result.GetResult<Prisma.$PaymentCustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentCustomers
     * const paymentCustomers = await prisma.paymentCustomer.findMany()
     * 
     * // Get first 10 PaymentCustomers
     * const paymentCustomers = await prisma.paymentCustomer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentCustomerWithIdOnly = await prisma.paymentCustomer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentCustomerFindManyArgs>(args?: SelectSubset<T, PaymentCustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentCustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentCustomer.
     * @param {PaymentCustomerCreateArgs} args - Arguments to create a PaymentCustomer.
     * @example
     * // Create one PaymentCustomer
     * const PaymentCustomer = await prisma.paymentCustomer.create({
     *   data: {
     *     // ... data to create a PaymentCustomer
     *   }
     * })
     * 
     */
    create<T extends PaymentCustomerCreateArgs>(args: SelectSubset<T, PaymentCustomerCreateArgs<ExtArgs>>): Prisma__PaymentCustomerClient<$Result.GetResult<Prisma.$PaymentCustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentCustomers.
     * @param {PaymentCustomerCreateManyArgs} args - Arguments to create many PaymentCustomers.
     * @example
     * // Create many PaymentCustomers
     * const paymentCustomer = await prisma.paymentCustomer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCustomerCreateManyArgs>(args?: SelectSubset<T, PaymentCustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentCustomers and returns the data saved in the database.
     * @param {PaymentCustomerCreateManyAndReturnArgs} args - Arguments to create many PaymentCustomers.
     * @example
     * // Create many PaymentCustomers
     * const paymentCustomer = await prisma.paymentCustomer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentCustomers and only return the `id`
     * const paymentCustomerWithIdOnly = await prisma.paymentCustomer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentCustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentCustomer.
     * @param {PaymentCustomerDeleteArgs} args - Arguments to delete one PaymentCustomer.
     * @example
     * // Delete one PaymentCustomer
     * const PaymentCustomer = await prisma.paymentCustomer.delete({
     *   where: {
     *     // ... filter to delete one PaymentCustomer
     *   }
     * })
     * 
     */
    delete<T extends PaymentCustomerDeleteArgs>(args: SelectSubset<T, PaymentCustomerDeleteArgs<ExtArgs>>): Prisma__PaymentCustomerClient<$Result.GetResult<Prisma.$PaymentCustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentCustomer.
     * @param {PaymentCustomerUpdateArgs} args - Arguments to update one PaymentCustomer.
     * @example
     * // Update one PaymentCustomer
     * const paymentCustomer = await prisma.paymentCustomer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentCustomerUpdateArgs>(args: SelectSubset<T, PaymentCustomerUpdateArgs<ExtArgs>>): Prisma__PaymentCustomerClient<$Result.GetResult<Prisma.$PaymentCustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentCustomers.
     * @param {PaymentCustomerDeleteManyArgs} args - Arguments to filter PaymentCustomers to delete.
     * @example
     * // Delete a few PaymentCustomers
     * const { count } = await prisma.paymentCustomer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentCustomerDeleteManyArgs>(args?: SelectSubset<T, PaymentCustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentCustomers
     * const paymentCustomer = await prisma.paymentCustomer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentCustomerUpdateManyArgs>(args: SelectSubset<T, PaymentCustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentCustomers and returns the data updated in the database.
     * @param {PaymentCustomerUpdateManyAndReturnArgs} args - Arguments to update many PaymentCustomers.
     * @example
     * // Update many PaymentCustomers
     * const paymentCustomer = await prisma.paymentCustomer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentCustomers and only return the `id`
     * const paymentCustomerWithIdOnly = await prisma.paymentCustomer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentCustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentCustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentCustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentCustomer.
     * @param {PaymentCustomerUpsertArgs} args - Arguments to update or create a PaymentCustomer.
     * @example
     * // Update or create a PaymentCustomer
     * const paymentCustomer = await prisma.paymentCustomer.upsert({
     *   create: {
     *     // ... data to create a PaymentCustomer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentCustomer we want to update
     *   }
     * })
     */
    upsert<T extends PaymentCustomerUpsertArgs>(args: SelectSubset<T, PaymentCustomerUpsertArgs<ExtArgs>>): Prisma__PaymentCustomerClient<$Result.GetResult<Prisma.$PaymentCustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCustomerCountArgs} args - Arguments to filter PaymentCustomers to count.
     * @example
     * // Count the number of PaymentCustomers
     * const count = await prisma.paymentCustomer.count({
     *   where: {
     *     // ... the filter for the PaymentCustomers we want to count
     *   }
     * })
    **/
    count<T extends PaymentCustomerCountArgs>(
      args?: Subset<T, PaymentCustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentCustomerAggregateArgs>(args: Subset<T, PaymentCustomerAggregateArgs>): Prisma.PrismaPromise<GetPaymentCustomerAggregateType<T>>

    /**
     * Group by PaymentCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentCustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentCustomerGroupByArgs['orderBy'] }
        : { orderBy?: PaymentCustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentCustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentCustomer model
   */
  readonly fields: PaymentCustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentCustomer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentCustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentCustomer model
   */
  interface PaymentCustomerFieldRefs {
    readonly id: FieldRef<"PaymentCustomer", 'String'>
    readonly userId: FieldRef<"PaymentCustomer", 'String'>
    readonly clinicId: FieldRef<"PaymentCustomer", 'String'>
    readonly email: FieldRef<"PaymentCustomer", 'String'>
    readonly document: FieldRef<"PaymentCustomer", 'String'>
    readonly fullName: FieldRef<"PaymentCustomer", 'String'>
    readonly phones: FieldRef<"PaymentCustomer", 'String'>
    readonly createdAt: FieldRef<"PaymentCustomer", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentCustomer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentCustomer findUnique
   */
  export type PaymentCustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
    /**
     * Filter, which PaymentCustomer to fetch.
     */
    where: PaymentCustomerWhereUniqueInput
  }

  /**
   * PaymentCustomer findUniqueOrThrow
   */
  export type PaymentCustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
    /**
     * Filter, which PaymentCustomer to fetch.
     */
    where: PaymentCustomerWhereUniqueInput
  }

  /**
   * PaymentCustomer findFirst
   */
  export type PaymentCustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
    /**
     * Filter, which PaymentCustomer to fetch.
     */
    where?: PaymentCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentCustomers to fetch.
     */
    orderBy?: PaymentCustomerOrderByWithRelationInput | PaymentCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentCustomers.
     */
    cursor?: PaymentCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentCustomers.
     */
    distinct?: PaymentCustomerScalarFieldEnum | PaymentCustomerScalarFieldEnum[]
  }

  /**
   * PaymentCustomer findFirstOrThrow
   */
  export type PaymentCustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
    /**
     * Filter, which PaymentCustomer to fetch.
     */
    where?: PaymentCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentCustomers to fetch.
     */
    orderBy?: PaymentCustomerOrderByWithRelationInput | PaymentCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentCustomers.
     */
    cursor?: PaymentCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentCustomers.
     */
    distinct?: PaymentCustomerScalarFieldEnum | PaymentCustomerScalarFieldEnum[]
  }

  /**
   * PaymentCustomer findMany
   */
  export type PaymentCustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
    /**
     * Filter, which PaymentCustomers to fetch.
     */
    where?: PaymentCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentCustomers to fetch.
     */
    orderBy?: PaymentCustomerOrderByWithRelationInput | PaymentCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentCustomers.
     */
    cursor?: PaymentCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentCustomers.
     */
    skip?: number
    distinct?: PaymentCustomerScalarFieldEnum | PaymentCustomerScalarFieldEnum[]
  }

  /**
   * PaymentCustomer create
   */
  export type PaymentCustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentCustomer.
     */
    data?: XOR<PaymentCustomerCreateInput, PaymentCustomerUncheckedCreateInput>
  }

  /**
   * PaymentCustomer createMany
   */
  export type PaymentCustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentCustomers.
     */
    data: PaymentCustomerCreateManyInput | PaymentCustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentCustomer createManyAndReturn
   */
  export type PaymentCustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentCustomers.
     */
    data: PaymentCustomerCreateManyInput | PaymentCustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentCustomer update
   */
  export type PaymentCustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentCustomer.
     */
    data: XOR<PaymentCustomerUpdateInput, PaymentCustomerUncheckedUpdateInput>
    /**
     * Choose, which PaymentCustomer to update.
     */
    where: PaymentCustomerWhereUniqueInput
  }

  /**
   * PaymentCustomer updateMany
   */
  export type PaymentCustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentCustomers.
     */
    data: XOR<PaymentCustomerUpdateManyMutationInput, PaymentCustomerUncheckedUpdateManyInput>
    /**
     * Filter which PaymentCustomers to update
     */
    where?: PaymentCustomerWhereInput
    /**
     * Limit how many PaymentCustomers to update.
     */
    limit?: number
  }

  /**
   * PaymentCustomer updateManyAndReturn
   */
  export type PaymentCustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
    /**
     * The data used to update PaymentCustomers.
     */
    data: XOR<PaymentCustomerUpdateManyMutationInput, PaymentCustomerUncheckedUpdateManyInput>
    /**
     * Filter which PaymentCustomers to update
     */
    where?: PaymentCustomerWhereInput
    /**
     * Limit how many PaymentCustomers to update.
     */
    limit?: number
  }

  /**
   * PaymentCustomer upsert
   */
  export type PaymentCustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentCustomer to update in case it exists.
     */
    where: PaymentCustomerWhereUniqueInput
    /**
     * In case the PaymentCustomer found by the `where` argument doesn't exist, create a new PaymentCustomer with this data.
     */
    create: XOR<PaymentCustomerCreateInput, PaymentCustomerUncheckedCreateInput>
    /**
     * In case the PaymentCustomer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentCustomerUpdateInput, PaymentCustomerUncheckedUpdateInput>
  }

  /**
   * PaymentCustomer delete
   */
  export type PaymentCustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
    /**
     * Filter which PaymentCustomer to delete.
     */
    where: PaymentCustomerWhereUniqueInput
  }

  /**
   * PaymentCustomer deleteMany
   */
  export type PaymentCustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentCustomers to delete
     */
    where?: PaymentCustomerWhereInput
    /**
     * Limit how many PaymentCustomers to delete.
     */
    limit?: number
  }

  /**
   * PaymentCustomer without action
   */
  export type PaymentCustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCustomer
     */
    select?: PaymentCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentCustomer
     */
    omit?: PaymentCustomerOmit<ExtArgs> | null
  }


  /**
   * Model MessageTemplate
   */

  export type AggregateMessageTemplate = {
    _count: MessageTemplateCountAggregateOutputType | null
    _avg: MessageTemplateAvgAggregateOutputType | null
    _sum: MessageTemplateSumAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  export type MessageTemplateAvgAggregateOutputType = {
    smsMaxSegments: number | null
  }

  export type MessageTemplateSumAggregateOutputType = {
    smsMaxSegments: number | null
  }

  export type MessageTemplateMinAggregateOutputType = {
    id: string | null
    doctorId: string | null
    name: string | null
    channel: string | null
    subject: string | null
    html: string | null
    text: string | null
    mjml: string | null
    renderStrategy: string | null
    fromName: string | null
    fromEmail: string | null
    replyTo: string | null
    provider: string | null
    waTemplateName: string | null
    waLanguage: string | null
    waCategory: string | null
    waStatus: string | null
    waProviderId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    smsMaxSegments: number | null
  }

  export type MessageTemplateMaxAggregateOutputType = {
    id: string | null
    doctorId: string | null
    name: string | null
    channel: string | null
    subject: string | null
    html: string | null
    text: string | null
    mjml: string | null
    renderStrategy: string | null
    fromName: string | null
    fromEmail: string | null
    replyTo: string | null
    provider: string | null
    waTemplateName: string | null
    waLanguage: string | null
    waCategory: string | null
    waStatus: string | null
    waProviderId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    smsMaxSegments: number | null
  }

  export type MessageTemplateCountAggregateOutputType = {
    id: number
    doctorId: number
    name: number
    channel: number
    subject: number
    html: number
    text: number
    mjml: number
    renderStrategy: number
    fromName: number
    fromEmail: number
    replyTo: number
    provider: number
    waTemplateName: number
    waLanguage: number
    waCategory: number
    waComponents: number
    waStatus: number
    waProviderId: number
    isActive: number
    createdAt: number
    updatedAt: number
    variablesSchema: number
    sampleVariables: number
    tags: number
    smsMaxSegments: number
    _all: number
  }


  export type MessageTemplateAvgAggregateInputType = {
    smsMaxSegments?: true
  }

  export type MessageTemplateSumAggregateInputType = {
    smsMaxSegments?: true
  }

  export type MessageTemplateMinAggregateInputType = {
    id?: true
    doctorId?: true
    name?: true
    channel?: true
    subject?: true
    html?: true
    text?: true
    mjml?: true
    renderStrategy?: true
    fromName?: true
    fromEmail?: true
    replyTo?: true
    provider?: true
    waTemplateName?: true
    waLanguage?: true
    waCategory?: true
    waStatus?: true
    waProviderId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    smsMaxSegments?: true
  }

  export type MessageTemplateMaxAggregateInputType = {
    id?: true
    doctorId?: true
    name?: true
    channel?: true
    subject?: true
    html?: true
    text?: true
    mjml?: true
    renderStrategy?: true
    fromName?: true
    fromEmail?: true
    replyTo?: true
    provider?: true
    waTemplateName?: true
    waLanguage?: true
    waCategory?: true
    waStatus?: true
    waProviderId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    smsMaxSegments?: true
  }

  export type MessageTemplateCountAggregateInputType = {
    id?: true
    doctorId?: true
    name?: true
    channel?: true
    subject?: true
    html?: true
    text?: true
    mjml?: true
    renderStrategy?: true
    fromName?: true
    fromEmail?: true
    replyTo?: true
    provider?: true
    waTemplateName?: true
    waLanguage?: true
    waCategory?: true
    waComponents?: true
    waStatus?: true
    waProviderId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    variablesSchema?: true
    sampleVariables?: true
    tags?: true
    smsMaxSegments?: true
    _all?: true
  }

  export type MessageTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplate to aggregate.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageTemplates
    **/
    _count?: true | MessageTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type GetMessageTemplateAggregateType<T extends MessageTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageTemplate[P]>
      : GetScalarType<T[P], AggregateMessageTemplate[P]>
  }




  export type MessageTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplateWhereInput
    orderBy?: MessageTemplateOrderByWithAggregationInput | MessageTemplateOrderByWithAggregationInput[]
    by: MessageTemplateScalarFieldEnum[] | MessageTemplateScalarFieldEnum
    having?: MessageTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageTemplateCountAggregateInputType | true
    _avg?: MessageTemplateAvgAggregateInputType
    _sum?: MessageTemplateSumAggregateInputType
    _min?: MessageTemplateMinAggregateInputType
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type MessageTemplateGroupByOutputType = {
    id: string
    doctorId: string
    name: string
    channel: string
    subject: string | null
    html: string | null
    text: string | null
    mjml: string | null
    renderStrategy: string | null
    fromName: string | null
    fromEmail: string | null
    replyTo: string | null
    provider: string | null
    waTemplateName: string | null
    waLanguage: string | null
    waCategory: string | null
    waComponents: JsonValue | null
    waStatus: string | null
    waProviderId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    variablesSchema: JsonValue | null
    sampleVariables: JsonValue | null
    tags: string[]
    smsMaxSegments: number | null
    _count: MessageTemplateCountAggregateOutputType | null
    _avg: MessageTemplateAvgAggregateOutputType | null
    _sum: MessageTemplateSumAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  type GetMessageTemplateGroupByPayload<T extends MessageTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
        }
      >
    >


  export type MessageTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    name?: boolean
    channel?: boolean
    subject?: boolean
    html?: boolean
    text?: boolean
    mjml?: boolean
    renderStrategy?: boolean
    fromName?: boolean
    fromEmail?: boolean
    replyTo?: boolean
    provider?: boolean
    waTemplateName?: boolean
    waLanguage?: boolean
    waCategory?: boolean
    waComponents?: boolean
    waStatus?: boolean
    waProviderId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variablesSchema?: boolean
    sampleVariables?: boolean
    tags?: boolean
    smsMaxSegments?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | MessageTemplate$stepsArgs<ExtArgs>
    _count?: boolean | MessageTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    name?: boolean
    channel?: boolean
    subject?: boolean
    html?: boolean
    text?: boolean
    mjml?: boolean
    renderStrategy?: boolean
    fromName?: boolean
    fromEmail?: boolean
    replyTo?: boolean
    provider?: boolean
    waTemplateName?: boolean
    waLanguage?: boolean
    waCategory?: boolean
    waComponents?: boolean
    waStatus?: boolean
    waProviderId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variablesSchema?: boolean
    sampleVariables?: boolean
    tags?: boolean
    smsMaxSegments?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    name?: boolean
    channel?: boolean
    subject?: boolean
    html?: boolean
    text?: boolean
    mjml?: boolean
    renderStrategy?: boolean
    fromName?: boolean
    fromEmail?: boolean
    replyTo?: boolean
    provider?: boolean
    waTemplateName?: boolean
    waLanguage?: boolean
    waCategory?: boolean
    waComponents?: boolean
    waStatus?: boolean
    waProviderId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variablesSchema?: boolean
    sampleVariables?: boolean
    tags?: boolean
    smsMaxSegments?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectScalar = {
    id?: boolean
    doctorId?: boolean
    name?: boolean
    channel?: boolean
    subject?: boolean
    html?: boolean
    text?: boolean
    mjml?: boolean
    renderStrategy?: boolean
    fromName?: boolean
    fromEmail?: boolean
    replyTo?: boolean
    provider?: boolean
    waTemplateName?: boolean
    waLanguage?: boolean
    waCategory?: boolean
    waComponents?: boolean
    waStatus?: boolean
    waProviderId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variablesSchema?: boolean
    sampleVariables?: boolean
    tags?: boolean
    smsMaxSegments?: boolean
  }

  export type MessageTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doctorId" | "name" | "channel" | "subject" | "html" | "text" | "mjml" | "renderStrategy" | "fromName" | "fromEmail" | "replyTo" | "provider" | "waTemplateName" | "waLanguage" | "waCategory" | "waComponents" | "waStatus" | "waProviderId" | "isActive" | "createdAt" | "updatedAt" | "variablesSchema" | "sampleVariables" | "tags" | "smsMaxSegments", ExtArgs["result"]["messageTemplate"]>
  export type MessageTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | MessageTemplate$stepsArgs<ExtArgs>
    _count?: boolean | MessageTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageTemplate"
    objects: {
      doctor: Prisma.$UserPayload<ExtArgs>
      steps: Prisma.$MessageSequenceStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      doctorId: string
      name: string
      channel: string
      subject: string | null
      html: string | null
      text: string | null
      mjml: string | null
      renderStrategy: string | null
      fromName: string | null
      fromEmail: string | null
      replyTo: string | null
      provider: string | null
      waTemplateName: string | null
      waLanguage: string | null
      waCategory: string | null
      waComponents: Prisma.JsonValue | null
      waStatus: string | null
      waProviderId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      variablesSchema: Prisma.JsonValue | null
      sampleVariables: Prisma.JsonValue | null
      tags: string[]
      smsMaxSegments: number | null
    }, ExtArgs["result"]["messageTemplate"]>
    composites: {}
  }

  type MessageTemplateGetPayload<S extends boolean | null | undefined | MessageTemplateDefaultArgs> = $Result.GetResult<Prisma.$MessageTemplatePayload, S>

  type MessageTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageTemplateCountAggregateInputType | true
    }

  export interface MessageTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageTemplate'], meta: { name: 'MessageTemplate' } }
    /**
     * Find zero or one MessageTemplate that matches the filter.
     * @param {MessageTemplateFindUniqueArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageTemplateFindUniqueArgs>(args: SelectSubset<T, MessageTemplateFindUniqueArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageTemplateFindUniqueOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageTemplateFindFirstArgs>(args?: SelectSubset<T, MessageTemplateFindFirstArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany()
     * 
     * // Get first 10 MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageTemplateFindManyArgs>(args?: SelectSubset<T, MessageTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageTemplate.
     * @param {MessageTemplateCreateArgs} args - Arguments to create a MessageTemplate.
     * @example
     * // Create one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.create({
     *   data: {
     *     // ... data to create a MessageTemplate
     *   }
     * })
     * 
     */
    create<T extends MessageTemplateCreateArgs>(args: SelectSubset<T, MessageTemplateCreateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageTemplates.
     * @param {MessageTemplateCreateManyArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageTemplateCreateManyArgs>(args?: SelectSubset<T, MessageTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageTemplates and returns the data saved in the database.
     * @param {MessageTemplateCreateManyAndReturnArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageTemplates and only return the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageTemplate.
     * @param {MessageTemplateDeleteArgs} args - Arguments to delete one MessageTemplate.
     * @example
     * // Delete one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.delete({
     *   where: {
     *     // ... filter to delete one MessageTemplate
     *   }
     * })
     * 
     */
    delete<T extends MessageTemplateDeleteArgs>(args: SelectSubset<T, MessageTemplateDeleteArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageTemplate.
     * @param {MessageTemplateUpdateArgs} args - Arguments to update one MessageTemplate.
     * @example
     * // Update one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageTemplateUpdateArgs>(args: SelectSubset<T, MessageTemplateUpdateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageTemplates.
     * @param {MessageTemplateDeleteManyArgs} args - Arguments to filter MessageTemplates to delete.
     * @example
     * // Delete a few MessageTemplates
     * const { count } = await prisma.messageTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageTemplateDeleteManyArgs>(args?: SelectSubset<T, MessageTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageTemplateUpdateManyArgs>(args: SelectSubset<T, MessageTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageTemplates and returns the data updated in the database.
     * @param {MessageTemplateUpdateManyAndReturnArgs} args - Arguments to update many MessageTemplates.
     * @example
     * // Update many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageTemplates and only return the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageTemplate.
     * @param {MessageTemplateUpsertArgs} args - Arguments to update or create a MessageTemplate.
     * @example
     * // Update or create a MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.upsert({
     *   create: {
     *     // ... data to create a MessageTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageTemplate we want to update
     *   }
     * })
     */
    upsert<T extends MessageTemplateUpsertArgs>(args: SelectSubset<T, MessageTemplateUpsertArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateCountArgs} args - Arguments to filter MessageTemplates to count.
     * @example
     * // Count the number of MessageTemplates
     * const count = await prisma.messageTemplate.count({
     *   where: {
     *     // ... the filter for the MessageTemplates we want to count
     *   }
     * })
    **/
    count<T extends MessageTemplateCountArgs>(
      args?: Subset<T, MessageTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageTemplateAggregateArgs>(args: Subset<T, MessageTemplateAggregateArgs>): Prisma.PrismaPromise<GetMessageTemplateAggregateType<T>>

    /**
     * Group by MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageTemplateGroupByArgs['orderBy'] }
        : { orderBy?: MessageTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageTemplate model
   */
  readonly fields: MessageTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    steps<T extends MessageTemplate$stepsArgs<ExtArgs> = {}>(args?: Subset<T, MessageTemplate$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageTemplate model
   */
  interface MessageTemplateFieldRefs {
    readonly id: FieldRef<"MessageTemplate", 'String'>
    readonly doctorId: FieldRef<"MessageTemplate", 'String'>
    readonly name: FieldRef<"MessageTemplate", 'String'>
    readonly channel: FieldRef<"MessageTemplate", 'String'>
    readonly subject: FieldRef<"MessageTemplate", 'String'>
    readonly html: FieldRef<"MessageTemplate", 'String'>
    readonly text: FieldRef<"MessageTemplate", 'String'>
    readonly mjml: FieldRef<"MessageTemplate", 'String'>
    readonly renderStrategy: FieldRef<"MessageTemplate", 'String'>
    readonly fromName: FieldRef<"MessageTemplate", 'String'>
    readonly fromEmail: FieldRef<"MessageTemplate", 'String'>
    readonly replyTo: FieldRef<"MessageTemplate", 'String'>
    readonly provider: FieldRef<"MessageTemplate", 'String'>
    readonly waTemplateName: FieldRef<"MessageTemplate", 'String'>
    readonly waLanguage: FieldRef<"MessageTemplate", 'String'>
    readonly waCategory: FieldRef<"MessageTemplate", 'String'>
    readonly waComponents: FieldRef<"MessageTemplate", 'Json'>
    readonly waStatus: FieldRef<"MessageTemplate", 'String'>
    readonly waProviderId: FieldRef<"MessageTemplate", 'String'>
    readonly isActive: FieldRef<"MessageTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"MessageTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageTemplate", 'DateTime'>
    readonly variablesSchema: FieldRef<"MessageTemplate", 'Json'>
    readonly sampleVariables: FieldRef<"MessageTemplate", 'Json'>
    readonly tags: FieldRef<"MessageTemplate", 'String[]'>
    readonly smsMaxSegments: FieldRef<"MessageTemplate", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MessageTemplate findUnique
   */
  export type MessageTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findUniqueOrThrow
   */
  export type MessageTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findFirst
   */
  export type MessageTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findFirstOrThrow
   */
  export type MessageTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findMany
   */
  export type MessageTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplates to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate create
   */
  export type MessageTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageTemplate.
     */
    data: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
  }

  /**
   * MessageTemplate createMany
   */
  export type MessageTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplateCreateManyInput | MessageTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageTemplate createManyAndReturn
   */
  export type MessageTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplateCreateManyInput | MessageTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageTemplate update
   */
  export type MessageTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageTemplate.
     */
    data: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
    /**
     * Choose, which MessageTemplate to update.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate updateMany
   */
  export type MessageTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageTemplates.
     */
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyInput>
    /**
     * Filter which MessageTemplates to update
     */
    where?: MessageTemplateWhereInput
    /**
     * Limit how many MessageTemplates to update.
     */
    limit?: number
  }

  /**
   * MessageTemplate updateManyAndReturn
   */
  export type MessageTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * The data used to update MessageTemplates.
     */
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyInput>
    /**
     * Filter which MessageTemplates to update
     */
    where?: MessageTemplateWhereInput
    /**
     * Limit how many MessageTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageTemplate upsert
   */
  export type MessageTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageTemplate to update in case it exists.
     */
    where: MessageTemplateWhereUniqueInput
    /**
     * In case the MessageTemplate found by the `where` argument doesn't exist, create a new MessageTemplate with this data.
     */
    create: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
    /**
     * In case the MessageTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
  }

  /**
   * MessageTemplate delete
   */
  export type MessageTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter which MessageTemplate to delete.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate deleteMany
   */
  export type MessageTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplates to delete
     */
    where?: MessageTemplateWhereInput
    /**
     * Limit how many MessageTemplates to delete.
     */
    limit?: number
  }

  /**
   * MessageTemplate.steps
   */
  export type MessageTemplate$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
    where?: MessageSequenceStepWhereInput
    orderBy?: MessageSequenceStepOrderByWithRelationInput | MessageSequenceStepOrderByWithRelationInput[]
    cursor?: MessageSequenceStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageSequenceStepScalarFieldEnum | MessageSequenceStepScalarFieldEnum[]
  }

  /**
   * MessageTemplate without action
   */
  export type MessageTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
  }


  /**
   * Model MessageSequence
   */

  export type AggregateMessageSequence = {
    _count: MessageSequenceCountAggregateOutputType | null
    _min: MessageSequenceMinAggregateOutputType | null
    _max: MessageSequenceMaxAggregateOutputType | null
  }

  export type MessageSequenceMinAggregateOutputType = {
    id: string | null
    doctorId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageSequenceMaxAggregateOutputType = {
    id: string | null
    doctorId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageSequenceCountAggregateOutputType = {
    id: number
    doctorId: number
    name: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageSequenceMinAggregateInputType = {
    id?: true
    doctorId?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageSequenceMaxAggregateInputType = {
    id?: true
    doctorId?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageSequenceCountAggregateInputType = {
    id?: true
    doctorId?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageSequenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageSequence to aggregate.
     */
    where?: MessageSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageSequences to fetch.
     */
    orderBy?: MessageSequenceOrderByWithRelationInput | MessageSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageSequences
    **/
    _count?: true | MessageSequenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageSequenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageSequenceMaxAggregateInputType
  }

  export type GetMessageSequenceAggregateType<T extends MessageSequenceAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageSequence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageSequence[P]>
      : GetScalarType<T[P], AggregateMessageSequence[P]>
  }




  export type MessageSequenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageSequenceWhereInput
    orderBy?: MessageSequenceOrderByWithAggregationInput | MessageSequenceOrderByWithAggregationInput[]
    by: MessageSequenceScalarFieldEnum[] | MessageSequenceScalarFieldEnum
    having?: MessageSequenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageSequenceCountAggregateInputType | true
    _min?: MessageSequenceMinAggregateInputType
    _max?: MessageSequenceMaxAggregateInputType
  }

  export type MessageSequenceGroupByOutputType = {
    id: string
    doctorId: string
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MessageSequenceCountAggregateOutputType | null
    _min: MessageSequenceMinAggregateOutputType | null
    _max: MessageSequenceMaxAggregateOutputType | null
  }

  type GetMessageSequenceGroupByPayload<T extends MessageSequenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageSequenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageSequenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageSequenceGroupByOutputType[P]>
            : GetScalarType<T[P], MessageSequenceGroupByOutputType[P]>
        }
      >
    >


  export type MessageSequenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | MessageSequence$stepsArgs<ExtArgs>
    _count?: boolean | MessageSequenceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageSequence"]>

  export type MessageSequenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageSequence"]>

  export type MessageSequenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageSequence"]>

  export type MessageSequenceSelectScalar = {
    id?: boolean
    doctorId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageSequenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doctorId" | "name" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["messageSequence"]>
  export type MessageSequenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | MessageSequence$stepsArgs<ExtArgs>
    _count?: boolean | MessageSequenceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageSequenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageSequenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageSequencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageSequence"
    objects: {
      doctor: Prisma.$UserPayload<ExtArgs>
      steps: Prisma.$MessageSequenceStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      doctorId: string
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messageSequence"]>
    composites: {}
  }

  type MessageSequenceGetPayload<S extends boolean | null | undefined | MessageSequenceDefaultArgs> = $Result.GetResult<Prisma.$MessageSequencePayload, S>

  type MessageSequenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageSequenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageSequenceCountAggregateInputType | true
    }

  export interface MessageSequenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageSequence'], meta: { name: 'MessageSequence' } }
    /**
     * Find zero or one MessageSequence that matches the filter.
     * @param {MessageSequenceFindUniqueArgs} args - Arguments to find a MessageSequence
     * @example
     * // Get one MessageSequence
     * const messageSequence = await prisma.messageSequence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageSequenceFindUniqueArgs>(args: SelectSubset<T, MessageSequenceFindUniqueArgs<ExtArgs>>): Prisma__MessageSequenceClient<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageSequence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageSequenceFindUniqueOrThrowArgs} args - Arguments to find a MessageSequence
     * @example
     * // Get one MessageSequence
     * const messageSequence = await prisma.messageSequence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageSequenceFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageSequenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageSequenceClient<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageSequence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceFindFirstArgs} args - Arguments to find a MessageSequence
     * @example
     * // Get one MessageSequence
     * const messageSequence = await prisma.messageSequence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageSequenceFindFirstArgs>(args?: SelectSubset<T, MessageSequenceFindFirstArgs<ExtArgs>>): Prisma__MessageSequenceClient<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageSequence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceFindFirstOrThrowArgs} args - Arguments to find a MessageSequence
     * @example
     * // Get one MessageSequence
     * const messageSequence = await prisma.messageSequence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageSequenceFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageSequenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageSequenceClient<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageSequences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageSequences
     * const messageSequences = await prisma.messageSequence.findMany()
     * 
     * // Get first 10 MessageSequences
     * const messageSequences = await prisma.messageSequence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageSequenceWithIdOnly = await prisma.messageSequence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageSequenceFindManyArgs>(args?: SelectSubset<T, MessageSequenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageSequence.
     * @param {MessageSequenceCreateArgs} args - Arguments to create a MessageSequence.
     * @example
     * // Create one MessageSequence
     * const MessageSequence = await prisma.messageSequence.create({
     *   data: {
     *     // ... data to create a MessageSequence
     *   }
     * })
     * 
     */
    create<T extends MessageSequenceCreateArgs>(args: SelectSubset<T, MessageSequenceCreateArgs<ExtArgs>>): Prisma__MessageSequenceClient<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageSequences.
     * @param {MessageSequenceCreateManyArgs} args - Arguments to create many MessageSequences.
     * @example
     * // Create many MessageSequences
     * const messageSequence = await prisma.messageSequence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageSequenceCreateManyArgs>(args?: SelectSubset<T, MessageSequenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageSequences and returns the data saved in the database.
     * @param {MessageSequenceCreateManyAndReturnArgs} args - Arguments to create many MessageSequences.
     * @example
     * // Create many MessageSequences
     * const messageSequence = await prisma.messageSequence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageSequences and only return the `id`
     * const messageSequenceWithIdOnly = await prisma.messageSequence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageSequenceCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageSequenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageSequence.
     * @param {MessageSequenceDeleteArgs} args - Arguments to delete one MessageSequence.
     * @example
     * // Delete one MessageSequence
     * const MessageSequence = await prisma.messageSequence.delete({
     *   where: {
     *     // ... filter to delete one MessageSequence
     *   }
     * })
     * 
     */
    delete<T extends MessageSequenceDeleteArgs>(args: SelectSubset<T, MessageSequenceDeleteArgs<ExtArgs>>): Prisma__MessageSequenceClient<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageSequence.
     * @param {MessageSequenceUpdateArgs} args - Arguments to update one MessageSequence.
     * @example
     * // Update one MessageSequence
     * const messageSequence = await prisma.messageSequence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageSequenceUpdateArgs>(args: SelectSubset<T, MessageSequenceUpdateArgs<ExtArgs>>): Prisma__MessageSequenceClient<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageSequences.
     * @param {MessageSequenceDeleteManyArgs} args - Arguments to filter MessageSequences to delete.
     * @example
     * // Delete a few MessageSequences
     * const { count } = await prisma.messageSequence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageSequenceDeleteManyArgs>(args?: SelectSubset<T, MessageSequenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageSequences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageSequences
     * const messageSequence = await prisma.messageSequence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageSequenceUpdateManyArgs>(args: SelectSubset<T, MessageSequenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageSequences and returns the data updated in the database.
     * @param {MessageSequenceUpdateManyAndReturnArgs} args - Arguments to update many MessageSequences.
     * @example
     * // Update many MessageSequences
     * const messageSequence = await prisma.messageSequence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageSequences and only return the `id`
     * const messageSequenceWithIdOnly = await prisma.messageSequence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageSequenceUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageSequenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageSequence.
     * @param {MessageSequenceUpsertArgs} args - Arguments to update or create a MessageSequence.
     * @example
     * // Update or create a MessageSequence
     * const messageSequence = await prisma.messageSequence.upsert({
     *   create: {
     *     // ... data to create a MessageSequence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageSequence we want to update
     *   }
     * })
     */
    upsert<T extends MessageSequenceUpsertArgs>(args: SelectSubset<T, MessageSequenceUpsertArgs<ExtArgs>>): Prisma__MessageSequenceClient<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageSequences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceCountArgs} args - Arguments to filter MessageSequences to count.
     * @example
     * // Count the number of MessageSequences
     * const count = await prisma.messageSequence.count({
     *   where: {
     *     // ... the filter for the MessageSequences we want to count
     *   }
     * })
    **/
    count<T extends MessageSequenceCountArgs>(
      args?: Subset<T, MessageSequenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageSequenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageSequence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageSequenceAggregateArgs>(args: Subset<T, MessageSequenceAggregateArgs>): Prisma.PrismaPromise<GetMessageSequenceAggregateType<T>>

    /**
     * Group by MessageSequence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageSequenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageSequenceGroupByArgs['orderBy'] }
        : { orderBy?: MessageSequenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageSequenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageSequenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageSequence model
   */
  readonly fields: MessageSequenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageSequence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageSequenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    steps<T extends MessageSequence$stepsArgs<ExtArgs> = {}>(args?: Subset<T, MessageSequence$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageSequence model
   */
  interface MessageSequenceFieldRefs {
    readonly id: FieldRef<"MessageSequence", 'String'>
    readonly doctorId: FieldRef<"MessageSequence", 'String'>
    readonly name: FieldRef<"MessageSequence", 'String'>
    readonly description: FieldRef<"MessageSequence", 'String'>
    readonly isActive: FieldRef<"MessageSequence", 'Boolean'>
    readonly createdAt: FieldRef<"MessageSequence", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageSequence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageSequence findUnique
   */
  export type MessageSequenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceInclude<ExtArgs> | null
    /**
     * Filter, which MessageSequence to fetch.
     */
    where: MessageSequenceWhereUniqueInput
  }

  /**
   * MessageSequence findUniqueOrThrow
   */
  export type MessageSequenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceInclude<ExtArgs> | null
    /**
     * Filter, which MessageSequence to fetch.
     */
    where: MessageSequenceWhereUniqueInput
  }

  /**
   * MessageSequence findFirst
   */
  export type MessageSequenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceInclude<ExtArgs> | null
    /**
     * Filter, which MessageSequence to fetch.
     */
    where?: MessageSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageSequences to fetch.
     */
    orderBy?: MessageSequenceOrderByWithRelationInput | MessageSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageSequences.
     */
    cursor?: MessageSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageSequences.
     */
    distinct?: MessageSequenceScalarFieldEnum | MessageSequenceScalarFieldEnum[]
  }

  /**
   * MessageSequence findFirstOrThrow
   */
  export type MessageSequenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceInclude<ExtArgs> | null
    /**
     * Filter, which MessageSequence to fetch.
     */
    where?: MessageSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageSequences to fetch.
     */
    orderBy?: MessageSequenceOrderByWithRelationInput | MessageSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageSequences.
     */
    cursor?: MessageSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageSequences.
     */
    distinct?: MessageSequenceScalarFieldEnum | MessageSequenceScalarFieldEnum[]
  }

  /**
   * MessageSequence findMany
   */
  export type MessageSequenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceInclude<ExtArgs> | null
    /**
     * Filter, which MessageSequences to fetch.
     */
    where?: MessageSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageSequences to fetch.
     */
    orderBy?: MessageSequenceOrderByWithRelationInput | MessageSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageSequences.
     */
    cursor?: MessageSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageSequences.
     */
    skip?: number
    distinct?: MessageSequenceScalarFieldEnum | MessageSequenceScalarFieldEnum[]
  }

  /**
   * MessageSequence create
   */
  export type MessageSequenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageSequence.
     */
    data: XOR<MessageSequenceCreateInput, MessageSequenceUncheckedCreateInput>
  }

  /**
   * MessageSequence createMany
   */
  export type MessageSequenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageSequences.
     */
    data: MessageSequenceCreateManyInput | MessageSequenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageSequence createManyAndReturn
   */
  export type MessageSequenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * The data used to create many MessageSequences.
     */
    data: MessageSequenceCreateManyInput | MessageSequenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageSequence update
   */
  export type MessageSequenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageSequence.
     */
    data: XOR<MessageSequenceUpdateInput, MessageSequenceUncheckedUpdateInput>
    /**
     * Choose, which MessageSequence to update.
     */
    where: MessageSequenceWhereUniqueInput
  }

  /**
   * MessageSequence updateMany
   */
  export type MessageSequenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageSequences.
     */
    data: XOR<MessageSequenceUpdateManyMutationInput, MessageSequenceUncheckedUpdateManyInput>
    /**
     * Filter which MessageSequences to update
     */
    where?: MessageSequenceWhereInput
    /**
     * Limit how many MessageSequences to update.
     */
    limit?: number
  }

  /**
   * MessageSequence updateManyAndReturn
   */
  export type MessageSequenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * The data used to update MessageSequences.
     */
    data: XOR<MessageSequenceUpdateManyMutationInput, MessageSequenceUncheckedUpdateManyInput>
    /**
     * Filter which MessageSequences to update
     */
    where?: MessageSequenceWhereInput
    /**
     * Limit how many MessageSequences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageSequence upsert
   */
  export type MessageSequenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageSequence to update in case it exists.
     */
    where: MessageSequenceWhereUniqueInput
    /**
     * In case the MessageSequence found by the `where` argument doesn't exist, create a new MessageSequence with this data.
     */
    create: XOR<MessageSequenceCreateInput, MessageSequenceUncheckedCreateInput>
    /**
     * In case the MessageSequence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageSequenceUpdateInput, MessageSequenceUncheckedUpdateInput>
  }

  /**
   * MessageSequence delete
   */
  export type MessageSequenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceInclude<ExtArgs> | null
    /**
     * Filter which MessageSequence to delete.
     */
    where: MessageSequenceWhereUniqueInput
  }

  /**
   * MessageSequence deleteMany
   */
  export type MessageSequenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageSequences to delete
     */
    where?: MessageSequenceWhereInput
    /**
     * Limit how many MessageSequences to delete.
     */
    limit?: number
  }

  /**
   * MessageSequence.steps
   */
  export type MessageSequence$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
    where?: MessageSequenceStepWhereInput
    orderBy?: MessageSequenceStepOrderByWithRelationInput | MessageSequenceStepOrderByWithRelationInput[]
    cursor?: MessageSequenceStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageSequenceStepScalarFieldEnum | MessageSequenceStepScalarFieldEnum[]
  }

  /**
   * MessageSequence without action
   */
  export type MessageSequenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequence
     */
    select?: MessageSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequence
     */
    omit?: MessageSequenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceInclude<ExtArgs> | null
  }


  /**
   * Model MessageSequenceStep
   */

  export type AggregateMessageSequenceStep = {
    _count: MessageSequenceStepCountAggregateOutputType | null
    _avg: MessageSequenceStepAvgAggregateOutputType | null
    _sum: MessageSequenceStepSumAggregateOutputType | null
    _min: MessageSequenceStepMinAggregateOutputType | null
    _max: MessageSequenceStepMaxAggregateOutputType | null
  }

  export type MessageSequenceStepAvgAggregateOutputType = {
    orderIndex: number | null
    delayAmount: number | null
  }

  export type MessageSequenceStepSumAggregateOutputType = {
    orderIndex: number | null
    delayAmount: number | null
  }

  export type MessageSequenceStepMinAggregateOutputType = {
    id: string | null
    sequenceId: string | null
    orderIndex: number | null
    delayAmount: number | null
    delayUnit: string | null
    templateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageSequenceStepMaxAggregateOutputType = {
    id: string | null
    sequenceId: string | null
    orderIndex: number | null
    delayAmount: number | null
    delayUnit: string | null
    templateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageSequenceStepCountAggregateOutputType = {
    id: number
    sequenceId: number
    orderIndex: number
    delayAmount: number
    delayUnit: number
    templateId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageSequenceStepAvgAggregateInputType = {
    orderIndex?: true
    delayAmount?: true
  }

  export type MessageSequenceStepSumAggregateInputType = {
    orderIndex?: true
    delayAmount?: true
  }

  export type MessageSequenceStepMinAggregateInputType = {
    id?: true
    sequenceId?: true
    orderIndex?: true
    delayAmount?: true
    delayUnit?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageSequenceStepMaxAggregateInputType = {
    id?: true
    sequenceId?: true
    orderIndex?: true
    delayAmount?: true
    delayUnit?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageSequenceStepCountAggregateInputType = {
    id?: true
    sequenceId?: true
    orderIndex?: true
    delayAmount?: true
    delayUnit?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageSequenceStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageSequenceStep to aggregate.
     */
    where?: MessageSequenceStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageSequenceSteps to fetch.
     */
    orderBy?: MessageSequenceStepOrderByWithRelationInput | MessageSequenceStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageSequenceStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageSequenceSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageSequenceSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageSequenceSteps
    **/
    _count?: true | MessageSequenceStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageSequenceStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSequenceStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageSequenceStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageSequenceStepMaxAggregateInputType
  }

  export type GetMessageSequenceStepAggregateType<T extends MessageSequenceStepAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageSequenceStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageSequenceStep[P]>
      : GetScalarType<T[P], AggregateMessageSequenceStep[P]>
  }




  export type MessageSequenceStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageSequenceStepWhereInput
    orderBy?: MessageSequenceStepOrderByWithAggregationInput | MessageSequenceStepOrderByWithAggregationInput[]
    by: MessageSequenceStepScalarFieldEnum[] | MessageSequenceStepScalarFieldEnum
    having?: MessageSequenceStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageSequenceStepCountAggregateInputType | true
    _avg?: MessageSequenceStepAvgAggregateInputType
    _sum?: MessageSequenceStepSumAggregateInputType
    _min?: MessageSequenceStepMinAggregateInputType
    _max?: MessageSequenceStepMaxAggregateInputType
  }

  export type MessageSequenceStepGroupByOutputType = {
    id: string
    sequenceId: string
    orderIndex: number
    delayAmount: number
    delayUnit: string
    templateId: string
    createdAt: Date
    updatedAt: Date
    _count: MessageSequenceStepCountAggregateOutputType | null
    _avg: MessageSequenceStepAvgAggregateOutputType | null
    _sum: MessageSequenceStepSumAggregateOutputType | null
    _min: MessageSequenceStepMinAggregateOutputType | null
    _max: MessageSequenceStepMaxAggregateOutputType | null
  }

  type GetMessageSequenceStepGroupByPayload<T extends MessageSequenceStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageSequenceStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageSequenceStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageSequenceStepGroupByOutputType[P]>
            : GetScalarType<T[P], MessageSequenceStepGroupByOutputType[P]>
        }
      >
    >


  export type MessageSequenceStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequenceId?: boolean
    orderIndex?: boolean
    delayAmount?: boolean
    delayUnit?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sequence?: boolean | MessageSequenceDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageSequenceStep"]>

  export type MessageSequenceStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequenceId?: boolean
    orderIndex?: boolean
    delayAmount?: boolean
    delayUnit?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sequence?: boolean | MessageSequenceDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageSequenceStep"]>

  export type MessageSequenceStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequenceId?: boolean
    orderIndex?: boolean
    delayAmount?: boolean
    delayUnit?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sequence?: boolean | MessageSequenceDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageSequenceStep"]>

  export type MessageSequenceStepSelectScalar = {
    id?: boolean
    sequenceId?: boolean
    orderIndex?: boolean
    delayAmount?: boolean
    delayUnit?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageSequenceStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sequenceId" | "orderIndex" | "delayAmount" | "delayUnit" | "templateId" | "createdAt" | "updatedAt", ExtArgs["result"]["messageSequenceStep"]>
  export type MessageSequenceStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sequence?: boolean | MessageSequenceDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
  }
  export type MessageSequenceStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sequence?: boolean | MessageSequenceDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
  }
  export type MessageSequenceStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sequence?: boolean | MessageSequenceDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
  }

  export type $MessageSequenceStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageSequenceStep"
    objects: {
      sequence: Prisma.$MessageSequencePayload<ExtArgs>
      template: Prisma.$MessageTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sequenceId: string
      orderIndex: number
      delayAmount: number
      delayUnit: string
      templateId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messageSequenceStep"]>
    composites: {}
  }

  type MessageSequenceStepGetPayload<S extends boolean | null | undefined | MessageSequenceStepDefaultArgs> = $Result.GetResult<Prisma.$MessageSequenceStepPayload, S>

  type MessageSequenceStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageSequenceStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageSequenceStepCountAggregateInputType | true
    }

  export interface MessageSequenceStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageSequenceStep'], meta: { name: 'MessageSequenceStep' } }
    /**
     * Find zero or one MessageSequenceStep that matches the filter.
     * @param {MessageSequenceStepFindUniqueArgs} args - Arguments to find a MessageSequenceStep
     * @example
     * // Get one MessageSequenceStep
     * const messageSequenceStep = await prisma.messageSequenceStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageSequenceStepFindUniqueArgs>(args: SelectSubset<T, MessageSequenceStepFindUniqueArgs<ExtArgs>>): Prisma__MessageSequenceStepClient<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageSequenceStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageSequenceStepFindUniqueOrThrowArgs} args - Arguments to find a MessageSequenceStep
     * @example
     * // Get one MessageSequenceStep
     * const messageSequenceStep = await prisma.messageSequenceStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageSequenceStepFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageSequenceStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageSequenceStepClient<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageSequenceStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceStepFindFirstArgs} args - Arguments to find a MessageSequenceStep
     * @example
     * // Get one MessageSequenceStep
     * const messageSequenceStep = await prisma.messageSequenceStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageSequenceStepFindFirstArgs>(args?: SelectSubset<T, MessageSequenceStepFindFirstArgs<ExtArgs>>): Prisma__MessageSequenceStepClient<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageSequenceStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceStepFindFirstOrThrowArgs} args - Arguments to find a MessageSequenceStep
     * @example
     * // Get one MessageSequenceStep
     * const messageSequenceStep = await prisma.messageSequenceStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageSequenceStepFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageSequenceStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageSequenceStepClient<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageSequenceSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageSequenceSteps
     * const messageSequenceSteps = await prisma.messageSequenceStep.findMany()
     * 
     * // Get first 10 MessageSequenceSteps
     * const messageSequenceSteps = await prisma.messageSequenceStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageSequenceStepWithIdOnly = await prisma.messageSequenceStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageSequenceStepFindManyArgs>(args?: SelectSubset<T, MessageSequenceStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageSequenceStep.
     * @param {MessageSequenceStepCreateArgs} args - Arguments to create a MessageSequenceStep.
     * @example
     * // Create one MessageSequenceStep
     * const MessageSequenceStep = await prisma.messageSequenceStep.create({
     *   data: {
     *     // ... data to create a MessageSequenceStep
     *   }
     * })
     * 
     */
    create<T extends MessageSequenceStepCreateArgs>(args: SelectSubset<T, MessageSequenceStepCreateArgs<ExtArgs>>): Prisma__MessageSequenceStepClient<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageSequenceSteps.
     * @param {MessageSequenceStepCreateManyArgs} args - Arguments to create many MessageSequenceSteps.
     * @example
     * // Create many MessageSequenceSteps
     * const messageSequenceStep = await prisma.messageSequenceStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageSequenceStepCreateManyArgs>(args?: SelectSubset<T, MessageSequenceStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageSequenceSteps and returns the data saved in the database.
     * @param {MessageSequenceStepCreateManyAndReturnArgs} args - Arguments to create many MessageSequenceSteps.
     * @example
     * // Create many MessageSequenceSteps
     * const messageSequenceStep = await prisma.messageSequenceStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageSequenceSteps and only return the `id`
     * const messageSequenceStepWithIdOnly = await prisma.messageSequenceStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageSequenceStepCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageSequenceStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageSequenceStep.
     * @param {MessageSequenceStepDeleteArgs} args - Arguments to delete one MessageSequenceStep.
     * @example
     * // Delete one MessageSequenceStep
     * const MessageSequenceStep = await prisma.messageSequenceStep.delete({
     *   where: {
     *     // ... filter to delete one MessageSequenceStep
     *   }
     * })
     * 
     */
    delete<T extends MessageSequenceStepDeleteArgs>(args: SelectSubset<T, MessageSequenceStepDeleteArgs<ExtArgs>>): Prisma__MessageSequenceStepClient<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageSequenceStep.
     * @param {MessageSequenceStepUpdateArgs} args - Arguments to update one MessageSequenceStep.
     * @example
     * // Update one MessageSequenceStep
     * const messageSequenceStep = await prisma.messageSequenceStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageSequenceStepUpdateArgs>(args: SelectSubset<T, MessageSequenceStepUpdateArgs<ExtArgs>>): Prisma__MessageSequenceStepClient<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageSequenceSteps.
     * @param {MessageSequenceStepDeleteManyArgs} args - Arguments to filter MessageSequenceSteps to delete.
     * @example
     * // Delete a few MessageSequenceSteps
     * const { count } = await prisma.messageSequenceStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageSequenceStepDeleteManyArgs>(args?: SelectSubset<T, MessageSequenceStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageSequenceSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageSequenceSteps
     * const messageSequenceStep = await prisma.messageSequenceStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageSequenceStepUpdateManyArgs>(args: SelectSubset<T, MessageSequenceStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageSequenceSteps and returns the data updated in the database.
     * @param {MessageSequenceStepUpdateManyAndReturnArgs} args - Arguments to update many MessageSequenceSteps.
     * @example
     * // Update many MessageSequenceSteps
     * const messageSequenceStep = await prisma.messageSequenceStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageSequenceSteps and only return the `id`
     * const messageSequenceStepWithIdOnly = await prisma.messageSequenceStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageSequenceStepUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageSequenceStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageSequenceStep.
     * @param {MessageSequenceStepUpsertArgs} args - Arguments to update or create a MessageSequenceStep.
     * @example
     * // Update or create a MessageSequenceStep
     * const messageSequenceStep = await prisma.messageSequenceStep.upsert({
     *   create: {
     *     // ... data to create a MessageSequenceStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageSequenceStep we want to update
     *   }
     * })
     */
    upsert<T extends MessageSequenceStepUpsertArgs>(args: SelectSubset<T, MessageSequenceStepUpsertArgs<ExtArgs>>): Prisma__MessageSequenceStepClient<$Result.GetResult<Prisma.$MessageSequenceStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageSequenceSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceStepCountArgs} args - Arguments to filter MessageSequenceSteps to count.
     * @example
     * // Count the number of MessageSequenceSteps
     * const count = await prisma.messageSequenceStep.count({
     *   where: {
     *     // ... the filter for the MessageSequenceSteps we want to count
     *   }
     * })
    **/
    count<T extends MessageSequenceStepCountArgs>(
      args?: Subset<T, MessageSequenceStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageSequenceStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageSequenceStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageSequenceStepAggregateArgs>(args: Subset<T, MessageSequenceStepAggregateArgs>): Prisma.PrismaPromise<GetMessageSequenceStepAggregateType<T>>

    /**
     * Group by MessageSequenceStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageSequenceStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageSequenceStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageSequenceStepGroupByArgs['orderBy'] }
        : { orderBy?: MessageSequenceStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageSequenceStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageSequenceStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageSequenceStep model
   */
  readonly fields: MessageSequenceStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageSequenceStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageSequenceStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sequence<T extends MessageSequenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageSequenceDefaultArgs<ExtArgs>>): Prisma__MessageSequenceClient<$Result.GetResult<Prisma.$MessageSequencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends MessageTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageTemplateDefaultArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageSequenceStep model
   */
  interface MessageSequenceStepFieldRefs {
    readonly id: FieldRef<"MessageSequenceStep", 'String'>
    readonly sequenceId: FieldRef<"MessageSequenceStep", 'String'>
    readonly orderIndex: FieldRef<"MessageSequenceStep", 'Int'>
    readonly delayAmount: FieldRef<"MessageSequenceStep", 'Int'>
    readonly delayUnit: FieldRef<"MessageSequenceStep", 'String'>
    readonly templateId: FieldRef<"MessageSequenceStep", 'String'>
    readonly createdAt: FieldRef<"MessageSequenceStep", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageSequenceStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageSequenceStep findUnique
   */
  export type MessageSequenceStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
    /**
     * Filter, which MessageSequenceStep to fetch.
     */
    where: MessageSequenceStepWhereUniqueInput
  }

  /**
   * MessageSequenceStep findUniqueOrThrow
   */
  export type MessageSequenceStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
    /**
     * Filter, which MessageSequenceStep to fetch.
     */
    where: MessageSequenceStepWhereUniqueInput
  }

  /**
   * MessageSequenceStep findFirst
   */
  export type MessageSequenceStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
    /**
     * Filter, which MessageSequenceStep to fetch.
     */
    where?: MessageSequenceStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageSequenceSteps to fetch.
     */
    orderBy?: MessageSequenceStepOrderByWithRelationInput | MessageSequenceStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageSequenceSteps.
     */
    cursor?: MessageSequenceStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageSequenceSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageSequenceSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageSequenceSteps.
     */
    distinct?: MessageSequenceStepScalarFieldEnum | MessageSequenceStepScalarFieldEnum[]
  }

  /**
   * MessageSequenceStep findFirstOrThrow
   */
  export type MessageSequenceStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
    /**
     * Filter, which MessageSequenceStep to fetch.
     */
    where?: MessageSequenceStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageSequenceSteps to fetch.
     */
    orderBy?: MessageSequenceStepOrderByWithRelationInput | MessageSequenceStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageSequenceSteps.
     */
    cursor?: MessageSequenceStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageSequenceSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageSequenceSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageSequenceSteps.
     */
    distinct?: MessageSequenceStepScalarFieldEnum | MessageSequenceStepScalarFieldEnum[]
  }

  /**
   * MessageSequenceStep findMany
   */
  export type MessageSequenceStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
    /**
     * Filter, which MessageSequenceSteps to fetch.
     */
    where?: MessageSequenceStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageSequenceSteps to fetch.
     */
    orderBy?: MessageSequenceStepOrderByWithRelationInput | MessageSequenceStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageSequenceSteps.
     */
    cursor?: MessageSequenceStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageSequenceSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageSequenceSteps.
     */
    skip?: number
    distinct?: MessageSequenceStepScalarFieldEnum | MessageSequenceStepScalarFieldEnum[]
  }

  /**
   * MessageSequenceStep create
   */
  export type MessageSequenceStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageSequenceStep.
     */
    data: XOR<MessageSequenceStepCreateInput, MessageSequenceStepUncheckedCreateInput>
  }

  /**
   * MessageSequenceStep createMany
   */
  export type MessageSequenceStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageSequenceSteps.
     */
    data: MessageSequenceStepCreateManyInput | MessageSequenceStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageSequenceStep createManyAndReturn
   */
  export type MessageSequenceStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * The data used to create many MessageSequenceSteps.
     */
    data: MessageSequenceStepCreateManyInput | MessageSequenceStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageSequenceStep update
   */
  export type MessageSequenceStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageSequenceStep.
     */
    data: XOR<MessageSequenceStepUpdateInput, MessageSequenceStepUncheckedUpdateInput>
    /**
     * Choose, which MessageSequenceStep to update.
     */
    where: MessageSequenceStepWhereUniqueInput
  }

  /**
   * MessageSequenceStep updateMany
   */
  export type MessageSequenceStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageSequenceSteps.
     */
    data: XOR<MessageSequenceStepUpdateManyMutationInput, MessageSequenceStepUncheckedUpdateManyInput>
    /**
     * Filter which MessageSequenceSteps to update
     */
    where?: MessageSequenceStepWhereInput
    /**
     * Limit how many MessageSequenceSteps to update.
     */
    limit?: number
  }

  /**
   * MessageSequenceStep updateManyAndReturn
   */
  export type MessageSequenceStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * The data used to update MessageSequenceSteps.
     */
    data: XOR<MessageSequenceStepUpdateManyMutationInput, MessageSequenceStepUncheckedUpdateManyInput>
    /**
     * Filter which MessageSequenceSteps to update
     */
    where?: MessageSequenceStepWhereInput
    /**
     * Limit how many MessageSequenceSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageSequenceStep upsert
   */
  export type MessageSequenceStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageSequenceStep to update in case it exists.
     */
    where: MessageSequenceStepWhereUniqueInput
    /**
     * In case the MessageSequenceStep found by the `where` argument doesn't exist, create a new MessageSequenceStep with this data.
     */
    create: XOR<MessageSequenceStepCreateInput, MessageSequenceStepUncheckedCreateInput>
    /**
     * In case the MessageSequenceStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageSequenceStepUpdateInput, MessageSequenceStepUncheckedUpdateInput>
  }

  /**
   * MessageSequenceStep delete
   */
  export type MessageSequenceStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
    /**
     * Filter which MessageSequenceStep to delete.
     */
    where: MessageSequenceStepWhereUniqueInput
  }

  /**
   * MessageSequenceStep deleteMany
   */
  export type MessageSequenceStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageSequenceSteps to delete
     */
    where?: MessageSequenceStepWhereInput
    /**
     * Limit how many MessageSequenceSteps to delete.
     */
    limit?: number
  }

  /**
   * MessageSequenceStep without action
   */
  export type MessageSequenceStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageSequenceStep
     */
    select?: MessageSequenceStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageSequenceStep
     */
    omit?: MessageSequenceStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageSequenceStepInclude<ExtArgs> | null
  }


  /**
   * Model CampaignJob
   */

  export type AggregateCampaignJob = {
    _count: CampaignJobCountAggregateOutputType | null
    _min: CampaignJobMinAggregateOutputType | null
    _max: CampaignJobMaxAggregateOutputType | null
  }

  export type CampaignJobMinAggregateOutputType = {
    id: string | null
    doctorId: string | null
    campaignId: string | null
    channel: string | null
    trigger: string | null
    scheduleAt: Date | null
    createdAt: Date | null
    status: string | null
    lastError: string | null
  }

  export type CampaignJobMaxAggregateOutputType = {
    id: string | null
    doctorId: string | null
    campaignId: string | null
    channel: string | null
    trigger: string | null
    scheduleAt: Date | null
    createdAt: Date | null
    status: string | null
    lastError: string | null
  }

  export type CampaignJobCountAggregateOutputType = {
    id: number
    doctorId: number
    campaignId: number
    channel: number
    trigger: number
    scheduleAt: number
    createdAt: number
    status: number
    lastError: number
    _all: number
  }


  export type CampaignJobMinAggregateInputType = {
    id?: true
    doctorId?: true
    campaignId?: true
    channel?: true
    trigger?: true
    scheduleAt?: true
    createdAt?: true
    status?: true
    lastError?: true
  }

  export type CampaignJobMaxAggregateInputType = {
    id?: true
    doctorId?: true
    campaignId?: true
    channel?: true
    trigger?: true
    scheduleAt?: true
    createdAt?: true
    status?: true
    lastError?: true
  }

  export type CampaignJobCountAggregateInputType = {
    id?: true
    doctorId?: true
    campaignId?: true
    channel?: true
    trigger?: true
    scheduleAt?: true
    createdAt?: true
    status?: true
    lastError?: true
    _all?: true
  }

  export type CampaignJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignJob to aggregate.
     */
    where?: CampaignJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignJobs to fetch.
     */
    orderBy?: CampaignJobOrderByWithRelationInput | CampaignJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignJobs
    **/
    _count?: true | CampaignJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignJobMaxAggregateInputType
  }

  export type GetCampaignJobAggregateType<T extends CampaignJobAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignJob[P]>
      : GetScalarType<T[P], AggregateCampaignJob[P]>
  }




  export type CampaignJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignJobWhereInput
    orderBy?: CampaignJobOrderByWithAggregationInput | CampaignJobOrderByWithAggregationInput[]
    by: CampaignJobScalarFieldEnum[] | CampaignJobScalarFieldEnum
    having?: CampaignJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignJobCountAggregateInputType | true
    _min?: CampaignJobMinAggregateInputType
    _max?: CampaignJobMaxAggregateInputType
  }

  export type CampaignJobGroupByOutputType = {
    id: string
    doctorId: string
    campaignId: string
    channel: string
    trigger: string | null
    scheduleAt: Date
    createdAt: Date
    status: string
    lastError: string | null
    _count: CampaignJobCountAggregateOutputType | null
    _min: CampaignJobMinAggregateOutputType | null
    _max: CampaignJobMaxAggregateOutputType | null
  }

  type GetCampaignJobGroupByPayload<T extends CampaignJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignJobGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignJobGroupByOutputType[P]>
        }
      >
    >


  export type CampaignJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    campaignId?: boolean
    channel?: boolean
    trigger?: boolean
    scheduleAt?: boolean
    createdAt?: boolean
    status?: boolean
    lastError?: boolean
  }, ExtArgs["result"]["campaignJob"]>

  export type CampaignJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    campaignId?: boolean
    channel?: boolean
    trigger?: boolean
    scheduleAt?: boolean
    createdAt?: boolean
    status?: boolean
    lastError?: boolean
  }, ExtArgs["result"]["campaignJob"]>

  export type CampaignJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    campaignId?: boolean
    channel?: boolean
    trigger?: boolean
    scheduleAt?: boolean
    createdAt?: boolean
    status?: boolean
    lastError?: boolean
  }, ExtArgs["result"]["campaignJob"]>

  export type CampaignJobSelectScalar = {
    id?: boolean
    doctorId?: boolean
    campaignId?: boolean
    channel?: boolean
    trigger?: boolean
    scheduleAt?: boolean
    createdAt?: boolean
    status?: boolean
    lastError?: boolean
  }

  export type CampaignJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doctorId" | "campaignId" | "channel" | "trigger" | "scheduleAt" | "createdAt" | "status" | "lastError", ExtArgs["result"]["campaignJob"]>

  export type $CampaignJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      doctorId: string
      campaignId: string
      channel: string
      trigger: string | null
      scheduleAt: Date
      createdAt: Date
      status: string
      lastError: string | null
    }, ExtArgs["result"]["campaignJob"]>
    composites: {}
  }

  type CampaignJobGetPayload<S extends boolean | null | undefined | CampaignJobDefaultArgs> = $Result.GetResult<Prisma.$CampaignJobPayload, S>

  type CampaignJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignJobCountAggregateInputType | true
    }

  export interface CampaignJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignJob'], meta: { name: 'CampaignJob' } }
    /**
     * Find zero or one CampaignJob that matches the filter.
     * @param {CampaignJobFindUniqueArgs} args - Arguments to find a CampaignJob
     * @example
     * // Get one CampaignJob
     * const campaignJob = await prisma.campaignJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignJobFindUniqueArgs>(args: SelectSubset<T, CampaignJobFindUniqueArgs<ExtArgs>>): Prisma__CampaignJobClient<$Result.GetResult<Prisma.$CampaignJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignJobFindUniqueOrThrowArgs} args - Arguments to find a CampaignJob
     * @example
     * // Get one CampaignJob
     * const campaignJob = await prisma.campaignJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignJobFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignJobClient<$Result.GetResult<Prisma.$CampaignJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignJobFindFirstArgs} args - Arguments to find a CampaignJob
     * @example
     * // Get one CampaignJob
     * const campaignJob = await prisma.campaignJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignJobFindFirstArgs>(args?: SelectSubset<T, CampaignJobFindFirstArgs<ExtArgs>>): Prisma__CampaignJobClient<$Result.GetResult<Prisma.$CampaignJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignJobFindFirstOrThrowArgs} args - Arguments to find a CampaignJob
     * @example
     * // Get one CampaignJob
     * const campaignJob = await prisma.campaignJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignJobFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignJobClient<$Result.GetResult<Prisma.$CampaignJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignJobs
     * const campaignJobs = await prisma.campaignJob.findMany()
     * 
     * // Get first 10 CampaignJobs
     * const campaignJobs = await prisma.campaignJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignJobWithIdOnly = await prisma.campaignJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignJobFindManyArgs>(args?: SelectSubset<T, CampaignJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignJob.
     * @param {CampaignJobCreateArgs} args - Arguments to create a CampaignJob.
     * @example
     * // Create one CampaignJob
     * const CampaignJob = await prisma.campaignJob.create({
     *   data: {
     *     // ... data to create a CampaignJob
     *   }
     * })
     * 
     */
    create<T extends CampaignJobCreateArgs>(args: SelectSubset<T, CampaignJobCreateArgs<ExtArgs>>): Prisma__CampaignJobClient<$Result.GetResult<Prisma.$CampaignJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignJobs.
     * @param {CampaignJobCreateManyArgs} args - Arguments to create many CampaignJobs.
     * @example
     * // Create many CampaignJobs
     * const campaignJob = await prisma.campaignJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignJobCreateManyArgs>(args?: SelectSubset<T, CampaignJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignJobs and returns the data saved in the database.
     * @param {CampaignJobCreateManyAndReturnArgs} args - Arguments to create many CampaignJobs.
     * @example
     * // Create many CampaignJobs
     * const campaignJob = await prisma.campaignJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignJobs and only return the `id`
     * const campaignJobWithIdOnly = await prisma.campaignJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignJobCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignJob.
     * @param {CampaignJobDeleteArgs} args - Arguments to delete one CampaignJob.
     * @example
     * // Delete one CampaignJob
     * const CampaignJob = await prisma.campaignJob.delete({
     *   where: {
     *     // ... filter to delete one CampaignJob
     *   }
     * })
     * 
     */
    delete<T extends CampaignJobDeleteArgs>(args: SelectSubset<T, CampaignJobDeleteArgs<ExtArgs>>): Prisma__CampaignJobClient<$Result.GetResult<Prisma.$CampaignJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignJob.
     * @param {CampaignJobUpdateArgs} args - Arguments to update one CampaignJob.
     * @example
     * // Update one CampaignJob
     * const campaignJob = await prisma.campaignJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignJobUpdateArgs>(args: SelectSubset<T, CampaignJobUpdateArgs<ExtArgs>>): Prisma__CampaignJobClient<$Result.GetResult<Prisma.$CampaignJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignJobs.
     * @param {CampaignJobDeleteManyArgs} args - Arguments to filter CampaignJobs to delete.
     * @example
     * // Delete a few CampaignJobs
     * const { count } = await prisma.campaignJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignJobDeleteManyArgs>(args?: SelectSubset<T, CampaignJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignJobs
     * const campaignJob = await prisma.campaignJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignJobUpdateManyArgs>(args: SelectSubset<T, CampaignJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignJobs and returns the data updated in the database.
     * @param {CampaignJobUpdateManyAndReturnArgs} args - Arguments to update many CampaignJobs.
     * @example
     * // Update many CampaignJobs
     * const campaignJob = await prisma.campaignJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignJobs and only return the `id`
     * const campaignJobWithIdOnly = await prisma.campaignJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignJobUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignJob.
     * @param {CampaignJobUpsertArgs} args - Arguments to update or create a CampaignJob.
     * @example
     * // Update or create a CampaignJob
     * const campaignJob = await prisma.campaignJob.upsert({
     *   create: {
     *     // ... data to create a CampaignJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignJob we want to update
     *   }
     * })
     */
    upsert<T extends CampaignJobUpsertArgs>(args: SelectSubset<T, CampaignJobUpsertArgs<ExtArgs>>): Prisma__CampaignJobClient<$Result.GetResult<Prisma.$CampaignJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignJobCountArgs} args - Arguments to filter CampaignJobs to count.
     * @example
     * // Count the number of CampaignJobs
     * const count = await prisma.campaignJob.count({
     *   where: {
     *     // ... the filter for the CampaignJobs we want to count
     *   }
     * })
    **/
    count<T extends CampaignJobCountArgs>(
      args?: Subset<T, CampaignJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignJobAggregateArgs>(args: Subset<T, CampaignJobAggregateArgs>): Prisma.PrismaPromise<GetCampaignJobAggregateType<T>>

    /**
     * Group by CampaignJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignJobGroupByArgs['orderBy'] }
        : { orderBy?: CampaignJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignJob model
   */
  readonly fields: CampaignJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignJob model
   */
  interface CampaignJobFieldRefs {
    readonly id: FieldRef<"CampaignJob", 'String'>
    readonly doctorId: FieldRef<"CampaignJob", 'String'>
    readonly campaignId: FieldRef<"CampaignJob", 'String'>
    readonly channel: FieldRef<"CampaignJob", 'String'>
    readonly trigger: FieldRef<"CampaignJob", 'String'>
    readonly scheduleAt: FieldRef<"CampaignJob", 'DateTime'>
    readonly createdAt: FieldRef<"CampaignJob", 'DateTime'>
    readonly status: FieldRef<"CampaignJob", 'String'>
    readonly lastError: FieldRef<"CampaignJob", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CampaignJob findUnique
   */
  export type CampaignJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
    /**
     * Filter, which CampaignJob to fetch.
     */
    where: CampaignJobWhereUniqueInput
  }

  /**
   * CampaignJob findUniqueOrThrow
   */
  export type CampaignJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
    /**
     * Filter, which CampaignJob to fetch.
     */
    where: CampaignJobWhereUniqueInput
  }

  /**
   * CampaignJob findFirst
   */
  export type CampaignJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
    /**
     * Filter, which CampaignJob to fetch.
     */
    where?: CampaignJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignJobs to fetch.
     */
    orderBy?: CampaignJobOrderByWithRelationInput | CampaignJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignJobs.
     */
    cursor?: CampaignJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignJobs.
     */
    distinct?: CampaignJobScalarFieldEnum | CampaignJobScalarFieldEnum[]
  }

  /**
   * CampaignJob findFirstOrThrow
   */
  export type CampaignJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
    /**
     * Filter, which CampaignJob to fetch.
     */
    where?: CampaignJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignJobs to fetch.
     */
    orderBy?: CampaignJobOrderByWithRelationInput | CampaignJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignJobs.
     */
    cursor?: CampaignJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignJobs.
     */
    distinct?: CampaignJobScalarFieldEnum | CampaignJobScalarFieldEnum[]
  }

  /**
   * CampaignJob findMany
   */
  export type CampaignJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
    /**
     * Filter, which CampaignJobs to fetch.
     */
    where?: CampaignJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignJobs to fetch.
     */
    orderBy?: CampaignJobOrderByWithRelationInput | CampaignJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignJobs.
     */
    cursor?: CampaignJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignJobs.
     */
    skip?: number
    distinct?: CampaignJobScalarFieldEnum | CampaignJobScalarFieldEnum[]
  }

  /**
   * CampaignJob create
   */
  export type CampaignJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
    /**
     * The data needed to create a CampaignJob.
     */
    data: XOR<CampaignJobCreateInput, CampaignJobUncheckedCreateInput>
  }

  /**
   * CampaignJob createMany
   */
  export type CampaignJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignJobs.
     */
    data: CampaignJobCreateManyInput | CampaignJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignJob createManyAndReturn
   */
  export type CampaignJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignJobs.
     */
    data: CampaignJobCreateManyInput | CampaignJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignJob update
   */
  export type CampaignJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
    /**
     * The data needed to update a CampaignJob.
     */
    data: XOR<CampaignJobUpdateInput, CampaignJobUncheckedUpdateInput>
    /**
     * Choose, which CampaignJob to update.
     */
    where: CampaignJobWhereUniqueInput
  }

  /**
   * CampaignJob updateMany
   */
  export type CampaignJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignJobs.
     */
    data: XOR<CampaignJobUpdateManyMutationInput, CampaignJobUncheckedUpdateManyInput>
    /**
     * Filter which CampaignJobs to update
     */
    where?: CampaignJobWhereInput
    /**
     * Limit how many CampaignJobs to update.
     */
    limit?: number
  }

  /**
   * CampaignJob updateManyAndReturn
   */
  export type CampaignJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
    /**
     * The data used to update CampaignJobs.
     */
    data: XOR<CampaignJobUpdateManyMutationInput, CampaignJobUncheckedUpdateManyInput>
    /**
     * Filter which CampaignJobs to update
     */
    where?: CampaignJobWhereInput
    /**
     * Limit how many CampaignJobs to update.
     */
    limit?: number
  }

  /**
   * CampaignJob upsert
   */
  export type CampaignJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
    /**
     * The filter to search for the CampaignJob to update in case it exists.
     */
    where: CampaignJobWhereUniqueInput
    /**
     * In case the CampaignJob found by the `where` argument doesn't exist, create a new CampaignJob with this data.
     */
    create: XOR<CampaignJobCreateInput, CampaignJobUncheckedCreateInput>
    /**
     * In case the CampaignJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignJobUpdateInput, CampaignJobUncheckedUpdateInput>
  }

  /**
   * CampaignJob delete
   */
  export type CampaignJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
    /**
     * Filter which CampaignJob to delete.
     */
    where: CampaignJobWhereUniqueInput
  }

  /**
   * CampaignJob deleteMany
   */
  export type CampaignJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignJobs to delete
     */
    where?: CampaignJobWhereInput
    /**
     * Limit how many CampaignJobs to delete.
     */
    limit?: number
  }

  /**
   * CampaignJob without action
   */
  export type CampaignJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignJob
     */
    select?: CampaignJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignJob
     */
    omit?: CampaignJobOmit<ExtArgs> | null
  }


  /**
   * Model OpenFinanceLink
   */

  export type AggregateOpenFinanceLink = {
    _count: OpenFinanceLinkCountAggregateOutputType | null
    _min: OpenFinanceLinkMinAggregateOutputType | null
    _max: OpenFinanceLinkMaxAggregateOutputType | null
  }

  export type OpenFinanceLinkMinAggregateOutputType = {
    id: string | null
    userId: string | null
    clinicId: string | null
    organisationId: string | null
    authorisationServerId: string | null
    enrollmentId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpenFinanceLinkMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    clinicId: string | null
    organisationId: string | null
    authorisationServerId: string | null
    enrollmentId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpenFinanceLinkCountAggregateOutputType = {
    id: number
    userId: number
    clinicId: number
    organisationId: number
    authorisationServerId: number
    enrollmentId: number
    status: number
    deviceBinding: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OpenFinanceLinkMinAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    organisationId?: true
    authorisationServerId?: true
    enrollmentId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpenFinanceLinkMaxAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    organisationId?: true
    authorisationServerId?: true
    enrollmentId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpenFinanceLinkCountAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    organisationId?: true
    authorisationServerId?: true
    enrollmentId?: true
    status?: true
    deviceBinding?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OpenFinanceLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenFinanceLink to aggregate.
     */
    where?: OpenFinanceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenFinanceLinks to fetch.
     */
    orderBy?: OpenFinanceLinkOrderByWithRelationInput | OpenFinanceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpenFinanceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenFinanceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenFinanceLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpenFinanceLinks
    **/
    _count?: true | OpenFinanceLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpenFinanceLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpenFinanceLinkMaxAggregateInputType
  }

  export type GetOpenFinanceLinkAggregateType<T extends OpenFinanceLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateOpenFinanceLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpenFinanceLink[P]>
      : GetScalarType<T[P], AggregateOpenFinanceLink[P]>
  }




  export type OpenFinanceLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenFinanceLinkWhereInput
    orderBy?: OpenFinanceLinkOrderByWithAggregationInput | OpenFinanceLinkOrderByWithAggregationInput[]
    by: OpenFinanceLinkScalarFieldEnum[] | OpenFinanceLinkScalarFieldEnum
    having?: OpenFinanceLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpenFinanceLinkCountAggregateInputType | true
    _min?: OpenFinanceLinkMinAggregateInputType
    _max?: OpenFinanceLinkMaxAggregateInputType
  }

  export type OpenFinanceLinkGroupByOutputType = {
    id: string
    userId: string
    clinicId: string | null
    organisationId: string
    authorisationServerId: string
    enrollmentId: string
    status: string
    deviceBinding: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: OpenFinanceLinkCountAggregateOutputType | null
    _min: OpenFinanceLinkMinAggregateOutputType | null
    _max: OpenFinanceLinkMaxAggregateOutputType | null
  }

  type GetOpenFinanceLinkGroupByPayload<T extends OpenFinanceLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpenFinanceLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpenFinanceLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpenFinanceLinkGroupByOutputType[P]>
            : GetScalarType<T[P], OpenFinanceLinkGroupByOutputType[P]>
        }
      >
    >


  export type OpenFinanceLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    enrollmentId?: boolean
    status?: boolean
    deviceBinding?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consent?: boolean | OpenFinanceLink$consentArgs<ExtArgs>
  }, ExtArgs["result"]["openFinanceLink"]>

  export type OpenFinanceLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    enrollmentId?: boolean
    status?: boolean
    deviceBinding?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["openFinanceLink"]>

  export type OpenFinanceLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    enrollmentId?: boolean
    status?: boolean
    deviceBinding?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["openFinanceLink"]>

  export type OpenFinanceLinkSelectScalar = {
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    enrollmentId?: boolean
    status?: boolean
    deviceBinding?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OpenFinanceLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "clinicId" | "organisationId" | "authorisationServerId" | "enrollmentId" | "status" | "deviceBinding" | "createdAt" | "updatedAt", ExtArgs["result"]["openFinanceLink"]>
  export type OpenFinanceLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consent?: boolean | OpenFinanceLink$consentArgs<ExtArgs>
  }
  export type OpenFinanceLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OpenFinanceLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OpenFinanceLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpenFinanceLink"
    objects: {
      consent: Prisma.$OpenFinanceConsentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      clinicId: string | null
      organisationId: string
      authorisationServerId: string
      enrollmentId: string
      status: string
      deviceBinding: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["openFinanceLink"]>
    composites: {}
  }

  type OpenFinanceLinkGetPayload<S extends boolean | null | undefined | OpenFinanceLinkDefaultArgs> = $Result.GetResult<Prisma.$OpenFinanceLinkPayload, S>

  type OpenFinanceLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpenFinanceLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpenFinanceLinkCountAggregateInputType | true
    }

  export interface OpenFinanceLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpenFinanceLink'], meta: { name: 'OpenFinanceLink' } }
    /**
     * Find zero or one OpenFinanceLink that matches the filter.
     * @param {OpenFinanceLinkFindUniqueArgs} args - Arguments to find a OpenFinanceLink
     * @example
     * // Get one OpenFinanceLink
     * const openFinanceLink = await prisma.openFinanceLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpenFinanceLinkFindUniqueArgs>(args: SelectSubset<T, OpenFinanceLinkFindUniqueArgs<ExtArgs>>): Prisma__OpenFinanceLinkClient<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OpenFinanceLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpenFinanceLinkFindUniqueOrThrowArgs} args - Arguments to find a OpenFinanceLink
     * @example
     * // Get one OpenFinanceLink
     * const openFinanceLink = await prisma.openFinanceLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpenFinanceLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, OpenFinanceLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpenFinanceLinkClient<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpenFinanceLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceLinkFindFirstArgs} args - Arguments to find a OpenFinanceLink
     * @example
     * // Get one OpenFinanceLink
     * const openFinanceLink = await prisma.openFinanceLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpenFinanceLinkFindFirstArgs>(args?: SelectSubset<T, OpenFinanceLinkFindFirstArgs<ExtArgs>>): Prisma__OpenFinanceLinkClient<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpenFinanceLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceLinkFindFirstOrThrowArgs} args - Arguments to find a OpenFinanceLink
     * @example
     * // Get one OpenFinanceLink
     * const openFinanceLink = await prisma.openFinanceLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpenFinanceLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, OpenFinanceLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpenFinanceLinkClient<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OpenFinanceLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpenFinanceLinks
     * const openFinanceLinks = await prisma.openFinanceLink.findMany()
     * 
     * // Get first 10 OpenFinanceLinks
     * const openFinanceLinks = await prisma.openFinanceLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const openFinanceLinkWithIdOnly = await prisma.openFinanceLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpenFinanceLinkFindManyArgs>(args?: SelectSubset<T, OpenFinanceLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OpenFinanceLink.
     * @param {OpenFinanceLinkCreateArgs} args - Arguments to create a OpenFinanceLink.
     * @example
     * // Create one OpenFinanceLink
     * const OpenFinanceLink = await prisma.openFinanceLink.create({
     *   data: {
     *     // ... data to create a OpenFinanceLink
     *   }
     * })
     * 
     */
    create<T extends OpenFinanceLinkCreateArgs>(args: SelectSubset<T, OpenFinanceLinkCreateArgs<ExtArgs>>): Prisma__OpenFinanceLinkClient<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OpenFinanceLinks.
     * @param {OpenFinanceLinkCreateManyArgs} args - Arguments to create many OpenFinanceLinks.
     * @example
     * // Create many OpenFinanceLinks
     * const openFinanceLink = await prisma.openFinanceLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpenFinanceLinkCreateManyArgs>(args?: SelectSubset<T, OpenFinanceLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpenFinanceLinks and returns the data saved in the database.
     * @param {OpenFinanceLinkCreateManyAndReturnArgs} args - Arguments to create many OpenFinanceLinks.
     * @example
     * // Create many OpenFinanceLinks
     * const openFinanceLink = await prisma.openFinanceLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpenFinanceLinks and only return the `id`
     * const openFinanceLinkWithIdOnly = await prisma.openFinanceLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpenFinanceLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, OpenFinanceLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OpenFinanceLink.
     * @param {OpenFinanceLinkDeleteArgs} args - Arguments to delete one OpenFinanceLink.
     * @example
     * // Delete one OpenFinanceLink
     * const OpenFinanceLink = await prisma.openFinanceLink.delete({
     *   where: {
     *     // ... filter to delete one OpenFinanceLink
     *   }
     * })
     * 
     */
    delete<T extends OpenFinanceLinkDeleteArgs>(args: SelectSubset<T, OpenFinanceLinkDeleteArgs<ExtArgs>>): Prisma__OpenFinanceLinkClient<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OpenFinanceLink.
     * @param {OpenFinanceLinkUpdateArgs} args - Arguments to update one OpenFinanceLink.
     * @example
     * // Update one OpenFinanceLink
     * const openFinanceLink = await prisma.openFinanceLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpenFinanceLinkUpdateArgs>(args: SelectSubset<T, OpenFinanceLinkUpdateArgs<ExtArgs>>): Prisma__OpenFinanceLinkClient<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OpenFinanceLinks.
     * @param {OpenFinanceLinkDeleteManyArgs} args - Arguments to filter OpenFinanceLinks to delete.
     * @example
     * // Delete a few OpenFinanceLinks
     * const { count } = await prisma.openFinanceLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpenFinanceLinkDeleteManyArgs>(args?: SelectSubset<T, OpenFinanceLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenFinanceLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpenFinanceLinks
     * const openFinanceLink = await prisma.openFinanceLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpenFinanceLinkUpdateManyArgs>(args: SelectSubset<T, OpenFinanceLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenFinanceLinks and returns the data updated in the database.
     * @param {OpenFinanceLinkUpdateManyAndReturnArgs} args - Arguments to update many OpenFinanceLinks.
     * @example
     * // Update many OpenFinanceLinks
     * const openFinanceLink = await prisma.openFinanceLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OpenFinanceLinks and only return the `id`
     * const openFinanceLinkWithIdOnly = await prisma.openFinanceLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpenFinanceLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, OpenFinanceLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OpenFinanceLink.
     * @param {OpenFinanceLinkUpsertArgs} args - Arguments to update or create a OpenFinanceLink.
     * @example
     * // Update or create a OpenFinanceLink
     * const openFinanceLink = await prisma.openFinanceLink.upsert({
     *   create: {
     *     // ... data to create a OpenFinanceLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpenFinanceLink we want to update
     *   }
     * })
     */
    upsert<T extends OpenFinanceLinkUpsertArgs>(args: SelectSubset<T, OpenFinanceLinkUpsertArgs<ExtArgs>>): Prisma__OpenFinanceLinkClient<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OpenFinanceLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceLinkCountArgs} args - Arguments to filter OpenFinanceLinks to count.
     * @example
     * // Count the number of OpenFinanceLinks
     * const count = await prisma.openFinanceLink.count({
     *   where: {
     *     // ... the filter for the OpenFinanceLinks we want to count
     *   }
     * })
    **/
    count<T extends OpenFinanceLinkCountArgs>(
      args?: Subset<T, OpenFinanceLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpenFinanceLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpenFinanceLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpenFinanceLinkAggregateArgs>(args: Subset<T, OpenFinanceLinkAggregateArgs>): Prisma.PrismaPromise<GetOpenFinanceLinkAggregateType<T>>

    /**
     * Group by OpenFinanceLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpenFinanceLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpenFinanceLinkGroupByArgs['orderBy'] }
        : { orderBy?: OpenFinanceLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpenFinanceLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpenFinanceLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpenFinanceLink model
   */
  readonly fields: OpenFinanceLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpenFinanceLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpenFinanceLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consent<T extends OpenFinanceLink$consentArgs<ExtArgs> = {}>(args?: Subset<T, OpenFinanceLink$consentArgs<ExtArgs>>): Prisma__OpenFinanceConsentClient<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpenFinanceLink model
   */
  interface OpenFinanceLinkFieldRefs {
    readonly id: FieldRef<"OpenFinanceLink", 'String'>
    readonly userId: FieldRef<"OpenFinanceLink", 'String'>
    readonly clinicId: FieldRef<"OpenFinanceLink", 'String'>
    readonly organisationId: FieldRef<"OpenFinanceLink", 'String'>
    readonly authorisationServerId: FieldRef<"OpenFinanceLink", 'String'>
    readonly enrollmentId: FieldRef<"OpenFinanceLink", 'String'>
    readonly status: FieldRef<"OpenFinanceLink", 'String'>
    readonly deviceBinding: FieldRef<"OpenFinanceLink", 'Json'>
    readonly createdAt: FieldRef<"OpenFinanceLink", 'DateTime'>
    readonly updatedAt: FieldRef<"OpenFinanceLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OpenFinanceLink findUnique
   */
  export type OpenFinanceLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceLinkInclude<ExtArgs> | null
    /**
     * Filter, which OpenFinanceLink to fetch.
     */
    where: OpenFinanceLinkWhereUniqueInput
  }

  /**
   * OpenFinanceLink findUniqueOrThrow
   */
  export type OpenFinanceLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceLinkInclude<ExtArgs> | null
    /**
     * Filter, which OpenFinanceLink to fetch.
     */
    where: OpenFinanceLinkWhereUniqueInput
  }

  /**
   * OpenFinanceLink findFirst
   */
  export type OpenFinanceLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceLinkInclude<ExtArgs> | null
    /**
     * Filter, which OpenFinanceLink to fetch.
     */
    where?: OpenFinanceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenFinanceLinks to fetch.
     */
    orderBy?: OpenFinanceLinkOrderByWithRelationInput | OpenFinanceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenFinanceLinks.
     */
    cursor?: OpenFinanceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenFinanceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenFinanceLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenFinanceLinks.
     */
    distinct?: OpenFinanceLinkScalarFieldEnum | OpenFinanceLinkScalarFieldEnum[]
  }

  /**
   * OpenFinanceLink findFirstOrThrow
   */
  export type OpenFinanceLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceLinkInclude<ExtArgs> | null
    /**
     * Filter, which OpenFinanceLink to fetch.
     */
    where?: OpenFinanceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenFinanceLinks to fetch.
     */
    orderBy?: OpenFinanceLinkOrderByWithRelationInput | OpenFinanceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenFinanceLinks.
     */
    cursor?: OpenFinanceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenFinanceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenFinanceLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenFinanceLinks.
     */
    distinct?: OpenFinanceLinkScalarFieldEnum | OpenFinanceLinkScalarFieldEnum[]
  }

  /**
   * OpenFinanceLink findMany
   */
  export type OpenFinanceLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceLinkInclude<ExtArgs> | null
    /**
     * Filter, which OpenFinanceLinks to fetch.
     */
    where?: OpenFinanceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenFinanceLinks to fetch.
     */
    orderBy?: OpenFinanceLinkOrderByWithRelationInput | OpenFinanceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpenFinanceLinks.
     */
    cursor?: OpenFinanceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenFinanceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenFinanceLinks.
     */
    skip?: number
    distinct?: OpenFinanceLinkScalarFieldEnum | OpenFinanceLinkScalarFieldEnum[]
  }

  /**
   * OpenFinanceLink create
   */
  export type OpenFinanceLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a OpenFinanceLink.
     */
    data: XOR<OpenFinanceLinkCreateInput, OpenFinanceLinkUncheckedCreateInput>
  }

  /**
   * OpenFinanceLink createMany
   */
  export type OpenFinanceLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpenFinanceLinks.
     */
    data: OpenFinanceLinkCreateManyInput | OpenFinanceLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenFinanceLink createManyAndReturn
   */
  export type OpenFinanceLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * The data used to create many OpenFinanceLinks.
     */
    data: OpenFinanceLinkCreateManyInput | OpenFinanceLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenFinanceLink update
   */
  export type OpenFinanceLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a OpenFinanceLink.
     */
    data: XOR<OpenFinanceLinkUpdateInput, OpenFinanceLinkUncheckedUpdateInput>
    /**
     * Choose, which OpenFinanceLink to update.
     */
    where: OpenFinanceLinkWhereUniqueInput
  }

  /**
   * OpenFinanceLink updateMany
   */
  export type OpenFinanceLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpenFinanceLinks.
     */
    data: XOR<OpenFinanceLinkUpdateManyMutationInput, OpenFinanceLinkUncheckedUpdateManyInput>
    /**
     * Filter which OpenFinanceLinks to update
     */
    where?: OpenFinanceLinkWhereInput
    /**
     * Limit how many OpenFinanceLinks to update.
     */
    limit?: number
  }

  /**
   * OpenFinanceLink updateManyAndReturn
   */
  export type OpenFinanceLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * The data used to update OpenFinanceLinks.
     */
    data: XOR<OpenFinanceLinkUpdateManyMutationInput, OpenFinanceLinkUncheckedUpdateManyInput>
    /**
     * Filter which OpenFinanceLinks to update
     */
    where?: OpenFinanceLinkWhereInput
    /**
     * Limit how many OpenFinanceLinks to update.
     */
    limit?: number
  }

  /**
   * OpenFinanceLink upsert
   */
  export type OpenFinanceLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the OpenFinanceLink to update in case it exists.
     */
    where: OpenFinanceLinkWhereUniqueInput
    /**
     * In case the OpenFinanceLink found by the `where` argument doesn't exist, create a new OpenFinanceLink with this data.
     */
    create: XOR<OpenFinanceLinkCreateInput, OpenFinanceLinkUncheckedCreateInput>
    /**
     * In case the OpenFinanceLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpenFinanceLinkUpdateInput, OpenFinanceLinkUncheckedUpdateInput>
  }

  /**
   * OpenFinanceLink delete
   */
  export type OpenFinanceLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceLinkInclude<ExtArgs> | null
    /**
     * Filter which OpenFinanceLink to delete.
     */
    where: OpenFinanceLinkWhereUniqueInput
  }

  /**
   * OpenFinanceLink deleteMany
   */
  export type OpenFinanceLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenFinanceLinks to delete
     */
    where?: OpenFinanceLinkWhereInput
    /**
     * Limit how many OpenFinanceLinks to delete.
     */
    limit?: number
  }

  /**
   * OpenFinanceLink.consent
   */
  export type OpenFinanceLink$consentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentInclude<ExtArgs> | null
    where?: OpenFinanceConsentWhereInput
  }

  /**
   * OpenFinanceLink without action
   */
  export type OpenFinanceLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceLink
     */
    select?: OpenFinanceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceLink
     */
    omit?: OpenFinanceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceLinkInclude<ExtArgs> | null
  }


  /**
   * Model OpenFinanceConsent
   */

  export type AggregateOpenFinanceConsent = {
    _count: OpenFinanceConsentCountAggregateOutputType | null
    _avg: OpenFinanceConsentAvgAggregateOutputType | null
    _sum: OpenFinanceConsentSumAggregateOutputType | null
    _min: OpenFinanceConsentMinAggregateOutputType | null
    _max: OpenFinanceConsentMaxAggregateOutputType | null
  }

  export type OpenFinanceConsentAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type OpenFinanceConsentSumAggregateOutputType = {
    amountCents: number | null
  }

  export type OpenFinanceConsentMinAggregateOutputType = {
    id: string | null
    linkId: string | null
    consentId: string | null
    contractId: string | null
    status: string | null
    amountCents: number | null
    periodicity: string | null
    nextExecutionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpenFinanceConsentMaxAggregateOutputType = {
    id: string | null
    linkId: string | null
    consentId: string | null
    contractId: string | null
    status: string | null
    amountCents: number | null
    periodicity: string | null
    nextExecutionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpenFinanceConsentCountAggregateOutputType = {
    id: number
    linkId: number
    consentId: number
    contractId: number
    status: number
    amountCents: number
    periodicity: number
    nextExecutionAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OpenFinanceConsentAvgAggregateInputType = {
    amountCents?: true
  }

  export type OpenFinanceConsentSumAggregateInputType = {
    amountCents?: true
  }

  export type OpenFinanceConsentMinAggregateInputType = {
    id?: true
    linkId?: true
    consentId?: true
    contractId?: true
    status?: true
    amountCents?: true
    periodicity?: true
    nextExecutionAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpenFinanceConsentMaxAggregateInputType = {
    id?: true
    linkId?: true
    consentId?: true
    contractId?: true
    status?: true
    amountCents?: true
    periodicity?: true
    nextExecutionAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpenFinanceConsentCountAggregateInputType = {
    id?: true
    linkId?: true
    consentId?: true
    contractId?: true
    status?: true
    amountCents?: true
    periodicity?: true
    nextExecutionAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OpenFinanceConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenFinanceConsent to aggregate.
     */
    where?: OpenFinanceConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenFinanceConsents to fetch.
     */
    orderBy?: OpenFinanceConsentOrderByWithRelationInput | OpenFinanceConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpenFinanceConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenFinanceConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenFinanceConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpenFinanceConsents
    **/
    _count?: true | OpenFinanceConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpenFinanceConsentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpenFinanceConsentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpenFinanceConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpenFinanceConsentMaxAggregateInputType
  }

  export type GetOpenFinanceConsentAggregateType<T extends OpenFinanceConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateOpenFinanceConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpenFinanceConsent[P]>
      : GetScalarType<T[P], AggregateOpenFinanceConsent[P]>
  }




  export type OpenFinanceConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenFinanceConsentWhereInput
    orderBy?: OpenFinanceConsentOrderByWithAggregationInput | OpenFinanceConsentOrderByWithAggregationInput[]
    by: OpenFinanceConsentScalarFieldEnum[] | OpenFinanceConsentScalarFieldEnum
    having?: OpenFinanceConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpenFinanceConsentCountAggregateInputType | true
    _avg?: OpenFinanceConsentAvgAggregateInputType
    _sum?: OpenFinanceConsentSumAggregateInputType
    _min?: OpenFinanceConsentMinAggregateInputType
    _max?: OpenFinanceConsentMaxAggregateInputType
  }

  export type OpenFinanceConsentGroupByOutputType = {
    id: string
    linkId: string
    consentId: string
    contractId: string
    status: string
    amountCents: number
    periodicity: string
    nextExecutionAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: OpenFinanceConsentCountAggregateOutputType | null
    _avg: OpenFinanceConsentAvgAggregateOutputType | null
    _sum: OpenFinanceConsentSumAggregateOutputType | null
    _min: OpenFinanceConsentMinAggregateOutputType | null
    _max: OpenFinanceConsentMaxAggregateOutputType | null
  }

  type GetOpenFinanceConsentGroupByPayload<T extends OpenFinanceConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpenFinanceConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpenFinanceConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpenFinanceConsentGroupByOutputType[P]>
            : GetScalarType<T[P], OpenFinanceConsentGroupByOutputType[P]>
        }
      >
    >


  export type OpenFinanceConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    consentId?: boolean
    contractId?: boolean
    status?: boolean
    amountCents?: boolean
    periodicity?: boolean
    nextExecutionAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    link?: boolean | OpenFinanceLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openFinanceConsent"]>

  export type OpenFinanceConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    consentId?: boolean
    contractId?: boolean
    status?: boolean
    amountCents?: boolean
    periodicity?: boolean
    nextExecutionAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    link?: boolean | OpenFinanceLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openFinanceConsent"]>

  export type OpenFinanceConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    consentId?: boolean
    contractId?: boolean
    status?: boolean
    amountCents?: boolean
    periodicity?: boolean
    nextExecutionAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    link?: boolean | OpenFinanceLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openFinanceConsent"]>

  export type OpenFinanceConsentSelectScalar = {
    id?: boolean
    linkId?: boolean
    consentId?: boolean
    contractId?: boolean
    status?: boolean
    amountCents?: boolean
    periodicity?: boolean
    nextExecutionAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OpenFinanceConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "linkId" | "consentId" | "contractId" | "status" | "amountCents" | "periodicity" | "nextExecutionAt" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["openFinanceConsent"]>
  export type OpenFinanceConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    link?: boolean | OpenFinanceLinkDefaultArgs<ExtArgs>
  }
  export type OpenFinanceConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    link?: boolean | OpenFinanceLinkDefaultArgs<ExtArgs>
  }
  export type OpenFinanceConsentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    link?: boolean | OpenFinanceLinkDefaultArgs<ExtArgs>
  }

  export type $OpenFinanceConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpenFinanceConsent"
    objects: {
      link: Prisma.$OpenFinanceLinkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      linkId: string
      consentId: string
      contractId: string
      status: string
      amountCents: number
      periodicity: string
      nextExecutionAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["openFinanceConsent"]>
    composites: {}
  }

  type OpenFinanceConsentGetPayload<S extends boolean | null | undefined | OpenFinanceConsentDefaultArgs> = $Result.GetResult<Prisma.$OpenFinanceConsentPayload, S>

  type OpenFinanceConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpenFinanceConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpenFinanceConsentCountAggregateInputType | true
    }

  export interface OpenFinanceConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpenFinanceConsent'], meta: { name: 'OpenFinanceConsent' } }
    /**
     * Find zero or one OpenFinanceConsent that matches the filter.
     * @param {OpenFinanceConsentFindUniqueArgs} args - Arguments to find a OpenFinanceConsent
     * @example
     * // Get one OpenFinanceConsent
     * const openFinanceConsent = await prisma.openFinanceConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpenFinanceConsentFindUniqueArgs>(args: SelectSubset<T, OpenFinanceConsentFindUniqueArgs<ExtArgs>>): Prisma__OpenFinanceConsentClient<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OpenFinanceConsent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpenFinanceConsentFindUniqueOrThrowArgs} args - Arguments to find a OpenFinanceConsent
     * @example
     * // Get one OpenFinanceConsent
     * const openFinanceConsent = await prisma.openFinanceConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpenFinanceConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, OpenFinanceConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpenFinanceConsentClient<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpenFinanceConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceConsentFindFirstArgs} args - Arguments to find a OpenFinanceConsent
     * @example
     * // Get one OpenFinanceConsent
     * const openFinanceConsent = await prisma.openFinanceConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpenFinanceConsentFindFirstArgs>(args?: SelectSubset<T, OpenFinanceConsentFindFirstArgs<ExtArgs>>): Prisma__OpenFinanceConsentClient<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpenFinanceConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceConsentFindFirstOrThrowArgs} args - Arguments to find a OpenFinanceConsent
     * @example
     * // Get one OpenFinanceConsent
     * const openFinanceConsent = await prisma.openFinanceConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpenFinanceConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, OpenFinanceConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpenFinanceConsentClient<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OpenFinanceConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpenFinanceConsents
     * const openFinanceConsents = await prisma.openFinanceConsent.findMany()
     * 
     * // Get first 10 OpenFinanceConsents
     * const openFinanceConsents = await prisma.openFinanceConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const openFinanceConsentWithIdOnly = await prisma.openFinanceConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpenFinanceConsentFindManyArgs>(args?: SelectSubset<T, OpenFinanceConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OpenFinanceConsent.
     * @param {OpenFinanceConsentCreateArgs} args - Arguments to create a OpenFinanceConsent.
     * @example
     * // Create one OpenFinanceConsent
     * const OpenFinanceConsent = await prisma.openFinanceConsent.create({
     *   data: {
     *     // ... data to create a OpenFinanceConsent
     *   }
     * })
     * 
     */
    create<T extends OpenFinanceConsentCreateArgs>(args: SelectSubset<T, OpenFinanceConsentCreateArgs<ExtArgs>>): Prisma__OpenFinanceConsentClient<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OpenFinanceConsents.
     * @param {OpenFinanceConsentCreateManyArgs} args - Arguments to create many OpenFinanceConsents.
     * @example
     * // Create many OpenFinanceConsents
     * const openFinanceConsent = await prisma.openFinanceConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpenFinanceConsentCreateManyArgs>(args?: SelectSubset<T, OpenFinanceConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpenFinanceConsents and returns the data saved in the database.
     * @param {OpenFinanceConsentCreateManyAndReturnArgs} args - Arguments to create many OpenFinanceConsents.
     * @example
     * // Create many OpenFinanceConsents
     * const openFinanceConsent = await prisma.openFinanceConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpenFinanceConsents and only return the `id`
     * const openFinanceConsentWithIdOnly = await prisma.openFinanceConsent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpenFinanceConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, OpenFinanceConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OpenFinanceConsent.
     * @param {OpenFinanceConsentDeleteArgs} args - Arguments to delete one OpenFinanceConsent.
     * @example
     * // Delete one OpenFinanceConsent
     * const OpenFinanceConsent = await prisma.openFinanceConsent.delete({
     *   where: {
     *     // ... filter to delete one OpenFinanceConsent
     *   }
     * })
     * 
     */
    delete<T extends OpenFinanceConsentDeleteArgs>(args: SelectSubset<T, OpenFinanceConsentDeleteArgs<ExtArgs>>): Prisma__OpenFinanceConsentClient<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OpenFinanceConsent.
     * @param {OpenFinanceConsentUpdateArgs} args - Arguments to update one OpenFinanceConsent.
     * @example
     * // Update one OpenFinanceConsent
     * const openFinanceConsent = await prisma.openFinanceConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpenFinanceConsentUpdateArgs>(args: SelectSubset<T, OpenFinanceConsentUpdateArgs<ExtArgs>>): Prisma__OpenFinanceConsentClient<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OpenFinanceConsents.
     * @param {OpenFinanceConsentDeleteManyArgs} args - Arguments to filter OpenFinanceConsents to delete.
     * @example
     * // Delete a few OpenFinanceConsents
     * const { count } = await prisma.openFinanceConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpenFinanceConsentDeleteManyArgs>(args?: SelectSubset<T, OpenFinanceConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenFinanceConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpenFinanceConsents
     * const openFinanceConsent = await prisma.openFinanceConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpenFinanceConsentUpdateManyArgs>(args: SelectSubset<T, OpenFinanceConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenFinanceConsents and returns the data updated in the database.
     * @param {OpenFinanceConsentUpdateManyAndReturnArgs} args - Arguments to update many OpenFinanceConsents.
     * @example
     * // Update many OpenFinanceConsents
     * const openFinanceConsent = await prisma.openFinanceConsent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OpenFinanceConsents and only return the `id`
     * const openFinanceConsentWithIdOnly = await prisma.openFinanceConsent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpenFinanceConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, OpenFinanceConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OpenFinanceConsent.
     * @param {OpenFinanceConsentUpsertArgs} args - Arguments to update or create a OpenFinanceConsent.
     * @example
     * // Update or create a OpenFinanceConsent
     * const openFinanceConsent = await prisma.openFinanceConsent.upsert({
     *   create: {
     *     // ... data to create a OpenFinanceConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpenFinanceConsent we want to update
     *   }
     * })
     */
    upsert<T extends OpenFinanceConsentUpsertArgs>(args: SelectSubset<T, OpenFinanceConsentUpsertArgs<ExtArgs>>): Prisma__OpenFinanceConsentClient<$Result.GetResult<Prisma.$OpenFinanceConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OpenFinanceConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceConsentCountArgs} args - Arguments to filter OpenFinanceConsents to count.
     * @example
     * // Count the number of OpenFinanceConsents
     * const count = await prisma.openFinanceConsent.count({
     *   where: {
     *     // ... the filter for the OpenFinanceConsents we want to count
     *   }
     * })
    **/
    count<T extends OpenFinanceConsentCountArgs>(
      args?: Subset<T, OpenFinanceConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpenFinanceConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpenFinanceConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpenFinanceConsentAggregateArgs>(args: Subset<T, OpenFinanceConsentAggregateArgs>): Prisma.PrismaPromise<GetOpenFinanceConsentAggregateType<T>>

    /**
     * Group by OpenFinanceConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenFinanceConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpenFinanceConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpenFinanceConsentGroupByArgs['orderBy'] }
        : { orderBy?: OpenFinanceConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpenFinanceConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpenFinanceConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpenFinanceConsent model
   */
  readonly fields: OpenFinanceConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpenFinanceConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpenFinanceConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    link<T extends OpenFinanceLinkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpenFinanceLinkDefaultArgs<ExtArgs>>): Prisma__OpenFinanceLinkClient<$Result.GetResult<Prisma.$OpenFinanceLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpenFinanceConsent model
   */
  interface OpenFinanceConsentFieldRefs {
    readonly id: FieldRef<"OpenFinanceConsent", 'String'>
    readonly linkId: FieldRef<"OpenFinanceConsent", 'String'>
    readonly consentId: FieldRef<"OpenFinanceConsent", 'String'>
    readonly contractId: FieldRef<"OpenFinanceConsent", 'String'>
    readonly status: FieldRef<"OpenFinanceConsent", 'String'>
    readonly amountCents: FieldRef<"OpenFinanceConsent", 'Int'>
    readonly periodicity: FieldRef<"OpenFinanceConsent", 'String'>
    readonly nextExecutionAt: FieldRef<"OpenFinanceConsent", 'DateTime'>
    readonly metadata: FieldRef<"OpenFinanceConsent", 'Json'>
    readonly createdAt: FieldRef<"OpenFinanceConsent", 'DateTime'>
    readonly updatedAt: FieldRef<"OpenFinanceConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OpenFinanceConsent findUnique
   */
  export type OpenFinanceConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentInclude<ExtArgs> | null
    /**
     * Filter, which OpenFinanceConsent to fetch.
     */
    where: OpenFinanceConsentWhereUniqueInput
  }

  /**
   * OpenFinanceConsent findUniqueOrThrow
   */
  export type OpenFinanceConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentInclude<ExtArgs> | null
    /**
     * Filter, which OpenFinanceConsent to fetch.
     */
    where: OpenFinanceConsentWhereUniqueInput
  }

  /**
   * OpenFinanceConsent findFirst
   */
  export type OpenFinanceConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentInclude<ExtArgs> | null
    /**
     * Filter, which OpenFinanceConsent to fetch.
     */
    where?: OpenFinanceConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenFinanceConsents to fetch.
     */
    orderBy?: OpenFinanceConsentOrderByWithRelationInput | OpenFinanceConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenFinanceConsents.
     */
    cursor?: OpenFinanceConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenFinanceConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenFinanceConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenFinanceConsents.
     */
    distinct?: OpenFinanceConsentScalarFieldEnum | OpenFinanceConsentScalarFieldEnum[]
  }

  /**
   * OpenFinanceConsent findFirstOrThrow
   */
  export type OpenFinanceConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentInclude<ExtArgs> | null
    /**
     * Filter, which OpenFinanceConsent to fetch.
     */
    where?: OpenFinanceConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenFinanceConsents to fetch.
     */
    orderBy?: OpenFinanceConsentOrderByWithRelationInput | OpenFinanceConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenFinanceConsents.
     */
    cursor?: OpenFinanceConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenFinanceConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenFinanceConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenFinanceConsents.
     */
    distinct?: OpenFinanceConsentScalarFieldEnum | OpenFinanceConsentScalarFieldEnum[]
  }

  /**
   * OpenFinanceConsent findMany
   */
  export type OpenFinanceConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentInclude<ExtArgs> | null
    /**
     * Filter, which OpenFinanceConsents to fetch.
     */
    where?: OpenFinanceConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenFinanceConsents to fetch.
     */
    orderBy?: OpenFinanceConsentOrderByWithRelationInput | OpenFinanceConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpenFinanceConsents.
     */
    cursor?: OpenFinanceConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenFinanceConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenFinanceConsents.
     */
    skip?: number
    distinct?: OpenFinanceConsentScalarFieldEnum | OpenFinanceConsentScalarFieldEnum[]
  }

  /**
   * OpenFinanceConsent create
   */
  export type OpenFinanceConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a OpenFinanceConsent.
     */
    data: XOR<OpenFinanceConsentCreateInput, OpenFinanceConsentUncheckedCreateInput>
  }

  /**
   * OpenFinanceConsent createMany
   */
  export type OpenFinanceConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpenFinanceConsents.
     */
    data: OpenFinanceConsentCreateManyInput | OpenFinanceConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenFinanceConsent createManyAndReturn
   */
  export type OpenFinanceConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * The data used to create many OpenFinanceConsents.
     */
    data: OpenFinanceConsentCreateManyInput | OpenFinanceConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpenFinanceConsent update
   */
  export type OpenFinanceConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a OpenFinanceConsent.
     */
    data: XOR<OpenFinanceConsentUpdateInput, OpenFinanceConsentUncheckedUpdateInput>
    /**
     * Choose, which OpenFinanceConsent to update.
     */
    where: OpenFinanceConsentWhereUniqueInput
  }

  /**
   * OpenFinanceConsent updateMany
   */
  export type OpenFinanceConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpenFinanceConsents.
     */
    data: XOR<OpenFinanceConsentUpdateManyMutationInput, OpenFinanceConsentUncheckedUpdateManyInput>
    /**
     * Filter which OpenFinanceConsents to update
     */
    where?: OpenFinanceConsentWhereInput
    /**
     * Limit how many OpenFinanceConsents to update.
     */
    limit?: number
  }

  /**
   * OpenFinanceConsent updateManyAndReturn
   */
  export type OpenFinanceConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * The data used to update OpenFinanceConsents.
     */
    data: XOR<OpenFinanceConsentUpdateManyMutationInput, OpenFinanceConsentUncheckedUpdateManyInput>
    /**
     * Filter which OpenFinanceConsents to update
     */
    where?: OpenFinanceConsentWhereInput
    /**
     * Limit how many OpenFinanceConsents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpenFinanceConsent upsert
   */
  export type OpenFinanceConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the OpenFinanceConsent to update in case it exists.
     */
    where: OpenFinanceConsentWhereUniqueInput
    /**
     * In case the OpenFinanceConsent found by the `where` argument doesn't exist, create a new OpenFinanceConsent with this data.
     */
    create: XOR<OpenFinanceConsentCreateInput, OpenFinanceConsentUncheckedCreateInput>
    /**
     * In case the OpenFinanceConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpenFinanceConsentUpdateInput, OpenFinanceConsentUncheckedUpdateInput>
  }

  /**
   * OpenFinanceConsent delete
   */
  export type OpenFinanceConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentInclude<ExtArgs> | null
    /**
     * Filter which OpenFinanceConsent to delete.
     */
    where: OpenFinanceConsentWhereUniqueInput
  }

  /**
   * OpenFinanceConsent deleteMany
   */
  export type OpenFinanceConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenFinanceConsents to delete
     */
    where?: OpenFinanceConsentWhereInput
    /**
     * Limit how many OpenFinanceConsents to delete.
     */
    limit?: number
  }

  /**
   * OpenFinanceConsent without action
   */
  export type OpenFinanceConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenFinanceConsent
     */
    select?: OpenFinanceConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenFinanceConsent
     */
    omit?: OpenFinanceConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenFinanceConsentInclude<ExtArgs> | null
  }


  /**
   * Model OpenBankingPayment
   */

  export type AggregateOpenBankingPayment = {
    _count: OpenBankingPaymentCountAggregateOutputType | null
    _avg: OpenBankingPaymentAvgAggregateOutputType | null
    _sum: OpenBankingPaymentSumAggregateOutputType | null
    _min: OpenBankingPaymentMinAggregateOutputType | null
    _max: OpenBankingPaymentMaxAggregateOutputType | null
  }

  export type OpenBankingPaymentAvgAggregateOutputType = {
    amountCents: number | null
    executionOrder: number | null
  }

  export type OpenBankingPaymentSumAggregateOutputType = {
    amountCents: number | null
    executionOrder: number | null
  }

  export type OpenBankingPaymentMinAggregateOutputType = {
    id: string | null
    providerPaymentId: string | null
    consentId: string | null
    amountCents: number | null
    currency: string | null
    status: $Enums.PaymentStatusOB | null
    createdAt: Date | null
    updatedAt: Date | null
    enrollmentId: string | null
    transactionIdentification: string | null
    payerId: string | null
    payerDocument: string | null
    payerEmail: string | null
    payerName: string | null
    creditorName: string | null
    creditorCpfCnpj: string | null
    clinicId: string | null
    productId: string | null
    purchaseId: string | null
    type: $Enums.PaymentTypeOB | null
    executedAt: Date | null
    settledAt: Date | null
    recurrenceType: string | null
    subscriptionId: string | null
    executionOrder: number | null
    paymentLinkId: string | null
    userId: string | null
    orderRef: string | null
    redirectUri: string | null
    transactionId: string | null
    expiresAt: Date | null
  }

  export type OpenBankingPaymentMaxAggregateOutputType = {
    id: string | null
    providerPaymentId: string | null
    consentId: string | null
    amountCents: number | null
    currency: string | null
    status: $Enums.PaymentStatusOB | null
    createdAt: Date | null
    updatedAt: Date | null
    enrollmentId: string | null
    transactionIdentification: string | null
    payerId: string | null
    payerDocument: string | null
    payerEmail: string | null
    payerName: string | null
    creditorName: string | null
    creditorCpfCnpj: string | null
    clinicId: string | null
    productId: string | null
    purchaseId: string | null
    type: $Enums.PaymentTypeOB | null
    executedAt: Date | null
    settledAt: Date | null
    recurrenceType: string | null
    subscriptionId: string | null
    executionOrder: number | null
    paymentLinkId: string | null
    userId: string | null
    orderRef: string | null
    redirectUri: string | null
    transactionId: string | null
    expiresAt: Date | null
  }

  export type OpenBankingPaymentCountAggregateOutputType = {
    id: number
    providerPaymentId: number
    consentId: number
    amountCents: number
    currency: number
    status: number
    createdAt: number
    updatedAt: number
    enrollmentId: number
    transactionIdentification: number
    payerId: number
    payerDocument: number
    payerEmail: number
    payerName: number
    creditorName: number
    creditorCpfCnpj: number
    clinicId: number
    productId: number
    purchaseId: number
    type: number
    executedAt: number
    settledAt: number
    recurrenceType: number
    subscriptionId: number
    executionOrder: number
    providerResponse: number
    fidoAssertion: number
    riskSignals: number
    paymentLinkId: number
    userId: number
    orderRef: number
    redirectUri: number
    transactionId: number
    expiresAt: number
    metadata: number
    _all: number
  }


  export type OpenBankingPaymentAvgAggregateInputType = {
    amountCents?: true
    executionOrder?: true
  }

  export type OpenBankingPaymentSumAggregateInputType = {
    amountCents?: true
    executionOrder?: true
  }

  export type OpenBankingPaymentMinAggregateInputType = {
    id?: true
    providerPaymentId?: true
    consentId?: true
    amountCents?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    enrollmentId?: true
    transactionIdentification?: true
    payerId?: true
    payerDocument?: true
    payerEmail?: true
    payerName?: true
    creditorName?: true
    creditorCpfCnpj?: true
    clinicId?: true
    productId?: true
    purchaseId?: true
    type?: true
    executedAt?: true
    settledAt?: true
    recurrenceType?: true
    subscriptionId?: true
    executionOrder?: true
    paymentLinkId?: true
    userId?: true
    orderRef?: true
    redirectUri?: true
    transactionId?: true
    expiresAt?: true
  }

  export type OpenBankingPaymentMaxAggregateInputType = {
    id?: true
    providerPaymentId?: true
    consentId?: true
    amountCents?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    enrollmentId?: true
    transactionIdentification?: true
    payerId?: true
    payerDocument?: true
    payerEmail?: true
    payerName?: true
    creditorName?: true
    creditorCpfCnpj?: true
    clinicId?: true
    productId?: true
    purchaseId?: true
    type?: true
    executedAt?: true
    settledAt?: true
    recurrenceType?: true
    subscriptionId?: true
    executionOrder?: true
    paymentLinkId?: true
    userId?: true
    orderRef?: true
    redirectUri?: true
    transactionId?: true
    expiresAt?: true
  }

  export type OpenBankingPaymentCountAggregateInputType = {
    id?: true
    providerPaymentId?: true
    consentId?: true
    amountCents?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    enrollmentId?: true
    transactionIdentification?: true
    payerId?: true
    payerDocument?: true
    payerEmail?: true
    payerName?: true
    creditorName?: true
    creditorCpfCnpj?: true
    clinicId?: true
    productId?: true
    purchaseId?: true
    type?: true
    executedAt?: true
    settledAt?: true
    recurrenceType?: true
    subscriptionId?: true
    executionOrder?: true
    providerResponse?: true
    fidoAssertion?: true
    riskSignals?: true
    paymentLinkId?: true
    userId?: true
    orderRef?: true
    redirectUri?: true
    transactionId?: true
    expiresAt?: true
    metadata?: true
    _all?: true
  }

  export type OpenBankingPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenBankingPayment to aggregate.
     */
    where?: OpenBankingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenBankingPayments to fetch.
     */
    orderBy?: OpenBankingPaymentOrderByWithRelationInput | OpenBankingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpenBankingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenBankingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenBankingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpenBankingPayments
    **/
    _count?: true | OpenBankingPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpenBankingPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpenBankingPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpenBankingPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpenBankingPaymentMaxAggregateInputType
  }

  export type GetOpenBankingPaymentAggregateType<T extends OpenBankingPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateOpenBankingPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpenBankingPayment[P]>
      : GetScalarType<T[P], AggregateOpenBankingPayment[P]>
  }




  export type OpenBankingPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenBankingPaymentWhereInput
    orderBy?: OpenBankingPaymentOrderByWithAggregationInput | OpenBankingPaymentOrderByWithAggregationInput[]
    by: OpenBankingPaymentScalarFieldEnum[] | OpenBankingPaymentScalarFieldEnum
    having?: OpenBankingPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpenBankingPaymentCountAggregateInputType | true
    _avg?: OpenBankingPaymentAvgAggregateInputType
    _sum?: OpenBankingPaymentSumAggregateInputType
    _min?: OpenBankingPaymentMinAggregateInputType
    _max?: OpenBankingPaymentMaxAggregateInputType
  }

  export type OpenBankingPaymentGroupByOutputType = {
    id: string
    providerPaymentId: string | null
    consentId: string | null
    amountCents: number | null
    currency: string | null
    status: $Enums.PaymentStatusOB | null
    createdAt: Date
    updatedAt: Date
    enrollmentId: string | null
    transactionIdentification: string | null
    payerId: string | null
    payerDocument: string | null
    payerEmail: string | null
    payerName: string | null
    creditorName: string | null
    creditorCpfCnpj: string | null
    clinicId: string | null
    productId: string | null
    purchaseId: string | null
    type: $Enums.PaymentTypeOB | null
    executedAt: Date | null
    settledAt: Date | null
    recurrenceType: string | null
    subscriptionId: string | null
    executionOrder: number | null
    providerResponse: JsonValue | null
    fidoAssertion: JsonValue | null
    riskSignals: JsonValue | null
    paymentLinkId: string | null
    userId: string | null
    orderRef: string | null
    redirectUri: string | null
    transactionId: string | null
    expiresAt: Date | null
    metadata: JsonValue | null
    _count: OpenBankingPaymentCountAggregateOutputType | null
    _avg: OpenBankingPaymentAvgAggregateOutputType | null
    _sum: OpenBankingPaymentSumAggregateOutputType | null
    _min: OpenBankingPaymentMinAggregateOutputType | null
    _max: OpenBankingPaymentMaxAggregateOutputType | null
  }

  type GetOpenBankingPaymentGroupByPayload<T extends OpenBankingPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpenBankingPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpenBankingPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpenBankingPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], OpenBankingPaymentGroupByOutputType[P]>
        }
      >
    >


  export type OpenBankingPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerPaymentId?: boolean
    consentId?: boolean
    amountCents?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enrollmentId?: boolean
    transactionIdentification?: boolean
    payerId?: boolean
    payerDocument?: boolean
    payerEmail?: boolean
    payerName?: boolean
    creditorName?: boolean
    creditorCpfCnpj?: boolean
    clinicId?: boolean
    productId?: boolean
    purchaseId?: boolean
    type?: boolean
    executedAt?: boolean
    settledAt?: boolean
    recurrenceType?: boolean
    subscriptionId?: boolean
    executionOrder?: boolean
    providerResponse?: boolean
    fidoAssertion?: boolean
    riskSignals?: boolean
    paymentLinkId?: boolean
    userId?: boolean
    orderRef?: boolean
    redirectUri?: boolean
    transactionId?: boolean
    expiresAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["openBankingPayment"]>

  export type OpenBankingPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerPaymentId?: boolean
    consentId?: boolean
    amountCents?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enrollmentId?: boolean
    transactionIdentification?: boolean
    payerId?: boolean
    payerDocument?: boolean
    payerEmail?: boolean
    payerName?: boolean
    creditorName?: boolean
    creditorCpfCnpj?: boolean
    clinicId?: boolean
    productId?: boolean
    purchaseId?: boolean
    type?: boolean
    executedAt?: boolean
    settledAt?: boolean
    recurrenceType?: boolean
    subscriptionId?: boolean
    executionOrder?: boolean
    providerResponse?: boolean
    fidoAssertion?: boolean
    riskSignals?: boolean
    paymentLinkId?: boolean
    userId?: boolean
    orderRef?: boolean
    redirectUri?: boolean
    transactionId?: boolean
    expiresAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["openBankingPayment"]>

  export type OpenBankingPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerPaymentId?: boolean
    consentId?: boolean
    amountCents?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enrollmentId?: boolean
    transactionIdentification?: boolean
    payerId?: boolean
    payerDocument?: boolean
    payerEmail?: boolean
    payerName?: boolean
    creditorName?: boolean
    creditorCpfCnpj?: boolean
    clinicId?: boolean
    productId?: boolean
    purchaseId?: boolean
    type?: boolean
    executedAt?: boolean
    settledAt?: boolean
    recurrenceType?: boolean
    subscriptionId?: boolean
    executionOrder?: boolean
    providerResponse?: boolean
    fidoAssertion?: boolean
    riskSignals?: boolean
    paymentLinkId?: boolean
    userId?: boolean
    orderRef?: boolean
    redirectUri?: boolean
    transactionId?: boolean
    expiresAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["openBankingPayment"]>

  export type OpenBankingPaymentSelectScalar = {
    id?: boolean
    providerPaymentId?: boolean
    consentId?: boolean
    amountCents?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enrollmentId?: boolean
    transactionIdentification?: boolean
    payerId?: boolean
    payerDocument?: boolean
    payerEmail?: boolean
    payerName?: boolean
    creditorName?: boolean
    creditorCpfCnpj?: boolean
    clinicId?: boolean
    productId?: boolean
    purchaseId?: boolean
    type?: boolean
    executedAt?: boolean
    settledAt?: boolean
    recurrenceType?: boolean
    subscriptionId?: boolean
    executionOrder?: boolean
    providerResponse?: boolean
    fidoAssertion?: boolean
    riskSignals?: boolean
    paymentLinkId?: boolean
    userId?: boolean
    orderRef?: boolean
    redirectUri?: boolean
    transactionId?: boolean
    expiresAt?: boolean
    metadata?: boolean
  }

  export type OpenBankingPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerPaymentId" | "consentId" | "amountCents" | "currency" | "status" | "createdAt" | "updatedAt" | "enrollmentId" | "transactionIdentification" | "payerId" | "payerDocument" | "payerEmail" | "payerName" | "creditorName" | "creditorCpfCnpj" | "clinicId" | "productId" | "purchaseId" | "type" | "executedAt" | "settledAt" | "recurrenceType" | "subscriptionId" | "executionOrder" | "providerResponse" | "fidoAssertion" | "riskSignals" | "paymentLinkId" | "userId" | "orderRef" | "redirectUri" | "transactionId" | "expiresAt" | "metadata", ExtArgs["result"]["openBankingPayment"]>

  export type $OpenBankingPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpenBankingPayment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerPaymentId: string | null
      consentId: string | null
      amountCents: number | null
      currency: string | null
      status: $Enums.PaymentStatusOB | null
      createdAt: Date
      updatedAt: Date
      enrollmentId: string | null
      transactionIdentification: string | null
      payerId: string | null
      payerDocument: string | null
      payerEmail: string | null
      payerName: string | null
      creditorName: string | null
      creditorCpfCnpj: string | null
      clinicId: string | null
      productId: string | null
      purchaseId: string | null
      type: $Enums.PaymentTypeOB | null
      executedAt: Date | null
      settledAt: Date | null
      recurrenceType: string | null
      subscriptionId: string | null
      executionOrder: number | null
      providerResponse: Prisma.JsonValue | null
      fidoAssertion: Prisma.JsonValue | null
      riskSignals: Prisma.JsonValue | null
      paymentLinkId: string | null
      userId: string | null
      orderRef: string | null
      redirectUri: string | null
      transactionId: string | null
      expiresAt: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["openBankingPayment"]>
    composites: {}
  }

  type OpenBankingPaymentGetPayload<S extends boolean | null | undefined | OpenBankingPaymentDefaultArgs> = $Result.GetResult<Prisma.$OpenBankingPaymentPayload, S>

  type OpenBankingPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpenBankingPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpenBankingPaymentCountAggregateInputType | true
    }

  export interface OpenBankingPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpenBankingPayment'], meta: { name: 'OpenBankingPayment' } }
    /**
     * Find zero or one OpenBankingPayment that matches the filter.
     * @param {OpenBankingPaymentFindUniqueArgs} args - Arguments to find a OpenBankingPayment
     * @example
     * // Get one OpenBankingPayment
     * const openBankingPayment = await prisma.openBankingPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpenBankingPaymentFindUniqueArgs>(args: SelectSubset<T, OpenBankingPaymentFindUniqueArgs<ExtArgs>>): Prisma__OpenBankingPaymentClient<$Result.GetResult<Prisma.$OpenBankingPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OpenBankingPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpenBankingPaymentFindUniqueOrThrowArgs} args - Arguments to find a OpenBankingPayment
     * @example
     * // Get one OpenBankingPayment
     * const openBankingPayment = await prisma.openBankingPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpenBankingPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, OpenBankingPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpenBankingPaymentClient<$Result.GetResult<Prisma.$OpenBankingPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpenBankingPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingPaymentFindFirstArgs} args - Arguments to find a OpenBankingPayment
     * @example
     * // Get one OpenBankingPayment
     * const openBankingPayment = await prisma.openBankingPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpenBankingPaymentFindFirstArgs>(args?: SelectSubset<T, OpenBankingPaymentFindFirstArgs<ExtArgs>>): Prisma__OpenBankingPaymentClient<$Result.GetResult<Prisma.$OpenBankingPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpenBankingPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingPaymentFindFirstOrThrowArgs} args - Arguments to find a OpenBankingPayment
     * @example
     * // Get one OpenBankingPayment
     * const openBankingPayment = await prisma.openBankingPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpenBankingPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, OpenBankingPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpenBankingPaymentClient<$Result.GetResult<Prisma.$OpenBankingPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OpenBankingPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpenBankingPayments
     * const openBankingPayments = await prisma.openBankingPayment.findMany()
     * 
     * // Get first 10 OpenBankingPayments
     * const openBankingPayments = await prisma.openBankingPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const openBankingPaymentWithIdOnly = await prisma.openBankingPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpenBankingPaymentFindManyArgs>(args?: SelectSubset<T, OpenBankingPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenBankingPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OpenBankingPayment.
     * @param {OpenBankingPaymentCreateArgs} args - Arguments to create a OpenBankingPayment.
     * @example
     * // Create one OpenBankingPayment
     * const OpenBankingPayment = await prisma.openBankingPayment.create({
     *   data: {
     *     // ... data to create a OpenBankingPayment
     *   }
     * })
     * 
     */
    create<T extends OpenBankingPaymentCreateArgs>(args: SelectSubset<T, OpenBankingPaymentCreateArgs<ExtArgs>>): Prisma__OpenBankingPaymentClient<$Result.GetResult<Prisma.$OpenBankingPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OpenBankingPayments.
     * @param {OpenBankingPaymentCreateManyArgs} args - Arguments to create many OpenBankingPayments.
     * @example
     * // Create many OpenBankingPayments
     * const openBankingPayment = await prisma.openBankingPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpenBankingPaymentCreateManyArgs>(args?: SelectSubset<T, OpenBankingPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpenBankingPayments and returns the data saved in the database.
     * @param {OpenBankingPaymentCreateManyAndReturnArgs} args - Arguments to create many OpenBankingPayments.
     * @example
     * // Create many OpenBankingPayments
     * const openBankingPayment = await prisma.openBankingPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpenBankingPayments and only return the `id`
     * const openBankingPaymentWithIdOnly = await prisma.openBankingPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpenBankingPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, OpenBankingPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenBankingPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OpenBankingPayment.
     * @param {OpenBankingPaymentDeleteArgs} args - Arguments to delete one OpenBankingPayment.
     * @example
     * // Delete one OpenBankingPayment
     * const OpenBankingPayment = await prisma.openBankingPayment.delete({
     *   where: {
     *     // ... filter to delete one OpenBankingPayment
     *   }
     * })
     * 
     */
    delete<T extends OpenBankingPaymentDeleteArgs>(args: SelectSubset<T, OpenBankingPaymentDeleteArgs<ExtArgs>>): Prisma__OpenBankingPaymentClient<$Result.GetResult<Prisma.$OpenBankingPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OpenBankingPayment.
     * @param {OpenBankingPaymentUpdateArgs} args - Arguments to update one OpenBankingPayment.
     * @example
     * // Update one OpenBankingPayment
     * const openBankingPayment = await prisma.openBankingPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpenBankingPaymentUpdateArgs>(args: SelectSubset<T, OpenBankingPaymentUpdateArgs<ExtArgs>>): Prisma__OpenBankingPaymentClient<$Result.GetResult<Prisma.$OpenBankingPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OpenBankingPayments.
     * @param {OpenBankingPaymentDeleteManyArgs} args - Arguments to filter OpenBankingPayments to delete.
     * @example
     * // Delete a few OpenBankingPayments
     * const { count } = await prisma.openBankingPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpenBankingPaymentDeleteManyArgs>(args?: SelectSubset<T, OpenBankingPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenBankingPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpenBankingPayments
     * const openBankingPayment = await prisma.openBankingPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpenBankingPaymentUpdateManyArgs>(args: SelectSubset<T, OpenBankingPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenBankingPayments and returns the data updated in the database.
     * @param {OpenBankingPaymentUpdateManyAndReturnArgs} args - Arguments to update many OpenBankingPayments.
     * @example
     * // Update many OpenBankingPayments
     * const openBankingPayment = await prisma.openBankingPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OpenBankingPayments and only return the `id`
     * const openBankingPaymentWithIdOnly = await prisma.openBankingPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpenBankingPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, OpenBankingPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenBankingPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OpenBankingPayment.
     * @param {OpenBankingPaymentUpsertArgs} args - Arguments to update or create a OpenBankingPayment.
     * @example
     * // Update or create a OpenBankingPayment
     * const openBankingPayment = await prisma.openBankingPayment.upsert({
     *   create: {
     *     // ... data to create a OpenBankingPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpenBankingPayment we want to update
     *   }
     * })
     */
    upsert<T extends OpenBankingPaymentUpsertArgs>(args: SelectSubset<T, OpenBankingPaymentUpsertArgs<ExtArgs>>): Prisma__OpenBankingPaymentClient<$Result.GetResult<Prisma.$OpenBankingPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OpenBankingPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingPaymentCountArgs} args - Arguments to filter OpenBankingPayments to count.
     * @example
     * // Count the number of OpenBankingPayments
     * const count = await prisma.openBankingPayment.count({
     *   where: {
     *     // ... the filter for the OpenBankingPayments we want to count
     *   }
     * })
    **/
    count<T extends OpenBankingPaymentCountArgs>(
      args?: Subset<T, OpenBankingPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpenBankingPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpenBankingPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpenBankingPaymentAggregateArgs>(args: Subset<T, OpenBankingPaymentAggregateArgs>): Prisma.PrismaPromise<GetOpenBankingPaymentAggregateType<T>>

    /**
     * Group by OpenBankingPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpenBankingPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpenBankingPaymentGroupByArgs['orderBy'] }
        : { orderBy?: OpenBankingPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpenBankingPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpenBankingPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpenBankingPayment model
   */
  readonly fields: OpenBankingPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpenBankingPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpenBankingPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpenBankingPayment model
   */
  interface OpenBankingPaymentFieldRefs {
    readonly id: FieldRef<"OpenBankingPayment", 'String'>
    readonly providerPaymentId: FieldRef<"OpenBankingPayment", 'String'>
    readonly consentId: FieldRef<"OpenBankingPayment", 'String'>
    readonly amountCents: FieldRef<"OpenBankingPayment", 'Int'>
    readonly currency: FieldRef<"OpenBankingPayment", 'String'>
    readonly status: FieldRef<"OpenBankingPayment", 'PaymentStatusOB'>
    readonly createdAt: FieldRef<"OpenBankingPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"OpenBankingPayment", 'DateTime'>
    readonly enrollmentId: FieldRef<"OpenBankingPayment", 'String'>
    readonly transactionIdentification: FieldRef<"OpenBankingPayment", 'String'>
    readonly payerId: FieldRef<"OpenBankingPayment", 'String'>
    readonly payerDocument: FieldRef<"OpenBankingPayment", 'String'>
    readonly payerEmail: FieldRef<"OpenBankingPayment", 'String'>
    readonly payerName: FieldRef<"OpenBankingPayment", 'String'>
    readonly creditorName: FieldRef<"OpenBankingPayment", 'String'>
    readonly creditorCpfCnpj: FieldRef<"OpenBankingPayment", 'String'>
    readonly clinicId: FieldRef<"OpenBankingPayment", 'String'>
    readonly productId: FieldRef<"OpenBankingPayment", 'String'>
    readonly purchaseId: FieldRef<"OpenBankingPayment", 'String'>
    readonly type: FieldRef<"OpenBankingPayment", 'PaymentTypeOB'>
    readonly executedAt: FieldRef<"OpenBankingPayment", 'DateTime'>
    readonly settledAt: FieldRef<"OpenBankingPayment", 'DateTime'>
    readonly recurrenceType: FieldRef<"OpenBankingPayment", 'String'>
    readonly subscriptionId: FieldRef<"OpenBankingPayment", 'String'>
    readonly executionOrder: FieldRef<"OpenBankingPayment", 'Int'>
    readonly providerResponse: FieldRef<"OpenBankingPayment", 'Json'>
    readonly fidoAssertion: FieldRef<"OpenBankingPayment", 'Json'>
    readonly riskSignals: FieldRef<"OpenBankingPayment", 'Json'>
    readonly paymentLinkId: FieldRef<"OpenBankingPayment", 'String'>
    readonly userId: FieldRef<"OpenBankingPayment", 'String'>
    readonly orderRef: FieldRef<"OpenBankingPayment", 'String'>
    readonly redirectUri: FieldRef<"OpenBankingPayment", 'String'>
    readonly transactionId: FieldRef<"OpenBankingPayment", 'String'>
    readonly expiresAt: FieldRef<"OpenBankingPayment", 'DateTime'>
    readonly metadata: FieldRef<"OpenBankingPayment", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * OpenBankingPayment findUnique
   */
  export type OpenBankingPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
    /**
     * Filter, which OpenBankingPayment to fetch.
     */
    where: OpenBankingPaymentWhereUniqueInput
  }

  /**
   * OpenBankingPayment findUniqueOrThrow
   */
  export type OpenBankingPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
    /**
     * Filter, which OpenBankingPayment to fetch.
     */
    where: OpenBankingPaymentWhereUniqueInput
  }

  /**
   * OpenBankingPayment findFirst
   */
  export type OpenBankingPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
    /**
     * Filter, which OpenBankingPayment to fetch.
     */
    where?: OpenBankingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenBankingPayments to fetch.
     */
    orderBy?: OpenBankingPaymentOrderByWithRelationInput | OpenBankingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenBankingPayments.
     */
    cursor?: OpenBankingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenBankingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenBankingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenBankingPayments.
     */
    distinct?: OpenBankingPaymentScalarFieldEnum | OpenBankingPaymentScalarFieldEnum[]
  }

  /**
   * OpenBankingPayment findFirstOrThrow
   */
  export type OpenBankingPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
    /**
     * Filter, which OpenBankingPayment to fetch.
     */
    where?: OpenBankingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenBankingPayments to fetch.
     */
    orderBy?: OpenBankingPaymentOrderByWithRelationInput | OpenBankingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenBankingPayments.
     */
    cursor?: OpenBankingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenBankingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenBankingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenBankingPayments.
     */
    distinct?: OpenBankingPaymentScalarFieldEnum | OpenBankingPaymentScalarFieldEnum[]
  }

  /**
   * OpenBankingPayment findMany
   */
  export type OpenBankingPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
    /**
     * Filter, which OpenBankingPayments to fetch.
     */
    where?: OpenBankingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenBankingPayments to fetch.
     */
    orderBy?: OpenBankingPaymentOrderByWithRelationInput | OpenBankingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpenBankingPayments.
     */
    cursor?: OpenBankingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenBankingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenBankingPayments.
     */
    skip?: number
    distinct?: OpenBankingPaymentScalarFieldEnum | OpenBankingPaymentScalarFieldEnum[]
  }

  /**
   * OpenBankingPayment create
   */
  export type OpenBankingPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
    /**
     * The data needed to create a OpenBankingPayment.
     */
    data?: XOR<OpenBankingPaymentCreateInput, OpenBankingPaymentUncheckedCreateInput>
  }

  /**
   * OpenBankingPayment createMany
   */
  export type OpenBankingPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpenBankingPayments.
     */
    data: OpenBankingPaymentCreateManyInput | OpenBankingPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenBankingPayment createManyAndReturn
   */
  export type OpenBankingPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many OpenBankingPayments.
     */
    data: OpenBankingPaymentCreateManyInput | OpenBankingPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenBankingPayment update
   */
  export type OpenBankingPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
    /**
     * The data needed to update a OpenBankingPayment.
     */
    data: XOR<OpenBankingPaymentUpdateInput, OpenBankingPaymentUncheckedUpdateInput>
    /**
     * Choose, which OpenBankingPayment to update.
     */
    where: OpenBankingPaymentWhereUniqueInput
  }

  /**
   * OpenBankingPayment updateMany
   */
  export type OpenBankingPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpenBankingPayments.
     */
    data: XOR<OpenBankingPaymentUpdateManyMutationInput, OpenBankingPaymentUncheckedUpdateManyInput>
    /**
     * Filter which OpenBankingPayments to update
     */
    where?: OpenBankingPaymentWhereInput
    /**
     * Limit how many OpenBankingPayments to update.
     */
    limit?: number
  }

  /**
   * OpenBankingPayment updateManyAndReturn
   */
  export type OpenBankingPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
    /**
     * The data used to update OpenBankingPayments.
     */
    data: XOR<OpenBankingPaymentUpdateManyMutationInput, OpenBankingPaymentUncheckedUpdateManyInput>
    /**
     * Filter which OpenBankingPayments to update
     */
    where?: OpenBankingPaymentWhereInput
    /**
     * Limit how many OpenBankingPayments to update.
     */
    limit?: number
  }

  /**
   * OpenBankingPayment upsert
   */
  export type OpenBankingPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
    /**
     * The filter to search for the OpenBankingPayment to update in case it exists.
     */
    where: OpenBankingPaymentWhereUniqueInput
    /**
     * In case the OpenBankingPayment found by the `where` argument doesn't exist, create a new OpenBankingPayment with this data.
     */
    create: XOR<OpenBankingPaymentCreateInput, OpenBankingPaymentUncheckedCreateInput>
    /**
     * In case the OpenBankingPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpenBankingPaymentUpdateInput, OpenBankingPaymentUncheckedUpdateInput>
  }

  /**
   * OpenBankingPayment delete
   */
  export type OpenBankingPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
    /**
     * Filter which OpenBankingPayment to delete.
     */
    where: OpenBankingPaymentWhereUniqueInput
  }

  /**
   * OpenBankingPayment deleteMany
   */
  export type OpenBankingPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenBankingPayments to delete
     */
    where?: OpenBankingPaymentWhereInput
    /**
     * Limit how many OpenBankingPayments to delete.
     */
    limit?: number
  }

  /**
   * OpenBankingPayment without action
   */
  export type OpenBankingPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingPayment
     */
    select?: OpenBankingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingPayment
     */
    omit?: OpenBankingPaymentOmit<ExtArgs> | null
  }


  /**
   * Model OpenBankingConsent
   */

  export type AggregateOpenBankingConsent = {
    _count: OpenBankingConsentCountAggregateOutputType | null
    _avg: OpenBankingConsentAvgAggregateOutputType | null
    _sum: OpenBankingConsentSumAggregateOutputType | null
    _min: OpenBankingConsentMinAggregateOutputType | null
    _max: OpenBankingConsentMaxAggregateOutputType | null
  }

  export type OpenBankingConsentAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type OpenBankingConsentSumAggregateOutputType = {
    amountCents: number | null
  }

  export type OpenBankingConsentMinAggregateOutputType = {
    id: string | null
    enrollmentId: string | null
    consentId: string | null
    amountCents: number | null
    currency: string | null
    creditorName: string | null
    creditorCpfCnpj: string | null
    productId: string | null
    clinicId: string | null
    status: $Enums.ConsentStatusOB | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpenBankingConsentMaxAggregateOutputType = {
    id: string | null
    enrollmentId: string | null
    consentId: string | null
    amountCents: number | null
    currency: string | null
    creditorName: string | null
    creditorCpfCnpj: string | null
    productId: string | null
    clinicId: string | null
    status: $Enums.ConsentStatusOB | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpenBankingConsentCountAggregateOutputType = {
    id: number
    enrollmentId: number
    consentId: number
    amountCents: number
    currency: number
    creditorName: number
    creditorCpfCnpj: number
    productId: number
    clinicId: number
    status: number
    providerResponse: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OpenBankingConsentAvgAggregateInputType = {
    amountCents?: true
  }

  export type OpenBankingConsentSumAggregateInputType = {
    amountCents?: true
  }

  export type OpenBankingConsentMinAggregateInputType = {
    id?: true
    enrollmentId?: true
    consentId?: true
    amountCents?: true
    currency?: true
    creditorName?: true
    creditorCpfCnpj?: true
    productId?: true
    clinicId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpenBankingConsentMaxAggregateInputType = {
    id?: true
    enrollmentId?: true
    consentId?: true
    amountCents?: true
    currency?: true
    creditorName?: true
    creditorCpfCnpj?: true
    productId?: true
    clinicId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpenBankingConsentCountAggregateInputType = {
    id?: true
    enrollmentId?: true
    consentId?: true
    amountCents?: true
    currency?: true
    creditorName?: true
    creditorCpfCnpj?: true
    productId?: true
    clinicId?: true
    status?: true
    providerResponse?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OpenBankingConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenBankingConsent to aggregate.
     */
    where?: OpenBankingConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenBankingConsents to fetch.
     */
    orderBy?: OpenBankingConsentOrderByWithRelationInput | OpenBankingConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpenBankingConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenBankingConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenBankingConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpenBankingConsents
    **/
    _count?: true | OpenBankingConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpenBankingConsentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpenBankingConsentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpenBankingConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpenBankingConsentMaxAggregateInputType
  }

  export type GetOpenBankingConsentAggregateType<T extends OpenBankingConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateOpenBankingConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpenBankingConsent[P]>
      : GetScalarType<T[P], AggregateOpenBankingConsent[P]>
  }




  export type OpenBankingConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenBankingConsentWhereInput
    orderBy?: OpenBankingConsentOrderByWithAggregationInput | OpenBankingConsentOrderByWithAggregationInput[]
    by: OpenBankingConsentScalarFieldEnum[] | OpenBankingConsentScalarFieldEnum
    having?: OpenBankingConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpenBankingConsentCountAggregateInputType | true
    _avg?: OpenBankingConsentAvgAggregateInputType
    _sum?: OpenBankingConsentSumAggregateInputType
    _min?: OpenBankingConsentMinAggregateInputType
    _max?: OpenBankingConsentMaxAggregateInputType
  }

  export type OpenBankingConsentGroupByOutputType = {
    id: string
    enrollmentId: string | null
    consentId: string
    amountCents: number | null
    currency: string | null
    creditorName: string | null
    creditorCpfCnpj: string | null
    productId: string | null
    clinicId: string | null
    status: $Enums.ConsentStatusOB | null
    providerResponse: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: OpenBankingConsentCountAggregateOutputType | null
    _avg: OpenBankingConsentAvgAggregateOutputType | null
    _sum: OpenBankingConsentSumAggregateOutputType | null
    _min: OpenBankingConsentMinAggregateOutputType | null
    _max: OpenBankingConsentMaxAggregateOutputType | null
  }

  type GetOpenBankingConsentGroupByPayload<T extends OpenBankingConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpenBankingConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpenBankingConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpenBankingConsentGroupByOutputType[P]>
            : GetScalarType<T[P], OpenBankingConsentGroupByOutputType[P]>
        }
      >
    >


  export type OpenBankingConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    consentId?: boolean
    amountCents?: boolean
    currency?: boolean
    creditorName?: boolean
    creditorCpfCnpj?: boolean
    productId?: boolean
    clinicId?: boolean
    status?: boolean
    providerResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["openBankingConsent"]>

  export type OpenBankingConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    consentId?: boolean
    amountCents?: boolean
    currency?: boolean
    creditorName?: boolean
    creditorCpfCnpj?: boolean
    productId?: boolean
    clinicId?: boolean
    status?: boolean
    providerResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["openBankingConsent"]>

  export type OpenBankingConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    consentId?: boolean
    amountCents?: boolean
    currency?: boolean
    creditorName?: boolean
    creditorCpfCnpj?: boolean
    productId?: boolean
    clinicId?: boolean
    status?: boolean
    providerResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["openBankingConsent"]>

  export type OpenBankingConsentSelectScalar = {
    id?: boolean
    enrollmentId?: boolean
    consentId?: boolean
    amountCents?: boolean
    currency?: boolean
    creditorName?: boolean
    creditorCpfCnpj?: boolean
    productId?: boolean
    clinicId?: boolean
    status?: boolean
    providerResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OpenBankingConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enrollmentId" | "consentId" | "amountCents" | "currency" | "creditorName" | "creditorCpfCnpj" | "productId" | "clinicId" | "status" | "providerResponse" | "createdAt" | "updatedAt", ExtArgs["result"]["openBankingConsent"]>

  export type $OpenBankingConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpenBankingConsent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enrollmentId: string | null
      consentId: string
      amountCents: number | null
      currency: string | null
      creditorName: string | null
      creditorCpfCnpj: string | null
      productId: string | null
      clinicId: string | null
      status: $Enums.ConsentStatusOB | null
      providerResponse: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["openBankingConsent"]>
    composites: {}
  }

  type OpenBankingConsentGetPayload<S extends boolean | null | undefined | OpenBankingConsentDefaultArgs> = $Result.GetResult<Prisma.$OpenBankingConsentPayload, S>

  type OpenBankingConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpenBankingConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpenBankingConsentCountAggregateInputType | true
    }

  export interface OpenBankingConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpenBankingConsent'], meta: { name: 'OpenBankingConsent' } }
    /**
     * Find zero or one OpenBankingConsent that matches the filter.
     * @param {OpenBankingConsentFindUniqueArgs} args - Arguments to find a OpenBankingConsent
     * @example
     * // Get one OpenBankingConsent
     * const openBankingConsent = await prisma.openBankingConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpenBankingConsentFindUniqueArgs>(args: SelectSubset<T, OpenBankingConsentFindUniqueArgs<ExtArgs>>): Prisma__OpenBankingConsentClient<$Result.GetResult<Prisma.$OpenBankingConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OpenBankingConsent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpenBankingConsentFindUniqueOrThrowArgs} args - Arguments to find a OpenBankingConsent
     * @example
     * // Get one OpenBankingConsent
     * const openBankingConsent = await prisma.openBankingConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpenBankingConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, OpenBankingConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpenBankingConsentClient<$Result.GetResult<Prisma.$OpenBankingConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpenBankingConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingConsentFindFirstArgs} args - Arguments to find a OpenBankingConsent
     * @example
     * // Get one OpenBankingConsent
     * const openBankingConsent = await prisma.openBankingConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpenBankingConsentFindFirstArgs>(args?: SelectSubset<T, OpenBankingConsentFindFirstArgs<ExtArgs>>): Prisma__OpenBankingConsentClient<$Result.GetResult<Prisma.$OpenBankingConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpenBankingConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingConsentFindFirstOrThrowArgs} args - Arguments to find a OpenBankingConsent
     * @example
     * // Get one OpenBankingConsent
     * const openBankingConsent = await prisma.openBankingConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpenBankingConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, OpenBankingConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpenBankingConsentClient<$Result.GetResult<Prisma.$OpenBankingConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OpenBankingConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpenBankingConsents
     * const openBankingConsents = await prisma.openBankingConsent.findMany()
     * 
     * // Get first 10 OpenBankingConsents
     * const openBankingConsents = await prisma.openBankingConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const openBankingConsentWithIdOnly = await prisma.openBankingConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpenBankingConsentFindManyArgs>(args?: SelectSubset<T, OpenBankingConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenBankingConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OpenBankingConsent.
     * @param {OpenBankingConsentCreateArgs} args - Arguments to create a OpenBankingConsent.
     * @example
     * // Create one OpenBankingConsent
     * const OpenBankingConsent = await prisma.openBankingConsent.create({
     *   data: {
     *     // ... data to create a OpenBankingConsent
     *   }
     * })
     * 
     */
    create<T extends OpenBankingConsentCreateArgs>(args: SelectSubset<T, OpenBankingConsentCreateArgs<ExtArgs>>): Prisma__OpenBankingConsentClient<$Result.GetResult<Prisma.$OpenBankingConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OpenBankingConsents.
     * @param {OpenBankingConsentCreateManyArgs} args - Arguments to create many OpenBankingConsents.
     * @example
     * // Create many OpenBankingConsents
     * const openBankingConsent = await prisma.openBankingConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpenBankingConsentCreateManyArgs>(args?: SelectSubset<T, OpenBankingConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpenBankingConsents and returns the data saved in the database.
     * @param {OpenBankingConsentCreateManyAndReturnArgs} args - Arguments to create many OpenBankingConsents.
     * @example
     * // Create many OpenBankingConsents
     * const openBankingConsent = await prisma.openBankingConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpenBankingConsents and only return the `id`
     * const openBankingConsentWithIdOnly = await prisma.openBankingConsent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpenBankingConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, OpenBankingConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenBankingConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OpenBankingConsent.
     * @param {OpenBankingConsentDeleteArgs} args - Arguments to delete one OpenBankingConsent.
     * @example
     * // Delete one OpenBankingConsent
     * const OpenBankingConsent = await prisma.openBankingConsent.delete({
     *   where: {
     *     // ... filter to delete one OpenBankingConsent
     *   }
     * })
     * 
     */
    delete<T extends OpenBankingConsentDeleteArgs>(args: SelectSubset<T, OpenBankingConsentDeleteArgs<ExtArgs>>): Prisma__OpenBankingConsentClient<$Result.GetResult<Prisma.$OpenBankingConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OpenBankingConsent.
     * @param {OpenBankingConsentUpdateArgs} args - Arguments to update one OpenBankingConsent.
     * @example
     * // Update one OpenBankingConsent
     * const openBankingConsent = await prisma.openBankingConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpenBankingConsentUpdateArgs>(args: SelectSubset<T, OpenBankingConsentUpdateArgs<ExtArgs>>): Prisma__OpenBankingConsentClient<$Result.GetResult<Prisma.$OpenBankingConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OpenBankingConsents.
     * @param {OpenBankingConsentDeleteManyArgs} args - Arguments to filter OpenBankingConsents to delete.
     * @example
     * // Delete a few OpenBankingConsents
     * const { count } = await prisma.openBankingConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpenBankingConsentDeleteManyArgs>(args?: SelectSubset<T, OpenBankingConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenBankingConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpenBankingConsents
     * const openBankingConsent = await prisma.openBankingConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpenBankingConsentUpdateManyArgs>(args: SelectSubset<T, OpenBankingConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenBankingConsents and returns the data updated in the database.
     * @param {OpenBankingConsentUpdateManyAndReturnArgs} args - Arguments to update many OpenBankingConsents.
     * @example
     * // Update many OpenBankingConsents
     * const openBankingConsent = await prisma.openBankingConsent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OpenBankingConsents and only return the `id`
     * const openBankingConsentWithIdOnly = await prisma.openBankingConsent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpenBankingConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, OpenBankingConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenBankingConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OpenBankingConsent.
     * @param {OpenBankingConsentUpsertArgs} args - Arguments to update or create a OpenBankingConsent.
     * @example
     * // Update or create a OpenBankingConsent
     * const openBankingConsent = await prisma.openBankingConsent.upsert({
     *   create: {
     *     // ... data to create a OpenBankingConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpenBankingConsent we want to update
     *   }
     * })
     */
    upsert<T extends OpenBankingConsentUpsertArgs>(args: SelectSubset<T, OpenBankingConsentUpsertArgs<ExtArgs>>): Prisma__OpenBankingConsentClient<$Result.GetResult<Prisma.$OpenBankingConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OpenBankingConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingConsentCountArgs} args - Arguments to filter OpenBankingConsents to count.
     * @example
     * // Count the number of OpenBankingConsents
     * const count = await prisma.openBankingConsent.count({
     *   where: {
     *     // ... the filter for the OpenBankingConsents we want to count
     *   }
     * })
    **/
    count<T extends OpenBankingConsentCountArgs>(
      args?: Subset<T, OpenBankingConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpenBankingConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpenBankingConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpenBankingConsentAggregateArgs>(args: Subset<T, OpenBankingConsentAggregateArgs>): Prisma.PrismaPromise<GetOpenBankingConsentAggregateType<T>>

    /**
     * Group by OpenBankingConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenBankingConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpenBankingConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpenBankingConsentGroupByArgs['orderBy'] }
        : { orderBy?: OpenBankingConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpenBankingConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpenBankingConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpenBankingConsent model
   */
  readonly fields: OpenBankingConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpenBankingConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpenBankingConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpenBankingConsent model
   */
  interface OpenBankingConsentFieldRefs {
    readonly id: FieldRef<"OpenBankingConsent", 'String'>
    readonly enrollmentId: FieldRef<"OpenBankingConsent", 'String'>
    readonly consentId: FieldRef<"OpenBankingConsent", 'String'>
    readonly amountCents: FieldRef<"OpenBankingConsent", 'Int'>
    readonly currency: FieldRef<"OpenBankingConsent", 'String'>
    readonly creditorName: FieldRef<"OpenBankingConsent", 'String'>
    readonly creditorCpfCnpj: FieldRef<"OpenBankingConsent", 'String'>
    readonly productId: FieldRef<"OpenBankingConsent", 'String'>
    readonly clinicId: FieldRef<"OpenBankingConsent", 'String'>
    readonly status: FieldRef<"OpenBankingConsent", 'ConsentStatusOB'>
    readonly providerResponse: FieldRef<"OpenBankingConsent", 'Json'>
    readonly createdAt: FieldRef<"OpenBankingConsent", 'DateTime'>
    readonly updatedAt: FieldRef<"OpenBankingConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OpenBankingConsent findUnique
   */
  export type OpenBankingConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
    /**
     * Filter, which OpenBankingConsent to fetch.
     */
    where: OpenBankingConsentWhereUniqueInput
  }

  /**
   * OpenBankingConsent findUniqueOrThrow
   */
  export type OpenBankingConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
    /**
     * Filter, which OpenBankingConsent to fetch.
     */
    where: OpenBankingConsentWhereUniqueInput
  }

  /**
   * OpenBankingConsent findFirst
   */
  export type OpenBankingConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
    /**
     * Filter, which OpenBankingConsent to fetch.
     */
    where?: OpenBankingConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenBankingConsents to fetch.
     */
    orderBy?: OpenBankingConsentOrderByWithRelationInput | OpenBankingConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenBankingConsents.
     */
    cursor?: OpenBankingConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenBankingConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenBankingConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenBankingConsents.
     */
    distinct?: OpenBankingConsentScalarFieldEnum | OpenBankingConsentScalarFieldEnum[]
  }

  /**
   * OpenBankingConsent findFirstOrThrow
   */
  export type OpenBankingConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
    /**
     * Filter, which OpenBankingConsent to fetch.
     */
    where?: OpenBankingConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenBankingConsents to fetch.
     */
    orderBy?: OpenBankingConsentOrderByWithRelationInput | OpenBankingConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenBankingConsents.
     */
    cursor?: OpenBankingConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenBankingConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenBankingConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenBankingConsents.
     */
    distinct?: OpenBankingConsentScalarFieldEnum | OpenBankingConsentScalarFieldEnum[]
  }

  /**
   * OpenBankingConsent findMany
   */
  export type OpenBankingConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
    /**
     * Filter, which OpenBankingConsents to fetch.
     */
    where?: OpenBankingConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenBankingConsents to fetch.
     */
    orderBy?: OpenBankingConsentOrderByWithRelationInput | OpenBankingConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpenBankingConsents.
     */
    cursor?: OpenBankingConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenBankingConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenBankingConsents.
     */
    skip?: number
    distinct?: OpenBankingConsentScalarFieldEnum | OpenBankingConsentScalarFieldEnum[]
  }

  /**
   * OpenBankingConsent create
   */
  export type OpenBankingConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
    /**
     * The data needed to create a OpenBankingConsent.
     */
    data: XOR<OpenBankingConsentCreateInput, OpenBankingConsentUncheckedCreateInput>
  }

  /**
   * OpenBankingConsent createMany
   */
  export type OpenBankingConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpenBankingConsents.
     */
    data: OpenBankingConsentCreateManyInput | OpenBankingConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenBankingConsent createManyAndReturn
   */
  export type OpenBankingConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
    /**
     * The data used to create many OpenBankingConsents.
     */
    data: OpenBankingConsentCreateManyInput | OpenBankingConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenBankingConsent update
   */
  export type OpenBankingConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
    /**
     * The data needed to update a OpenBankingConsent.
     */
    data: XOR<OpenBankingConsentUpdateInput, OpenBankingConsentUncheckedUpdateInput>
    /**
     * Choose, which OpenBankingConsent to update.
     */
    where: OpenBankingConsentWhereUniqueInput
  }

  /**
   * OpenBankingConsent updateMany
   */
  export type OpenBankingConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpenBankingConsents.
     */
    data: XOR<OpenBankingConsentUpdateManyMutationInput, OpenBankingConsentUncheckedUpdateManyInput>
    /**
     * Filter which OpenBankingConsents to update
     */
    where?: OpenBankingConsentWhereInput
    /**
     * Limit how many OpenBankingConsents to update.
     */
    limit?: number
  }

  /**
   * OpenBankingConsent updateManyAndReturn
   */
  export type OpenBankingConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
    /**
     * The data used to update OpenBankingConsents.
     */
    data: XOR<OpenBankingConsentUpdateManyMutationInput, OpenBankingConsentUncheckedUpdateManyInput>
    /**
     * Filter which OpenBankingConsents to update
     */
    where?: OpenBankingConsentWhereInput
    /**
     * Limit how many OpenBankingConsents to update.
     */
    limit?: number
  }

  /**
   * OpenBankingConsent upsert
   */
  export type OpenBankingConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
    /**
     * The filter to search for the OpenBankingConsent to update in case it exists.
     */
    where: OpenBankingConsentWhereUniqueInput
    /**
     * In case the OpenBankingConsent found by the `where` argument doesn't exist, create a new OpenBankingConsent with this data.
     */
    create: XOR<OpenBankingConsentCreateInput, OpenBankingConsentUncheckedCreateInput>
    /**
     * In case the OpenBankingConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpenBankingConsentUpdateInput, OpenBankingConsentUncheckedUpdateInput>
  }

  /**
   * OpenBankingConsent delete
   */
  export type OpenBankingConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
    /**
     * Filter which OpenBankingConsent to delete.
     */
    where: OpenBankingConsentWhereUniqueInput
  }

  /**
   * OpenBankingConsent deleteMany
   */
  export type OpenBankingConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenBankingConsents to delete
     */
    where?: OpenBankingConsentWhereInput
    /**
     * Limit how many OpenBankingConsents to delete.
     */
    limit?: number
  }

  /**
   * OpenBankingConsent without action
   */
  export type OpenBankingConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenBankingConsent
     */
    select?: OpenBankingConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenBankingConsent
     */
    omit?: OpenBankingConsentOmit<ExtArgs> | null
  }


  /**
   * Model EnrollmentContext
   */

  export type AggregateEnrollmentContext = {
    _count: EnrollmentContextCountAggregateOutputType | null
    _min: EnrollmentContextMinAggregateOutputType | null
    _max: EnrollmentContextMaxAggregateOutputType | null
  }

  export type EnrollmentContextMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    enrollmentId: string | null
    organisationId: string | null
    authorisationServerId: string | null
    fallbackUsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.EnrollmentStatusOB | null
    deviceRegistered: boolean | null
    expiresAt: Date | null
    clinicId: string | null
    payerEmail: string | null
    payerDocument: string | null
    payerName: string | null
    recurringEnabled: boolean | null
  }

  export type EnrollmentContextMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    enrollmentId: string | null
    organisationId: string | null
    authorisationServerId: string | null
    fallbackUsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.EnrollmentStatusOB | null
    deviceRegistered: boolean | null
    expiresAt: Date | null
    clinicId: string | null
    payerEmail: string | null
    payerDocument: string | null
    payerName: string | null
    recurringEnabled: boolean | null
  }

  export type EnrollmentContextCountAggregateOutputType = {
    id: number
    userId: number
    sessionId: number
    enrollmentId: number
    organisationId: number
    authorisationServerId: number
    fallbackUsed: number
    createdAt: number
    updatedAt: number
    status: number
    deviceRegistered: number
    expiresAt: number
    clinicId: number
    payerEmail: number
    payerDocument: number
    payerName: number
    recurringEnabled: number
    deviceBinding: number
    providerResponse: number
    _all: number
  }


  export type EnrollmentContextMinAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    enrollmentId?: true
    organisationId?: true
    authorisationServerId?: true
    fallbackUsed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    deviceRegistered?: true
    expiresAt?: true
    clinicId?: true
    payerEmail?: true
    payerDocument?: true
    payerName?: true
    recurringEnabled?: true
  }

  export type EnrollmentContextMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    enrollmentId?: true
    organisationId?: true
    authorisationServerId?: true
    fallbackUsed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    deviceRegistered?: true
    expiresAt?: true
    clinicId?: true
    payerEmail?: true
    payerDocument?: true
    payerName?: true
    recurringEnabled?: true
  }

  export type EnrollmentContextCountAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    enrollmentId?: true
    organisationId?: true
    authorisationServerId?: true
    fallbackUsed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    deviceRegistered?: true
    expiresAt?: true
    clinicId?: true
    payerEmail?: true
    payerDocument?: true
    payerName?: true
    recurringEnabled?: true
    deviceBinding?: true
    providerResponse?: true
    _all?: true
  }

  export type EnrollmentContextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnrollmentContext to aggregate.
     */
    where?: EnrollmentContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnrollmentContexts to fetch.
     */
    orderBy?: EnrollmentContextOrderByWithRelationInput | EnrollmentContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnrollmentContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnrollmentContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnrollmentContexts
    **/
    _count?: true | EnrollmentContextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentContextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentContextMaxAggregateInputType
  }

  export type GetEnrollmentContextAggregateType<T extends EnrollmentContextAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollmentContext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollmentContext[P]>
      : GetScalarType<T[P], AggregateEnrollmentContext[P]>
  }




  export type EnrollmentContextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentContextWhereInput
    orderBy?: EnrollmentContextOrderByWithAggregationInput | EnrollmentContextOrderByWithAggregationInput[]
    by: EnrollmentContextScalarFieldEnum[] | EnrollmentContextScalarFieldEnum
    having?: EnrollmentContextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentContextCountAggregateInputType | true
    _min?: EnrollmentContextMinAggregateInputType
    _max?: EnrollmentContextMaxAggregateInputType
  }

  export type EnrollmentContextGroupByOutputType = {
    id: string
    userId: string
    sessionId: string | null
    enrollmentId: string
    organisationId: string
    authorisationServerId: string
    fallbackUsed: boolean
    createdAt: Date
    updatedAt: Date
    status: $Enums.EnrollmentStatusOB | null
    deviceRegistered: boolean
    expiresAt: Date | null
    clinicId: string | null
    payerEmail: string | null
    payerDocument: string | null
    payerName: string | null
    recurringEnabled: boolean | null
    deviceBinding: JsonValue | null
    providerResponse: JsonValue | null
    _count: EnrollmentContextCountAggregateOutputType | null
    _min: EnrollmentContextMinAggregateOutputType | null
    _max: EnrollmentContextMaxAggregateOutputType | null
  }

  type GetEnrollmentContextGroupByPayload<T extends EnrollmentContextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentContextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentContextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentContextGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentContextGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentContextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    enrollmentId?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    fallbackUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    deviceRegistered?: boolean
    expiresAt?: boolean
    clinicId?: boolean
    payerEmail?: boolean
    payerDocument?: boolean
    payerName?: boolean
    recurringEnabled?: boolean
    deviceBinding?: boolean
    providerResponse?: boolean
  }, ExtArgs["result"]["enrollmentContext"]>

  export type EnrollmentContextSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    enrollmentId?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    fallbackUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    deviceRegistered?: boolean
    expiresAt?: boolean
    clinicId?: boolean
    payerEmail?: boolean
    payerDocument?: boolean
    payerName?: boolean
    recurringEnabled?: boolean
    deviceBinding?: boolean
    providerResponse?: boolean
  }, ExtArgs["result"]["enrollmentContext"]>

  export type EnrollmentContextSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    enrollmentId?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    fallbackUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    deviceRegistered?: boolean
    expiresAt?: boolean
    clinicId?: boolean
    payerEmail?: boolean
    payerDocument?: boolean
    payerName?: boolean
    recurringEnabled?: boolean
    deviceBinding?: boolean
    providerResponse?: boolean
  }, ExtArgs["result"]["enrollmentContext"]>

  export type EnrollmentContextSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    enrollmentId?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    fallbackUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    deviceRegistered?: boolean
    expiresAt?: boolean
    clinicId?: boolean
    payerEmail?: boolean
    payerDocument?: boolean
    payerName?: boolean
    recurringEnabled?: boolean
    deviceBinding?: boolean
    providerResponse?: boolean
  }

  export type EnrollmentContextOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sessionId" | "enrollmentId" | "organisationId" | "authorisationServerId" | "fallbackUsed" | "createdAt" | "updatedAt" | "status" | "deviceRegistered" | "expiresAt" | "clinicId" | "payerEmail" | "payerDocument" | "payerName" | "recurringEnabled" | "deviceBinding" | "providerResponse", ExtArgs["result"]["enrollmentContext"]>

  export type $EnrollmentContextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnrollmentContext"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sessionId: string | null
      enrollmentId: string
      organisationId: string
      authorisationServerId: string
      fallbackUsed: boolean
      createdAt: Date
      updatedAt: Date
      status: $Enums.EnrollmentStatusOB | null
      deviceRegistered: boolean
      expiresAt: Date | null
      clinicId: string | null
      payerEmail: string | null
      payerDocument: string | null
      payerName: string | null
      recurringEnabled: boolean | null
      deviceBinding: Prisma.JsonValue | null
      providerResponse: Prisma.JsonValue | null
    }, ExtArgs["result"]["enrollmentContext"]>
    composites: {}
  }

  type EnrollmentContextGetPayload<S extends boolean | null | undefined | EnrollmentContextDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentContextPayload, S>

  type EnrollmentContextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnrollmentContextFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentContextCountAggregateInputType | true
    }

  export interface EnrollmentContextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnrollmentContext'], meta: { name: 'EnrollmentContext' } }
    /**
     * Find zero or one EnrollmentContext that matches the filter.
     * @param {EnrollmentContextFindUniqueArgs} args - Arguments to find a EnrollmentContext
     * @example
     * // Get one EnrollmentContext
     * const enrollmentContext = await prisma.enrollmentContext.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentContextFindUniqueArgs>(args: SelectSubset<T, EnrollmentContextFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentContextClient<$Result.GetResult<Prisma.$EnrollmentContextPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EnrollmentContext that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnrollmentContextFindUniqueOrThrowArgs} args - Arguments to find a EnrollmentContext
     * @example
     * // Get one EnrollmentContext
     * const enrollmentContext = await prisma.enrollmentContext.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentContextFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentContextFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentContextClient<$Result.GetResult<Prisma.$EnrollmentContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnrollmentContext that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentContextFindFirstArgs} args - Arguments to find a EnrollmentContext
     * @example
     * // Get one EnrollmentContext
     * const enrollmentContext = await prisma.enrollmentContext.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentContextFindFirstArgs>(args?: SelectSubset<T, EnrollmentContextFindFirstArgs<ExtArgs>>): Prisma__EnrollmentContextClient<$Result.GetResult<Prisma.$EnrollmentContextPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnrollmentContext that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentContextFindFirstOrThrowArgs} args - Arguments to find a EnrollmentContext
     * @example
     * // Get one EnrollmentContext
     * const enrollmentContext = await prisma.enrollmentContext.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentContextFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentContextFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentContextClient<$Result.GetResult<Prisma.$EnrollmentContextPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EnrollmentContexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentContextFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnrollmentContexts
     * const enrollmentContexts = await prisma.enrollmentContext.findMany()
     * 
     * // Get first 10 EnrollmentContexts
     * const enrollmentContexts = await prisma.enrollmentContext.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentContextWithIdOnly = await prisma.enrollmentContext.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentContextFindManyArgs>(args?: SelectSubset<T, EnrollmentContextFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentContextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EnrollmentContext.
     * @param {EnrollmentContextCreateArgs} args - Arguments to create a EnrollmentContext.
     * @example
     * // Create one EnrollmentContext
     * const EnrollmentContext = await prisma.enrollmentContext.create({
     *   data: {
     *     // ... data to create a EnrollmentContext
     *   }
     * })
     * 
     */
    create<T extends EnrollmentContextCreateArgs>(args: SelectSubset<T, EnrollmentContextCreateArgs<ExtArgs>>): Prisma__EnrollmentContextClient<$Result.GetResult<Prisma.$EnrollmentContextPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EnrollmentContexts.
     * @param {EnrollmentContextCreateManyArgs} args - Arguments to create many EnrollmentContexts.
     * @example
     * // Create many EnrollmentContexts
     * const enrollmentContext = await prisma.enrollmentContext.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentContextCreateManyArgs>(args?: SelectSubset<T, EnrollmentContextCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EnrollmentContexts and returns the data saved in the database.
     * @param {EnrollmentContextCreateManyAndReturnArgs} args - Arguments to create many EnrollmentContexts.
     * @example
     * // Create many EnrollmentContexts
     * const enrollmentContext = await prisma.enrollmentContext.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EnrollmentContexts and only return the `id`
     * const enrollmentContextWithIdOnly = await prisma.enrollmentContext.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnrollmentContextCreateManyAndReturnArgs>(args?: SelectSubset<T, EnrollmentContextCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentContextPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EnrollmentContext.
     * @param {EnrollmentContextDeleteArgs} args - Arguments to delete one EnrollmentContext.
     * @example
     * // Delete one EnrollmentContext
     * const EnrollmentContext = await prisma.enrollmentContext.delete({
     *   where: {
     *     // ... filter to delete one EnrollmentContext
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentContextDeleteArgs>(args: SelectSubset<T, EnrollmentContextDeleteArgs<ExtArgs>>): Prisma__EnrollmentContextClient<$Result.GetResult<Prisma.$EnrollmentContextPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EnrollmentContext.
     * @param {EnrollmentContextUpdateArgs} args - Arguments to update one EnrollmentContext.
     * @example
     * // Update one EnrollmentContext
     * const enrollmentContext = await prisma.enrollmentContext.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentContextUpdateArgs>(args: SelectSubset<T, EnrollmentContextUpdateArgs<ExtArgs>>): Prisma__EnrollmentContextClient<$Result.GetResult<Prisma.$EnrollmentContextPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EnrollmentContexts.
     * @param {EnrollmentContextDeleteManyArgs} args - Arguments to filter EnrollmentContexts to delete.
     * @example
     * // Delete a few EnrollmentContexts
     * const { count } = await prisma.enrollmentContext.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentContextDeleteManyArgs>(args?: SelectSubset<T, EnrollmentContextDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnrollmentContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentContextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnrollmentContexts
     * const enrollmentContext = await prisma.enrollmentContext.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentContextUpdateManyArgs>(args: SelectSubset<T, EnrollmentContextUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnrollmentContexts and returns the data updated in the database.
     * @param {EnrollmentContextUpdateManyAndReturnArgs} args - Arguments to update many EnrollmentContexts.
     * @example
     * // Update many EnrollmentContexts
     * const enrollmentContext = await prisma.enrollmentContext.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EnrollmentContexts and only return the `id`
     * const enrollmentContextWithIdOnly = await prisma.enrollmentContext.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnrollmentContextUpdateManyAndReturnArgs>(args: SelectSubset<T, EnrollmentContextUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentContextPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EnrollmentContext.
     * @param {EnrollmentContextUpsertArgs} args - Arguments to update or create a EnrollmentContext.
     * @example
     * // Update or create a EnrollmentContext
     * const enrollmentContext = await prisma.enrollmentContext.upsert({
     *   create: {
     *     // ... data to create a EnrollmentContext
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnrollmentContext we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentContextUpsertArgs>(args: SelectSubset<T, EnrollmentContextUpsertArgs<ExtArgs>>): Prisma__EnrollmentContextClient<$Result.GetResult<Prisma.$EnrollmentContextPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EnrollmentContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentContextCountArgs} args - Arguments to filter EnrollmentContexts to count.
     * @example
     * // Count the number of EnrollmentContexts
     * const count = await prisma.enrollmentContext.count({
     *   where: {
     *     // ... the filter for the EnrollmentContexts we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentContextCountArgs>(
      args?: Subset<T, EnrollmentContextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentContextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnrollmentContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentContextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentContextAggregateArgs>(args: Subset<T, EnrollmentContextAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentContextAggregateType<T>>

    /**
     * Group by EnrollmentContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentContextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentContextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentContextGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentContextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentContextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentContextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnrollmentContext model
   */
  readonly fields: EnrollmentContextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnrollmentContext.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentContextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EnrollmentContext model
   */
  interface EnrollmentContextFieldRefs {
    readonly id: FieldRef<"EnrollmentContext", 'String'>
    readonly userId: FieldRef<"EnrollmentContext", 'String'>
    readonly sessionId: FieldRef<"EnrollmentContext", 'String'>
    readonly enrollmentId: FieldRef<"EnrollmentContext", 'String'>
    readonly organisationId: FieldRef<"EnrollmentContext", 'String'>
    readonly authorisationServerId: FieldRef<"EnrollmentContext", 'String'>
    readonly fallbackUsed: FieldRef<"EnrollmentContext", 'Boolean'>
    readonly createdAt: FieldRef<"EnrollmentContext", 'DateTime'>
    readonly updatedAt: FieldRef<"EnrollmentContext", 'DateTime'>
    readonly status: FieldRef<"EnrollmentContext", 'EnrollmentStatusOB'>
    readonly deviceRegistered: FieldRef<"EnrollmentContext", 'Boolean'>
    readonly expiresAt: FieldRef<"EnrollmentContext", 'DateTime'>
    readonly clinicId: FieldRef<"EnrollmentContext", 'String'>
    readonly payerEmail: FieldRef<"EnrollmentContext", 'String'>
    readonly payerDocument: FieldRef<"EnrollmentContext", 'String'>
    readonly payerName: FieldRef<"EnrollmentContext", 'String'>
    readonly recurringEnabled: FieldRef<"EnrollmentContext", 'Boolean'>
    readonly deviceBinding: FieldRef<"EnrollmentContext", 'Json'>
    readonly providerResponse: FieldRef<"EnrollmentContext", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * EnrollmentContext findUnique
   */
  export type EnrollmentContextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
    /**
     * Filter, which EnrollmentContext to fetch.
     */
    where: EnrollmentContextWhereUniqueInput
  }

  /**
   * EnrollmentContext findUniqueOrThrow
   */
  export type EnrollmentContextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
    /**
     * Filter, which EnrollmentContext to fetch.
     */
    where: EnrollmentContextWhereUniqueInput
  }

  /**
   * EnrollmentContext findFirst
   */
  export type EnrollmentContextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
    /**
     * Filter, which EnrollmentContext to fetch.
     */
    where?: EnrollmentContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnrollmentContexts to fetch.
     */
    orderBy?: EnrollmentContextOrderByWithRelationInput | EnrollmentContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnrollmentContexts.
     */
    cursor?: EnrollmentContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnrollmentContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnrollmentContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnrollmentContexts.
     */
    distinct?: EnrollmentContextScalarFieldEnum | EnrollmentContextScalarFieldEnum[]
  }

  /**
   * EnrollmentContext findFirstOrThrow
   */
  export type EnrollmentContextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
    /**
     * Filter, which EnrollmentContext to fetch.
     */
    where?: EnrollmentContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnrollmentContexts to fetch.
     */
    orderBy?: EnrollmentContextOrderByWithRelationInput | EnrollmentContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnrollmentContexts.
     */
    cursor?: EnrollmentContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnrollmentContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnrollmentContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnrollmentContexts.
     */
    distinct?: EnrollmentContextScalarFieldEnum | EnrollmentContextScalarFieldEnum[]
  }

  /**
   * EnrollmentContext findMany
   */
  export type EnrollmentContextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
    /**
     * Filter, which EnrollmentContexts to fetch.
     */
    where?: EnrollmentContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnrollmentContexts to fetch.
     */
    orderBy?: EnrollmentContextOrderByWithRelationInput | EnrollmentContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnrollmentContexts.
     */
    cursor?: EnrollmentContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnrollmentContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnrollmentContexts.
     */
    skip?: number
    distinct?: EnrollmentContextScalarFieldEnum | EnrollmentContextScalarFieldEnum[]
  }

  /**
   * EnrollmentContext create
   */
  export type EnrollmentContextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
    /**
     * The data needed to create a EnrollmentContext.
     */
    data: XOR<EnrollmentContextCreateInput, EnrollmentContextUncheckedCreateInput>
  }

  /**
   * EnrollmentContext createMany
   */
  export type EnrollmentContextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnrollmentContexts.
     */
    data: EnrollmentContextCreateManyInput | EnrollmentContextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnrollmentContext createManyAndReturn
   */
  export type EnrollmentContextCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
    /**
     * The data used to create many EnrollmentContexts.
     */
    data: EnrollmentContextCreateManyInput | EnrollmentContextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnrollmentContext update
   */
  export type EnrollmentContextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
    /**
     * The data needed to update a EnrollmentContext.
     */
    data: XOR<EnrollmentContextUpdateInput, EnrollmentContextUncheckedUpdateInput>
    /**
     * Choose, which EnrollmentContext to update.
     */
    where: EnrollmentContextWhereUniqueInput
  }

  /**
   * EnrollmentContext updateMany
   */
  export type EnrollmentContextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnrollmentContexts.
     */
    data: XOR<EnrollmentContextUpdateManyMutationInput, EnrollmentContextUncheckedUpdateManyInput>
    /**
     * Filter which EnrollmentContexts to update
     */
    where?: EnrollmentContextWhereInput
    /**
     * Limit how many EnrollmentContexts to update.
     */
    limit?: number
  }

  /**
   * EnrollmentContext updateManyAndReturn
   */
  export type EnrollmentContextUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
    /**
     * The data used to update EnrollmentContexts.
     */
    data: XOR<EnrollmentContextUpdateManyMutationInput, EnrollmentContextUncheckedUpdateManyInput>
    /**
     * Filter which EnrollmentContexts to update
     */
    where?: EnrollmentContextWhereInput
    /**
     * Limit how many EnrollmentContexts to update.
     */
    limit?: number
  }

  /**
   * EnrollmentContext upsert
   */
  export type EnrollmentContextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
    /**
     * The filter to search for the EnrollmentContext to update in case it exists.
     */
    where: EnrollmentContextWhereUniqueInput
    /**
     * In case the EnrollmentContext found by the `where` argument doesn't exist, create a new EnrollmentContext with this data.
     */
    create: XOR<EnrollmentContextCreateInput, EnrollmentContextUncheckedCreateInput>
    /**
     * In case the EnrollmentContext was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentContextUpdateInput, EnrollmentContextUncheckedUpdateInput>
  }

  /**
   * EnrollmentContext delete
   */
  export type EnrollmentContextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
    /**
     * Filter which EnrollmentContext to delete.
     */
    where: EnrollmentContextWhereUniqueInput
  }

  /**
   * EnrollmentContext deleteMany
   */
  export type EnrollmentContextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnrollmentContexts to delete
     */
    where?: EnrollmentContextWhereInput
    /**
     * Limit how many EnrollmentContexts to delete.
     */
    limit?: number
  }

  /**
   * EnrollmentContext without action
   */
  export type EnrollmentContextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentContext
     */
    select?: EnrollmentContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnrollmentContext
     */
    omit?: EnrollmentContextOmit<ExtArgs> | null
  }


  /**
   * Model PaymentConsent
   */

  export type AggregatePaymentConsent = {
    _count: PaymentConsentCountAggregateOutputType | null
    _min: PaymentConsentMinAggregateOutputType | null
    _max: PaymentConsentMaxAggregateOutputType | null
  }

  export type PaymentConsentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    consentId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentConsentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    consentId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentConsentCountAggregateOutputType = {
    id: number
    tenantId: number
    consentId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentConsentMinAggregateInputType = {
    id?: true
    tenantId?: true
    consentId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentConsentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    consentId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentConsentCountAggregateInputType = {
    id?: true
    tenantId?: true
    consentId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentConsent to aggregate.
     */
    where?: PaymentConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConsents to fetch.
     */
    orderBy?: PaymentConsentOrderByWithRelationInput | PaymentConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentConsents
    **/
    _count?: true | PaymentConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentConsentMaxAggregateInputType
  }

  export type GetPaymentConsentAggregateType<T extends PaymentConsentAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentConsent[P]>
      : GetScalarType<T[P], AggregatePaymentConsent[P]>
  }




  export type PaymentConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentConsentWhereInput
    orderBy?: PaymentConsentOrderByWithAggregationInput | PaymentConsentOrderByWithAggregationInput[]
    by: PaymentConsentScalarFieldEnum[] | PaymentConsentScalarFieldEnum
    having?: PaymentConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentConsentCountAggregateInputType | true
    _min?: PaymentConsentMinAggregateInputType
    _max?: PaymentConsentMaxAggregateInputType
  }

  export type PaymentConsentGroupByOutputType = {
    id: string
    tenantId: string | null
    consentId: string
    status: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentConsentCountAggregateOutputType | null
    _min: PaymentConsentMinAggregateOutputType | null
    _max: PaymentConsentMaxAggregateOutputType | null
  }

  type GetPaymentConsentGroupByPayload<T extends PaymentConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentConsentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentConsentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    consentId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentConsent"]>

  export type PaymentConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    consentId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentConsent"]>

  export type PaymentConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    consentId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentConsent"]>

  export type PaymentConsentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    consentId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "consentId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentConsent"]>

  export type $PaymentConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentConsent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      consentId: string
      status: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentConsent"]>
    composites: {}
  }

  type PaymentConsentGetPayload<S extends boolean | null | undefined | PaymentConsentDefaultArgs> = $Result.GetResult<Prisma.$PaymentConsentPayload, S>

  type PaymentConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentConsentCountAggregateInputType | true
    }

  export interface PaymentConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentConsent'], meta: { name: 'PaymentConsent' } }
    /**
     * Find zero or one PaymentConsent that matches the filter.
     * @param {PaymentConsentFindUniqueArgs} args - Arguments to find a PaymentConsent
     * @example
     * // Get one PaymentConsent
     * const paymentConsent = await prisma.paymentConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentConsentFindUniqueArgs>(args: SelectSubset<T, PaymentConsentFindUniqueArgs<ExtArgs>>): Prisma__PaymentConsentClient<$Result.GetResult<Prisma.$PaymentConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentConsent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentConsentFindUniqueOrThrowArgs} args - Arguments to find a PaymentConsent
     * @example
     * // Get one PaymentConsent
     * const paymentConsent = await prisma.paymentConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentConsentClient<$Result.GetResult<Prisma.$PaymentConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConsentFindFirstArgs} args - Arguments to find a PaymentConsent
     * @example
     * // Get one PaymentConsent
     * const paymentConsent = await prisma.paymentConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentConsentFindFirstArgs>(args?: SelectSubset<T, PaymentConsentFindFirstArgs<ExtArgs>>): Prisma__PaymentConsentClient<$Result.GetResult<Prisma.$PaymentConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConsentFindFirstOrThrowArgs} args - Arguments to find a PaymentConsent
     * @example
     * // Get one PaymentConsent
     * const paymentConsent = await prisma.paymentConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentConsentClient<$Result.GetResult<Prisma.$PaymentConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentConsents
     * const paymentConsents = await prisma.paymentConsent.findMany()
     * 
     * // Get first 10 PaymentConsents
     * const paymentConsents = await prisma.paymentConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentConsentWithIdOnly = await prisma.paymentConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentConsentFindManyArgs>(args?: SelectSubset<T, PaymentConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentConsent.
     * @param {PaymentConsentCreateArgs} args - Arguments to create a PaymentConsent.
     * @example
     * // Create one PaymentConsent
     * const PaymentConsent = await prisma.paymentConsent.create({
     *   data: {
     *     // ... data to create a PaymentConsent
     *   }
     * })
     * 
     */
    create<T extends PaymentConsentCreateArgs>(args: SelectSubset<T, PaymentConsentCreateArgs<ExtArgs>>): Prisma__PaymentConsentClient<$Result.GetResult<Prisma.$PaymentConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentConsents.
     * @param {PaymentConsentCreateManyArgs} args - Arguments to create many PaymentConsents.
     * @example
     * // Create many PaymentConsents
     * const paymentConsent = await prisma.paymentConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentConsentCreateManyArgs>(args?: SelectSubset<T, PaymentConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentConsents and returns the data saved in the database.
     * @param {PaymentConsentCreateManyAndReturnArgs} args - Arguments to create many PaymentConsents.
     * @example
     * // Create many PaymentConsents
     * const paymentConsent = await prisma.paymentConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentConsents and only return the `id`
     * const paymentConsentWithIdOnly = await prisma.paymentConsent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentConsent.
     * @param {PaymentConsentDeleteArgs} args - Arguments to delete one PaymentConsent.
     * @example
     * // Delete one PaymentConsent
     * const PaymentConsent = await prisma.paymentConsent.delete({
     *   where: {
     *     // ... filter to delete one PaymentConsent
     *   }
     * })
     * 
     */
    delete<T extends PaymentConsentDeleteArgs>(args: SelectSubset<T, PaymentConsentDeleteArgs<ExtArgs>>): Prisma__PaymentConsentClient<$Result.GetResult<Prisma.$PaymentConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentConsent.
     * @param {PaymentConsentUpdateArgs} args - Arguments to update one PaymentConsent.
     * @example
     * // Update one PaymentConsent
     * const paymentConsent = await prisma.paymentConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentConsentUpdateArgs>(args: SelectSubset<T, PaymentConsentUpdateArgs<ExtArgs>>): Prisma__PaymentConsentClient<$Result.GetResult<Prisma.$PaymentConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentConsents.
     * @param {PaymentConsentDeleteManyArgs} args - Arguments to filter PaymentConsents to delete.
     * @example
     * // Delete a few PaymentConsents
     * const { count } = await prisma.paymentConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentConsentDeleteManyArgs>(args?: SelectSubset<T, PaymentConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentConsents
     * const paymentConsent = await prisma.paymentConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentConsentUpdateManyArgs>(args: SelectSubset<T, PaymentConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentConsents and returns the data updated in the database.
     * @param {PaymentConsentUpdateManyAndReturnArgs} args - Arguments to update many PaymentConsents.
     * @example
     * // Update many PaymentConsents
     * const paymentConsent = await prisma.paymentConsent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentConsents and only return the `id`
     * const paymentConsentWithIdOnly = await prisma.paymentConsent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentConsent.
     * @param {PaymentConsentUpsertArgs} args - Arguments to update or create a PaymentConsent.
     * @example
     * // Update or create a PaymentConsent
     * const paymentConsent = await prisma.paymentConsent.upsert({
     *   create: {
     *     // ... data to create a PaymentConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentConsent we want to update
     *   }
     * })
     */
    upsert<T extends PaymentConsentUpsertArgs>(args: SelectSubset<T, PaymentConsentUpsertArgs<ExtArgs>>): Prisma__PaymentConsentClient<$Result.GetResult<Prisma.$PaymentConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConsentCountArgs} args - Arguments to filter PaymentConsents to count.
     * @example
     * // Count the number of PaymentConsents
     * const count = await prisma.paymentConsent.count({
     *   where: {
     *     // ... the filter for the PaymentConsents we want to count
     *   }
     * })
    **/
    count<T extends PaymentConsentCountArgs>(
      args?: Subset<T, PaymentConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentConsentAggregateArgs>(args: Subset<T, PaymentConsentAggregateArgs>): Prisma.PrismaPromise<GetPaymentConsentAggregateType<T>>

    /**
     * Group by PaymentConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentConsentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentConsent model
   */
  readonly fields: PaymentConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentConsent model
   */
  interface PaymentConsentFieldRefs {
    readonly id: FieldRef<"PaymentConsent", 'String'>
    readonly tenantId: FieldRef<"PaymentConsent", 'String'>
    readonly consentId: FieldRef<"PaymentConsent", 'String'>
    readonly status: FieldRef<"PaymentConsent", 'String'>
    readonly createdAt: FieldRef<"PaymentConsent", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentConsent findUnique
   */
  export type PaymentConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
    /**
     * Filter, which PaymentConsent to fetch.
     */
    where: PaymentConsentWhereUniqueInput
  }

  /**
   * PaymentConsent findUniqueOrThrow
   */
  export type PaymentConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
    /**
     * Filter, which PaymentConsent to fetch.
     */
    where: PaymentConsentWhereUniqueInput
  }

  /**
   * PaymentConsent findFirst
   */
  export type PaymentConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
    /**
     * Filter, which PaymentConsent to fetch.
     */
    where?: PaymentConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConsents to fetch.
     */
    orderBy?: PaymentConsentOrderByWithRelationInput | PaymentConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentConsents.
     */
    cursor?: PaymentConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentConsents.
     */
    distinct?: PaymentConsentScalarFieldEnum | PaymentConsentScalarFieldEnum[]
  }

  /**
   * PaymentConsent findFirstOrThrow
   */
  export type PaymentConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
    /**
     * Filter, which PaymentConsent to fetch.
     */
    where?: PaymentConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConsents to fetch.
     */
    orderBy?: PaymentConsentOrderByWithRelationInput | PaymentConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentConsents.
     */
    cursor?: PaymentConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentConsents.
     */
    distinct?: PaymentConsentScalarFieldEnum | PaymentConsentScalarFieldEnum[]
  }

  /**
   * PaymentConsent findMany
   */
  export type PaymentConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
    /**
     * Filter, which PaymentConsents to fetch.
     */
    where?: PaymentConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConsents to fetch.
     */
    orderBy?: PaymentConsentOrderByWithRelationInput | PaymentConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentConsents.
     */
    cursor?: PaymentConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConsents.
     */
    skip?: number
    distinct?: PaymentConsentScalarFieldEnum | PaymentConsentScalarFieldEnum[]
  }

  /**
   * PaymentConsent create
   */
  export type PaymentConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentConsent.
     */
    data: XOR<PaymentConsentCreateInput, PaymentConsentUncheckedCreateInput>
  }

  /**
   * PaymentConsent createMany
   */
  export type PaymentConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentConsents.
     */
    data: PaymentConsentCreateManyInput | PaymentConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentConsent createManyAndReturn
   */
  export type PaymentConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentConsents.
     */
    data: PaymentConsentCreateManyInput | PaymentConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentConsent update
   */
  export type PaymentConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentConsent.
     */
    data: XOR<PaymentConsentUpdateInput, PaymentConsentUncheckedUpdateInput>
    /**
     * Choose, which PaymentConsent to update.
     */
    where: PaymentConsentWhereUniqueInput
  }

  /**
   * PaymentConsent updateMany
   */
  export type PaymentConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentConsents.
     */
    data: XOR<PaymentConsentUpdateManyMutationInput, PaymentConsentUncheckedUpdateManyInput>
    /**
     * Filter which PaymentConsents to update
     */
    where?: PaymentConsentWhereInput
    /**
     * Limit how many PaymentConsents to update.
     */
    limit?: number
  }

  /**
   * PaymentConsent updateManyAndReturn
   */
  export type PaymentConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
    /**
     * The data used to update PaymentConsents.
     */
    data: XOR<PaymentConsentUpdateManyMutationInput, PaymentConsentUncheckedUpdateManyInput>
    /**
     * Filter which PaymentConsents to update
     */
    where?: PaymentConsentWhereInput
    /**
     * Limit how many PaymentConsents to update.
     */
    limit?: number
  }

  /**
   * PaymentConsent upsert
   */
  export type PaymentConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentConsent to update in case it exists.
     */
    where: PaymentConsentWhereUniqueInput
    /**
     * In case the PaymentConsent found by the `where` argument doesn't exist, create a new PaymentConsent with this data.
     */
    create: XOR<PaymentConsentCreateInput, PaymentConsentUncheckedCreateInput>
    /**
     * In case the PaymentConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentConsentUpdateInput, PaymentConsentUncheckedUpdateInput>
  }

  /**
   * PaymentConsent delete
   */
  export type PaymentConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
    /**
     * Filter which PaymentConsent to delete.
     */
    where: PaymentConsentWhereUniqueInput
  }

  /**
   * PaymentConsent deleteMany
   */
  export type PaymentConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentConsents to delete
     */
    where?: PaymentConsentWhereInput
    /**
     * Limit how many PaymentConsents to delete.
     */
    limit?: number
  }

  /**
   * PaymentConsent without action
   */
  export type PaymentConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConsent
     */
    select?: PaymentConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConsent
     */
    omit?: PaymentConsentOmit<ExtArgs> | null
  }


  /**
   * Model OAuthState
   */

  export type AggregateOAuthState = {
    _count: OAuthStateCountAggregateOutputType | null
    _min: OAuthStateMinAggregateOutputType | null
    _max: OAuthStateMaxAggregateOutputType | null
  }

  export type OAuthStateMinAggregateOutputType = {
    id: string | null
    state: string | null
    nonce: string | null
    codeVerifier: string | null
    tenantId: string | null
    createdAt: Date | null
    usedAt: Date | null
  }

  export type OAuthStateMaxAggregateOutputType = {
    id: string | null
    state: string | null
    nonce: string | null
    codeVerifier: string | null
    tenantId: string | null
    createdAt: Date | null
    usedAt: Date | null
  }

  export type OAuthStateCountAggregateOutputType = {
    id: number
    state: number
    nonce: number
    codeVerifier: number
    tenantId: number
    createdAt: number
    usedAt: number
    _all: number
  }


  export type OAuthStateMinAggregateInputType = {
    id?: true
    state?: true
    nonce?: true
    codeVerifier?: true
    tenantId?: true
    createdAt?: true
    usedAt?: true
  }

  export type OAuthStateMaxAggregateInputType = {
    id?: true
    state?: true
    nonce?: true
    codeVerifier?: true
    tenantId?: true
    createdAt?: true
    usedAt?: true
  }

  export type OAuthStateCountAggregateInputType = {
    id?: true
    state?: true
    nonce?: true
    codeVerifier?: true
    tenantId?: true
    createdAt?: true
    usedAt?: true
    _all?: true
  }

  export type OAuthStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthState to aggregate.
     */
    where?: OAuthStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStates to fetch.
     */
    orderBy?: OAuthStateOrderByWithRelationInput | OAuthStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthStates
    **/
    _count?: true | OAuthStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthStateMaxAggregateInputType
  }

  export type GetOAuthStateAggregateType<T extends OAuthStateAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthState[P]>
      : GetScalarType<T[P], AggregateOAuthState[P]>
  }




  export type OAuthStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthStateWhereInput
    orderBy?: OAuthStateOrderByWithAggregationInput | OAuthStateOrderByWithAggregationInput[]
    by: OAuthStateScalarFieldEnum[] | OAuthStateScalarFieldEnum
    having?: OAuthStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthStateCountAggregateInputType | true
    _min?: OAuthStateMinAggregateInputType
    _max?: OAuthStateMaxAggregateInputType
  }

  export type OAuthStateGroupByOutputType = {
    id: string
    state: string
    nonce: string | null
    codeVerifier: string | null
    tenantId: string | null
    createdAt: Date
    usedAt: Date | null
    _count: OAuthStateCountAggregateOutputType | null
    _min: OAuthStateMinAggregateOutputType | null
    _max: OAuthStateMaxAggregateOutputType | null
  }

  type GetOAuthStateGroupByPayload<T extends OAuthStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthStateGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthStateGroupByOutputType[P]>
        }
      >
    >


  export type OAuthStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    state?: boolean
    nonce?: boolean
    codeVerifier?: boolean
    tenantId?: boolean
    createdAt?: boolean
    usedAt?: boolean
  }, ExtArgs["result"]["oAuthState"]>

  export type OAuthStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    state?: boolean
    nonce?: boolean
    codeVerifier?: boolean
    tenantId?: boolean
    createdAt?: boolean
    usedAt?: boolean
  }, ExtArgs["result"]["oAuthState"]>

  export type OAuthStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    state?: boolean
    nonce?: boolean
    codeVerifier?: boolean
    tenantId?: boolean
    createdAt?: boolean
    usedAt?: boolean
  }, ExtArgs["result"]["oAuthState"]>

  export type OAuthStateSelectScalar = {
    id?: boolean
    state?: boolean
    nonce?: boolean
    codeVerifier?: boolean
    tenantId?: boolean
    createdAt?: boolean
    usedAt?: boolean
  }

  export type OAuthStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "state" | "nonce" | "codeVerifier" | "tenantId" | "createdAt" | "usedAt", ExtArgs["result"]["oAuthState"]>

  export type $OAuthStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthState"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      state: string
      nonce: string | null
      codeVerifier: string | null
      tenantId: string | null
      createdAt: Date
      usedAt: Date | null
    }, ExtArgs["result"]["oAuthState"]>
    composites: {}
  }

  type OAuthStateGetPayload<S extends boolean | null | undefined | OAuthStateDefaultArgs> = $Result.GetResult<Prisma.$OAuthStatePayload, S>

  type OAuthStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OAuthStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OAuthStateCountAggregateInputType | true
    }

  export interface OAuthStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthState'], meta: { name: 'OAuthState' } }
    /**
     * Find zero or one OAuthState that matches the filter.
     * @param {OAuthStateFindUniqueArgs} args - Arguments to find a OAuthState
     * @example
     * // Get one OAuthState
     * const oAuthState = await prisma.oAuthState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthStateFindUniqueArgs>(args: SelectSubset<T, OAuthStateFindUniqueArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OAuthState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OAuthStateFindUniqueOrThrowArgs} args - Arguments to find a OAuthState
     * @example
     * // Get one OAuthState
     * const oAuthState = await prisma.oAuthState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthStateFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OAuthState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateFindFirstArgs} args - Arguments to find a OAuthState
     * @example
     * // Get one OAuthState
     * const oAuthState = await prisma.oAuthState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthStateFindFirstArgs>(args?: SelectSubset<T, OAuthStateFindFirstArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OAuthState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateFindFirstOrThrowArgs} args - Arguments to find a OAuthState
     * @example
     * // Get one OAuthState
     * const oAuthState = await prisma.oAuthState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthStateFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OAuthStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthStates
     * const oAuthStates = await prisma.oAuthState.findMany()
     * 
     * // Get first 10 OAuthStates
     * const oAuthStates = await prisma.oAuthState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthStateWithIdOnly = await prisma.oAuthState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OAuthStateFindManyArgs>(args?: SelectSubset<T, OAuthStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OAuthState.
     * @param {OAuthStateCreateArgs} args - Arguments to create a OAuthState.
     * @example
     * // Create one OAuthState
     * const OAuthState = await prisma.oAuthState.create({
     *   data: {
     *     // ... data to create a OAuthState
     *   }
     * })
     * 
     */
    create<T extends OAuthStateCreateArgs>(args: SelectSubset<T, OAuthStateCreateArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OAuthStates.
     * @param {OAuthStateCreateManyArgs} args - Arguments to create many OAuthStates.
     * @example
     * // Create many OAuthStates
     * const oAuthState = await prisma.oAuthState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthStateCreateManyArgs>(args?: SelectSubset<T, OAuthStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OAuthStates and returns the data saved in the database.
     * @param {OAuthStateCreateManyAndReturnArgs} args - Arguments to create many OAuthStates.
     * @example
     * // Create many OAuthStates
     * const oAuthState = await prisma.oAuthState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OAuthStates and only return the `id`
     * const oAuthStateWithIdOnly = await prisma.oAuthState.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OAuthStateCreateManyAndReturnArgs>(args?: SelectSubset<T, OAuthStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OAuthState.
     * @param {OAuthStateDeleteArgs} args - Arguments to delete one OAuthState.
     * @example
     * // Delete one OAuthState
     * const OAuthState = await prisma.oAuthState.delete({
     *   where: {
     *     // ... filter to delete one OAuthState
     *   }
     * })
     * 
     */
    delete<T extends OAuthStateDeleteArgs>(args: SelectSubset<T, OAuthStateDeleteArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OAuthState.
     * @param {OAuthStateUpdateArgs} args - Arguments to update one OAuthState.
     * @example
     * // Update one OAuthState
     * const oAuthState = await prisma.oAuthState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthStateUpdateArgs>(args: SelectSubset<T, OAuthStateUpdateArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OAuthStates.
     * @param {OAuthStateDeleteManyArgs} args - Arguments to filter OAuthStates to delete.
     * @example
     * // Delete a few OAuthStates
     * const { count } = await prisma.oAuthState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthStateDeleteManyArgs>(args?: SelectSubset<T, OAuthStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthStates
     * const oAuthState = await prisma.oAuthState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthStateUpdateManyArgs>(args: SelectSubset<T, OAuthStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthStates and returns the data updated in the database.
     * @param {OAuthStateUpdateManyAndReturnArgs} args - Arguments to update many OAuthStates.
     * @example
     * // Update many OAuthStates
     * const oAuthState = await prisma.oAuthState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OAuthStates and only return the `id`
     * const oAuthStateWithIdOnly = await prisma.oAuthState.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OAuthStateUpdateManyAndReturnArgs>(args: SelectSubset<T, OAuthStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OAuthState.
     * @param {OAuthStateUpsertArgs} args - Arguments to update or create a OAuthState.
     * @example
     * // Update or create a OAuthState
     * const oAuthState = await prisma.oAuthState.upsert({
     *   create: {
     *     // ... data to create a OAuthState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthState we want to update
     *   }
     * })
     */
    upsert<T extends OAuthStateUpsertArgs>(args: SelectSubset<T, OAuthStateUpsertArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OAuthStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateCountArgs} args - Arguments to filter OAuthStates to count.
     * @example
     * // Count the number of OAuthStates
     * const count = await prisma.oAuthState.count({
     *   where: {
     *     // ... the filter for the OAuthStates we want to count
     *   }
     * })
    **/
    count<T extends OAuthStateCountArgs>(
      args?: Subset<T, OAuthStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthStateAggregateArgs>(args: Subset<T, OAuthStateAggregateArgs>): Prisma.PrismaPromise<GetOAuthStateAggregateType<T>>

    /**
     * Group by OAuthState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthStateGroupByArgs['orderBy'] }
        : { orderBy?: OAuthStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthState model
   */
  readonly fields: OAuthStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthState model
   */
  interface OAuthStateFieldRefs {
    readonly id: FieldRef<"OAuthState", 'String'>
    readonly state: FieldRef<"OAuthState", 'String'>
    readonly nonce: FieldRef<"OAuthState", 'String'>
    readonly codeVerifier: FieldRef<"OAuthState", 'String'>
    readonly tenantId: FieldRef<"OAuthState", 'String'>
    readonly createdAt: FieldRef<"OAuthState", 'DateTime'>
    readonly usedAt: FieldRef<"OAuthState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OAuthState findUnique
   */
  export type OAuthStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter, which OAuthState to fetch.
     */
    where: OAuthStateWhereUniqueInput
  }

  /**
   * OAuthState findUniqueOrThrow
   */
  export type OAuthStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter, which OAuthState to fetch.
     */
    where: OAuthStateWhereUniqueInput
  }

  /**
   * OAuthState findFirst
   */
  export type OAuthStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter, which OAuthState to fetch.
     */
    where?: OAuthStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStates to fetch.
     */
    orderBy?: OAuthStateOrderByWithRelationInput | OAuthStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthStates.
     */
    cursor?: OAuthStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthStates.
     */
    distinct?: OAuthStateScalarFieldEnum | OAuthStateScalarFieldEnum[]
  }

  /**
   * OAuthState findFirstOrThrow
   */
  export type OAuthStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter, which OAuthState to fetch.
     */
    where?: OAuthStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStates to fetch.
     */
    orderBy?: OAuthStateOrderByWithRelationInput | OAuthStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthStates.
     */
    cursor?: OAuthStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthStates.
     */
    distinct?: OAuthStateScalarFieldEnum | OAuthStateScalarFieldEnum[]
  }

  /**
   * OAuthState findMany
   */
  export type OAuthStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter, which OAuthStates to fetch.
     */
    where?: OAuthStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStates to fetch.
     */
    orderBy?: OAuthStateOrderByWithRelationInput | OAuthStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthStates.
     */
    cursor?: OAuthStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStates.
     */
    skip?: number
    distinct?: OAuthStateScalarFieldEnum | OAuthStateScalarFieldEnum[]
  }

  /**
   * OAuthState create
   */
  export type OAuthStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * The data needed to create a OAuthState.
     */
    data: XOR<OAuthStateCreateInput, OAuthStateUncheckedCreateInput>
  }

  /**
   * OAuthState createMany
   */
  export type OAuthStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthStates.
     */
    data: OAuthStateCreateManyInput | OAuthStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthState createManyAndReturn
   */
  export type OAuthStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * The data used to create many OAuthStates.
     */
    data: OAuthStateCreateManyInput | OAuthStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthState update
   */
  export type OAuthStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * The data needed to update a OAuthState.
     */
    data: XOR<OAuthStateUpdateInput, OAuthStateUncheckedUpdateInput>
    /**
     * Choose, which OAuthState to update.
     */
    where: OAuthStateWhereUniqueInput
  }

  /**
   * OAuthState updateMany
   */
  export type OAuthStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthStates.
     */
    data: XOR<OAuthStateUpdateManyMutationInput, OAuthStateUncheckedUpdateManyInput>
    /**
     * Filter which OAuthStates to update
     */
    where?: OAuthStateWhereInput
    /**
     * Limit how many OAuthStates to update.
     */
    limit?: number
  }

  /**
   * OAuthState updateManyAndReturn
   */
  export type OAuthStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * The data used to update OAuthStates.
     */
    data: XOR<OAuthStateUpdateManyMutationInput, OAuthStateUncheckedUpdateManyInput>
    /**
     * Filter which OAuthStates to update
     */
    where?: OAuthStateWhereInput
    /**
     * Limit how many OAuthStates to update.
     */
    limit?: number
  }

  /**
   * OAuthState upsert
   */
  export type OAuthStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * The filter to search for the OAuthState to update in case it exists.
     */
    where: OAuthStateWhereUniqueInput
    /**
     * In case the OAuthState found by the `where` argument doesn't exist, create a new OAuthState with this data.
     */
    create: XOR<OAuthStateCreateInput, OAuthStateUncheckedCreateInput>
    /**
     * In case the OAuthState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthStateUpdateInput, OAuthStateUncheckedUpdateInput>
  }

  /**
   * OAuthState delete
   */
  export type OAuthStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter which OAuthState to delete.
     */
    where: OAuthStateWhereUniqueInput
  }

  /**
   * OAuthState deleteMany
   */
  export type OAuthStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthStates to delete
     */
    where?: OAuthStateWhereInput
    /**
     * Limit how many OAuthStates to delete.
     */
    limit?: number
  }

  /**
   * OAuthState without action
   */
  export type OAuthStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
  }


  /**
   * Model OAuthStateMeta
   */

  export type AggregateOAuthStateMeta = {
    _count: OAuthStateMetaCountAggregateOutputType | null
    _avg: OAuthStateMetaAvgAggregateOutputType | null
    _sum: OAuthStateMetaSumAggregateOutputType | null
    _min: OAuthStateMetaMinAggregateOutputType | null
    _max: OAuthStateMetaMaxAggregateOutputType | null
  }

  export type OAuthStateMetaAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type OAuthStateMetaSumAggregateOutputType = {
    amountCents: number | null
  }

  export type OAuthStateMetaMinAggregateOutputType = {
    state: string | null
    organisationId: string | null
    authorisationServerId: string | null
    createdAt: Date | null
    productId: string | null
    amountCents: number | null
    currency: string | null
    orderRef: string | null
  }

  export type OAuthStateMetaMaxAggregateOutputType = {
    state: string | null
    organisationId: string | null
    authorisationServerId: string | null
    createdAt: Date | null
    productId: string | null
    amountCents: number | null
    currency: string | null
    orderRef: string | null
  }

  export type OAuthStateMetaCountAggregateOutputType = {
    state: number
    organisationId: number
    authorisationServerId: number
    createdAt: number
    productId: number
    amountCents: number
    currency: number
    orderRef: number
    _all: number
  }


  export type OAuthStateMetaAvgAggregateInputType = {
    amountCents?: true
  }

  export type OAuthStateMetaSumAggregateInputType = {
    amountCents?: true
  }

  export type OAuthStateMetaMinAggregateInputType = {
    state?: true
    organisationId?: true
    authorisationServerId?: true
    createdAt?: true
    productId?: true
    amountCents?: true
    currency?: true
    orderRef?: true
  }

  export type OAuthStateMetaMaxAggregateInputType = {
    state?: true
    organisationId?: true
    authorisationServerId?: true
    createdAt?: true
    productId?: true
    amountCents?: true
    currency?: true
    orderRef?: true
  }

  export type OAuthStateMetaCountAggregateInputType = {
    state?: true
    organisationId?: true
    authorisationServerId?: true
    createdAt?: true
    productId?: true
    amountCents?: true
    currency?: true
    orderRef?: true
    _all?: true
  }

  export type OAuthStateMetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthStateMeta to aggregate.
     */
    where?: OAuthStateMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStateMetas to fetch.
     */
    orderBy?: OAuthStateMetaOrderByWithRelationInput | OAuthStateMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthStateMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStateMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStateMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthStateMetas
    **/
    _count?: true | OAuthStateMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OAuthStateMetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OAuthStateMetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthStateMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthStateMetaMaxAggregateInputType
  }

  export type GetOAuthStateMetaAggregateType<T extends OAuthStateMetaAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthStateMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthStateMeta[P]>
      : GetScalarType<T[P], AggregateOAuthStateMeta[P]>
  }




  export type OAuthStateMetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthStateMetaWhereInput
    orderBy?: OAuthStateMetaOrderByWithAggregationInput | OAuthStateMetaOrderByWithAggregationInput[]
    by: OAuthStateMetaScalarFieldEnum[] | OAuthStateMetaScalarFieldEnum
    having?: OAuthStateMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthStateMetaCountAggregateInputType | true
    _avg?: OAuthStateMetaAvgAggregateInputType
    _sum?: OAuthStateMetaSumAggregateInputType
    _min?: OAuthStateMetaMinAggregateInputType
    _max?: OAuthStateMetaMaxAggregateInputType
  }

  export type OAuthStateMetaGroupByOutputType = {
    state: string
    organisationId: string | null
    authorisationServerId: string | null
    createdAt: Date
    productId: string | null
    amountCents: number | null
    currency: string | null
    orderRef: string | null
    _count: OAuthStateMetaCountAggregateOutputType | null
    _avg: OAuthStateMetaAvgAggregateOutputType | null
    _sum: OAuthStateMetaSumAggregateOutputType | null
    _min: OAuthStateMetaMinAggregateOutputType | null
    _max: OAuthStateMetaMaxAggregateOutputType | null
  }

  type GetOAuthStateMetaGroupByPayload<T extends OAuthStateMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthStateMetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthStateMetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthStateMetaGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthStateMetaGroupByOutputType[P]>
        }
      >
    >


  export type OAuthStateMetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    state?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    createdAt?: boolean
    productId?: boolean
    amountCents?: boolean
    currency?: boolean
    orderRef?: boolean
  }, ExtArgs["result"]["oAuthStateMeta"]>

  export type OAuthStateMetaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    state?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    createdAt?: boolean
    productId?: boolean
    amountCents?: boolean
    currency?: boolean
    orderRef?: boolean
  }, ExtArgs["result"]["oAuthStateMeta"]>

  export type OAuthStateMetaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    state?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    createdAt?: boolean
    productId?: boolean
    amountCents?: boolean
    currency?: boolean
    orderRef?: boolean
  }, ExtArgs["result"]["oAuthStateMeta"]>

  export type OAuthStateMetaSelectScalar = {
    state?: boolean
    organisationId?: boolean
    authorisationServerId?: boolean
    createdAt?: boolean
    productId?: boolean
    amountCents?: boolean
    currency?: boolean
    orderRef?: boolean
  }

  export type OAuthStateMetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"state" | "organisationId" | "authorisationServerId" | "createdAt" | "productId" | "amountCents" | "currency" | "orderRef", ExtArgs["result"]["oAuthStateMeta"]>

  export type $OAuthStateMetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthStateMeta"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      state: string
      organisationId: string | null
      authorisationServerId: string | null
      createdAt: Date
      productId: string | null
      amountCents: number | null
      currency: string | null
      orderRef: string | null
    }, ExtArgs["result"]["oAuthStateMeta"]>
    composites: {}
  }

  type OAuthStateMetaGetPayload<S extends boolean | null | undefined | OAuthStateMetaDefaultArgs> = $Result.GetResult<Prisma.$OAuthStateMetaPayload, S>

  type OAuthStateMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OAuthStateMetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OAuthStateMetaCountAggregateInputType | true
    }

  export interface OAuthStateMetaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthStateMeta'], meta: { name: 'OAuthStateMeta' } }
    /**
     * Find zero or one OAuthStateMeta that matches the filter.
     * @param {OAuthStateMetaFindUniqueArgs} args - Arguments to find a OAuthStateMeta
     * @example
     * // Get one OAuthStateMeta
     * const oAuthStateMeta = await prisma.oAuthStateMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthStateMetaFindUniqueArgs>(args: SelectSubset<T, OAuthStateMetaFindUniqueArgs<ExtArgs>>): Prisma__OAuthStateMetaClient<$Result.GetResult<Prisma.$OAuthStateMetaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OAuthStateMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OAuthStateMetaFindUniqueOrThrowArgs} args - Arguments to find a OAuthStateMeta
     * @example
     * // Get one OAuthStateMeta
     * const oAuthStateMeta = await prisma.oAuthStateMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthStateMetaFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthStateMetaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthStateMetaClient<$Result.GetResult<Prisma.$OAuthStateMetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OAuthStateMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateMetaFindFirstArgs} args - Arguments to find a OAuthStateMeta
     * @example
     * // Get one OAuthStateMeta
     * const oAuthStateMeta = await prisma.oAuthStateMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthStateMetaFindFirstArgs>(args?: SelectSubset<T, OAuthStateMetaFindFirstArgs<ExtArgs>>): Prisma__OAuthStateMetaClient<$Result.GetResult<Prisma.$OAuthStateMetaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OAuthStateMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateMetaFindFirstOrThrowArgs} args - Arguments to find a OAuthStateMeta
     * @example
     * // Get one OAuthStateMeta
     * const oAuthStateMeta = await prisma.oAuthStateMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthStateMetaFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthStateMetaFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthStateMetaClient<$Result.GetResult<Prisma.$OAuthStateMetaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OAuthStateMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthStateMetas
     * const oAuthStateMetas = await prisma.oAuthStateMeta.findMany()
     * 
     * // Get first 10 OAuthStateMetas
     * const oAuthStateMetas = await prisma.oAuthStateMeta.findMany({ take: 10 })
     * 
     * // Only select the `state`
     * const oAuthStateMetaWithStateOnly = await prisma.oAuthStateMeta.findMany({ select: { state: true } })
     * 
     */
    findMany<T extends OAuthStateMetaFindManyArgs>(args?: SelectSubset<T, OAuthStateMetaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthStateMetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OAuthStateMeta.
     * @param {OAuthStateMetaCreateArgs} args - Arguments to create a OAuthStateMeta.
     * @example
     * // Create one OAuthStateMeta
     * const OAuthStateMeta = await prisma.oAuthStateMeta.create({
     *   data: {
     *     // ... data to create a OAuthStateMeta
     *   }
     * })
     * 
     */
    create<T extends OAuthStateMetaCreateArgs>(args: SelectSubset<T, OAuthStateMetaCreateArgs<ExtArgs>>): Prisma__OAuthStateMetaClient<$Result.GetResult<Prisma.$OAuthStateMetaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OAuthStateMetas.
     * @param {OAuthStateMetaCreateManyArgs} args - Arguments to create many OAuthStateMetas.
     * @example
     * // Create many OAuthStateMetas
     * const oAuthStateMeta = await prisma.oAuthStateMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthStateMetaCreateManyArgs>(args?: SelectSubset<T, OAuthStateMetaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OAuthStateMetas and returns the data saved in the database.
     * @param {OAuthStateMetaCreateManyAndReturnArgs} args - Arguments to create many OAuthStateMetas.
     * @example
     * // Create many OAuthStateMetas
     * const oAuthStateMeta = await prisma.oAuthStateMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OAuthStateMetas and only return the `state`
     * const oAuthStateMetaWithStateOnly = await prisma.oAuthStateMeta.createManyAndReturn({
     *   select: { state: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OAuthStateMetaCreateManyAndReturnArgs>(args?: SelectSubset<T, OAuthStateMetaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthStateMetaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OAuthStateMeta.
     * @param {OAuthStateMetaDeleteArgs} args - Arguments to delete one OAuthStateMeta.
     * @example
     * // Delete one OAuthStateMeta
     * const OAuthStateMeta = await prisma.oAuthStateMeta.delete({
     *   where: {
     *     // ... filter to delete one OAuthStateMeta
     *   }
     * })
     * 
     */
    delete<T extends OAuthStateMetaDeleteArgs>(args: SelectSubset<T, OAuthStateMetaDeleteArgs<ExtArgs>>): Prisma__OAuthStateMetaClient<$Result.GetResult<Prisma.$OAuthStateMetaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OAuthStateMeta.
     * @param {OAuthStateMetaUpdateArgs} args - Arguments to update one OAuthStateMeta.
     * @example
     * // Update one OAuthStateMeta
     * const oAuthStateMeta = await prisma.oAuthStateMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthStateMetaUpdateArgs>(args: SelectSubset<T, OAuthStateMetaUpdateArgs<ExtArgs>>): Prisma__OAuthStateMetaClient<$Result.GetResult<Prisma.$OAuthStateMetaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OAuthStateMetas.
     * @param {OAuthStateMetaDeleteManyArgs} args - Arguments to filter OAuthStateMetas to delete.
     * @example
     * // Delete a few OAuthStateMetas
     * const { count } = await prisma.oAuthStateMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthStateMetaDeleteManyArgs>(args?: SelectSubset<T, OAuthStateMetaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthStateMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthStateMetas
     * const oAuthStateMeta = await prisma.oAuthStateMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthStateMetaUpdateManyArgs>(args: SelectSubset<T, OAuthStateMetaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthStateMetas and returns the data updated in the database.
     * @param {OAuthStateMetaUpdateManyAndReturnArgs} args - Arguments to update many OAuthStateMetas.
     * @example
     * // Update many OAuthStateMetas
     * const oAuthStateMeta = await prisma.oAuthStateMeta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OAuthStateMetas and only return the `state`
     * const oAuthStateMetaWithStateOnly = await prisma.oAuthStateMeta.updateManyAndReturn({
     *   select: { state: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OAuthStateMetaUpdateManyAndReturnArgs>(args: SelectSubset<T, OAuthStateMetaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthStateMetaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OAuthStateMeta.
     * @param {OAuthStateMetaUpsertArgs} args - Arguments to update or create a OAuthStateMeta.
     * @example
     * // Update or create a OAuthStateMeta
     * const oAuthStateMeta = await prisma.oAuthStateMeta.upsert({
     *   create: {
     *     // ... data to create a OAuthStateMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthStateMeta we want to update
     *   }
     * })
     */
    upsert<T extends OAuthStateMetaUpsertArgs>(args: SelectSubset<T, OAuthStateMetaUpsertArgs<ExtArgs>>): Prisma__OAuthStateMetaClient<$Result.GetResult<Prisma.$OAuthStateMetaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OAuthStateMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateMetaCountArgs} args - Arguments to filter OAuthStateMetas to count.
     * @example
     * // Count the number of OAuthStateMetas
     * const count = await prisma.oAuthStateMeta.count({
     *   where: {
     *     // ... the filter for the OAuthStateMetas we want to count
     *   }
     * })
    **/
    count<T extends OAuthStateMetaCountArgs>(
      args?: Subset<T, OAuthStateMetaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthStateMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthStateMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthStateMetaAggregateArgs>(args: Subset<T, OAuthStateMetaAggregateArgs>): Prisma.PrismaPromise<GetOAuthStateMetaAggregateType<T>>

    /**
     * Group by OAuthStateMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthStateMetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthStateMetaGroupByArgs['orderBy'] }
        : { orderBy?: OAuthStateMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthStateMetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthStateMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthStateMeta model
   */
  readonly fields: OAuthStateMetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthStateMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthStateMetaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthStateMeta model
   */
  interface OAuthStateMetaFieldRefs {
    readonly state: FieldRef<"OAuthStateMeta", 'String'>
    readonly organisationId: FieldRef<"OAuthStateMeta", 'String'>
    readonly authorisationServerId: FieldRef<"OAuthStateMeta", 'String'>
    readonly createdAt: FieldRef<"OAuthStateMeta", 'DateTime'>
    readonly productId: FieldRef<"OAuthStateMeta", 'String'>
    readonly amountCents: FieldRef<"OAuthStateMeta", 'Int'>
    readonly currency: FieldRef<"OAuthStateMeta", 'String'>
    readonly orderRef: FieldRef<"OAuthStateMeta", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OAuthStateMeta findUnique
   */
  export type OAuthStateMetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
    /**
     * Filter, which OAuthStateMeta to fetch.
     */
    where: OAuthStateMetaWhereUniqueInput
  }

  /**
   * OAuthStateMeta findUniqueOrThrow
   */
  export type OAuthStateMetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
    /**
     * Filter, which OAuthStateMeta to fetch.
     */
    where: OAuthStateMetaWhereUniqueInput
  }

  /**
   * OAuthStateMeta findFirst
   */
  export type OAuthStateMetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
    /**
     * Filter, which OAuthStateMeta to fetch.
     */
    where?: OAuthStateMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStateMetas to fetch.
     */
    orderBy?: OAuthStateMetaOrderByWithRelationInput | OAuthStateMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthStateMetas.
     */
    cursor?: OAuthStateMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStateMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStateMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthStateMetas.
     */
    distinct?: OAuthStateMetaScalarFieldEnum | OAuthStateMetaScalarFieldEnum[]
  }

  /**
   * OAuthStateMeta findFirstOrThrow
   */
  export type OAuthStateMetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
    /**
     * Filter, which OAuthStateMeta to fetch.
     */
    where?: OAuthStateMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStateMetas to fetch.
     */
    orderBy?: OAuthStateMetaOrderByWithRelationInput | OAuthStateMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthStateMetas.
     */
    cursor?: OAuthStateMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStateMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStateMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthStateMetas.
     */
    distinct?: OAuthStateMetaScalarFieldEnum | OAuthStateMetaScalarFieldEnum[]
  }

  /**
   * OAuthStateMeta findMany
   */
  export type OAuthStateMetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
    /**
     * Filter, which OAuthStateMetas to fetch.
     */
    where?: OAuthStateMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStateMetas to fetch.
     */
    orderBy?: OAuthStateMetaOrderByWithRelationInput | OAuthStateMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthStateMetas.
     */
    cursor?: OAuthStateMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStateMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStateMetas.
     */
    skip?: number
    distinct?: OAuthStateMetaScalarFieldEnum | OAuthStateMetaScalarFieldEnum[]
  }

  /**
   * OAuthStateMeta create
   */
  export type OAuthStateMetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
    /**
     * The data needed to create a OAuthStateMeta.
     */
    data: XOR<OAuthStateMetaCreateInput, OAuthStateMetaUncheckedCreateInput>
  }

  /**
   * OAuthStateMeta createMany
   */
  export type OAuthStateMetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthStateMetas.
     */
    data: OAuthStateMetaCreateManyInput | OAuthStateMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthStateMeta createManyAndReturn
   */
  export type OAuthStateMetaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
    /**
     * The data used to create many OAuthStateMetas.
     */
    data: OAuthStateMetaCreateManyInput | OAuthStateMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthStateMeta update
   */
  export type OAuthStateMetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
    /**
     * The data needed to update a OAuthStateMeta.
     */
    data: XOR<OAuthStateMetaUpdateInput, OAuthStateMetaUncheckedUpdateInput>
    /**
     * Choose, which OAuthStateMeta to update.
     */
    where: OAuthStateMetaWhereUniqueInput
  }

  /**
   * OAuthStateMeta updateMany
   */
  export type OAuthStateMetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthStateMetas.
     */
    data: XOR<OAuthStateMetaUpdateManyMutationInput, OAuthStateMetaUncheckedUpdateManyInput>
    /**
     * Filter which OAuthStateMetas to update
     */
    where?: OAuthStateMetaWhereInput
    /**
     * Limit how many OAuthStateMetas to update.
     */
    limit?: number
  }

  /**
   * OAuthStateMeta updateManyAndReturn
   */
  export type OAuthStateMetaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
    /**
     * The data used to update OAuthStateMetas.
     */
    data: XOR<OAuthStateMetaUpdateManyMutationInput, OAuthStateMetaUncheckedUpdateManyInput>
    /**
     * Filter which OAuthStateMetas to update
     */
    where?: OAuthStateMetaWhereInput
    /**
     * Limit how many OAuthStateMetas to update.
     */
    limit?: number
  }

  /**
   * OAuthStateMeta upsert
   */
  export type OAuthStateMetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
    /**
     * The filter to search for the OAuthStateMeta to update in case it exists.
     */
    where: OAuthStateMetaWhereUniqueInput
    /**
     * In case the OAuthStateMeta found by the `where` argument doesn't exist, create a new OAuthStateMeta with this data.
     */
    create: XOR<OAuthStateMetaCreateInput, OAuthStateMetaUncheckedCreateInput>
    /**
     * In case the OAuthStateMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthStateMetaUpdateInput, OAuthStateMetaUncheckedUpdateInput>
  }

  /**
   * OAuthStateMeta delete
   */
  export type OAuthStateMetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
    /**
     * Filter which OAuthStateMeta to delete.
     */
    where: OAuthStateMetaWhereUniqueInput
  }

  /**
   * OAuthStateMeta deleteMany
   */
  export type OAuthStateMetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthStateMetas to delete
     */
    where?: OAuthStateMetaWhereInput
    /**
     * Limit how many OAuthStateMetas to delete.
     */
    limit?: number
  }

  /**
   * OAuthStateMeta without action
   */
  export type OAuthStateMetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthStateMeta
     */
    select?: OAuthStateMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthStateMeta
     */
    omit?: OAuthStateMetaOmit<ExtArgs> | null
  }


  /**
   * Model OAuthToken
   */

  export type AggregateOAuthToken = {
    _count: OAuthTokenCountAggregateOutputType | null
    _min: OAuthTokenMinAggregateOutputType | null
    _max: OAuthTokenMaxAggregateOutputType | null
  }

  export type OAuthTokenMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    accessToken: string | null
    refreshToken: string | null
    scope: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OAuthTokenMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    accessToken: string | null
    refreshToken: string | null
    scope: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OAuthTokenCountAggregateOutputType = {
    id: number
    tenantId: number
    provider: number
    accessToken: number
    refreshToken: number
    scope: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type OAuthTokenMinAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    scope?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OAuthTokenMaxAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    scope?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OAuthTokenCountAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    scope?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type OAuthTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthToken to aggregate.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthTokens
    **/
    _count?: true | OAuthTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthTokenMaxAggregateInputType
  }

  export type GetOAuthTokenAggregateType<T extends OAuthTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthToken[P]>
      : GetScalarType<T[P], AggregateOAuthToken[P]>
  }




  export type OAuthTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthTokenWhereInput
    orderBy?: OAuthTokenOrderByWithAggregationInput | OAuthTokenOrderByWithAggregationInput[]
    by: OAuthTokenScalarFieldEnum[] | OAuthTokenScalarFieldEnum
    having?: OAuthTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthTokenCountAggregateInputType | true
    _min?: OAuthTokenMinAggregateInputType
    _max?: OAuthTokenMaxAggregateInputType
  }

  export type OAuthTokenGroupByOutputType = {
    id: string
    tenantId: string | null
    provider: string
    accessToken: string
    refreshToken: string | null
    scope: string | null
    expiresAt: Date | null
    createdAt: Date
    _count: OAuthTokenCountAggregateOutputType | null
    _min: OAuthTokenMinAggregateOutputType | null
    _max: OAuthTokenMaxAggregateOutputType | null
  }

  type GetOAuthTokenGroupByPayload<T extends OAuthTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthTokenGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthTokenGroupByOutputType[P]>
        }
      >
    >


  export type OAuthTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scope?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["oAuthToken"]>

  export type OAuthTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scope?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["oAuthToken"]>

  export type OAuthTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scope?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["oAuthToken"]>

  export type OAuthTokenSelectScalar = {
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scope?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type OAuthTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "provider" | "accessToken" | "refreshToken" | "scope" | "expiresAt" | "createdAt", ExtArgs["result"]["oAuthToken"]>

  export type $OAuthTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      provider: string
      accessToken: string
      refreshToken: string | null
      scope: string | null
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["oAuthToken"]>
    composites: {}
  }

  type OAuthTokenGetPayload<S extends boolean | null | undefined | OAuthTokenDefaultArgs> = $Result.GetResult<Prisma.$OAuthTokenPayload, S>

  type OAuthTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OAuthTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OAuthTokenCountAggregateInputType | true
    }

  export interface OAuthTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthToken'], meta: { name: 'OAuthToken' } }
    /**
     * Find zero or one OAuthToken that matches the filter.
     * @param {OAuthTokenFindUniqueArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthTokenFindUniqueArgs>(args: SelectSubset<T, OAuthTokenFindUniqueArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OAuthToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OAuthTokenFindUniqueOrThrowArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OAuthToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenFindFirstArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthTokenFindFirstArgs>(args?: SelectSubset<T, OAuthTokenFindFirstArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OAuthToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenFindFirstOrThrowArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OAuthTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthTokens
     * const oAuthTokens = await prisma.oAuthToken.findMany()
     * 
     * // Get first 10 OAuthTokens
     * const oAuthTokens = await prisma.oAuthToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthTokenWithIdOnly = await prisma.oAuthToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OAuthTokenFindManyArgs>(args?: SelectSubset<T, OAuthTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OAuthToken.
     * @param {OAuthTokenCreateArgs} args - Arguments to create a OAuthToken.
     * @example
     * // Create one OAuthToken
     * const OAuthToken = await prisma.oAuthToken.create({
     *   data: {
     *     // ... data to create a OAuthToken
     *   }
     * })
     * 
     */
    create<T extends OAuthTokenCreateArgs>(args: SelectSubset<T, OAuthTokenCreateArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OAuthTokens.
     * @param {OAuthTokenCreateManyArgs} args - Arguments to create many OAuthTokens.
     * @example
     * // Create many OAuthTokens
     * const oAuthToken = await prisma.oAuthToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthTokenCreateManyArgs>(args?: SelectSubset<T, OAuthTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OAuthTokens and returns the data saved in the database.
     * @param {OAuthTokenCreateManyAndReturnArgs} args - Arguments to create many OAuthTokens.
     * @example
     * // Create many OAuthTokens
     * const oAuthToken = await prisma.oAuthToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OAuthTokens and only return the `id`
     * const oAuthTokenWithIdOnly = await prisma.oAuthToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OAuthTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, OAuthTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OAuthToken.
     * @param {OAuthTokenDeleteArgs} args - Arguments to delete one OAuthToken.
     * @example
     * // Delete one OAuthToken
     * const OAuthToken = await prisma.oAuthToken.delete({
     *   where: {
     *     // ... filter to delete one OAuthToken
     *   }
     * })
     * 
     */
    delete<T extends OAuthTokenDeleteArgs>(args: SelectSubset<T, OAuthTokenDeleteArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OAuthToken.
     * @param {OAuthTokenUpdateArgs} args - Arguments to update one OAuthToken.
     * @example
     * // Update one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthTokenUpdateArgs>(args: SelectSubset<T, OAuthTokenUpdateArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OAuthTokens.
     * @param {OAuthTokenDeleteManyArgs} args - Arguments to filter OAuthTokens to delete.
     * @example
     * // Delete a few OAuthTokens
     * const { count } = await prisma.oAuthToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthTokenDeleteManyArgs>(args?: SelectSubset<T, OAuthTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthTokens
     * const oAuthToken = await prisma.oAuthToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthTokenUpdateManyArgs>(args: SelectSubset<T, OAuthTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthTokens and returns the data updated in the database.
     * @param {OAuthTokenUpdateManyAndReturnArgs} args - Arguments to update many OAuthTokens.
     * @example
     * // Update many OAuthTokens
     * const oAuthToken = await prisma.oAuthToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OAuthTokens and only return the `id`
     * const oAuthTokenWithIdOnly = await prisma.oAuthToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OAuthTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, OAuthTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OAuthToken.
     * @param {OAuthTokenUpsertArgs} args - Arguments to update or create a OAuthToken.
     * @example
     * // Update or create a OAuthToken
     * const oAuthToken = await prisma.oAuthToken.upsert({
     *   create: {
     *     // ... data to create a OAuthToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthToken we want to update
     *   }
     * })
     */
    upsert<T extends OAuthTokenUpsertArgs>(args: SelectSubset<T, OAuthTokenUpsertArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OAuthTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenCountArgs} args - Arguments to filter OAuthTokens to count.
     * @example
     * // Count the number of OAuthTokens
     * const count = await prisma.oAuthToken.count({
     *   where: {
     *     // ... the filter for the OAuthTokens we want to count
     *   }
     * })
    **/
    count<T extends OAuthTokenCountArgs>(
      args?: Subset<T, OAuthTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthTokenAggregateArgs>(args: Subset<T, OAuthTokenAggregateArgs>): Prisma.PrismaPromise<GetOAuthTokenAggregateType<T>>

    /**
     * Group by OAuthToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthTokenGroupByArgs['orderBy'] }
        : { orderBy?: OAuthTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthToken model
   */
  readonly fields: OAuthTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthToken model
   */
  interface OAuthTokenFieldRefs {
    readonly id: FieldRef<"OAuthToken", 'String'>
    readonly tenantId: FieldRef<"OAuthToken", 'String'>
    readonly provider: FieldRef<"OAuthToken", 'String'>
    readonly accessToken: FieldRef<"OAuthToken", 'String'>
    readonly refreshToken: FieldRef<"OAuthToken", 'String'>
    readonly scope: FieldRef<"OAuthToken", 'String'>
    readonly expiresAt: FieldRef<"OAuthToken", 'DateTime'>
    readonly createdAt: FieldRef<"OAuthToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OAuthToken findUnique
   */
  export type OAuthTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where: OAuthTokenWhereUniqueInput
  }

  /**
   * OAuthToken findUniqueOrThrow
   */
  export type OAuthTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where: OAuthTokenWhereUniqueInput
  }

  /**
   * OAuthToken findFirst
   */
  export type OAuthTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthTokens.
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthTokens.
     */
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }

  /**
   * OAuthToken findFirstOrThrow
   */
  export type OAuthTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthTokens.
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthTokens.
     */
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }

  /**
   * OAuthToken findMany
   */
  export type OAuthTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
    /**
     * Filter, which OAuthTokens to fetch.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthTokens.
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }

  /**
   * OAuthToken create
   */
  export type OAuthTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a OAuthToken.
     */
    data: XOR<OAuthTokenCreateInput, OAuthTokenUncheckedCreateInput>
  }

  /**
   * OAuthToken createMany
   */
  export type OAuthTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthTokens.
     */
    data: OAuthTokenCreateManyInput | OAuthTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthToken createManyAndReturn
   */
  export type OAuthTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
    /**
     * The data used to create many OAuthTokens.
     */
    data: OAuthTokenCreateManyInput | OAuthTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthToken update
   */
  export type OAuthTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a OAuthToken.
     */
    data: XOR<OAuthTokenUpdateInput, OAuthTokenUncheckedUpdateInput>
    /**
     * Choose, which OAuthToken to update.
     */
    where: OAuthTokenWhereUniqueInput
  }

  /**
   * OAuthToken updateMany
   */
  export type OAuthTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthTokens.
     */
    data: XOR<OAuthTokenUpdateManyMutationInput, OAuthTokenUncheckedUpdateManyInput>
    /**
     * Filter which OAuthTokens to update
     */
    where?: OAuthTokenWhereInput
    /**
     * Limit how many OAuthTokens to update.
     */
    limit?: number
  }

  /**
   * OAuthToken updateManyAndReturn
   */
  export type OAuthTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
    /**
     * The data used to update OAuthTokens.
     */
    data: XOR<OAuthTokenUpdateManyMutationInput, OAuthTokenUncheckedUpdateManyInput>
    /**
     * Filter which OAuthTokens to update
     */
    where?: OAuthTokenWhereInput
    /**
     * Limit how many OAuthTokens to update.
     */
    limit?: number
  }

  /**
   * OAuthToken upsert
   */
  export type OAuthTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the OAuthToken to update in case it exists.
     */
    where: OAuthTokenWhereUniqueInput
    /**
     * In case the OAuthToken found by the `where` argument doesn't exist, create a new OAuthToken with this data.
     */
    create: XOR<OAuthTokenCreateInput, OAuthTokenUncheckedCreateInput>
    /**
     * In case the OAuthToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthTokenUpdateInput, OAuthTokenUncheckedUpdateInput>
  }

  /**
   * OAuthToken delete
   */
  export type OAuthTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
    /**
     * Filter which OAuthToken to delete.
     */
    where: OAuthTokenWhereUniqueInput
  }

  /**
   * OAuthToken deleteMany
   */
  export type OAuthTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthTokens to delete
     */
    where?: OAuthTokenWhereInput
    /**
     * Limit how many OAuthTokens to delete.
     */
    limit?: number
  }

  /**
   * OAuthToken without action
   */
  export type OAuthTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthToken
     */
    omit?: OAuthTokenOmit<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    eventType: $Enums.EventType | null
    customerId: string | null
    clinicId: string | null
    actor: $Enums.EventActor | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    eventType: $Enums.EventType | null
    customerId: string | null
    clinicId: string | null
    actor: $Enums.EventActor | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    eventId: number
    eventType: number
    customerId: number
    clinicId: number
    actor: number
    timestamp: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    customerId?: true
    clinicId?: true
    actor?: true
    timestamp?: true
    createdAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    customerId?: true
    clinicId?: true
    actor?: true
    timestamp?: true
    createdAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    customerId?: true
    clinicId?: true
    actor?: true
    timestamp?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    eventId: string | null
    eventType: $Enums.EventType
    customerId: string | null
    clinicId: string
    actor: $Enums.EventActor
    timestamp: Date
    metadata: JsonValue
    createdAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    customerId?: boolean
    clinicId?: boolean
    actor?: boolean
    timestamp?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    customerId?: boolean
    clinicId?: boolean
    actor?: boolean
    timestamp?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    customerId?: boolean
    clinicId?: boolean
    actor?: boolean
    timestamp?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    customerId?: boolean
    clinicId?: boolean
    actor?: boolean
    timestamp?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "eventType" | "customerId" | "clinicId" | "actor" | "timestamp" | "metadata" | "createdAt", ExtArgs["result"]["event"]>

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string | null
      eventType: $Enums.EventType
      customerId: string | null
      clinicId: string
      actor: $Enums.EventActor
      timestamp: Date
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly eventId: FieldRef<"Event", 'String'>
    readonly eventType: FieldRef<"Event", 'EventType'>
    readonly customerId: FieldRef<"Event", 'String'>
    readonly clinicId: FieldRef<"Event", 'String'>
    readonly actor: FieldRef<"Event", 'EventActor'>
    readonly timestamp: FieldRef<"Event", 'DateTime'>
    readonly metadata: FieldRef<"Event", 'Json'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
  }


  /**
   * Model WebhookEvent
   */

  export type AggregateWebhookEvent = {
    _count: WebhookEventCountAggregateOutputType | null
    _avg: WebhookEventAvgAggregateOutputType | null
    _sum: WebhookEventSumAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  export type WebhookEventAvgAggregateOutputType = {
    attempts: number | null
    retry_count: number | null
    max_retries: number | null
  }

  export type WebhookEventSumAggregateOutputType = {
    attempts: number | null
    retry_count: number | null
    max_retries: number | null
  }

  export type WebhookEventMinAggregateOutputType = {
    id: string | null
    provider: string | null
    hook_id: string | null
    type: string | null
    resource_order_id: string | null
    resource_charge_id: string | null
    status: string | null
    received_at: Date | null
    processed_at: Date | null
    attempts: number | null
    provider_event_id: string | null
    processed: boolean | null
    processing_error: string | null
    retry_count: number | null
    max_retries: number | null
    next_retry_at: Date | null
    last_retry_at: Date | null
    error_type: string | null
    is_retryable: boolean | null
    moved_dead_letter: boolean | null
    dead_letter_reason: string | null
  }

  export type WebhookEventMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    hook_id: string | null
    type: string | null
    resource_order_id: string | null
    resource_charge_id: string | null
    status: string | null
    received_at: Date | null
    processed_at: Date | null
    attempts: number | null
    provider_event_id: string | null
    processed: boolean | null
    processing_error: string | null
    retry_count: number | null
    max_retries: number | null
    next_retry_at: Date | null
    last_retry_at: Date | null
    error_type: string | null
    is_retryable: boolean | null
    moved_dead_letter: boolean | null
    dead_letter_reason: string | null
  }

  export type WebhookEventCountAggregateOutputType = {
    id: number
    provider: number
    hook_id: number
    type: number
    resource_order_id: number
    resource_charge_id: number
    status: number
    received_at: number
    processed_at: number
    attempts: number
    raw: number
    provider_event_id: number
    processed: number
    processing_error: number
    retry_count: number
    max_retries: number
    next_retry_at: number
    last_retry_at: number
    error_type: number
    is_retryable: number
    moved_dead_letter: number
    dead_letter_reason: number
    _all: number
  }


  export type WebhookEventAvgAggregateInputType = {
    attempts?: true
    retry_count?: true
    max_retries?: true
  }

  export type WebhookEventSumAggregateInputType = {
    attempts?: true
    retry_count?: true
    max_retries?: true
  }

  export type WebhookEventMinAggregateInputType = {
    id?: true
    provider?: true
    hook_id?: true
    type?: true
    resource_order_id?: true
    resource_charge_id?: true
    status?: true
    received_at?: true
    processed_at?: true
    attempts?: true
    provider_event_id?: true
    processed?: true
    processing_error?: true
    retry_count?: true
    max_retries?: true
    next_retry_at?: true
    last_retry_at?: true
    error_type?: true
    is_retryable?: true
    moved_dead_letter?: true
    dead_letter_reason?: true
  }

  export type WebhookEventMaxAggregateInputType = {
    id?: true
    provider?: true
    hook_id?: true
    type?: true
    resource_order_id?: true
    resource_charge_id?: true
    status?: true
    received_at?: true
    processed_at?: true
    attempts?: true
    provider_event_id?: true
    processed?: true
    processing_error?: true
    retry_count?: true
    max_retries?: true
    next_retry_at?: true
    last_retry_at?: true
    error_type?: true
    is_retryable?: true
    moved_dead_letter?: true
    dead_letter_reason?: true
  }

  export type WebhookEventCountAggregateInputType = {
    id?: true
    provider?: true
    hook_id?: true
    type?: true
    resource_order_id?: true
    resource_charge_id?: true
    status?: true
    received_at?: true
    processed_at?: true
    attempts?: true
    raw?: true
    provider_event_id?: true
    processed?: true
    processing_error?: true
    retry_count?: true
    max_retries?: true
    next_retry_at?: true
    last_retry_at?: true
    error_type?: true
    is_retryable?: true
    moved_dead_letter?: true
    dead_letter_reason?: true
    _all?: true
  }

  export type WebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvent to aggregate.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookEvents
    **/
    _count?: true | WebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookEventMaxAggregateInputType
  }

  export type GetWebhookEventAggregateType<T extends WebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookEvent[P]>
      : GetScalarType<T[P], AggregateWebhookEvent[P]>
  }




  export type WebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithAggregationInput | WebhookEventOrderByWithAggregationInput[]
    by: WebhookEventScalarFieldEnum[] | WebhookEventScalarFieldEnum
    having?: WebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookEventCountAggregateInputType | true
    _avg?: WebhookEventAvgAggregateInputType
    _sum?: WebhookEventSumAggregateInputType
    _min?: WebhookEventMinAggregateInputType
    _max?: WebhookEventMaxAggregateInputType
  }

  export type WebhookEventGroupByOutputType = {
    id: string
    provider: string
    hook_id: string
    type: string
    resource_order_id: string | null
    resource_charge_id: string | null
    status: string | null
    received_at: Date
    processed_at: Date | null
    attempts: number | null
    raw: JsonValue
    provider_event_id: string | null
    processed: boolean
    processing_error: string | null
    retry_count: number
    max_retries: number
    next_retry_at: Date | null
    last_retry_at: Date | null
    error_type: string | null
    is_retryable: boolean
    moved_dead_letter: boolean
    dead_letter_reason: string | null
    _count: WebhookEventCountAggregateOutputType | null
    _avg: WebhookEventAvgAggregateOutputType | null
    _sum: WebhookEventSumAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  type GetWebhookEventGroupByPayload<T extends WebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type WebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    hook_id?: boolean
    type?: boolean
    resource_order_id?: boolean
    resource_charge_id?: boolean
    status?: boolean
    received_at?: boolean
    processed_at?: boolean
    attempts?: boolean
    raw?: boolean
    provider_event_id?: boolean
    processed?: boolean
    processing_error?: boolean
    retry_count?: boolean
    max_retries?: boolean
    next_retry_at?: boolean
    last_retry_at?: boolean
    error_type?: boolean
    is_retryable?: boolean
    moved_dead_letter?: boolean
    dead_letter_reason?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    hook_id?: boolean
    type?: boolean
    resource_order_id?: boolean
    resource_charge_id?: boolean
    status?: boolean
    received_at?: boolean
    processed_at?: boolean
    attempts?: boolean
    raw?: boolean
    provider_event_id?: boolean
    processed?: boolean
    processing_error?: boolean
    retry_count?: boolean
    max_retries?: boolean
    next_retry_at?: boolean
    last_retry_at?: boolean
    error_type?: boolean
    is_retryable?: boolean
    moved_dead_letter?: boolean
    dead_letter_reason?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    hook_id?: boolean
    type?: boolean
    resource_order_id?: boolean
    resource_charge_id?: boolean
    status?: boolean
    received_at?: boolean
    processed_at?: boolean
    attempts?: boolean
    raw?: boolean
    provider_event_id?: boolean
    processed?: boolean
    processing_error?: boolean
    retry_count?: boolean
    max_retries?: boolean
    next_retry_at?: boolean
    last_retry_at?: boolean
    error_type?: boolean
    is_retryable?: boolean
    moved_dead_letter?: boolean
    dead_letter_reason?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectScalar = {
    id?: boolean
    provider?: boolean
    hook_id?: boolean
    type?: boolean
    resource_order_id?: boolean
    resource_charge_id?: boolean
    status?: boolean
    received_at?: boolean
    processed_at?: boolean
    attempts?: boolean
    raw?: boolean
    provider_event_id?: boolean
    processed?: boolean
    processing_error?: boolean
    retry_count?: boolean
    max_retries?: boolean
    next_retry_at?: boolean
    last_retry_at?: boolean
    error_type?: boolean
    is_retryable?: boolean
    moved_dead_letter?: boolean
    dead_letter_reason?: boolean
  }

  export type WebhookEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "hook_id" | "type" | "resource_order_id" | "resource_charge_id" | "status" | "received_at" | "processed_at" | "attempts" | "raw" | "provider_event_id" | "processed" | "processing_error" | "retry_count" | "max_retries" | "next_retry_at" | "last_retry_at" | "error_type" | "is_retryable" | "moved_dead_letter" | "dead_letter_reason", ExtArgs["result"]["webhookEvent"]>

  export type $WebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      hook_id: string
      type: string
      resource_order_id: string | null
      resource_charge_id: string | null
      status: string | null
      received_at: Date
      processed_at: Date | null
      attempts: number | null
      raw: Prisma.JsonValue
      provider_event_id: string | null
      processed: boolean
      processing_error: string | null
      retry_count: number
      max_retries: number
      next_retry_at: Date | null
      last_retry_at: Date | null
      error_type: string | null
      is_retryable: boolean
      moved_dead_letter: boolean
      dead_letter_reason: string | null
    }, ExtArgs["result"]["webhookEvent"]>
    composites: {}
  }

  type WebhookEventGetPayload<S extends boolean | null | undefined | WebhookEventDefaultArgs> = $Result.GetResult<Prisma.$WebhookEventPayload, S>

  type WebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookEventCountAggregateInputType | true
    }

  export interface WebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookEvent'], meta: { name: 'WebhookEvent' } }
    /**
     * Find zero or one WebhookEvent that matches the filter.
     * @param {WebhookEventFindUniqueArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookEventFindUniqueArgs>(args: SelectSubset<T, WebhookEventFindUniqueArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookEventFindUniqueOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookEventFindFirstArgs>(args?: SelectSubset<T, WebhookEventFindFirstArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany()
     * 
     * // Get first 10 WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookEventFindManyArgs>(args?: SelectSubset<T, WebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookEvent.
     * @param {WebhookEventCreateArgs} args - Arguments to create a WebhookEvent.
     * @example
     * // Create one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.create({
     *   data: {
     *     // ... data to create a WebhookEvent
     *   }
     * })
     * 
     */
    create<T extends WebhookEventCreateArgs>(args: SelectSubset<T, WebhookEventCreateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookEvents.
     * @param {WebhookEventCreateManyArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookEventCreateManyArgs>(args?: SelectSubset<T, WebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookEvents and returns the data saved in the database.
     * @param {WebhookEventCreateManyAndReturnArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookEvent.
     * @param {WebhookEventDeleteArgs} args - Arguments to delete one WebhookEvent.
     * @example
     * // Delete one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.delete({
     *   where: {
     *     // ... filter to delete one WebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends WebhookEventDeleteArgs>(args: SelectSubset<T, WebhookEventDeleteArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookEvent.
     * @param {WebhookEventUpdateArgs} args - Arguments to update one WebhookEvent.
     * @example
     * // Update one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookEventUpdateArgs>(args: SelectSubset<T, WebhookEventUpdateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookEvents.
     * @param {WebhookEventDeleteManyArgs} args - Arguments to filter WebhookEvents to delete.
     * @example
     * // Delete a few WebhookEvents
     * const { count } = await prisma.webhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookEventDeleteManyArgs>(args?: SelectSubset<T, WebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookEventUpdateManyArgs>(args: SelectSubset<T, WebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents and returns the data updated in the database.
     * @param {WebhookEventUpdateManyAndReturnArgs} args - Arguments to update many WebhookEvents.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookEventUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookEvent.
     * @param {WebhookEventUpsertArgs} args - Arguments to update or create a WebhookEvent.
     * @example
     * // Update or create a WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.upsert({
     *   create: {
     *     // ... data to create a WebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends WebhookEventUpsertArgs>(args: SelectSubset<T, WebhookEventUpsertArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventCountArgs} args - Arguments to filter WebhookEvents to count.
     * @example
     * // Count the number of WebhookEvents
     * const count = await prisma.webhookEvent.count({
     *   where: {
     *     // ... the filter for the WebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends WebhookEventCountArgs>(
      args?: Subset<T, WebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookEventAggregateArgs>(args: Subset<T, WebhookEventAggregateArgs>): Prisma.PrismaPromise<GetWebhookEventAggregateType<T>>

    /**
     * Group by WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: WebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookEvent model
   */
  readonly fields: WebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookEvent model
   */
  interface WebhookEventFieldRefs {
    readonly id: FieldRef<"WebhookEvent", 'String'>
    readonly provider: FieldRef<"WebhookEvent", 'String'>
    readonly hook_id: FieldRef<"WebhookEvent", 'String'>
    readonly type: FieldRef<"WebhookEvent", 'String'>
    readonly resource_order_id: FieldRef<"WebhookEvent", 'String'>
    readonly resource_charge_id: FieldRef<"WebhookEvent", 'String'>
    readonly status: FieldRef<"WebhookEvent", 'String'>
    readonly received_at: FieldRef<"WebhookEvent", 'DateTime'>
    readonly processed_at: FieldRef<"WebhookEvent", 'DateTime'>
    readonly attempts: FieldRef<"WebhookEvent", 'Int'>
    readonly raw: FieldRef<"WebhookEvent", 'Json'>
    readonly provider_event_id: FieldRef<"WebhookEvent", 'String'>
    readonly processed: FieldRef<"WebhookEvent", 'Boolean'>
    readonly processing_error: FieldRef<"WebhookEvent", 'String'>
    readonly retry_count: FieldRef<"WebhookEvent", 'Int'>
    readonly max_retries: FieldRef<"WebhookEvent", 'Int'>
    readonly next_retry_at: FieldRef<"WebhookEvent", 'DateTime'>
    readonly last_retry_at: FieldRef<"WebhookEvent", 'DateTime'>
    readonly error_type: FieldRef<"WebhookEvent", 'String'>
    readonly is_retryable: FieldRef<"WebhookEvent", 'Boolean'>
    readonly moved_dead_letter: FieldRef<"WebhookEvent", 'Boolean'>
    readonly dead_letter_reason: FieldRef<"WebhookEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WebhookEvent findUnique
   */
  export type WebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findUniqueOrThrow
   */
  export type WebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findFirst
   */
  export type WebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findFirstOrThrow
   */
  export type WebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findMany
   */
  export type WebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvents to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent create
   */
  export type WebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data needed to create a WebhookEvent.
     */
    data: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
  }

  /**
   * WebhookEvent createMany
   */
  export type WebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent createManyAndReturn
   */
  export type WebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent update
   */
  export type WebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data needed to update a WebhookEvent.
     */
    data: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
    /**
     * Choose, which WebhookEvent to update.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent updateMany
   */
  export type WebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to update.
     */
    limit?: number
  }

  /**
   * WebhookEvent updateManyAndReturn
   */
  export type WebhookEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to update.
     */
    limit?: number
  }

  /**
   * WebhookEvent upsert
   */
  export type WebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The filter to search for the WebhookEvent to update in case it exists.
     */
    where: WebhookEventWhereUniqueInput
    /**
     * In case the WebhookEvent found by the `where` argument doesn't exist, create a new WebhookEvent with this data.
     */
    create: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
    /**
     * In case the WebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
  }

  /**
   * WebhookEvent delete
   */
  export type WebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter which WebhookEvent to delete.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent deleteMany
   */
  export type WebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvents to delete
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to delete.
     */
    limit?: number
  }

  /**
   * WebhookEvent without action
   */
  export type WebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
  }


  /**
   * Model WebhookEndpoint
   */

  export type AggregateWebhookEndpoint = {
    _count: WebhookEndpointCountAggregateOutputType | null
    _avg: WebhookEndpointAvgAggregateOutputType | null
    _sum: WebhookEndpointSumAggregateOutputType | null
    _min: WebhookEndpointMinAggregateOutputType | null
    _max: WebhookEndpointMaxAggregateOutputType | null
  }

  export type WebhookEndpointAvgAggregateOutputType = {
    maxConcurrentDeliveries: number | null
  }

  export type WebhookEndpointSumAggregateOutputType = {
    maxConcurrentDeliveries: number | null
  }

  export type WebhookEndpointMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    name: string | null
    url: string | null
    secret: string | null
    enabled: boolean | null
    maxConcurrentDeliveries: number | null
    categoryFilter: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookEndpointMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    name: string | null
    url: string | null
    secret: string | null
    enabled: boolean | null
    maxConcurrentDeliveries: number | null
    categoryFilter: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookEndpointCountAggregateOutputType = {
    id: number
    clinicId: number
    name: number
    url: number
    secret: number
    events: number
    enabled: number
    maxConcurrentDeliveries: number
    categoryFilter: number
    statusFilters: number
    productFilters: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookEndpointAvgAggregateInputType = {
    maxConcurrentDeliveries?: true
  }

  export type WebhookEndpointSumAggregateInputType = {
    maxConcurrentDeliveries?: true
  }

  export type WebhookEndpointMinAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    url?: true
    secret?: true
    enabled?: true
    maxConcurrentDeliveries?: true
    categoryFilter?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookEndpointMaxAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    url?: true
    secret?: true
    enabled?: true
    maxConcurrentDeliveries?: true
    categoryFilter?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookEndpointCountAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    url?: true
    secret?: true
    events?: true
    enabled?: true
    maxConcurrentDeliveries?: true
    categoryFilter?: true
    statusFilters?: true
    productFilters?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookEndpointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEndpoint to aggregate.
     */
    where?: WebhookEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEndpoints to fetch.
     */
    orderBy?: WebhookEndpointOrderByWithRelationInput | WebhookEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookEndpoints
    **/
    _count?: true | WebhookEndpointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookEndpointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookEndpointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookEndpointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookEndpointMaxAggregateInputType
  }

  export type GetWebhookEndpointAggregateType<T extends WebhookEndpointAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookEndpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookEndpoint[P]>
      : GetScalarType<T[P], AggregateWebhookEndpoint[P]>
  }




  export type WebhookEndpointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEndpointWhereInput
    orderBy?: WebhookEndpointOrderByWithAggregationInput | WebhookEndpointOrderByWithAggregationInput[]
    by: WebhookEndpointScalarFieldEnum[] | WebhookEndpointScalarFieldEnum
    having?: WebhookEndpointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookEndpointCountAggregateInputType | true
    _avg?: WebhookEndpointAvgAggregateInputType
    _sum?: WebhookEndpointSumAggregateInputType
    _min?: WebhookEndpointMinAggregateInputType
    _max?: WebhookEndpointMaxAggregateInputType
  }

  export type WebhookEndpointGroupByOutputType = {
    id: string
    clinicId: string
    name: string
    url: string
    secret: string
    events: string[]
    enabled: boolean
    maxConcurrentDeliveries: number
    categoryFilter: string
    statusFilters: string[]
    productFilters: string[]
    createdAt: Date
    updatedAt: Date
    _count: WebhookEndpointCountAggregateOutputType | null
    _avg: WebhookEndpointAvgAggregateOutputType | null
    _sum: WebhookEndpointSumAggregateOutputType | null
    _min: WebhookEndpointMinAggregateOutputType | null
    _max: WebhookEndpointMaxAggregateOutputType | null
  }

  type GetWebhookEndpointGroupByPayload<T extends WebhookEndpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookEndpointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookEndpointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookEndpointGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookEndpointGroupByOutputType[P]>
        }
      >
    >


  export type WebhookEndpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    enabled?: boolean
    maxConcurrentDeliveries?: boolean
    categoryFilter?: boolean
    statusFilters?: boolean
    productFilters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    deliveries?: boolean | WebhookEndpoint$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookEndpointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookEndpoint"]>

  export type WebhookEndpointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    enabled?: boolean
    maxConcurrentDeliveries?: boolean
    categoryFilter?: boolean
    statusFilters?: boolean
    productFilters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookEndpoint"]>

  export type WebhookEndpointSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    enabled?: boolean
    maxConcurrentDeliveries?: boolean
    categoryFilter?: boolean
    statusFilters?: boolean
    productFilters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookEndpoint"]>

  export type WebhookEndpointSelectScalar = {
    id?: boolean
    clinicId?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    enabled?: boolean
    maxConcurrentDeliveries?: boolean
    categoryFilter?: boolean
    statusFilters?: boolean
    productFilters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebhookEndpointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "name" | "url" | "secret" | "events" | "enabled" | "maxConcurrentDeliveries" | "categoryFilter" | "statusFilters" | "productFilters" | "createdAt" | "updatedAt", ExtArgs["result"]["webhookEndpoint"]>
  export type WebhookEndpointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    deliveries?: boolean | WebhookEndpoint$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookEndpointCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebhookEndpointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }
  export type WebhookEndpointIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }

  export type $WebhookEndpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookEndpoint"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      deliveries: Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      name: string
      url: string
      secret: string
      events: string[]
      enabled: boolean
      maxConcurrentDeliveries: number
      categoryFilter: string
      statusFilters: string[]
      productFilters: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhookEndpoint"]>
    composites: {}
  }

  type WebhookEndpointGetPayload<S extends boolean | null | undefined | WebhookEndpointDefaultArgs> = $Result.GetResult<Prisma.$WebhookEndpointPayload, S>

  type WebhookEndpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookEndpointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookEndpointCountAggregateInputType | true
    }

  export interface WebhookEndpointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookEndpoint'], meta: { name: 'WebhookEndpoint' } }
    /**
     * Find zero or one WebhookEndpoint that matches the filter.
     * @param {WebhookEndpointFindUniqueArgs} args - Arguments to find a WebhookEndpoint
     * @example
     * // Get one WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookEndpointFindUniqueArgs>(args: SelectSubset<T, WebhookEndpointFindUniqueArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookEndpoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookEndpointFindUniqueOrThrowArgs} args - Arguments to find a WebhookEndpoint
     * @example
     * // Get one WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookEndpointFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookEndpointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEndpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointFindFirstArgs} args - Arguments to find a WebhookEndpoint
     * @example
     * // Get one WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookEndpointFindFirstArgs>(args?: SelectSubset<T, WebhookEndpointFindFirstArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEndpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointFindFirstOrThrowArgs} args - Arguments to find a WebhookEndpoint
     * @example
     * // Get one WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookEndpointFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookEndpointFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookEndpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookEndpoints
     * const webhookEndpoints = await prisma.webhookEndpoint.findMany()
     * 
     * // Get first 10 WebhookEndpoints
     * const webhookEndpoints = await prisma.webhookEndpoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookEndpointWithIdOnly = await prisma.webhookEndpoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookEndpointFindManyArgs>(args?: SelectSubset<T, WebhookEndpointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookEndpoint.
     * @param {WebhookEndpointCreateArgs} args - Arguments to create a WebhookEndpoint.
     * @example
     * // Create one WebhookEndpoint
     * const WebhookEndpoint = await prisma.webhookEndpoint.create({
     *   data: {
     *     // ... data to create a WebhookEndpoint
     *   }
     * })
     * 
     */
    create<T extends WebhookEndpointCreateArgs>(args: SelectSubset<T, WebhookEndpointCreateArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookEndpoints.
     * @param {WebhookEndpointCreateManyArgs} args - Arguments to create many WebhookEndpoints.
     * @example
     * // Create many WebhookEndpoints
     * const webhookEndpoint = await prisma.webhookEndpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookEndpointCreateManyArgs>(args?: SelectSubset<T, WebhookEndpointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookEndpoints and returns the data saved in the database.
     * @param {WebhookEndpointCreateManyAndReturnArgs} args - Arguments to create many WebhookEndpoints.
     * @example
     * // Create many WebhookEndpoints
     * const webhookEndpoint = await prisma.webhookEndpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookEndpoints and only return the `id`
     * const webhookEndpointWithIdOnly = await prisma.webhookEndpoint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookEndpointCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookEndpointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookEndpoint.
     * @param {WebhookEndpointDeleteArgs} args - Arguments to delete one WebhookEndpoint.
     * @example
     * // Delete one WebhookEndpoint
     * const WebhookEndpoint = await prisma.webhookEndpoint.delete({
     *   where: {
     *     // ... filter to delete one WebhookEndpoint
     *   }
     * })
     * 
     */
    delete<T extends WebhookEndpointDeleteArgs>(args: SelectSubset<T, WebhookEndpointDeleteArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookEndpoint.
     * @param {WebhookEndpointUpdateArgs} args - Arguments to update one WebhookEndpoint.
     * @example
     * // Update one WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookEndpointUpdateArgs>(args: SelectSubset<T, WebhookEndpointUpdateArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookEndpoints.
     * @param {WebhookEndpointDeleteManyArgs} args - Arguments to filter WebhookEndpoints to delete.
     * @example
     * // Delete a few WebhookEndpoints
     * const { count } = await prisma.webhookEndpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookEndpointDeleteManyArgs>(args?: SelectSubset<T, WebhookEndpointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEndpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookEndpoints
     * const webhookEndpoint = await prisma.webhookEndpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookEndpointUpdateManyArgs>(args: SelectSubset<T, WebhookEndpointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEndpoints and returns the data updated in the database.
     * @param {WebhookEndpointUpdateManyAndReturnArgs} args - Arguments to update many WebhookEndpoints.
     * @example
     * // Update many WebhookEndpoints
     * const webhookEndpoint = await prisma.webhookEndpoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookEndpoints and only return the `id`
     * const webhookEndpointWithIdOnly = await prisma.webhookEndpoint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookEndpointUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookEndpointUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookEndpoint.
     * @param {WebhookEndpointUpsertArgs} args - Arguments to update or create a WebhookEndpoint.
     * @example
     * // Update or create a WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.upsert({
     *   create: {
     *     // ... data to create a WebhookEndpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookEndpoint we want to update
     *   }
     * })
     */
    upsert<T extends WebhookEndpointUpsertArgs>(args: SelectSubset<T, WebhookEndpointUpsertArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookEndpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointCountArgs} args - Arguments to filter WebhookEndpoints to count.
     * @example
     * // Count the number of WebhookEndpoints
     * const count = await prisma.webhookEndpoint.count({
     *   where: {
     *     // ... the filter for the WebhookEndpoints we want to count
     *   }
     * })
    **/
    count<T extends WebhookEndpointCountArgs>(
      args?: Subset<T, WebhookEndpointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookEndpointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookEndpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookEndpointAggregateArgs>(args: Subset<T, WebhookEndpointAggregateArgs>): Prisma.PrismaPromise<GetWebhookEndpointAggregateType<T>>

    /**
     * Group by WebhookEndpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookEndpointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookEndpointGroupByArgs['orderBy'] }
        : { orderBy?: WebhookEndpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookEndpointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookEndpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookEndpoint model
   */
  readonly fields: WebhookEndpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookEndpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookEndpointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveries<T extends WebhookEndpoint$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, WebhookEndpoint$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookEndpoint model
   */
  interface WebhookEndpointFieldRefs {
    readonly id: FieldRef<"WebhookEndpoint", 'String'>
    readonly clinicId: FieldRef<"WebhookEndpoint", 'String'>
    readonly name: FieldRef<"WebhookEndpoint", 'String'>
    readonly url: FieldRef<"WebhookEndpoint", 'String'>
    readonly secret: FieldRef<"WebhookEndpoint", 'String'>
    readonly events: FieldRef<"WebhookEndpoint", 'String[]'>
    readonly enabled: FieldRef<"WebhookEndpoint", 'Boolean'>
    readonly maxConcurrentDeliveries: FieldRef<"WebhookEndpoint", 'Int'>
    readonly categoryFilter: FieldRef<"WebhookEndpoint", 'String'>
    readonly statusFilters: FieldRef<"WebhookEndpoint", 'String[]'>
    readonly productFilters: FieldRef<"WebhookEndpoint", 'String[]'>
    readonly createdAt: FieldRef<"WebhookEndpoint", 'DateTime'>
    readonly updatedAt: FieldRef<"WebhookEndpoint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookEndpoint findUnique
   */
  export type WebhookEndpointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEndpoint to fetch.
     */
    where: WebhookEndpointWhereUniqueInput
  }

  /**
   * WebhookEndpoint findUniqueOrThrow
   */
  export type WebhookEndpointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEndpoint to fetch.
     */
    where: WebhookEndpointWhereUniqueInput
  }

  /**
   * WebhookEndpoint findFirst
   */
  export type WebhookEndpointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEndpoint to fetch.
     */
    where?: WebhookEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEndpoints to fetch.
     */
    orderBy?: WebhookEndpointOrderByWithRelationInput | WebhookEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEndpoints.
     */
    cursor?: WebhookEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEndpoints.
     */
    distinct?: WebhookEndpointScalarFieldEnum | WebhookEndpointScalarFieldEnum[]
  }

  /**
   * WebhookEndpoint findFirstOrThrow
   */
  export type WebhookEndpointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEndpoint to fetch.
     */
    where?: WebhookEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEndpoints to fetch.
     */
    orderBy?: WebhookEndpointOrderByWithRelationInput | WebhookEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEndpoints.
     */
    cursor?: WebhookEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEndpoints.
     */
    distinct?: WebhookEndpointScalarFieldEnum | WebhookEndpointScalarFieldEnum[]
  }

  /**
   * WebhookEndpoint findMany
   */
  export type WebhookEndpointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEndpoints to fetch.
     */
    where?: WebhookEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEndpoints to fetch.
     */
    orderBy?: WebhookEndpointOrderByWithRelationInput | WebhookEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookEndpoints.
     */
    cursor?: WebhookEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEndpoints.
     */
    skip?: number
    distinct?: WebhookEndpointScalarFieldEnum | WebhookEndpointScalarFieldEnum[]
  }

  /**
   * WebhookEndpoint create
   */
  export type WebhookEndpointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookEndpoint.
     */
    data: XOR<WebhookEndpointCreateInput, WebhookEndpointUncheckedCreateInput>
  }

  /**
   * WebhookEndpoint createMany
   */
  export type WebhookEndpointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookEndpoints.
     */
    data: WebhookEndpointCreateManyInput | WebhookEndpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEndpoint createManyAndReturn
   */
  export type WebhookEndpointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookEndpoints.
     */
    data: WebhookEndpointCreateManyInput | WebhookEndpointCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookEndpoint update
   */
  export type WebhookEndpointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookEndpoint.
     */
    data: XOR<WebhookEndpointUpdateInput, WebhookEndpointUncheckedUpdateInput>
    /**
     * Choose, which WebhookEndpoint to update.
     */
    where: WebhookEndpointWhereUniqueInput
  }

  /**
   * WebhookEndpoint updateMany
   */
  export type WebhookEndpointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookEndpoints.
     */
    data: XOR<WebhookEndpointUpdateManyMutationInput, WebhookEndpointUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEndpoints to update
     */
    where?: WebhookEndpointWhereInput
    /**
     * Limit how many WebhookEndpoints to update.
     */
    limit?: number
  }

  /**
   * WebhookEndpoint updateManyAndReturn
   */
  export type WebhookEndpointUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * The data used to update WebhookEndpoints.
     */
    data: XOR<WebhookEndpointUpdateManyMutationInput, WebhookEndpointUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEndpoints to update
     */
    where?: WebhookEndpointWhereInput
    /**
     * Limit how many WebhookEndpoints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookEndpoint upsert
   */
  export type WebhookEndpointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookEndpoint to update in case it exists.
     */
    where: WebhookEndpointWhereUniqueInput
    /**
     * In case the WebhookEndpoint found by the `where` argument doesn't exist, create a new WebhookEndpoint with this data.
     */
    create: XOR<WebhookEndpointCreateInput, WebhookEndpointUncheckedCreateInput>
    /**
     * In case the WebhookEndpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookEndpointUpdateInput, WebhookEndpointUncheckedUpdateInput>
  }

  /**
   * WebhookEndpoint delete
   */
  export type WebhookEndpointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointInclude<ExtArgs> | null
    /**
     * Filter which WebhookEndpoint to delete.
     */
    where: WebhookEndpointWhereUniqueInput
  }

  /**
   * WebhookEndpoint deleteMany
   */
  export type WebhookEndpointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEndpoints to delete
     */
    where?: WebhookEndpointWhereInput
    /**
     * Limit how many WebhookEndpoints to delete.
     */
    limit?: number
  }

  /**
   * WebhookEndpoint.deliveries
   */
  export type WebhookEndpoint$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
    where?: OutboundWebhookDeliveryWhereInput
    orderBy?: OutboundWebhookDeliveryOrderByWithRelationInput | OutboundWebhookDeliveryOrderByWithRelationInput[]
    cursor?: OutboundWebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutboundWebhookDeliveryScalarFieldEnum | OutboundWebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookEndpoint without action
   */
  export type WebhookEndpointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEndpointInclude<ExtArgs> | null
  }


  /**
   * Model OutboundWebhookEvent
   */

  export type AggregateOutboundWebhookEvent = {
    _count: OutboundWebhookEventCountAggregateOutputType | null
    _min: OutboundWebhookEventMinAggregateOutputType | null
    _max: OutboundWebhookEventMaxAggregateOutputType | null
  }

  export type OutboundWebhookEventMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    type: string | null
    resource: string | null
    resourceId: string | null
    createdAt: Date | null
  }

  export type OutboundWebhookEventMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    type: string | null
    resource: string | null
    resourceId: string | null
    createdAt: Date | null
  }

  export type OutboundWebhookEventCountAggregateOutputType = {
    id: number
    clinicId: number
    type: number
    resource: number
    resourceId: number
    payload: number
    createdAt: number
    _all: number
  }


  export type OutboundWebhookEventMinAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    resource?: true
    resourceId?: true
    createdAt?: true
  }

  export type OutboundWebhookEventMaxAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    resource?: true
    resourceId?: true
    createdAt?: true
  }

  export type OutboundWebhookEventCountAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    resource?: true
    resourceId?: true
    payload?: true
    createdAt?: true
    _all?: true
  }

  export type OutboundWebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboundWebhookEvent to aggregate.
     */
    where?: OutboundWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundWebhookEvents to fetch.
     */
    orderBy?: OutboundWebhookEventOrderByWithRelationInput | OutboundWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutboundWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutboundWebhookEvents
    **/
    _count?: true | OutboundWebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutboundWebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutboundWebhookEventMaxAggregateInputType
  }

  export type GetOutboundWebhookEventAggregateType<T extends OutboundWebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateOutboundWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutboundWebhookEvent[P]>
      : GetScalarType<T[P], AggregateOutboundWebhookEvent[P]>
  }




  export type OutboundWebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboundWebhookEventWhereInput
    orderBy?: OutboundWebhookEventOrderByWithAggregationInput | OutboundWebhookEventOrderByWithAggregationInput[]
    by: OutboundWebhookEventScalarFieldEnum[] | OutboundWebhookEventScalarFieldEnum
    having?: OutboundWebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutboundWebhookEventCountAggregateInputType | true
    _min?: OutboundWebhookEventMinAggregateInputType
    _max?: OutboundWebhookEventMaxAggregateInputType
  }

  export type OutboundWebhookEventGroupByOutputType = {
    id: string
    clinicId: string
    type: string
    resource: string
    resourceId: string
    payload: JsonValue
    createdAt: Date
    _count: OutboundWebhookEventCountAggregateOutputType | null
    _min: OutboundWebhookEventMinAggregateOutputType | null
    _max: OutboundWebhookEventMaxAggregateOutputType | null
  }

  type GetOutboundWebhookEventGroupByPayload<T extends OutboundWebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutboundWebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutboundWebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutboundWebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], OutboundWebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type OutboundWebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    resource?: boolean
    resourceId?: boolean
    payload?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    deliveries?: boolean | OutboundWebhookEvent$deliveriesArgs<ExtArgs>
    _count?: boolean | OutboundWebhookEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outboundWebhookEvent"]>

  export type OutboundWebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    resource?: boolean
    resourceId?: boolean
    payload?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outboundWebhookEvent"]>

  export type OutboundWebhookEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    resource?: boolean
    resourceId?: boolean
    payload?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outboundWebhookEvent"]>

  export type OutboundWebhookEventSelectScalar = {
    id?: boolean
    clinicId?: boolean
    type?: boolean
    resource?: boolean
    resourceId?: boolean
    payload?: boolean
    createdAt?: boolean
  }

  export type OutboundWebhookEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "type" | "resource" | "resourceId" | "payload" | "createdAt", ExtArgs["result"]["outboundWebhookEvent"]>
  export type OutboundWebhookEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    deliveries?: boolean | OutboundWebhookEvent$deliveriesArgs<ExtArgs>
    _count?: boolean | OutboundWebhookEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OutboundWebhookEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }
  export type OutboundWebhookEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }

  export type $OutboundWebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutboundWebhookEvent"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      deliveries: Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      type: string
      resource: string
      resourceId: string
      payload: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["outboundWebhookEvent"]>
    composites: {}
  }

  type OutboundWebhookEventGetPayload<S extends boolean | null | undefined | OutboundWebhookEventDefaultArgs> = $Result.GetResult<Prisma.$OutboundWebhookEventPayload, S>

  type OutboundWebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutboundWebhookEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutboundWebhookEventCountAggregateInputType | true
    }

  export interface OutboundWebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutboundWebhookEvent'], meta: { name: 'OutboundWebhookEvent' } }
    /**
     * Find zero or one OutboundWebhookEvent that matches the filter.
     * @param {OutboundWebhookEventFindUniqueArgs} args - Arguments to find a OutboundWebhookEvent
     * @example
     * // Get one OutboundWebhookEvent
     * const outboundWebhookEvent = await prisma.outboundWebhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutboundWebhookEventFindUniqueArgs>(args: SelectSubset<T, OutboundWebhookEventFindUniqueArgs<ExtArgs>>): Prisma__OutboundWebhookEventClient<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OutboundWebhookEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutboundWebhookEventFindUniqueOrThrowArgs} args - Arguments to find a OutboundWebhookEvent
     * @example
     * // Get one OutboundWebhookEvent
     * const outboundWebhookEvent = await prisma.outboundWebhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutboundWebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, OutboundWebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutboundWebhookEventClient<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutboundWebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookEventFindFirstArgs} args - Arguments to find a OutboundWebhookEvent
     * @example
     * // Get one OutboundWebhookEvent
     * const outboundWebhookEvent = await prisma.outboundWebhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutboundWebhookEventFindFirstArgs>(args?: SelectSubset<T, OutboundWebhookEventFindFirstArgs<ExtArgs>>): Prisma__OutboundWebhookEventClient<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutboundWebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookEventFindFirstOrThrowArgs} args - Arguments to find a OutboundWebhookEvent
     * @example
     * // Get one OutboundWebhookEvent
     * const outboundWebhookEvent = await prisma.outboundWebhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutboundWebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, OutboundWebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutboundWebhookEventClient<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OutboundWebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutboundWebhookEvents
     * const outboundWebhookEvents = await prisma.outboundWebhookEvent.findMany()
     * 
     * // Get first 10 OutboundWebhookEvents
     * const outboundWebhookEvents = await prisma.outboundWebhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outboundWebhookEventWithIdOnly = await prisma.outboundWebhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutboundWebhookEventFindManyArgs>(args?: SelectSubset<T, OutboundWebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OutboundWebhookEvent.
     * @param {OutboundWebhookEventCreateArgs} args - Arguments to create a OutboundWebhookEvent.
     * @example
     * // Create one OutboundWebhookEvent
     * const OutboundWebhookEvent = await prisma.outboundWebhookEvent.create({
     *   data: {
     *     // ... data to create a OutboundWebhookEvent
     *   }
     * })
     * 
     */
    create<T extends OutboundWebhookEventCreateArgs>(args: SelectSubset<T, OutboundWebhookEventCreateArgs<ExtArgs>>): Prisma__OutboundWebhookEventClient<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OutboundWebhookEvents.
     * @param {OutboundWebhookEventCreateManyArgs} args - Arguments to create many OutboundWebhookEvents.
     * @example
     * // Create many OutboundWebhookEvents
     * const outboundWebhookEvent = await prisma.outboundWebhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutboundWebhookEventCreateManyArgs>(args?: SelectSubset<T, OutboundWebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutboundWebhookEvents and returns the data saved in the database.
     * @param {OutboundWebhookEventCreateManyAndReturnArgs} args - Arguments to create many OutboundWebhookEvents.
     * @example
     * // Create many OutboundWebhookEvents
     * const outboundWebhookEvent = await prisma.outboundWebhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutboundWebhookEvents and only return the `id`
     * const outboundWebhookEventWithIdOnly = await prisma.outboundWebhookEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutboundWebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, OutboundWebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OutboundWebhookEvent.
     * @param {OutboundWebhookEventDeleteArgs} args - Arguments to delete one OutboundWebhookEvent.
     * @example
     * // Delete one OutboundWebhookEvent
     * const OutboundWebhookEvent = await prisma.outboundWebhookEvent.delete({
     *   where: {
     *     // ... filter to delete one OutboundWebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends OutboundWebhookEventDeleteArgs>(args: SelectSubset<T, OutboundWebhookEventDeleteArgs<ExtArgs>>): Prisma__OutboundWebhookEventClient<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OutboundWebhookEvent.
     * @param {OutboundWebhookEventUpdateArgs} args - Arguments to update one OutboundWebhookEvent.
     * @example
     * // Update one OutboundWebhookEvent
     * const outboundWebhookEvent = await prisma.outboundWebhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutboundWebhookEventUpdateArgs>(args: SelectSubset<T, OutboundWebhookEventUpdateArgs<ExtArgs>>): Prisma__OutboundWebhookEventClient<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OutboundWebhookEvents.
     * @param {OutboundWebhookEventDeleteManyArgs} args - Arguments to filter OutboundWebhookEvents to delete.
     * @example
     * // Delete a few OutboundWebhookEvents
     * const { count } = await prisma.outboundWebhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutboundWebhookEventDeleteManyArgs>(args?: SelectSubset<T, OutboundWebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutboundWebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutboundWebhookEvents
     * const outboundWebhookEvent = await prisma.outboundWebhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutboundWebhookEventUpdateManyArgs>(args: SelectSubset<T, OutboundWebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutboundWebhookEvents and returns the data updated in the database.
     * @param {OutboundWebhookEventUpdateManyAndReturnArgs} args - Arguments to update many OutboundWebhookEvents.
     * @example
     * // Update many OutboundWebhookEvents
     * const outboundWebhookEvent = await prisma.outboundWebhookEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OutboundWebhookEvents and only return the `id`
     * const outboundWebhookEventWithIdOnly = await prisma.outboundWebhookEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutboundWebhookEventUpdateManyAndReturnArgs>(args: SelectSubset<T, OutboundWebhookEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OutboundWebhookEvent.
     * @param {OutboundWebhookEventUpsertArgs} args - Arguments to update or create a OutboundWebhookEvent.
     * @example
     * // Update or create a OutboundWebhookEvent
     * const outboundWebhookEvent = await prisma.outboundWebhookEvent.upsert({
     *   create: {
     *     // ... data to create a OutboundWebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutboundWebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends OutboundWebhookEventUpsertArgs>(args: SelectSubset<T, OutboundWebhookEventUpsertArgs<ExtArgs>>): Prisma__OutboundWebhookEventClient<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OutboundWebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookEventCountArgs} args - Arguments to filter OutboundWebhookEvents to count.
     * @example
     * // Count the number of OutboundWebhookEvents
     * const count = await prisma.outboundWebhookEvent.count({
     *   where: {
     *     // ... the filter for the OutboundWebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends OutboundWebhookEventCountArgs>(
      args?: Subset<T, OutboundWebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutboundWebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutboundWebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutboundWebhookEventAggregateArgs>(args: Subset<T, OutboundWebhookEventAggregateArgs>): Prisma.PrismaPromise<GetOutboundWebhookEventAggregateType<T>>

    /**
     * Group by OutboundWebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutboundWebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutboundWebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: OutboundWebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutboundWebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutboundWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutboundWebhookEvent model
   */
  readonly fields: OutboundWebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutboundWebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutboundWebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveries<T extends OutboundWebhookEvent$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, OutboundWebhookEvent$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutboundWebhookEvent model
   */
  interface OutboundWebhookEventFieldRefs {
    readonly id: FieldRef<"OutboundWebhookEvent", 'String'>
    readonly clinicId: FieldRef<"OutboundWebhookEvent", 'String'>
    readonly type: FieldRef<"OutboundWebhookEvent", 'String'>
    readonly resource: FieldRef<"OutboundWebhookEvent", 'String'>
    readonly resourceId: FieldRef<"OutboundWebhookEvent", 'String'>
    readonly payload: FieldRef<"OutboundWebhookEvent", 'Json'>
    readonly createdAt: FieldRef<"OutboundWebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutboundWebhookEvent findUnique
   */
  export type OutboundWebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which OutboundWebhookEvent to fetch.
     */
    where: OutboundWebhookEventWhereUniqueInput
  }

  /**
   * OutboundWebhookEvent findUniqueOrThrow
   */
  export type OutboundWebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which OutboundWebhookEvent to fetch.
     */
    where: OutboundWebhookEventWhereUniqueInput
  }

  /**
   * OutboundWebhookEvent findFirst
   */
  export type OutboundWebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which OutboundWebhookEvent to fetch.
     */
    where?: OutboundWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundWebhookEvents to fetch.
     */
    orderBy?: OutboundWebhookEventOrderByWithRelationInput | OutboundWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboundWebhookEvents.
     */
    cursor?: OutboundWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboundWebhookEvents.
     */
    distinct?: OutboundWebhookEventScalarFieldEnum | OutboundWebhookEventScalarFieldEnum[]
  }

  /**
   * OutboundWebhookEvent findFirstOrThrow
   */
  export type OutboundWebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which OutboundWebhookEvent to fetch.
     */
    where?: OutboundWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundWebhookEvents to fetch.
     */
    orderBy?: OutboundWebhookEventOrderByWithRelationInput | OutboundWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboundWebhookEvents.
     */
    cursor?: OutboundWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboundWebhookEvents.
     */
    distinct?: OutboundWebhookEventScalarFieldEnum | OutboundWebhookEventScalarFieldEnum[]
  }

  /**
   * OutboundWebhookEvent findMany
   */
  export type OutboundWebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which OutboundWebhookEvents to fetch.
     */
    where?: OutboundWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundWebhookEvents to fetch.
     */
    orderBy?: OutboundWebhookEventOrderByWithRelationInput | OutboundWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutboundWebhookEvents.
     */
    cursor?: OutboundWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundWebhookEvents.
     */
    skip?: number
    distinct?: OutboundWebhookEventScalarFieldEnum | OutboundWebhookEventScalarFieldEnum[]
  }

  /**
   * OutboundWebhookEvent create
   */
  export type OutboundWebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventInclude<ExtArgs> | null
    /**
     * The data needed to create a OutboundWebhookEvent.
     */
    data: XOR<OutboundWebhookEventCreateInput, OutboundWebhookEventUncheckedCreateInput>
  }

  /**
   * OutboundWebhookEvent createMany
   */
  export type OutboundWebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutboundWebhookEvents.
     */
    data: OutboundWebhookEventCreateManyInput | OutboundWebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutboundWebhookEvent createManyAndReturn
   */
  export type OutboundWebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * The data used to create many OutboundWebhookEvents.
     */
    data: OutboundWebhookEventCreateManyInput | OutboundWebhookEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutboundWebhookEvent update
   */
  export type OutboundWebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventInclude<ExtArgs> | null
    /**
     * The data needed to update a OutboundWebhookEvent.
     */
    data: XOR<OutboundWebhookEventUpdateInput, OutboundWebhookEventUncheckedUpdateInput>
    /**
     * Choose, which OutboundWebhookEvent to update.
     */
    where: OutboundWebhookEventWhereUniqueInput
  }

  /**
   * OutboundWebhookEvent updateMany
   */
  export type OutboundWebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutboundWebhookEvents.
     */
    data: XOR<OutboundWebhookEventUpdateManyMutationInput, OutboundWebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which OutboundWebhookEvents to update
     */
    where?: OutboundWebhookEventWhereInput
    /**
     * Limit how many OutboundWebhookEvents to update.
     */
    limit?: number
  }

  /**
   * OutboundWebhookEvent updateManyAndReturn
   */
  export type OutboundWebhookEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * The data used to update OutboundWebhookEvents.
     */
    data: XOR<OutboundWebhookEventUpdateManyMutationInput, OutboundWebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which OutboundWebhookEvents to update
     */
    where?: OutboundWebhookEventWhereInput
    /**
     * Limit how many OutboundWebhookEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutboundWebhookEvent upsert
   */
  export type OutboundWebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventInclude<ExtArgs> | null
    /**
     * The filter to search for the OutboundWebhookEvent to update in case it exists.
     */
    where: OutboundWebhookEventWhereUniqueInput
    /**
     * In case the OutboundWebhookEvent found by the `where` argument doesn't exist, create a new OutboundWebhookEvent with this data.
     */
    create: XOR<OutboundWebhookEventCreateInput, OutboundWebhookEventUncheckedCreateInput>
    /**
     * In case the OutboundWebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutboundWebhookEventUpdateInput, OutboundWebhookEventUncheckedUpdateInput>
  }

  /**
   * OutboundWebhookEvent delete
   */
  export type OutboundWebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventInclude<ExtArgs> | null
    /**
     * Filter which OutboundWebhookEvent to delete.
     */
    where: OutboundWebhookEventWhereUniqueInput
  }

  /**
   * OutboundWebhookEvent deleteMany
   */
  export type OutboundWebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboundWebhookEvents to delete
     */
    where?: OutboundWebhookEventWhereInput
    /**
     * Limit how many OutboundWebhookEvents to delete.
     */
    limit?: number
  }

  /**
   * OutboundWebhookEvent.deliveries
   */
  export type OutboundWebhookEvent$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
    where?: OutboundWebhookDeliveryWhereInput
    orderBy?: OutboundWebhookDeliveryOrderByWithRelationInput | OutboundWebhookDeliveryOrderByWithRelationInput[]
    cursor?: OutboundWebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutboundWebhookDeliveryScalarFieldEnum | OutboundWebhookDeliveryScalarFieldEnum[]
  }

  /**
   * OutboundWebhookEvent without action
   */
  export type OutboundWebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookEvent
     */
    select?: OutboundWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookEvent
     */
    omit?: OutboundWebhookEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookEventInclude<ExtArgs> | null
  }


  /**
   * Model OutboundWebhookDelivery
   */

  export type AggregateOutboundWebhookDelivery = {
    _count: OutboundWebhookDeliveryCountAggregateOutputType | null
    _avg: OutboundWebhookDeliveryAvgAggregateOutputType | null
    _sum: OutboundWebhookDeliverySumAggregateOutputType | null
    _min: OutboundWebhookDeliveryMinAggregateOutputType | null
    _max: OutboundWebhookDeliveryMaxAggregateOutputType | null
  }

  export type OutboundWebhookDeliveryAvgAggregateOutputType = {
    attempts: number | null
    lastCode: number | null
  }

  export type OutboundWebhookDeliverySumAggregateOutputType = {
    attempts: number | null
    lastCode: number | null
  }

  export type OutboundWebhookDeliveryMinAggregateOutputType = {
    id: string | null
    endpointId: string | null
    eventId: string | null
    status: string | null
    attempts: number | null
    lastCode: number | null
    lastError: string | null
    nextAttemptAt: Date | null
    deliveredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutboundWebhookDeliveryMaxAggregateOutputType = {
    id: string | null
    endpointId: string | null
    eventId: string | null
    status: string | null
    attempts: number | null
    lastCode: number | null
    lastError: string | null
    nextAttemptAt: Date | null
    deliveredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutboundWebhookDeliveryCountAggregateOutputType = {
    id: number
    endpointId: number
    eventId: number
    status: number
    attempts: number
    lastCode: number
    lastError: number
    nextAttemptAt: number
    deliveredAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutboundWebhookDeliveryAvgAggregateInputType = {
    attempts?: true
    lastCode?: true
  }

  export type OutboundWebhookDeliverySumAggregateInputType = {
    attempts?: true
    lastCode?: true
  }

  export type OutboundWebhookDeliveryMinAggregateInputType = {
    id?: true
    endpointId?: true
    eventId?: true
    status?: true
    attempts?: true
    lastCode?: true
    lastError?: true
    nextAttemptAt?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutboundWebhookDeliveryMaxAggregateInputType = {
    id?: true
    endpointId?: true
    eventId?: true
    status?: true
    attempts?: true
    lastCode?: true
    lastError?: true
    nextAttemptAt?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutboundWebhookDeliveryCountAggregateInputType = {
    id?: true
    endpointId?: true
    eventId?: true
    status?: true
    attempts?: true
    lastCode?: true
    lastError?: true
    nextAttemptAt?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutboundWebhookDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboundWebhookDelivery to aggregate.
     */
    where?: OutboundWebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundWebhookDeliveries to fetch.
     */
    orderBy?: OutboundWebhookDeliveryOrderByWithRelationInput | OutboundWebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutboundWebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundWebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundWebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutboundWebhookDeliveries
    **/
    _count?: true | OutboundWebhookDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutboundWebhookDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutboundWebhookDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutboundWebhookDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutboundWebhookDeliveryMaxAggregateInputType
  }

  export type GetOutboundWebhookDeliveryAggregateType<T extends OutboundWebhookDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateOutboundWebhookDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutboundWebhookDelivery[P]>
      : GetScalarType<T[P], AggregateOutboundWebhookDelivery[P]>
  }




  export type OutboundWebhookDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboundWebhookDeliveryWhereInput
    orderBy?: OutboundWebhookDeliveryOrderByWithAggregationInput | OutboundWebhookDeliveryOrderByWithAggregationInput[]
    by: OutboundWebhookDeliveryScalarFieldEnum[] | OutboundWebhookDeliveryScalarFieldEnum
    having?: OutboundWebhookDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutboundWebhookDeliveryCountAggregateInputType | true
    _avg?: OutboundWebhookDeliveryAvgAggregateInputType
    _sum?: OutboundWebhookDeliverySumAggregateInputType
    _min?: OutboundWebhookDeliveryMinAggregateInputType
    _max?: OutboundWebhookDeliveryMaxAggregateInputType
  }

  export type OutboundWebhookDeliveryGroupByOutputType = {
    id: string
    endpointId: string
    eventId: string
    status: string
    attempts: number
    lastCode: number | null
    lastError: string | null
    nextAttemptAt: Date | null
    deliveredAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OutboundWebhookDeliveryCountAggregateOutputType | null
    _avg: OutboundWebhookDeliveryAvgAggregateOutputType | null
    _sum: OutboundWebhookDeliverySumAggregateOutputType | null
    _min: OutboundWebhookDeliveryMinAggregateOutputType | null
    _max: OutboundWebhookDeliveryMaxAggregateOutputType | null
  }

  type GetOutboundWebhookDeliveryGroupByPayload<T extends OutboundWebhookDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutboundWebhookDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutboundWebhookDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutboundWebhookDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], OutboundWebhookDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type OutboundWebhookDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpointId?: boolean
    eventId?: boolean
    status?: boolean
    attempts?: boolean
    lastCode?: boolean
    lastError?: boolean
    nextAttemptAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    endpoint?: boolean | WebhookEndpointDefaultArgs<ExtArgs>
    event?: boolean | OutboundWebhookEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outboundWebhookDelivery"]>

  export type OutboundWebhookDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpointId?: boolean
    eventId?: boolean
    status?: boolean
    attempts?: boolean
    lastCode?: boolean
    lastError?: boolean
    nextAttemptAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    endpoint?: boolean | WebhookEndpointDefaultArgs<ExtArgs>
    event?: boolean | OutboundWebhookEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outboundWebhookDelivery"]>

  export type OutboundWebhookDeliverySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpointId?: boolean
    eventId?: boolean
    status?: boolean
    attempts?: boolean
    lastCode?: boolean
    lastError?: boolean
    nextAttemptAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    endpoint?: boolean | WebhookEndpointDefaultArgs<ExtArgs>
    event?: boolean | OutboundWebhookEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outboundWebhookDelivery"]>

  export type OutboundWebhookDeliverySelectScalar = {
    id?: boolean
    endpointId?: boolean
    eventId?: boolean
    status?: boolean
    attempts?: boolean
    lastCode?: boolean
    lastError?: boolean
    nextAttemptAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OutboundWebhookDeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "endpointId" | "eventId" | "status" | "attempts" | "lastCode" | "lastError" | "nextAttemptAt" | "deliveredAt" | "createdAt" | "updatedAt", ExtArgs["result"]["outboundWebhookDelivery"]>
  export type OutboundWebhookDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endpoint?: boolean | WebhookEndpointDefaultArgs<ExtArgs>
    event?: boolean | OutboundWebhookEventDefaultArgs<ExtArgs>
  }
  export type OutboundWebhookDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endpoint?: boolean | WebhookEndpointDefaultArgs<ExtArgs>
    event?: boolean | OutboundWebhookEventDefaultArgs<ExtArgs>
  }
  export type OutboundWebhookDeliveryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endpoint?: boolean | WebhookEndpointDefaultArgs<ExtArgs>
    event?: boolean | OutboundWebhookEventDefaultArgs<ExtArgs>
  }

  export type $OutboundWebhookDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutboundWebhookDelivery"
    objects: {
      endpoint: Prisma.$WebhookEndpointPayload<ExtArgs>
      event: Prisma.$OutboundWebhookEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      endpointId: string
      eventId: string
      status: string
      attempts: number
      lastCode: number | null
      lastError: string | null
      nextAttemptAt: Date | null
      deliveredAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["outboundWebhookDelivery"]>
    composites: {}
  }

  type OutboundWebhookDeliveryGetPayload<S extends boolean | null | undefined | OutboundWebhookDeliveryDefaultArgs> = $Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload, S>

  type OutboundWebhookDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutboundWebhookDeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutboundWebhookDeliveryCountAggregateInputType | true
    }

  export interface OutboundWebhookDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutboundWebhookDelivery'], meta: { name: 'OutboundWebhookDelivery' } }
    /**
     * Find zero or one OutboundWebhookDelivery that matches the filter.
     * @param {OutboundWebhookDeliveryFindUniqueArgs} args - Arguments to find a OutboundWebhookDelivery
     * @example
     * // Get one OutboundWebhookDelivery
     * const outboundWebhookDelivery = await prisma.outboundWebhookDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutboundWebhookDeliveryFindUniqueArgs>(args: SelectSubset<T, OutboundWebhookDeliveryFindUniqueArgs<ExtArgs>>): Prisma__OutboundWebhookDeliveryClient<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OutboundWebhookDelivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutboundWebhookDeliveryFindUniqueOrThrowArgs} args - Arguments to find a OutboundWebhookDelivery
     * @example
     * // Get one OutboundWebhookDelivery
     * const outboundWebhookDelivery = await prisma.outboundWebhookDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutboundWebhookDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, OutboundWebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutboundWebhookDeliveryClient<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutboundWebhookDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookDeliveryFindFirstArgs} args - Arguments to find a OutboundWebhookDelivery
     * @example
     * // Get one OutboundWebhookDelivery
     * const outboundWebhookDelivery = await prisma.outboundWebhookDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutboundWebhookDeliveryFindFirstArgs>(args?: SelectSubset<T, OutboundWebhookDeliveryFindFirstArgs<ExtArgs>>): Prisma__OutboundWebhookDeliveryClient<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutboundWebhookDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookDeliveryFindFirstOrThrowArgs} args - Arguments to find a OutboundWebhookDelivery
     * @example
     * // Get one OutboundWebhookDelivery
     * const outboundWebhookDelivery = await prisma.outboundWebhookDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutboundWebhookDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, OutboundWebhookDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutboundWebhookDeliveryClient<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OutboundWebhookDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutboundWebhookDeliveries
     * const outboundWebhookDeliveries = await prisma.outboundWebhookDelivery.findMany()
     * 
     * // Get first 10 OutboundWebhookDeliveries
     * const outboundWebhookDeliveries = await prisma.outboundWebhookDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outboundWebhookDeliveryWithIdOnly = await prisma.outboundWebhookDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutboundWebhookDeliveryFindManyArgs>(args?: SelectSubset<T, OutboundWebhookDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OutboundWebhookDelivery.
     * @param {OutboundWebhookDeliveryCreateArgs} args - Arguments to create a OutboundWebhookDelivery.
     * @example
     * // Create one OutboundWebhookDelivery
     * const OutboundWebhookDelivery = await prisma.outboundWebhookDelivery.create({
     *   data: {
     *     // ... data to create a OutboundWebhookDelivery
     *   }
     * })
     * 
     */
    create<T extends OutboundWebhookDeliveryCreateArgs>(args: SelectSubset<T, OutboundWebhookDeliveryCreateArgs<ExtArgs>>): Prisma__OutboundWebhookDeliveryClient<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OutboundWebhookDeliveries.
     * @param {OutboundWebhookDeliveryCreateManyArgs} args - Arguments to create many OutboundWebhookDeliveries.
     * @example
     * // Create many OutboundWebhookDeliveries
     * const outboundWebhookDelivery = await prisma.outboundWebhookDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutboundWebhookDeliveryCreateManyArgs>(args?: SelectSubset<T, OutboundWebhookDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutboundWebhookDeliveries and returns the data saved in the database.
     * @param {OutboundWebhookDeliveryCreateManyAndReturnArgs} args - Arguments to create many OutboundWebhookDeliveries.
     * @example
     * // Create many OutboundWebhookDeliveries
     * const outboundWebhookDelivery = await prisma.outboundWebhookDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutboundWebhookDeliveries and only return the `id`
     * const outboundWebhookDeliveryWithIdOnly = await prisma.outboundWebhookDelivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutboundWebhookDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, OutboundWebhookDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OutboundWebhookDelivery.
     * @param {OutboundWebhookDeliveryDeleteArgs} args - Arguments to delete one OutboundWebhookDelivery.
     * @example
     * // Delete one OutboundWebhookDelivery
     * const OutboundWebhookDelivery = await prisma.outboundWebhookDelivery.delete({
     *   where: {
     *     // ... filter to delete one OutboundWebhookDelivery
     *   }
     * })
     * 
     */
    delete<T extends OutboundWebhookDeliveryDeleteArgs>(args: SelectSubset<T, OutboundWebhookDeliveryDeleteArgs<ExtArgs>>): Prisma__OutboundWebhookDeliveryClient<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OutboundWebhookDelivery.
     * @param {OutboundWebhookDeliveryUpdateArgs} args - Arguments to update one OutboundWebhookDelivery.
     * @example
     * // Update one OutboundWebhookDelivery
     * const outboundWebhookDelivery = await prisma.outboundWebhookDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutboundWebhookDeliveryUpdateArgs>(args: SelectSubset<T, OutboundWebhookDeliveryUpdateArgs<ExtArgs>>): Prisma__OutboundWebhookDeliveryClient<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OutboundWebhookDeliveries.
     * @param {OutboundWebhookDeliveryDeleteManyArgs} args - Arguments to filter OutboundWebhookDeliveries to delete.
     * @example
     * // Delete a few OutboundWebhookDeliveries
     * const { count } = await prisma.outboundWebhookDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutboundWebhookDeliveryDeleteManyArgs>(args?: SelectSubset<T, OutboundWebhookDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutboundWebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutboundWebhookDeliveries
     * const outboundWebhookDelivery = await prisma.outboundWebhookDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutboundWebhookDeliveryUpdateManyArgs>(args: SelectSubset<T, OutboundWebhookDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutboundWebhookDeliveries and returns the data updated in the database.
     * @param {OutboundWebhookDeliveryUpdateManyAndReturnArgs} args - Arguments to update many OutboundWebhookDeliveries.
     * @example
     * // Update many OutboundWebhookDeliveries
     * const outboundWebhookDelivery = await prisma.outboundWebhookDelivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OutboundWebhookDeliveries and only return the `id`
     * const outboundWebhookDeliveryWithIdOnly = await prisma.outboundWebhookDelivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutboundWebhookDeliveryUpdateManyAndReturnArgs>(args: SelectSubset<T, OutboundWebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OutboundWebhookDelivery.
     * @param {OutboundWebhookDeliveryUpsertArgs} args - Arguments to update or create a OutboundWebhookDelivery.
     * @example
     * // Update or create a OutboundWebhookDelivery
     * const outboundWebhookDelivery = await prisma.outboundWebhookDelivery.upsert({
     *   create: {
     *     // ... data to create a OutboundWebhookDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutboundWebhookDelivery we want to update
     *   }
     * })
     */
    upsert<T extends OutboundWebhookDeliveryUpsertArgs>(args: SelectSubset<T, OutboundWebhookDeliveryUpsertArgs<ExtArgs>>): Prisma__OutboundWebhookDeliveryClient<$Result.GetResult<Prisma.$OutboundWebhookDeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OutboundWebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookDeliveryCountArgs} args - Arguments to filter OutboundWebhookDeliveries to count.
     * @example
     * // Count the number of OutboundWebhookDeliveries
     * const count = await prisma.outboundWebhookDelivery.count({
     *   where: {
     *     // ... the filter for the OutboundWebhookDeliveries we want to count
     *   }
     * })
    **/
    count<T extends OutboundWebhookDeliveryCountArgs>(
      args?: Subset<T, OutboundWebhookDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutboundWebhookDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutboundWebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutboundWebhookDeliveryAggregateArgs>(args: Subset<T, OutboundWebhookDeliveryAggregateArgs>): Prisma.PrismaPromise<GetOutboundWebhookDeliveryAggregateType<T>>

    /**
     * Group by OutboundWebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundWebhookDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutboundWebhookDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutboundWebhookDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: OutboundWebhookDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutboundWebhookDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutboundWebhookDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutboundWebhookDelivery model
   */
  readonly fields: OutboundWebhookDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutboundWebhookDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutboundWebhookDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    endpoint<T extends WebhookEndpointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebhookEndpointDefaultArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    event<T extends OutboundWebhookEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutboundWebhookEventDefaultArgs<ExtArgs>>): Prisma__OutboundWebhookEventClient<$Result.GetResult<Prisma.$OutboundWebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutboundWebhookDelivery model
   */
  interface OutboundWebhookDeliveryFieldRefs {
    readonly id: FieldRef<"OutboundWebhookDelivery", 'String'>
    readonly endpointId: FieldRef<"OutboundWebhookDelivery", 'String'>
    readonly eventId: FieldRef<"OutboundWebhookDelivery", 'String'>
    readonly status: FieldRef<"OutboundWebhookDelivery", 'String'>
    readonly attempts: FieldRef<"OutboundWebhookDelivery", 'Int'>
    readonly lastCode: FieldRef<"OutboundWebhookDelivery", 'Int'>
    readonly lastError: FieldRef<"OutboundWebhookDelivery", 'String'>
    readonly nextAttemptAt: FieldRef<"OutboundWebhookDelivery", 'DateTime'>
    readonly deliveredAt: FieldRef<"OutboundWebhookDelivery", 'DateTime'>
    readonly createdAt: FieldRef<"OutboundWebhookDelivery", 'DateTime'>
    readonly updatedAt: FieldRef<"OutboundWebhookDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutboundWebhookDelivery findUnique
   */
  export type OutboundWebhookDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which OutboundWebhookDelivery to fetch.
     */
    where: OutboundWebhookDeliveryWhereUniqueInput
  }

  /**
   * OutboundWebhookDelivery findUniqueOrThrow
   */
  export type OutboundWebhookDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which OutboundWebhookDelivery to fetch.
     */
    where: OutboundWebhookDeliveryWhereUniqueInput
  }

  /**
   * OutboundWebhookDelivery findFirst
   */
  export type OutboundWebhookDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which OutboundWebhookDelivery to fetch.
     */
    where?: OutboundWebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundWebhookDeliveries to fetch.
     */
    orderBy?: OutboundWebhookDeliveryOrderByWithRelationInput | OutboundWebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboundWebhookDeliveries.
     */
    cursor?: OutboundWebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundWebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundWebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboundWebhookDeliveries.
     */
    distinct?: OutboundWebhookDeliveryScalarFieldEnum | OutboundWebhookDeliveryScalarFieldEnum[]
  }

  /**
   * OutboundWebhookDelivery findFirstOrThrow
   */
  export type OutboundWebhookDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which OutboundWebhookDelivery to fetch.
     */
    where?: OutboundWebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundWebhookDeliveries to fetch.
     */
    orderBy?: OutboundWebhookDeliveryOrderByWithRelationInput | OutboundWebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboundWebhookDeliveries.
     */
    cursor?: OutboundWebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundWebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundWebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboundWebhookDeliveries.
     */
    distinct?: OutboundWebhookDeliveryScalarFieldEnum | OutboundWebhookDeliveryScalarFieldEnum[]
  }

  /**
   * OutboundWebhookDelivery findMany
   */
  export type OutboundWebhookDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which OutboundWebhookDeliveries to fetch.
     */
    where?: OutboundWebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundWebhookDeliveries to fetch.
     */
    orderBy?: OutboundWebhookDeliveryOrderByWithRelationInput | OutboundWebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutboundWebhookDeliveries.
     */
    cursor?: OutboundWebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundWebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundWebhookDeliveries.
     */
    skip?: number
    distinct?: OutboundWebhookDeliveryScalarFieldEnum | OutboundWebhookDeliveryScalarFieldEnum[]
  }

  /**
   * OutboundWebhookDelivery create
   */
  export type OutboundWebhookDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a OutboundWebhookDelivery.
     */
    data: XOR<OutboundWebhookDeliveryCreateInput, OutboundWebhookDeliveryUncheckedCreateInput>
  }

  /**
   * OutboundWebhookDelivery createMany
   */
  export type OutboundWebhookDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutboundWebhookDeliveries.
     */
    data: OutboundWebhookDeliveryCreateManyInput | OutboundWebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutboundWebhookDelivery createManyAndReturn
   */
  export type OutboundWebhookDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * The data used to create many OutboundWebhookDeliveries.
     */
    data: OutboundWebhookDeliveryCreateManyInput | OutboundWebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutboundWebhookDelivery update
   */
  export type OutboundWebhookDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a OutboundWebhookDelivery.
     */
    data: XOR<OutboundWebhookDeliveryUpdateInput, OutboundWebhookDeliveryUncheckedUpdateInput>
    /**
     * Choose, which OutboundWebhookDelivery to update.
     */
    where: OutboundWebhookDeliveryWhereUniqueInput
  }

  /**
   * OutboundWebhookDelivery updateMany
   */
  export type OutboundWebhookDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutboundWebhookDeliveries.
     */
    data: XOR<OutboundWebhookDeliveryUpdateManyMutationInput, OutboundWebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which OutboundWebhookDeliveries to update
     */
    where?: OutboundWebhookDeliveryWhereInput
    /**
     * Limit how many OutboundWebhookDeliveries to update.
     */
    limit?: number
  }

  /**
   * OutboundWebhookDelivery updateManyAndReturn
   */
  export type OutboundWebhookDeliveryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * The data used to update OutboundWebhookDeliveries.
     */
    data: XOR<OutboundWebhookDeliveryUpdateManyMutationInput, OutboundWebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which OutboundWebhookDeliveries to update
     */
    where?: OutboundWebhookDeliveryWhereInput
    /**
     * Limit how many OutboundWebhookDeliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutboundWebhookDelivery upsert
   */
  export type OutboundWebhookDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the OutboundWebhookDelivery to update in case it exists.
     */
    where: OutboundWebhookDeliveryWhereUniqueInput
    /**
     * In case the OutboundWebhookDelivery found by the `where` argument doesn't exist, create a new OutboundWebhookDelivery with this data.
     */
    create: XOR<OutboundWebhookDeliveryCreateInput, OutboundWebhookDeliveryUncheckedCreateInput>
    /**
     * In case the OutboundWebhookDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutboundWebhookDeliveryUpdateInput, OutboundWebhookDeliveryUncheckedUpdateInput>
  }

  /**
   * OutboundWebhookDelivery delete
   */
  export type OutboundWebhookDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter which OutboundWebhookDelivery to delete.
     */
    where: OutboundWebhookDeliveryWhereUniqueInput
  }

  /**
   * OutboundWebhookDelivery deleteMany
   */
  export type OutboundWebhookDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboundWebhookDeliveries to delete
     */
    where?: OutboundWebhookDeliveryWhereInput
    /**
     * Limit how many OutboundWebhookDeliveries to delete.
     */
    limit?: number
  }

  /**
   * OutboundWebhookDelivery without action
   */
  export type OutboundWebhookDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundWebhookDelivery
     */
    select?: OutboundWebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutboundWebhookDelivery
     */
    omit?: OutboundWebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundWebhookDeliveryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    image: 'image',
    public_cover_image_url: 'public_cover_image_url',
    doctor_slug: 'doctor_slug',
    role: 'role',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    email_verified: 'email_verified',
    password: 'password',
    reset_token: 'reset_token',
    reset_token_expiry: 'reset_token_expiry',
    verification_code: 'verification_code',
    verification_code_expiry: 'verification_code_expiry',
    doctor_id: 'doctor_id',
    referral_code: 'referral_code',
    phone: 'phone',
    birth_date: 'birth_date',
    gender: 'gender',
    address: 'address',
    emergency_contact: 'emergency_contact',
    emergency_phone: 'emergency_phone',
    medical_history: 'medical_history',
    allergies: 'allergies',
    medications: 'medications',
    notes: 'notes',
    google_review_link: 'google_review_link',
    stripe_connect_id: 'stripe_connect_id',
    accessGranted: 'accessGranted'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const VerificationCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    user_id: 'user_id',
    doctor_id: 'doctor_id',
    type: 'type',
    created_at: 'created_at',
    expires_at: 'expires_at',
    used_at: 'used_at'
  };

  export type VerificationCodeScalarFieldEnum = (typeof VerificationCodeScalarFieldEnum)[keyof typeof VerificationCodeScalarFieldEnum]


  export const PatientProfileScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    userId: 'userId',
    name: 'name',
    phone: 'phone',
    address: 'address',
    emergency_contact: 'emergency_contact',
    emergency_phone: 'emergency_phone',
    medical_history: 'medical_history',
    allergies: 'allergies',
    medications: 'medications',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    totalPoints: 'totalPoints',
    currentPoints: 'currentPoints'
  };

  export type PatientProfileScalarFieldEnum = (typeof PatientProfileScalarFieldEnum)[keyof typeof PatientProfileScalarFieldEnum]


  export const PointsLedgerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    patientProfileId: 'patientProfileId',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    amount: 'amount',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type PointsLedgerScalarFieldEnum = (typeof PointsLedgerScalarFieldEnum)[keyof typeof PointsLedgerScalarFieldEnum]


  export const ClinicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    ownerId: 'ownerId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    phone: 'phone',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    website: 'website',
    logo: 'logo',
    slug: 'slug',
    subdomain: 'subdomain',
    monthlyRevenueRange: 'monthlyRevenueRange',
    currentGateway: 'currentGateway',
    theme: 'theme',
    buttonColor: 'buttonColor',
    buttonTextColor: 'buttonTextColor'
  };

  export type ClinicScalarFieldEnum = (typeof ClinicScalarFieldEnum)[keyof typeof ClinicScalarFieldEnum]


  export const ClinicMemberScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    userId: 'userId',
    role: 'role',
    isActive: 'isActive',
    joinedAt: 'joinedAt'
  };

  export type ClinicMemberScalarFieldEnum = (typeof ClinicMemberScalarFieldEnum)[keyof typeof ClinicMemberScalarFieldEnum]


  export const MerchantScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    status: 'status',
    recipientId: 'recipientId',
    externalAccountId: 'externalAccountId',
    onboardingState: 'onboardingState',
    splitPercent: 'splitPercent',
    platformFeeBps: 'platformFeeBps',
    transactionFeeCents: 'transactionFeeCents',
    transactionFeeType: 'transactionFeeType',
    lastSyncAt: 'lastSyncAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MerchantScalarFieldEnum = (typeof MerchantScalarFieldEnum)[keyof typeof MerchantScalarFieldEnum]


  export const MerchantApplicationScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    type: 'type',
    businessName: 'businessName',
    fullName: 'fullName',
    documentNumber: 'documentNumber',
    email: 'email',
    phone: 'phone',
    address: 'address',
    bankAccount: 'bankAccount',
    recipientId: 'recipientId',
    status: 'status',
    reviewNotes: 'reviewNotes',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MerchantApplicationScalarFieldEnum = (typeof MerchantApplicationScalarFieldEnum)[keyof typeof MerchantApplicationScalarFieldEnum]


  export const MerchantDocumentScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    type: 'type',
    fileUrl: 'fileUrl',
    status: 'status',
    notes: 'notes',
    uploadedAt: 'uploadedAt',
    reviewedAt: 'reviewedAt'
  };

  export type MerchantDocumentScalarFieldEnum = (typeof MerchantDocumentScalarFieldEnum)[keyof typeof MerchantDocumentScalarFieldEnum]


  export const MerchantIntegrationScalarFieldEnum: {
    id: 'id',
    merchantId: 'merchantId',
    provider: 'provider',
    credentials: 'credentials',
    config: 'config',
    isActive: 'isActive',
    isPrimary: 'isPrimary',
    connectedAt: 'connectedAt',
    lastUsedAt: 'lastUsedAt',
    lastError: 'lastError',
    lastErrorAt: 'lastErrorAt'
  };

  export type MerchantIntegrationScalarFieldEnum = (typeof MerchantIntegrationScalarFieldEnum)[keyof typeof MerchantIntegrationScalarFieldEnum]


  export const PaymentRoutingRuleScalarFieldEnum: {
    id: 'id',
    merchantId: 'merchantId',
    productId: 'productId',
    offerId: 'offerId',
    country: 'country',
    method: 'method',
    provider: 'provider',
    priority: 'priority',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentRoutingRuleScalarFieldEnum = (typeof PaymentRoutingRuleScalarFieldEnum)[keyof typeof PaymentRoutingRuleScalarFieldEnum]


  export const ClinicPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tier: 'tier',
    description: 'description',
    monthlyPrice: 'monthlyPrice',
    monthlyTxLimit: 'monthlyTxLimit',
    features: 'features',
    trialDays: 'trialDays',
    requireCard: 'requireCard',
    isActive: 'isActive',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicPlanScalarFieldEnum = (typeof ClinicPlanScalarFieldEnum)[keyof typeof ClinicPlanScalarFieldEnum]


  export const ClinicAddOnScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    description: 'description',
    monthlyPrice: 'monthlyPrice',
    quantity: 'quantity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicAddOnScalarFieldEnum = (typeof ClinicAddOnScalarFieldEnum)[keyof typeof ClinicAddOnScalarFieldEnum]


  export const ClinicSubscriptionScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    planId: 'planId',
    status: 'status',
    startDate: 'startDate',
    trialEndsAt: 'trialEndsAt',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    canceledAt: 'canceledAt',
    cancelReason: 'cancelReason',
    currentDoctorsCount: 'currentDoctorsCount',
    currentPatientsCount: 'currentPatientsCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicSubscriptionScalarFieldEnum = (typeof ClinicSubscriptionScalarFieldEnum)[keyof typeof ClinicSubscriptionScalarFieldEnum]


  export const ClinicAddOnSubscriptionScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    addOnId: 'addOnId',
    quantity: 'quantity',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicAddOnSubscriptionScalarFieldEnum = (typeof ClinicAddOnSubscriptionScalarFieldEnum)[keyof typeof ClinicAddOnSubscriptionScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    doctorId: 'doctorId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subtitle: 'subtitle',
    description: 'description',
    price: 'price',
    creditsPerUnit: 'creditsPerUnit',
    category: 'category',
    isActive: 'isActive',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    doctorId: 'doctorId',
    clinicId: 'clinicId',
    imageUrl: 'imageUrl',
    confirmationUrl: 'confirmationUrl',
    categoryId: 'categoryId',
    type: 'type',
    interval: 'interval',
    intervalCount: 'intervalCount',
    trialDays: 'trialDays',
    providerPlanId: 'providerPlanId',
    providerPlanData: 'providerPlanData',
    autoRenew: 'autoRenew'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CategoriesOnProductsScalarFieldEnum: {
    productId: 'productId',
    categoryId: 'categoryId',
    assignedAt: 'assignedAt'
  };

  export type CategoriesOnProductsScalarFieldEnum = (typeof CategoriesOnProductsScalarFieldEnum)[keyof typeof CategoriesOnProductsScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    name: 'name',
    description: 'description',
    currency: 'currency',
    priceCents: 'priceCents',
    preferredProvider: 'preferredProvider',
    maxInstallments: 'maxInstallments',
    installmentMinCents: 'installmentMinCents',
    active: 'active',
    isSubscription: 'isSubscription',
    intervalCount: 'intervalCount',
    intervalUnit: 'intervalUnit',
    trialDays: 'trialDays',
    checkoutUrl: 'checkoutUrl',
    providerConfig: 'providerConfig',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const OfferPriceScalarFieldEnum: {
    id: 'id',
    offerId: 'offerId',
    country: 'country',
    currency: 'currency',
    provider: 'provider',
    amountCents: 'amountCents',
    externalPriceId: 'externalPriceId',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfferPriceScalarFieldEnum = (typeof OfferPriceScalarFieldEnum)[keyof typeof OfferPriceScalarFieldEnum]


  export const OfferPaymentMethodScalarFieldEnum: {
    id: 'id',
    offerId: 'offerId',
    method: 'method',
    active: 'active',
    feePercent: 'feePercent'
  };

  export type OfferPaymentMethodScalarFieldEnum = (typeof OfferPaymentMethodScalarFieldEnum)[keyof typeof OfferPaymentMethodScalarFieldEnum]


  export const ProductIntegrationScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    provider: 'provider',
    externalProductId: 'externalProductId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductIntegrationScalarFieldEnum = (typeof ProductIntegrationScalarFieldEnum)[keyof typeof ProductIntegrationScalarFieldEnum]


  export const CheckoutSessionScalarFieldEnum: {
    id: 'id',
    resumeToken: 'resumeToken',
    clinicId: 'clinicId',
    productId: 'productId',
    offerId: 'offerId',
    slug: 'slug',
    provider: 'provider',
    country: 'country',
    locale: 'locale',
    status: 'status',
    paymentMethod: 'paymentMethod',
    orderId: 'orderId',
    pixOrderId: 'pixOrderId',
    pixExpiresAt: 'pixExpiresAt',
    paymentTransactionId: 'paymentTransactionId',
    email: 'email',
    phone: 'phone',
    document: 'document',
    utmSource: 'utmSource',
    utmMedium: 'utmMedium',
    utmCampaign: 'utmCampaign',
    utmTerm: 'utmTerm',
    utmContent: 'utmContent',
    referrer: 'referrer',
    ip: 'ip',
    userAgent: 'userAgent',
    selectedInstallments: 'selectedInstallments',
    selectedBank: 'selectedBank',
    paymentMethodsAllowed: 'paymentMethodsAllowed',
    metadata: 'metadata',
    startedAt: 'startedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastHeartbeatAt: 'lastHeartbeatAt',
    lastStep: 'lastStep',
    reminders: 'reminders',
    reminderExpiringSentAt: 'reminderExpiringSentAt',
    reminderExpiredSentAt: 'reminderExpiredSentAt',
    conversionLikelihood: 'conversionLikelihood',
    origin: 'origin',
    createdBy: 'createdBy'
  };

  export type CheckoutSessionScalarFieldEnum = (typeof CheckoutSessionScalarFieldEnum)[keyof typeof CheckoutSessionScalarFieldEnum]


  export const PaymentTransactionScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    providerOrderId: 'providerOrderId',
    providerChargeId: 'providerChargeId',
    doctorId: 'doctorId',
    patientProfileId: 'patientProfileId',
    clinicId: 'clinicId',
    merchantId: 'merchantId',
    productId: 'productId',
    amountCents: 'amountCents',
    currency: 'currency',
    installments: 'installments',
    paymentMethodType: 'paymentMethodType',
    status: 'status',
    status_v2: 'status_v2',
    rawPayload: 'rawPayload',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paidAt: 'paidAt',
    capturedAt: 'capturedAt',
    refundStatus: 'refundStatus',
    refundedAt: 'refundedAt',
    routedProvider: 'routedProvider',
    customerId: 'customerId',
    customerProviderId: 'customerProviderId',
    customerPaymentMethodId: 'customerPaymentMethodId',
    customerSubscriptionId: 'customerSubscriptionId',
    billingPeriodStart: 'billingPeriodStart',
    billingPeriodEnd: 'billingPeriodEnd',
    provider_v2: 'provider_v2'
  };

  export type PaymentTransactionScalarFieldEnum = (typeof PaymentTransactionScalarFieldEnum)[keyof typeof PaymentTransactionScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    doctorId: 'doctorId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    pointsAwarded: 'pointsAwarded',
    status: 'status',
    externalIdempotencyKey: 'externalIdempotencyKey',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    merchantId: 'merchantId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    document: 'document',
    address: 'address',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerProviderScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    provider: 'provider',
    accountId: 'accountId',
    providerCustomerId: 'providerCustomerId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerProviderScalarFieldEnum = (typeof CustomerProviderScalarFieldEnum)[keyof typeof CustomerProviderScalarFieldEnum]


  export const CustomerPaymentMethodScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    customerProviderId: 'customerProviderId',
    provider: 'provider',
    accountId: 'accountId',
    providerPaymentMethodId: 'providerPaymentMethodId',
    brand: 'brand',
    last4: 'last4',
    expMonth: 'expMonth',
    expYear: 'expYear',
    isDefault: 'isDefault',
    status: 'status',
    fingerprint: 'fingerprint',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerPaymentMethodScalarFieldEnum = (typeof CustomerPaymentMethodScalarFieldEnum)[keyof typeof CustomerPaymentMethodScalarFieldEnum]


  export const CustomerSubscriptionScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    merchantId: 'merchantId',
    productId: 'productId',
    offerId: 'offerId',
    provider: 'provider',
    accountId: 'accountId',
    isNative: 'isNative',
    customerProviderId: 'customerProviderId',
    providerSubscriptionId: 'providerSubscriptionId',
    vaultPaymentMethodId: 'vaultPaymentMethodId',
    status: 'status',
    startAt: 'startAt',
    trialEndsAt: 'trialEndsAt',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAt: 'cancelAt',
    canceledAt: 'canceledAt',
    priceCents: 'priceCents',
    currency: 'currency',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerSubscriptionScalarFieldEnum = (typeof CustomerSubscriptionScalarFieldEnum)[keyof typeof CustomerSubscriptionScalarFieldEnum]


  export const PaymentCustomerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    clinicId: 'clinicId',
    email: 'email',
    document: 'document',
    fullName: 'fullName',
    phones: 'phones',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentCustomerScalarFieldEnum = (typeof PaymentCustomerScalarFieldEnum)[keyof typeof PaymentCustomerScalarFieldEnum]


  export const MessageTemplateScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    name: 'name',
    channel: 'channel',
    subject: 'subject',
    html: 'html',
    text: 'text',
    mjml: 'mjml',
    renderStrategy: 'renderStrategy',
    fromName: 'fromName',
    fromEmail: 'fromEmail',
    replyTo: 'replyTo',
    provider: 'provider',
    waTemplateName: 'waTemplateName',
    waLanguage: 'waLanguage',
    waCategory: 'waCategory',
    waComponents: 'waComponents',
    waStatus: 'waStatus',
    waProviderId: 'waProviderId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    variablesSchema: 'variablesSchema',
    sampleVariables: 'sampleVariables',
    tags: 'tags',
    smsMaxSegments: 'smsMaxSegments'
  };

  export type MessageTemplateScalarFieldEnum = (typeof MessageTemplateScalarFieldEnum)[keyof typeof MessageTemplateScalarFieldEnum]


  export const MessageSequenceScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageSequenceScalarFieldEnum = (typeof MessageSequenceScalarFieldEnum)[keyof typeof MessageSequenceScalarFieldEnum]


  export const MessageSequenceStepScalarFieldEnum: {
    id: 'id',
    sequenceId: 'sequenceId',
    orderIndex: 'orderIndex',
    delayAmount: 'delayAmount',
    delayUnit: 'delayUnit',
    templateId: 'templateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageSequenceStepScalarFieldEnum = (typeof MessageSequenceStepScalarFieldEnum)[keyof typeof MessageSequenceStepScalarFieldEnum]


  export const CampaignJobScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    campaignId: 'campaignId',
    channel: 'channel',
    trigger: 'trigger',
    scheduleAt: 'scheduleAt',
    createdAt: 'createdAt',
    status: 'status',
    lastError: 'lastError'
  };

  export type CampaignJobScalarFieldEnum = (typeof CampaignJobScalarFieldEnum)[keyof typeof CampaignJobScalarFieldEnum]


  export const OpenFinanceLinkScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    clinicId: 'clinicId',
    organisationId: 'organisationId',
    authorisationServerId: 'authorisationServerId',
    enrollmentId: 'enrollmentId',
    status: 'status',
    deviceBinding: 'deviceBinding',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OpenFinanceLinkScalarFieldEnum = (typeof OpenFinanceLinkScalarFieldEnum)[keyof typeof OpenFinanceLinkScalarFieldEnum]


  export const OpenFinanceConsentScalarFieldEnum: {
    id: 'id',
    linkId: 'linkId',
    consentId: 'consentId',
    contractId: 'contractId',
    status: 'status',
    amountCents: 'amountCents',
    periodicity: 'periodicity',
    nextExecutionAt: 'nextExecutionAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OpenFinanceConsentScalarFieldEnum = (typeof OpenFinanceConsentScalarFieldEnum)[keyof typeof OpenFinanceConsentScalarFieldEnum]


  export const OpenBankingPaymentScalarFieldEnum: {
    id: 'id',
    providerPaymentId: 'providerPaymentId',
    consentId: 'consentId',
    amountCents: 'amountCents',
    currency: 'currency',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    enrollmentId: 'enrollmentId',
    transactionIdentification: 'transactionIdentification',
    payerId: 'payerId',
    payerDocument: 'payerDocument',
    payerEmail: 'payerEmail',
    payerName: 'payerName',
    creditorName: 'creditorName',
    creditorCpfCnpj: 'creditorCpfCnpj',
    clinicId: 'clinicId',
    productId: 'productId',
    purchaseId: 'purchaseId',
    type: 'type',
    executedAt: 'executedAt',
    settledAt: 'settledAt',
    recurrenceType: 'recurrenceType',
    subscriptionId: 'subscriptionId',
    executionOrder: 'executionOrder',
    providerResponse: 'providerResponse',
    fidoAssertion: 'fidoAssertion',
    riskSignals: 'riskSignals',
    paymentLinkId: 'paymentLinkId',
    userId: 'userId',
    orderRef: 'orderRef',
    redirectUri: 'redirectUri',
    transactionId: 'transactionId',
    expiresAt: 'expiresAt',
    metadata: 'metadata'
  };

  export type OpenBankingPaymentScalarFieldEnum = (typeof OpenBankingPaymentScalarFieldEnum)[keyof typeof OpenBankingPaymentScalarFieldEnum]


  export const OpenBankingConsentScalarFieldEnum: {
    id: 'id',
    enrollmentId: 'enrollmentId',
    consentId: 'consentId',
    amountCents: 'amountCents',
    currency: 'currency',
    creditorName: 'creditorName',
    creditorCpfCnpj: 'creditorCpfCnpj',
    productId: 'productId',
    clinicId: 'clinicId',
    status: 'status',
    providerResponse: 'providerResponse',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OpenBankingConsentScalarFieldEnum = (typeof OpenBankingConsentScalarFieldEnum)[keyof typeof OpenBankingConsentScalarFieldEnum]


  export const EnrollmentContextScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionId: 'sessionId',
    enrollmentId: 'enrollmentId',
    organisationId: 'organisationId',
    authorisationServerId: 'authorisationServerId',
    fallbackUsed: 'fallbackUsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    deviceRegistered: 'deviceRegistered',
    expiresAt: 'expiresAt',
    clinicId: 'clinicId',
    payerEmail: 'payerEmail',
    payerDocument: 'payerDocument',
    payerName: 'payerName',
    recurringEnabled: 'recurringEnabled',
    deviceBinding: 'deviceBinding',
    providerResponse: 'providerResponse'
  };

  export type EnrollmentContextScalarFieldEnum = (typeof EnrollmentContextScalarFieldEnum)[keyof typeof EnrollmentContextScalarFieldEnum]


  export const PaymentConsentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    consentId: 'consentId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentConsentScalarFieldEnum = (typeof PaymentConsentScalarFieldEnum)[keyof typeof PaymentConsentScalarFieldEnum]


  export const OAuthStateScalarFieldEnum: {
    id: 'id',
    state: 'state',
    nonce: 'nonce',
    codeVerifier: 'codeVerifier',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    usedAt: 'usedAt'
  };

  export type OAuthStateScalarFieldEnum = (typeof OAuthStateScalarFieldEnum)[keyof typeof OAuthStateScalarFieldEnum]


  export const OAuthStateMetaScalarFieldEnum: {
    state: 'state',
    organisationId: 'organisationId',
    authorisationServerId: 'authorisationServerId',
    createdAt: 'createdAt',
    productId: 'productId',
    amountCents: 'amountCents',
    currency: 'currency',
    orderRef: 'orderRef'
  };

  export type OAuthStateMetaScalarFieldEnum = (typeof OAuthStateMetaScalarFieldEnum)[keyof typeof OAuthStateMetaScalarFieldEnum]


  export const OAuthTokenScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    provider: 'provider',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    scope: 'scope',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type OAuthTokenScalarFieldEnum = (typeof OAuthTokenScalarFieldEnum)[keyof typeof OAuthTokenScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    eventType: 'eventType',
    customerId: 'customerId',
    clinicId: 'clinicId',
    actor: 'actor',
    timestamp: 'timestamp',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const WebhookEventScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    hook_id: 'hook_id',
    type: 'type',
    resource_order_id: 'resource_order_id',
    resource_charge_id: 'resource_charge_id',
    status: 'status',
    received_at: 'received_at',
    processed_at: 'processed_at',
    attempts: 'attempts',
    raw: 'raw',
    provider_event_id: 'provider_event_id',
    processed: 'processed',
    processing_error: 'processing_error',
    retry_count: 'retry_count',
    max_retries: 'max_retries',
    next_retry_at: 'next_retry_at',
    last_retry_at: 'last_retry_at',
    error_type: 'error_type',
    is_retryable: 'is_retryable',
    moved_dead_letter: 'moved_dead_letter',
    dead_letter_reason: 'dead_letter_reason'
  };

  export type WebhookEventScalarFieldEnum = (typeof WebhookEventScalarFieldEnum)[keyof typeof WebhookEventScalarFieldEnum]


  export const WebhookEndpointScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    name: 'name',
    url: 'url',
    secret: 'secret',
    events: 'events',
    enabled: 'enabled',
    maxConcurrentDeliveries: 'maxConcurrentDeliveries',
    categoryFilter: 'categoryFilter',
    statusFilters: 'statusFilters',
    productFilters: 'productFilters',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookEndpointScalarFieldEnum = (typeof WebhookEndpointScalarFieldEnum)[keyof typeof WebhookEndpointScalarFieldEnum]


  export const OutboundWebhookEventScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    type: 'type',
    resource: 'resource',
    resourceId: 'resourceId',
    payload: 'payload',
    createdAt: 'createdAt'
  };

  export type OutboundWebhookEventScalarFieldEnum = (typeof OutboundWebhookEventScalarFieldEnum)[keyof typeof OutboundWebhookEventScalarFieldEnum]


  export const OutboundWebhookDeliveryScalarFieldEnum: {
    id: 'id',
    endpointId: 'endpointId',
    eventId: 'eventId',
    status: 'status',
    attempts: 'attempts',
    lastCode: 'lastCode',
    lastError: 'lastError',
    nextAttemptAt: 'nextAttemptAt',
    deliveredAt: 'deliveredAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutboundWebhookDeliveryScalarFieldEnum = (typeof OutboundWebhookDeliveryScalarFieldEnum)[keyof typeof OutboundWebhookDeliveryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ClinicTheme'
   */
  export type EnumClinicThemeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClinicTheme'>
    


  /**
   * Reference to a field of type 'ClinicTheme[]'
   */
  export type ListEnumClinicThemeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClinicTheme[]'>
    


  /**
   * Reference to a field of type 'ClinicRole'
   */
  export type EnumClinicRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClinicRole'>
    


  /**
   * Reference to a field of type 'ClinicRole[]'
   */
  export type ListEnumClinicRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClinicRole[]'>
    


  /**
   * Reference to a field of type 'MerchantStatus'
   */
  export type EnumMerchantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MerchantStatus'>
    


  /**
   * Reference to a field of type 'MerchantStatus[]'
   */
  export type ListEnumMerchantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MerchantStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'MerchantType'
   */
  export type EnumMerchantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MerchantType'>
    


  /**
   * Reference to a field of type 'MerchantType[]'
   */
  export type ListEnumMerchantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MerchantType[]'>
    


  /**
   * Reference to a field of type 'MerchantAppStatus'
   */
  export type EnumMerchantAppStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MerchantAppStatus'>
    


  /**
   * Reference to a field of type 'MerchantAppStatus[]'
   */
  export type ListEnumMerchantAppStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MerchantAppStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'DocumentStatus'
   */
  export type EnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus'>
    


  /**
   * Reference to a field of type 'DocumentStatus[]'
   */
  export type ListEnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentProvider'
   */
  export type EnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider'>
    


  /**
   * Reference to a field of type 'PaymentProvider[]'
   */
  export type ListEnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PlanTier'
   */
  export type EnumPlanTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanTier'>
    


  /**
   * Reference to a field of type 'PlanTier[]'
   */
  export type ListEnumPlanTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanTier[]'>
    


  /**
   * Reference to a field of type 'AddOnType'
   */
  export type EnumAddOnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddOnType'>
    


  /**
   * Reference to a field of type 'AddOnType[]'
   */
  export type ListEnumAddOnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddOnType[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'ProductType[]'
   */
  export type ListEnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType[]'>
    


  /**
   * Reference to a field of type 'SubscriptionInterval'
   */
  export type EnumSubscriptionIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionInterval'>
    


  /**
   * Reference to a field of type 'SubscriptionInterval[]'
   */
  export type ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionInterval[]'>
    


  /**
   * Reference to a field of type 'Currency'
   */
  export type EnumCurrencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Currency'>
    


  /**
   * Reference to a field of type 'Currency[]'
   */
  export type ListEnumCurrencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Currency[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CheckoutSessionStatus'
   */
  export type EnumCheckoutSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckoutSessionStatus'>
    


  /**
   * Reference to a field of type 'CheckoutSessionStatus[]'
   */
  export type ListEnumCheckoutSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckoutSessionStatus[]'>
    


  /**
   * Reference to a field of type 'CheckoutPaymentMethod'
   */
  export type EnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckoutPaymentMethod'>
    


  /**
   * Reference to a field of type 'CheckoutPaymentMethod[]'
   */
  export type ListEnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckoutPaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatusOB'
   */
  export type EnumPaymentStatusOBFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatusOB'>
    


  /**
   * Reference to a field of type 'PaymentStatusOB[]'
   */
  export type ListEnumPaymentStatusOBFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatusOB[]'>
    


  /**
   * Reference to a field of type 'PaymentTypeOB'
   */
  export type EnumPaymentTypeOBFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentTypeOB'>
    


  /**
   * Reference to a field of type 'PaymentTypeOB[]'
   */
  export type ListEnumPaymentTypeOBFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentTypeOB[]'>
    


  /**
   * Reference to a field of type 'ConsentStatusOB'
   */
  export type EnumConsentStatusOBFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentStatusOB'>
    


  /**
   * Reference to a field of type 'ConsentStatusOB[]'
   */
  export type ListEnumConsentStatusOBFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentStatusOB[]'>
    


  /**
   * Reference to a field of type 'EnrollmentStatusOB'
   */
  export type EnumEnrollmentStatusOBFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnrollmentStatusOB'>
    


  /**
   * Reference to a field of type 'EnrollmentStatusOB[]'
   */
  export type ListEnumEnrollmentStatusOBFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnrollmentStatusOB[]'>
    


  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


  /**
   * Reference to a field of type 'EventActor'
   */
  export type EnumEventActorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventActor'>
    


  /**
   * Reference to a field of type 'EventActor[]'
   */
  export type ListEnumEventActorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventActor[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    public_cover_image_url?: StringNullableFilter<"User"> | string | null
    doctor_slug?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    is_active?: BoolFilter<"User"> | boolean
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    email_verified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    reset_token?: StringNullableFilter<"User"> | string | null
    reset_token_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    verification_code?: StringNullableFilter<"User"> | string | null
    verification_code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    doctor_id?: StringNullableFilter<"User"> | string | null
    referral_code?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    birth_date?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    emergency_contact?: StringNullableFilter<"User"> | string | null
    emergency_phone?: StringNullableFilter<"User"> | string | null
    medical_history?: StringNullableFilter<"User"> | string | null
    allergies?: StringNullableFilter<"User"> | string | null
    medications?: StringNullableFilter<"User"> | string | null
    notes?: StringNullableFilter<"User"> | string | null
    google_review_link?: StringNullableFilter<"User"> | string | null
    stripe_connect_id?: StringNullableFilter<"User"> | string | null
    accessGranted?: BoolFilter<"User"> | boolean
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    other_users?: UserListRelationFilter
    clinic_memberships?: ClinicMemberListRelationFilter
    owned_clinics?: ClinicListRelationFilter
    created_products?: ProductListRelationFilter
    created_categories?: ProductCategoryListRelationFilter
    user_verification_codes?: VerificationCodeListRelationFilter
    doctor_verification_codes?: VerificationCodeListRelationFilter
    purchases?: PurchaseListRelationFilter
    doctorPurchases?: PurchaseListRelationFilter
    pointsLedger?: PointsLedgerListRelationFilter
    doctor_profiles?: PatientProfileListRelationFilter
    patient_profiles?: PatientProfileListRelationFilter
    message_templates?: MessageTemplateListRelationFilter
    message_sequences?: MessageSequenceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    public_cover_image_url?: SortOrderInput | SortOrder
    doctor_slug?: SortOrderInput | SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expiry?: SortOrderInput | SortOrder
    verification_code?: SortOrderInput | SortOrder
    verification_code_expiry?: SortOrderInput | SortOrder
    doctor_id?: SortOrderInput | SortOrder
    referral_code?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    emergency_contact?: SortOrderInput | SortOrder
    emergency_phone?: SortOrderInput | SortOrder
    medical_history?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    google_review_link?: SortOrderInput | SortOrder
    stripe_connect_id?: SortOrderInput | SortOrder
    accessGranted?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
    other_users?: UserOrderByRelationAggregateInput
    clinic_memberships?: ClinicMemberOrderByRelationAggregateInput
    owned_clinics?: ClinicOrderByRelationAggregateInput
    created_products?: ProductOrderByRelationAggregateInput
    created_categories?: ProductCategoryOrderByRelationAggregateInput
    user_verification_codes?: VerificationCodeOrderByRelationAggregateInput
    doctor_verification_codes?: VerificationCodeOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    doctorPurchases?: PurchaseOrderByRelationAggregateInput
    pointsLedger?: PointsLedgerOrderByRelationAggregateInput
    doctor_profiles?: PatientProfileOrderByRelationAggregateInput
    patient_profiles?: PatientProfileOrderByRelationAggregateInput
    message_templates?: MessageTemplateOrderByRelationAggregateInput
    message_sequences?: MessageSequenceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    doctor_slug?: string
    referral_code?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    public_cover_image_url?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    is_active?: BoolFilter<"User"> | boolean
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    email_verified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    reset_token?: StringNullableFilter<"User"> | string | null
    reset_token_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    verification_code?: StringNullableFilter<"User"> | string | null
    verification_code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    doctor_id?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    birth_date?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    emergency_contact?: StringNullableFilter<"User"> | string | null
    emergency_phone?: StringNullableFilter<"User"> | string | null
    medical_history?: StringNullableFilter<"User"> | string | null
    allergies?: StringNullableFilter<"User"> | string | null
    medications?: StringNullableFilter<"User"> | string | null
    notes?: StringNullableFilter<"User"> | string | null
    google_review_link?: StringNullableFilter<"User"> | string | null
    stripe_connect_id?: StringNullableFilter<"User"> | string | null
    accessGranted?: BoolFilter<"User"> | boolean
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    other_users?: UserListRelationFilter
    clinic_memberships?: ClinicMemberListRelationFilter
    owned_clinics?: ClinicListRelationFilter
    created_products?: ProductListRelationFilter
    created_categories?: ProductCategoryListRelationFilter
    user_verification_codes?: VerificationCodeListRelationFilter
    doctor_verification_codes?: VerificationCodeListRelationFilter
    purchases?: PurchaseListRelationFilter
    doctorPurchases?: PurchaseListRelationFilter
    pointsLedger?: PointsLedgerListRelationFilter
    doctor_profiles?: PatientProfileListRelationFilter
    patient_profiles?: PatientProfileListRelationFilter
    message_templates?: MessageTemplateListRelationFilter
    message_sequences?: MessageSequenceListRelationFilter
  }, "id" | "email" | "doctor_slug" | "referral_code">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    public_cover_image_url?: SortOrderInput | SortOrder
    doctor_slug?: SortOrderInput | SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expiry?: SortOrderInput | SortOrder
    verification_code?: SortOrderInput | SortOrder
    verification_code_expiry?: SortOrderInput | SortOrder
    doctor_id?: SortOrderInput | SortOrder
    referral_code?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    emergency_contact?: SortOrderInput | SortOrder
    emergency_phone?: SortOrderInput | SortOrder
    medical_history?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    google_review_link?: SortOrderInput | SortOrder
    stripe_connect_id?: SortOrderInput | SortOrder
    accessGranted?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    public_cover_image_url?: StringNullableWithAggregatesFilter<"User"> | string | null
    doctor_slug?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    is_active?: BoolWithAggregatesFilter<"User"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email_verified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    reset_token?: StringNullableWithAggregatesFilter<"User"> | string | null
    reset_token_expiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    verification_code?: StringNullableWithAggregatesFilter<"User"> | string | null
    verification_code_expiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    doctor_id?: StringNullableWithAggregatesFilter<"User"> | string | null
    referral_code?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    birth_date?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    emergency_contact?: StringNullableWithAggregatesFilter<"User"> | string | null
    emergency_phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    medical_history?: StringNullableWithAggregatesFilter<"User"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"User"> | string | null
    medications?: StringNullableWithAggregatesFilter<"User"> | string | null
    notes?: StringNullableWithAggregatesFilter<"User"> | string | null
    google_review_link?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripe_connect_id?: StringNullableWithAggregatesFilter<"User"> | string | null
    accessGranted?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type VerificationCodeWhereInput = {
    AND?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    OR?: VerificationCodeWhereInput[]
    NOT?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    id?: StringFilter<"VerificationCode"> | string
    code?: StringFilter<"VerificationCode"> | string
    user_id?: StringFilter<"VerificationCode"> | string
    doctor_id?: StringFilter<"VerificationCode"> | string
    type?: StringFilter<"VerificationCode"> | string
    created_at?: DateTimeFilter<"VerificationCode"> | Date | string
    expires_at?: DateTimeFilter<"VerificationCode"> | Date | string
    used_at?: DateTimeNullableFilter<"VerificationCode"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VerificationCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    user_id?: SortOrder
    doctor_id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
  }

  export type VerificationCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    OR?: VerificationCodeWhereInput[]
    NOT?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    code?: StringFilter<"VerificationCode"> | string
    user_id?: StringFilter<"VerificationCode"> | string
    doctor_id?: StringFilter<"VerificationCode"> | string
    type?: StringFilter<"VerificationCode"> | string
    created_at?: DateTimeFilter<"VerificationCode"> | Date | string
    expires_at?: DateTimeFilter<"VerificationCode"> | Date | string
    used_at?: DateTimeNullableFilter<"VerificationCode"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VerificationCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    user_id?: SortOrder
    doctor_id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    _count?: VerificationCodeCountOrderByAggregateInput
    _max?: VerificationCodeMaxOrderByAggregateInput
    _min?: VerificationCodeMinOrderByAggregateInput
  }

  export type VerificationCodeScalarWhereWithAggregatesInput = {
    AND?: VerificationCodeScalarWhereWithAggregatesInput | VerificationCodeScalarWhereWithAggregatesInput[]
    OR?: VerificationCodeScalarWhereWithAggregatesInput[]
    NOT?: VerificationCodeScalarWhereWithAggregatesInput | VerificationCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationCode"> | string
    code?: StringWithAggregatesFilter<"VerificationCode"> | string
    user_id?: StringWithAggregatesFilter<"VerificationCode"> | string
    doctor_id?: StringWithAggregatesFilter<"VerificationCode"> | string
    type?: StringWithAggregatesFilter<"VerificationCode"> | string
    created_at?: DateTimeWithAggregatesFilter<"VerificationCode"> | Date | string
    expires_at?: DateTimeWithAggregatesFilter<"VerificationCode"> | Date | string
    used_at?: DateTimeNullableWithAggregatesFilter<"VerificationCode"> | Date | string | null
  }

  export type PatientProfileWhereInput = {
    AND?: PatientProfileWhereInput | PatientProfileWhereInput[]
    OR?: PatientProfileWhereInput[]
    NOT?: PatientProfileWhereInput | PatientProfileWhereInput[]
    id?: StringFilter<"PatientProfile"> | string
    doctorId?: StringFilter<"PatientProfile"> | string
    userId?: StringFilter<"PatientProfile"> | string
    name?: StringNullableFilter<"PatientProfile"> | string | null
    phone?: StringNullableFilter<"PatientProfile"> | string | null
    address?: StringNullableFilter<"PatientProfile"> | string | null
    emergency_contact?: StringNullableFilter<"PatientProfile"> | string | null
    emergency_phone?: StringNullableFilter<"PatientProfile"> | string | null
    medical_history?: StringNullableFilter<"PatientProfile"> | string | null
    allergies?: StringNullableFilter<"PatientProfile"> | string | null
    medications?: StringNullableFilter<"PatientProfile"> | string | null
    notes?: StringNullableFilter<"PatientProfile"> | string | null
    isActive?: BoolFilter<"PatientProfile"> | boolean
    createdAt?: DateTimeFilter<"PatientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PatientProfile"> | Date | string
    totalPoints?: IntFilter<"PatientProfile"> | number
    currentPoints?: IntFilter<"PatientProfile"> | number
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<UserScalarRelationFilter, UserWhereInput>
    pointsLedger?: PointsLedgerListRelationFilter
  }

  export type PatientProfileOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    emergency_contact?: SortOrderInput | SortOrder
    emergency_phone?: SortOrderInput | SortOrder
    medical_history?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalPoints?: SortOrder
    currentPoints?: SortOrder
    doctor?: UserOrderByWithRelationInput
    patient?: UserOrderByWithRelationInput
    pointsLedger?: PointsLedgerOrderByRelationAggregateInput
  }

  export type PatientProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    doctorId_userId?: PatientProfileDoctorIdUserIdCompoundUniqueInput
    AND?: PatientProfileWhereInput | PatientProfileWhereInput[]
    OR?: PatientProfileWhereInput[]
    NOT?: PatientProfileWhereInput | PatientProfileWhereInput[]
    doctorId?: StringFilter<"PatientProfile"> | string
    userId?: StringFilter<"PatientProfile"> | string
    name?: StringNullableFilter<"PatientProfile"> | string | null
    phone?: StringNullableFilter<"PatientProfile"> | string | null
    address?: StringNullableFilter<"PatientProfile"> | string | null
    emergency_contact?: StringNullableFilter<"PatientProfile"> | string | null
    emergency_phone?: StringNullableFilter<"PatientProfile"> | string | null
    medical_history?: StringNullableFilter<"PatientProfile"> | string | null
    allergies?: StringNullableFilter<"PatientProfile"> | string | null
    medications?: StringNullableFilter<"PatientProfile"> | string | null
    notes?: StringNullableFilter<"PatientProfile"> | string | null
    isActive?: BoolFilter<"PatientProfile"> | boolean
    createdAt?: DateTimeFilter<"PatientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PatientProfile"> | Date | string
    totalPoints?: IntFilter<"PatientProfile"> | number
    currentPoints?: IntFilter<"PatientProfile"> | number
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<UserScalarRelationFilter, UserWhereInput>
    pointsLedger?: PointsLedgerListRelationFilter
  }, "id" | "doctorId_userId">

  export type PatientProfileOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    emergency_contact?: SortOrderInput | SortOrder
    emergency_phone?: SortOrderInput | SortOrder
    medical_history?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalPoints?: SortOrder
    currentPoints?: SortOrder
    _count?: PatientProfileCountOrderByAggregateInput
    _avg?: PatientProfileAvgOrderByAggregateInput
    _max?: PatientProfileMaxOrderByAggregateInput
    _min?: PatientProfileMinOrderByAggregateInput
    _sum?: PatientProfileSumOrderByAggregateInput
  }

  export type PatientProfileScalarWhereWithAggregatesInput = {
    AND?: PatientProfileScalarWhereWithAggregatesInput | PatientProfileScalarWhereWithAggregatesInput[]
    OR?: PatientProfileScalarWhereWithAggregatesInput[]
    NOT?: PatientProfileScalarWhereWithAggregatesInput | PatientProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatientProfile"> | string
    doctorId?: StringWithAggregatesFilter<"PatientProfile"> | string
    userId?: StringWithAggregatesFilter<"PatientProfile"> | string
    name?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    address?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    emergency_contact?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    emergency_phone?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    medical_history?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    medications?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    notes?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    isActive?: BoolWithAggregatesFilter<"PatientProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PatientProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PatientProfile"> | Date | string
    totalPoints?: IntWithAggregatesFilter<"PatientProfile"> | number
    currentPoints?: IntWithAggregatesFilter<"PatientProfile"> | number
  }

  export type PointsLedgerWhereInput = {
    AND?: PointsLedgerWhereInput | PointsLedgerWhereInput[]
    OR?: PointsLedgerWhereInput[]
    NOT?: PointsLedgerWhereInput | PointsLedgerWhereInput[]
    id?: StringFilter<"PointsLedger"> | string
    userId?: StringFilter<"PointsLedger"> | string
    patientProfileId?: StringNullableFilter<"PointsLedger"> | string | null
    sourceType?: StringFilter<"PointsLedger"> | string
    sourceId?: StringFilter<"PointsLedger"> | string
    amount?: DecimalFilter<"PointsLedger"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"PointsLedger"> | string | null
    createdAt?: DateTimeFilter<"PointsLedger"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    patientProfile?: XOR<PatientProfileNullableScalarRelationFilter, PatientProfileWhereInput> | null
  }

  export type PointsLedgerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    patientProfileId?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    patientProfile?: PatientProfileOrderByWithRelationInput
  }

  export type PointsLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PointsLedgerWhereInput | PointsLedgerWhereInput[]
    OR?: PointsLedgerWhereInput[]
    NOT?: PointsLedgerWhereInput | PointsLedgerWhereInput[]
    userId?: StringFilter<"PointsLedger"> | string
    patientProfileId?: StringNullableFilter<"PointsLedger"> | string | null
    sourceType?: StringFilter<"PointsLedger"> | string
    sourceId?: StringFilter<"PointsLedger"> | string
    amount?: DecimalFilter<"PointsLedger"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"PointsLedger"> | string | null
    createdAt?: DateTimeFilter<"PointsLedger"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    patientProfile?: XOR<PatientProfileNullableScalarRelationFilter, PatientProfileWhereInput> | null
  }, "id">

  export type PointsLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    patientProfileId?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PointsLedgerCountOrderByAggregateInput
    _avg?: PointsLedgerAvgOrderByAggregateInput
    _max?: PointsLedgerMaxOrderByAggregateInput
    _min?: PointsLedgerMinOrderByAggregateInput
    _sum?: PointsLedgerSumOrderByAggregateInput
  }

  export type PointsLedgerScalarWhereWithAggregatesInput = {
    AND?: PointsLedgerScalarWhereWithAggregatesInput | PointsLedgerScalarWhereWithAggregatesInput[]
    OR?: PointsLedgerScalarWhereWithAggregatesInput[]
    NOT?: PointsLedgerScalarWhereWithAggregatesInput | PointsLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointsLedger"> | string
    userId?: StringWithAggregatesFilter<"PointsLedger"> | string
    patientProfileId?: StringNullableWithAggregatesFilter<"PointsLedger"> | string | null
    sourceType?: StringWithAggregatesFilter<"PointsLedger"> | string
    sourceId?: StringWithAggregatesFilter<"PointsLedger"> | string
    amount?: DecimalWithAggregatesFilter<"PointsLedger"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"PointsLedger"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PointsLedger"> | Date | string
  }

  export type ClinicWhereInput = {
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    id?: StringFilter<"Clinic"> | string
    name?: StringFilter<"Clinic"> | string
    description?: StringNullableFilter<"Clinic"> | string | null
    ownerId?: StringFilter<"Clinic"> | string
    isActive?: BoolFilter<"Clinic"> | boolean
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
    email?: StringNullableFilter<"Clinic"> | string | null
    phone?: StringNullableFilter<"Clinic"> | string | null
    address?: StringNullableFilter<"Clinic"> | string | null
    city?: StringNullableFilter<"Clinic"> | string | null
    state?: StringNullableFilter<"Clinic"> | string | null
    zipCode?: StringNullableFilter<"Clinic"> | string | null
    country?: StringNullableFilter<"Clinic"> | string | null
    website?: StringNullableFilter<"Clinic"> | string | null
    logo?: StringNullableFilter<"Clinic"> | string | null
    slug?: StringNullableFilter<"Clinic"> | string | null
    subdomain?: StringNullableFilter<"Clinic"> | string | null
    monthlyRevenueRange?: StringNullableFilter<"Clinic"> | string | null
    currentGateway?: StringNullableFilter<"Clinic"> | string | null
    theme?: EnumClinicThemeFilter<"Clinic"> | $Enums.ClinicTheme
    buttonColor?: StringNullableFilter<"Clinic"> | string | null
    buttonTextColor?: StringNullableFilter<"Clinic"> | string | null
    members?: ClinicMemberListRelationFilter
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    subscriptions?: ClinicSubscriptionListRelationFilter
    products?: ProductListRelationFilter
    merchant?: XOR<MerchantNullableScalarRelationFilter, MerchantWhereInput> | null
    merchantApplication?: XOR<MerchantApplicationNullableScalarRelationFilter, MerchantApplicationWhereInput> | null
    webhookEndpoints?: WebhookEndpointListRelationFilter
    outboundEvents?: OutboundWebhookEventListRelationFilter
  }

  export type ClinicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    subdomain?: SortOrderInput | SortOrder
    monthlyRevenueRange?: SortOrderInput | SortOrder
    currentGateway?: SortOrderInput | SortOrder
    theme?: SortOrder
    buttonColor?: SortOrderInput | SortOrder
    buttonTextColor?: SortOrderInput | SortOrder
    members?: ClinicMemberOrderByRelationAggregateInput
    owner?: UserOrderByWithRelationInput
    subscriptions?: ClinicSubscriptionOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    merchant?: MerchantOrderByWithRelationInput
    merchantApplication?: MerchantApplicationOrderByWithRelationInput
    webhookEndpoints?: WebhookEndpointOrderByRelationAggregateInput
    outboundEvents?: OutboundWebhookEventOrderByRelationAggregateInput
  }

  export type ClinicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    subdomain?: string
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    name?: StringFilter<"Clinic"> | string
    description?: StringNullableFilter<"Clinic"> | string | null
    ownerId?: StringFilter<"Clinic"> | string
    isActive?: BoolFilter<"Clinic"> | boolean
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
    email?: StringNullableFilter<"Clinic"> | string | null
    phone?: StringNullableFilter<"Clinic"> | string | null
    address?: StringNullableFilter<"Clinic"> | string | null
    city?: StringNullableFilter<"Clinic"> | string | null
    state?: StringNullableFilter<"Clinic"> | string | null
    zipCode?: StringNullableFilter<"Clinic"> | string | null
    country?: StringNullableFilter<"Clinic"> | string | null
    website?: StringNullableFilter<"Clinic"> | string | null
    logo?: StringNullableFilter<"Clinic"> | string | null
    monthlyRevenueRange?: StringNullableFilter<"Clinic"> | string | null
    currentGateway?: StringNullableFilter<"Clinic"> | string | null
    theme?: EnumClinicThemeFilter<"Clinic"> | $Enums.ClinicTheme
    buttonColor?: StringNullableFilter<"Clinic"> | string | null
    buttonTextColor?: StringNullableFilter<"Clinic"> | string | null
    members?: ClinicMemberListRelationFilter
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    subscriptions?: ClinicSubscriptionListRelationFilter
    products?: ProductListRelationFilter
    merchant?: XOR<MerchantNullableScalarRelationFilter, MerchantWhereInput> | null
    merchantApplication?: XOR<MerchantApplicationNullableScalarRelationFilter, MerchantApplicationWhereInput> | null
    webhookEndpoints?: WebhookEndpointListRelationFilter
    outboundEvents?: OutboundWebhookEventListRelationFilter
  }, "id" | "slug" | "subdomain">

  export type ClinicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    subdomain?: SortOrderInput | SortOrder
    monthlyRevenueRange?: SortOrderInput | SortOrder
    currentGateway?: SortOrderInput | SortOrder
    theme?: SortOrder
    buttonColor?: SortOrderInput | SortOrder
    buttonTextColor?: SortOrderInput | SortOrder
    _count?: ClinicCountOrderByAggregateInput
    _max?: ClinicMaxOrderByAggregateInput
    _min?: ClinicMinOrderByAggregateInput
  }

  export type ClinicScalarWhereWithAggregatesInput = {
    AND?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    OR?: ClinicScalarWhereWithAggregatesInput[]
    NOT?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Clinic"> | string
    name?: StringWithAggregatesFilter<"Clinic"> | string
    description?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    ownerId?: StringWithAggregatesFilter<"Clinic"> | string
    isActive?: BoolWithAggregatesFilter<"Clinic"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string
    email?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    address?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    city?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    state?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    country?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    website?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    slug?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    subdomain?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    monthlyRevenueRange?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    currentGateway?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    theme?: EnumClinicThemeWithAggregatesFilter<"Clinic"> | $Enums.ClinicTheme
    buttonColor?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    buttonTextColor?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
  }

  export type ClinicMemberWhereInput = {
    AND?: ClinicMemberWhereInput | ClinicMemberWhereInput[]
    OR?: ClinicMemberWhereInput[]
    NOT?: ClinicMemberWhereInput | ClinicMemberWhereInput[]
    id?: StringFilter<"ClinicMember"> | string
    clinicId?: StringFilter<"ClinicMember"> | string
    userId?: StringFilter<"ClinicMember"> | string
    role?: EnumClinicRoleFilter<"ClinicMember"> | $Enums.ClinicRole
    isActive?: BoolFilter<"ClinicMember"> | boolean
    joinedAt?: DateTimeFilter<"ClinicMember"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClinicMemberOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ClinicMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clinicId_userId?: ClinicMemberClinicIdUserIdCompoundUniqueInput
    AND?: ClinicMemberWhereInput | ClinicMemberWhereInput[]
    OR?: ClinicMemberWhereInput[]
    NOT?: ClinicMemberWhereInput | ClinicMemberWhereInput[]
    clinicId?: StringFilter<"ClinicMember"> | string
    userId?: StringFilter<"ClinicMember"> | string
    role?: EnumClinicRoleFilter<"ClinicMember"> | $Enums.ClinicRole
    isActive?: BoolFilter<"ClinicMember"> | boolean
    joinedAt?: DateTimeFilter<"ClinicMember"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "clinicId_userId">

  export type ClinicMemberOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    _count?: ClinicMemberCountOrderByAggregateInput
    _max?: ClinicMemberMaxOrderByAggregateInput
    _min?: ClinicMemberMinOrderByAggregateInput
  }

  export type ClinicMemberScalarWhereWithAggregatesInput = {
    AND?: ClinicMemberScalarWhereWithAggregatesInput | ClinicMemberScalarWhereWithAggregatesInput[]
    OR?: ClinicMemberScalarWhereWithAggregatesInput[]
    NOT?: ClinicMemberScalarWhereWithAggregatesInput | ClinicMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicMember"> | string
    clinicId?: StringWithAggregatesFilter<"ClinicMember"> | string
    userId?: StringWithAggregatesFilter<"ClinicMember"> | string
    role?: EnumClinicRoleWithAggregatesFilter<"ClinicMember"> | $Enums.ClinicRole
    isActive?: BoolWithAggregatesFilter<"ClinicMember"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"ClinicMember"> | Date | string
  }

  export type MerchantWhereInput = {
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    id?: StringFilter<"Merchant"> | string
    clinicId?: StringFilter<"Merchant"> | string
    status?: EnumMerchantStatusFilter<"Merchant"> | $Enums.MerchantStatus
    recipientId?: StringNullableFilter<"Merchant"> | string | null
    externalAccountId?: StringNullableFilter<"Merchant"> | string | null
    onboardingState?: JsonNullableFilter<"Merchant">
    splitPercent?: IntFilter<"Merchant"> | number
    platformFeeBps?: IntFilter<"Merchant"> | number
    transactionFeeCents?: IntNullableFilter<"Merchant"> | number | null
    transactionFeeType?: StringNullableFilter<"Merchant"> | string | null
    lastSyncAt?: DateTimeNullableFilter<"Merchant"> | Date | string | null
    createdAt?: DateTimeFilter<"Merchant"> | Date | string
    updatedAt?: DateTimeFilter<"Merchant"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    integrations?: MerchantIntegrationListRelationFilter
  }

  export type MerchantOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    status?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    externalAccountId?: SortOrderInput | SortOrder
    onboardingState?: SortOrderInput | SortOrder
    splitPercent?: SortOrder
    platformFeeBps?: SortOrder
    transactionFeeCents?: SortOrderInput | SortOrder
    transactionFeeType?: SortOrderInput | SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    integrations?: MerchantIntegrationOrderByRelationAggregateInput
  }

  export type MerchantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clinicId?: string
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    status?: EnumMerchantStatusFilter<"Merchant"> | $Enums.MerchantStatus
    recipientId?: StringNullableFilter<"Merchant"> | string | null
    externalAccountId?: StringNullableFilter<"Merchant"> | string | null
    onboardingState?: JsonNullableFilter<"Merchant">
    splitPercent?: IntFilter<"Merchant"> | number
    platformFeeBps?: IntFilter<"Merchant"> | number
    transactionFeeCents?: IntNullableFilter<"Merchant"> | number | null
    transactionFeeType?: StringNullableFilter<"Merchant"> | string | null
    lastSyncAt?: DateTimeNullableFilter<"Merchant"> | Date | string | null
    createdAt?: DateTimeFilter<"Merchant"> | Date | string
    updatedAt?: DateTimeFilter<"Merchant"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    integrations?: MerchantIntegrationListRelationFilter
  }, "id" | "clinicId">

  export type MerchantOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    status?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    externalAccountId?: SortOrderInput | SortOrder
    onboardingState?: SortOrderInput | SortOrder
    splitPercent?: SortOrder
    platformFeeBps?: SortOrder
    transactionFeeCents?: SortOrderInput | SortOrder
    transactionFeeType?: SortOrderInput | SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MerchantCountOrderByAggregateInput
    _avg?: MerchantAvgOrderByAggregateInput
    _max?: MerchantMaxOrderByAggregateInput
    _min?: MerchantMinOrderByAggregateInput
    _sum?: MerchantSumOrderByAggregateInput
  }

  export type MerchantScalarWhereWithAggregatesInput = {
    AND?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    OR?: MerchantScalarWhereWithAggregatesInput[]
    NOT?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Merchant"> | string
    clinicId?: StringWithAggregatesFilter<"Merchant"> | string
    status?: EnumMerchantStatusWithAggregatesFilter<"Merchant"> | $Enums.MerchantStatus
    recipientId?: StringNullableWithAggregatesFilter<"Merchant"> | string | null
    externalAccountId?: StringNullableWithAggregatesFilter<"Merchant"> | string | null
    onboardingState?: JsonNullableWithAggregatesFilter<"Merchant">
    splitPercent?: IntWithAggregatesFilter<"Merchant"> | number
    platformFeeBps?: IntWithAggregatesFilter<"Merchant"> | number
    transactionFeeCents?: IntNullableWithAggregatesFilter<"Merchant"> | number | null
    transactionFeeType?: StringNullableWithAggregatesFilter<"Merchant"> | string | null
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"Merchant"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Merchant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Merchant"> | Date | string
  }

  export type MerchantApplicationWhereInput = {
    AND?: MerchantApplicationWhereInput | MerchantApplicationWhereInput[]
    OR?: MerchantApplicationWhereInput[]
    NOT?: MerchantApplicationWhereInput | MerchantApplicationWhereInput[]
    id?: StringFilter<"MerchantApplication"> | string
    clinicId?: StringFilter<"MerchantApplication"> | string
    type?: EnumMerchantTypeFilter<"MerchantApplication"> | $Enums.MerchantType
    businessName?: StringNullableFilter<"MerchantApplication"> | string | null
    fullName?: StringNullableFilter<"MerchantApplication"> | string | null
    documentNumber?: StringNullableFilter<"MerchantApplication"> | string | null
    email?: StringNullableFilter<"MerchantApplication"> | string | null
    phone?: StringNullableFilter<"MerchantApplication"> | string | null
    address?: JsonNullableFilter<"MerchantApplication">
    bankAccount?: JsonNullableFilter<"MerchantApplication">
    recipientId?: StringNullableFilter<"MerchantApplication"> | string | null
    status?: EnumMerchantAppStatusFilter<"MerchantApplication"> | $Enums.MerchantAppStatus
    reviewNotes?: StringNullableFilter<"MerchantApplication"> | string | null
    reviewedBy?: StringNullableFilter<"MerchantApplication"> | string | null
    reviewedAt?: DateTimeNullableFilter<"MerchantApplication"> | Date | string | null
    createdAt?: DateTimeFilter<"MerchantApplication"> | Date | string
    updatedAt?: DateTimeFilter<"MerchantApplication"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    documents?: MerchantDocumentListRelationFilter
  }

  export type MerchantApplicationOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    businessName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    documentNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    recipientId?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    documents?: MerchantDocumentOrderByRelationAggregateInput
  }

  export type MerchantApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clinicId?: string
    AND?: MerchantApplicationWhereInput | MerchantApplicationWhereInput[]
    OR?: MerchantApplicationWhereInput[]
    NOT?: MerchantApplicationWhereInput | MerchantApplicationWhereInput[]
    type?: EnumMerchantTypeFilter<"MerchantApplication"> | $Enums.MerchantType
    businessName?: StringNullableFilter<"MerchantApplication"> | string | null
    fullName?: StringNullableFilter<"MerchantApplication"> | string | null
    documentNumber?: StringNullableFilter<"MerchantApplication"> | string | null
    email?: StringNullableFilter<"MerchantApplication"> | string | null
    phone?: StringNullableFilter<"MerchantApplication"> | string | null
    address?: JsonNullableFilter<"MerchantApplication">
    bankAccount?: JsonNullableFilter<"MerchantApplication">
    recipientId?: StringNullableFilter<"MerchantApplication"> | string | null
    status?: EnumMerchantAppStatusFilter<"MerchantApplication"> | $Enums.MerchantAppStatus
    reviewNotes?: StringNullableFilter<"MerchantApplication"> | string | null
    reviewedBy?: StringNullableFilter<"MerchantApplication"> | string | null
    reviewedAt?: DateTimeNullableFilter<"MerchantApplication"> | Date | string | null
    createdAt?: DateTimeFilter<"MerchantApplication"> | Date | string
    updatedAt?: DateTimeFilter<"MerchantApplication"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    documents?: MerchantDocumentListRelationFilter
  }, "id" | "clinicId">

  export type MerchantApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    businessName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    documentNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    recipientId?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MerchantApplicationCountOrderByAggregateInput
    _max?: MerchantApplicationMaxOrderByAggregateInput
    _min?: MerchantApplicationMinOrderByAggregateInput
  }

  export type MerchantApplicationScalarWhereWithAggregatesInput = {
    AND?: MerchantApplicationScalarWhereWithAggregatesInput | MerchantApplicationScalarWhereWithAggregatesInput[]
    OR?: MerchantApplicationScalarWhereWithAggregatesInput[]
    NOT?: MerchantApplicationScalarWhereWithAggregatesInput | MerchantApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MerchantApplication"> | string
    clinicId?: StringWithAggregatesFilter<"MerchantApplication"> | string
    type?: EnumMerchantTypeWithAggregatesFilter<"MerchantApplication"> | $Enums.MerchantType
    businessName?: StringNullableWithAggregatesFilter<"MerchantApplication"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"MerchantApplication"> | string | null
    documentNumber?: StringNullableWithAggregatesFilter<"MerchantApplication"> | string | null
    email?: StringNullableWithAggregatesFilter<"MerchantApplication"> | string | null
    phone?: StringNullableWithAggregatesFilter<"MerchantApplication"> | string | null
    address?: JsonNullableWithAggregatesFilter<"MerchantApplication">
    bankAccount?: JsonNullableWithAggregatesFilter<"MerchantApplication">
    recipientId?: StringNullableWithAggregatesFilter<"MerchantApplication"> | string | null
    status?: EnumMerchantAppStatusWithAggregatesFilter<"MerchantApplication"> | $Enums.MerchantAppStatus
    reviewNotes?: StringNullableWithAggregatesFilter<"MerchantApplication"> | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"MerchantApplication"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"MerchantApplication"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MerchantApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MerchantApplication"> | Date | string
  }

  export type MerchantDocumentWhereInput = {
    AND?: MerchantDocumentWhereInput | MerchantDocumentWhereInput[]
    OR?: MerchantDocumentWhereInput[]
    NOT?: MerchantDocumentWhereInput | MerchantDocumentWhereInput[]
    id?: StringFilter<"MerchantDocument"> | string
    applicationId?: StringFilter<"MerchantDocument"> | string
    type?: EnumDocumentTypeFilter<"MerchantDocument"> | $Enums.DocumentType
    fileUrl?: StringFilter<"MerchantDocument"> | string
    status?: EnumDocumentStatusFilter<"MerchantDocument"> | $Enums.DocumentStatus
    notes?: StringNullableFilter<"MerchantDocument"> | string | null
    uploadedAt?: DateTimeFilter<"MerchantDocument"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"MerchantDocument"> | Date | string | null
    application?: XOR<MerchantApplicationScalarRelationFilter, MerchantApplicationWhereInput>
  }

  export type MerchantDocumentOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    application?: MerchantApplicationOrderByWithRelationInput
  }

  export type MerchantDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MerchantDocumentWhereInput | MerchantDocumentWhereInput[]
    OR?: MerchantDocumentWhereInput[]
    NOT?: MerchantDocumentWhereInput | MerchantDocumentWhereInput[]
    applicationId?: StringFilter<"MerchantDocument"> | string
    type?: EnumDocumentTypeFilter<"MerchantDocument"> | $Enums.DocumentType
    fileUrl?: StringFilter<"MerchantDocument"> | string
    status?: EnumDocumentStatusFilter<"MerchantDocument"> | $Enums.DocumentStatus
    notes?: StringNullableFilter<"MerchantDocument"> | string | null
    uploadedAt?: DateTimeFilter<"MerchantDocument"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"MerchantDocument"> | Date | string | null
    application?: XOR<MerchantApplicationScalarRelationFilter, MerchantApplicationWhereInput>
  }, "id">

  export type MerchantDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    _count?: MerchantDocumentCountOrderByAggregateInput
    _max?: MerchantDocumentMaxOrderByAggregateInput
    _min?: MerchantDocumentMinOrderByAggregateInput
  }

  export type MerchantDocumentScalarWhereWithAggregatesInput = {
    AND?: MerchantDocumentScalarWhereWithAggregatesInput | MerchantDocumentScalarWhereWithAggregatesInput[]
    OR?: MerchantDocumentScalarWhereWithAggregatesInput[]
    NOT?: MerchantDocumentScalarWhereWithAggregatesInput | MerchantDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MerchantDocument"> | string
    applicationId?: StringWithAggregatesFilter<"MerchantDocument"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"MerchantDocument"> | $Enums.DocumentType
    fileUrl?: StringWithAggregatesFilter<"MerchantDocument"> | string
    status?: EnumDocumentStatusWithAggregatesFilter<"MerchantDocument"> | $Enums.DocumentStatus
    notes?: StringNullableWithAggregatesFilter<"MerchantDocument"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"MerchantDocument"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"MerchantDocument"> | Date | string | null
  }

  export type MerchantIntegrationWhereInput = {
    AND?: MerchantIntegrationWhereInput | MerchantIntegrationWhereInput[]
    OR?: MerchantIntegrationWhereInput[]
    NOT?: MerchantIntegrationWhereInput | MerchantIntegrationWhereInput[]
    id?: StringFilter<"MerchantIntegration"> | string
    merchantId?: StringFilter<"MerchantIntegration"> | string
    provider?: EnumPaymentProviderFilter<"MerchantIntegration"> | $Enums.PaymentProvider
    credentials?: JsonFilter<"MerchantIntegration">
    config?: JsonNullableFilter<"MerchantIntegration">
    isActive?: BoolFilter<"MerchantIntegration"> | boolean
    isPrimary?: BoolFilter<"MerchantIntegration"> | boolean
    connectedAt?: DateTimeFilter<"MerchantIntegration"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"MerchantIntegration"> | Date | string | null
    lastError?: StringNullableFilter<"MerchantIntegration"> | string | null
    lastErrorAt?: DateTimeNullableFilter<"MerchantIntegration"> | Date | string | null
    merchant?: XOR<MerchantScalarRelationFilter, MerchantWhereInput>
  }

  export type MerchantIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    config?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    connectedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    lastErrorAt?: SortOrderInput | SortOrder
    merchant?: MerchantOrderByWithRelationInput
  }

  export type MerchantIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    merchantId_provider?: MerchantIntegrationMerchantIdProviderCompoundUniqueInput
    AND?: MerchantIntegrationWhereInput | MerchantIntegrationWhereInput[]
    OR?: MerchantIntegrationWhereInput[]
    NOT?: MerchantIntegrationWhereInput | MerchantIntegrationWhereInput[]
    merchantId?: StringFilter<"MerchantIntegration"> | string
    provider?: EnumPaymentProviderFilter<"MerchantIntegration"> | $Enums.PaymentProvider
    credentials?: JsonFilter<"MerchantIntegration">
    config?: JsonNullableFilter<"MerchantIntegration">
    isActive?: BoolFilter<"MerchantIntegration"> | boolean
    isPrimary?: BoolFilter<"MerchantIntegration"> | boolean
    connectedAt?: DateTimeFilter<"MerchantIntegration"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"MerchantIntegration"> | Date | string | null
    lastError?: StringNullableFilter<"MerchantIntegration"> | string | null
    lastErrorAt?: DateTimeNullableFilter<"MerchantIntegration"> | Date | string | null
    merchant?: XOR<MerchantScalarRelationFilter, MerchantWhereInput>
  }, "id" | "merchantId_provider">

  export type MerchantIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    config?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    connectedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    lastErrorAt?: SortOrderInput | SortOrder
    _count?: MerchantIntegrationCountOrderByAggregateInput
    _max?: MerchantIntegrationMaxOrderByAggregateInput
    _min?: MerchantIntegrationMinOrderByAggregateInput
  }

  export type MerchantIntegrationScalarWhereWithAggregatesInput = {
    AND?: MerchantIntegrationScalarWhereWithAggregatesInput | MerchantIntegrationScalarWhereWithAggregatesInput[]
    OR?: MerchantIntegrationScalarWhereWithAggregatesInput[]
    NOT?: MerchantIntegrationScalarWhereWithAggregatesInput | MerchantIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MerchantIntegration"> | string
    merchantId?: StringWithAggregatesFilter<"MerchantIntegration"> | string
    provider?: EnumPaymentProviderWithAggregatesFilter<"MerchantIntegration"> | $Enums.PaymentProvider
    credentials?: JsonWithAggregatesFilter<"MerchantIntegration">
    config?: JsonNullableWithAggregatesFilter<"MerchantIntegration">
    isActive?: BoolWithAggregatesFilter<"MerchantIntegration"> | boolean
    isPrimary?: BoolWithAggregatesFilter<"MerchantIntegration"> | boolean
    connectedAt?: DateTimeWithAggregatesFilter<"MerchantIntegration"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"MerchantIntegration"> | Date | string | null
    lastError?: StringNullableWithAggregatesFilter<"MerchantIntegration"> | string | null
    lastErrorAt?: DateTimeNullableWithAggregatesFilter<"MerchantIntegration"> | Date | string | null
  }

  export type PaymentRoutingRuleWhereInput = {
    AND?: PaymentRoutingRuleWhereInput | PaymentRoutingRuleWhereInput[]
    OR?: PaymentRoutingRuleWhereInput[]
    NOT?: PaymentRoutingRuleWhereInput | PaymentRoutingRuleWhereInput[]
    id?: StringFilter<"PaymentRoutingRule"> | string
    merchantId?: StringFilter<"PaymentRoutingRule"> | string
    productId?: StringNullableFilter<"PaymentRoutingRule"> | string | null
    offerId?: StringNullableFilter<"PaymentRoutingRule"> | string | null
    country?: StringNullableFilter<"PaymentRoutingRule"> | string | null
    method?: EnumPaymentMethodNullableFilter<"PaymentRoutingRule"> | $Enums.PaymentMethod | null
    provider?: EnumPaymentProviderFilter<"PaymentRoutingRule"> | $Enums.PaymentProvider
    priority?: IntFilter<"PaymentRoutingRule"> | number
    isActive?: BoolFilter<"PaymentRoutingRule"> | boolean
    createdAt?: DateTimeFilter<"PaymentRoutingRule"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentRoutingRule"> | Date | string
  }

  export type PaymentRoutingRuleOrderByWithRelationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrderInput | SortOrder
    offerId?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    provider?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRoutingRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentRoutingRuleWhereInput | PaymentRoutingRuleWhereInput[]
    OR?: PaymentRoutingRuleWhereInput[]
    NOT?: PaymentRoutingRuleWhereInput | PaymentRoutingRuleWhereInput[]
    merchantId?: StringFilter<"PaymentRoutingRule"> | string
    productId?: StringNullableFilter<"PaymentRoutingRule"> | string | null
    offerId?: StringNullableFilter<"PaymentRoutingRule"> | string | null
    country?: StringNullableFilter<"PaymentRoutingRule"> | string | null
    method?: EnumPaymentMethodNullableFilter<"PaymentRoutingRule"> | $Enums.PaymentMethod | null
    provider?: EnumPaymentProviderFilter<"PaymentRoutingRule"> | $Enums.PaymentProvider
    priority?: IntFilter<"PaymentRoutingRule"> | number
    isActive?: BoolFilter<"PaymentRoutingRule"> | boolean
    createdAt?: DateTimeFilter<"PaymentRoutingRule"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentRoutingRule"> | Date | string
  }, "id">

  export type PaymentRoutingRuleOrderByWithAggregationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrderInput | SortOrder
    offerId?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    provider?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentRoutingRuleCountOrderByAggregateInput
    _avg?: PaymentRoutingRuleAvgOrderByAggregateInput
    _max?: PaymentRoutingRuleMaxOrderByAggregateInput
    _min?: PaymentRoutingRuleMinOrderByAggregateInput
    _sum?: PaymentRoutingRuleSumOrderByAggregateInput
  }

  export type PaymentRoutingRuleScalarWhereWithAggregatesInput = {
    AND?: PaymentRoutingRuleScalarWhereWithAggregatesInput | PaymentRoutingRuleScalarWhereWithAggregatesInput[]
    OR?: PaymentRoutingRuleScalarWhereWithAggregatesInput[]
    NOT?: PaymentRoutingRuleScalarWhereWithAggregatesInput | PaymentRoutingRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentRoutingRule"> | string
    merchantId?: StringWithAggregatesFilter<"PaymentRoutingRule"> | string
    productId?: StringNullableWithAggregatesFilter<"PaymentRoutingRule"> | string | null
    offerId?: StringNullableWithAggregatesFilter<"PaymentRoutingRule"> | string | null
    country?: StringNullableWithAggregatesFilter<"PaymentRoutingRule"> | string | null
    method?: EnumPaymentMethodNullableWithAggregatesFilter<"PaymentRoutingRule"> | $Enums.PaymentMethod | null
    provider?: EnumPaymentProviderWithAggregatesFilter<"PaymentRoutingRule"> | $Enums.PaymentProvider
    priority?: IntWithAggregatesFilter<"PaymentRoutingRule"> | number
    isActive?: BoolWithAggregatesFilter<"PaymentRoutingRule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentRoutingRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentRoutingRule"> | Date | string
  }

  export type ClinicPlanWhereInput = {
    AND?: ClinicPlanWhereInput | ClinicPlanWhereInput[]
    OR?: ClinicPlanWhereInput[]
    NOT?: ClinicPlanWhereInput | ClinicPlanWhereInput[]
    id?: StringFilter<"ClinicPlan"> | string
    name?: StringFilter<"ClinicPlan"> | string
    tier?: EnumPlanTierFilter<"ClinicPlan"> | $Enums.PlanTier
    description?: StringNullableFilter<"ClinicPlan"> | string | null
    monthlyPrice?: DecimalFilter<"ClinicPlan"> | Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: IntFilter<"ClinicPlan"> | number
    features?: JsonFilter<"ClinicPlan">
    trialDays?: IntFilter<"ClinicPlan"> | number
    requireCard?: BoolFilter<"ClinicPlan"> | boolean
    isActive?: BoolFilter<"ClinicPlan"> | boolean
    isPublic?: BoolFilter<"ClinicPlan"> | boolean
    createdAt?: DateTimeFilter<"ClinicPlan"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicPlan"> | Date | string
    subscriptions?: ClinicSubscriptionListRelationFilter
  }

  export type ClinicPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tier?: SortOrder
    description?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrder
    monthlyTxLimit?: SortOrder
    features?: SortOrder
    trialDays?: SortOrder
    requireCard?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: ClinicSubscriptionOrderByRelationAggregateInput
  }

  export type ClinicPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicPlanWhereInput | ClinicPlanWhereInput[]
    OR?: ClinicPlanWhereInput[]
    NOT?: ClinicPlanWhereInput | ClinicPlanWhereInput[]
    name?: StringFilter<"ClinicPlan"> | string
    tier?: EnumPlanTierFilter<"ClinicPlan"> | $Enums.PlanTier
    description?: StringNullableFilter<"ClinicPlan"> | string | null
    monthlyPrice?: DecimalFilter<"ClinicPlan"> | Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: IntFilter<"ClinicPlan"> | number
    features?: JsonFilter<"ClinicPlan">
    trialDays?: IntFilter<"ClinicPlan"> | number
    requireCard?: BoolFilter<"ClinicPlan"> | boolean
    isActive?: BoolFilter<"ClinicPlan"> | boolean
    isPublic?: BoolFilter<"ClinicPlan"> | boolean
    createdAt?: DateTimeFilter<"ClinicPlan"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicPlan"> | Date | string
    subscriptions?: ClinicSubscriptionListRelationFilter
  }, "id">

  export type ClinicPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tier?: SortOrder
    description?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrder
    monthlyTxLimit?: SortOrder
    features?: SortOrder
    trialDays?: SortOrder
    requireCard?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicPlanCountOrderByAggregateInput
    _avg?: ClinicPlanAvgOrderByAggregateInput
    _max?: ClinicPlanMaxOrderByAggregateInput
    _min?: ClinicPlanMinOrderByAggregateInput
    _sum?: ClinicPlanSumOrderByAggregateInput
  }

  export type ClinicPlanScalarWhereWithAggregatesInput = {
    AND?: ClinicPlanScalarWhereWithAggregatesInput | ClinicPlanScalarWhereWithAggregatesInput[]
    OR?: ClinicPlanScalarWhereWithAggregatesInput[]
    NOT?: ClinicPlanScalarWhereWithAggregatesInput | ClinicPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicPlan"> | string
    name?: StringWithAggregatesFilter<"ClinicPlan"> | string
    tier?: EnumPlanTierWithAggregatesFilter<"ClinicPlan"> | $Enums.PlanTier
    description?: StringNullableWithAggregatesFilter<"ClinicPlan"> | string | null
    monthlyPrice?: DecimalWithAggregatesFilter<"ClinicPlan"> | Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: IntWithAggregatesFilter<"ClinicPlan"> | number
    features?: JsonWithAggregatesFilter<"ClinicPlan">
    trialDays?: IntWithAggregatesFilter<"ClinicPlan"> | number
    requireCard?: BoolWithAggregatesFilter<"ClinicPlan"> | boolean
    isActive?: BoolWithAggregatesFilter<"ClinicPlan"> | boolean
    isPublic?: BoolWithAggregatesFilter<"ClinicPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ClinicPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClinicPlan"> | Date | string
  }

  export type ClinicAddOnWhereInput = {
    AND?: ClinicAddOnWhereInput | ClinicAddOnWhereInput[]
    OR?: ClinicAddOnWhereInput[]
    NOT?: ClinicAddOnWhereInput | ClinicAddOnWhereInput[]
    id?: StringFilter<"ClinicAddOn"> | string
    type?: EnumAddOnTypeFilter<"ClinicAddOn"> | $Enums.AddOnType
    name?: StringFilter<"ClinicAddOn"> | string
    description?: StringNullableFilter<"ClinicAddOn"> | string | null
    monthlyPrice?: DecimalFilter<"ClinicAddOn"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"ClinicAddOn"> | number
    isActive?: BoolFilter<"ClinicAddOn"> | boolean
    createdAt?: DateTimeFilter<"ClinicAddOn"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicAddOn"> | Date | string
    subscriptions?: ClinicAddOnSubscriptionListRelationFilter
  }

  export type ClinicAddOnOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: ClinicAddOnSubscriptionOrderByRelationAggregateInput
  }

  export type ClinicAddOnWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicAddOnWhereInput | ClinicAddOnWhereInput[]
    OR?: ClinicAddOnWhereInput[]
    NOT?: ClinicAddOnWhereInput | ClinicAddOnWhereInput[]
    type?: EnumAddOnTypeFilter<"ClinicAddOn"> | $Enums.AddOnType
    name?: StringFilter<"ClinicAddOn"> | string
    description?: StringNullableFilter<"ClinicAddOn"> | string | null
    monthlyPrice?: DecimalFilter<"ClinicAddOn"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"ClinicAddOn"> | number
    isActive?: BoolFilter<"ClinicAddOn"> | boolean
    createdAt?: DateTimeFilter<"ClinicAddOn"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicAddOn"> | Date | string
    subscriptions?: ClinicAddOnSubscriptionListRelationFilter
  }, "id">

  export type ClinicAddOnOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicAddOnCountOrderByAggregateInput
    _avg?: ClinicAddOnAvgOrderByAggregateInput
    _max?: ClinicAddOnMaxOrderByAggregateInput
    _min?: ClinicAddOnMinOrderByAggregateInput
    _sum?: ClinicAddOnSumOrderByAggregateInput
  }

  export type ClinicAddOnScalarWhereWithAggregatesInput = {
    AND?: ClinicAddOnScalarWhereWithAggregatesInput | ClinicAddOnScalarWhereWithAggregatesInput[]
    OR?: ClinicAddOnScalarWhereWithAggregatesInput[]
    NOT?: ClinicAddOnScalarWhereWithAggregatesInput | ClinicAddOnScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicAddOn"> | string
    type?: EnumAddOnTypeWithAggregatesFilter<"ClinicAddOn"> | $Enums.AddOnType
    name?: StringWithAggregatesFilter<"ClinicAddOn"> | string
    description?: StringNullableWithAggregatesFilter<"ClinicAddOn"> | string | null
    monthlyPrice?: DecimalWithAggregatesFilter<"ClinicAddOn"> | Decimal | DecimalJsLike | number | string
    quantity?: IntWithAggregatesFilter<"ClinicAddOn"> | number
    isActive?: BoolWithAggregatesFilter<"ClinicAddOn"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ClinicAddOn"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClinicAddOn"> | Date | string
  }

  export type ClinicSubscriptionWhereInput = {
    AND?: ClinicSubscriptionWhereInput | ClinicSubscriptionWhereInput[]
    OR?: ClinicSubscriptionWhereInput[]
    NOT?: ClinicSubscriptionWhereInput | ClinicSubscriptionWhereInput[]
    id?: StringFilter<"ClinicSubscription"> | string
    clinicId?: StringFilter<"ClinicSubscription"> | string
    planId?: StringFilter<"ClinicSubscription"> | string
    status?: EnumSubscriptionStatusFilter<"ClinicSubscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"ClinicSubscription"> | Date | string
    trialEndsAt?: DateTimeFilter<"ClinicSubscription"> | Date | string
    currentPeriodStart?: DateTimeFilter<"ClinicSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"ClinicSubscription"> | Date | string
    stripeCustomerId?: StringNullableFilter<"ClinicSubscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"ClinicSubscription"> | string | null
    canceledAt?: DateTimeNullableFilter<"ClinicSubscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"ClinicSubscription"> | string | null
    currentDoctorsCount?: IntFilter<"ClinicSubscription"> | number
    currentPatientsCount?: IntFilter<"ClinicSubscription"> | number
    createdAt?: DateTimeFilter<"ClinicSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicSubscription"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    plan?: XOR<ClinicPlanScalarRelationFilter, ClinicPlanWhereInput>
    addOns?: ClinicAddOnSubscriptionListRelationFilter
  }

  export type ClinicSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    currentDoctorsCount?: SortOrder
    currentPatientsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    plan?: ClinicPlanOrderByWithRelationInput
    addOns?: ClinicAddOnSubscriptionOrderByRelationAggregateInput
  }

  export type ClinicSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicSubscriptionWhereInput | ClinicSubscriptionWhereInput[]
    OR?: ClinicSubscriptionWhereInput[]
    NOT?: ClinicSubscriptionWhereInput | ClinicSubscriptionWhereInput[]
    clinicId?: StringFilter<"ClinicSubscription"> | string
    planId?: StringFilter<"ClinicSubscription"> | string
    status?: EnumSubscriptionStatusFilter<"ClinicSubscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"ClinicSubscription"> | Date | string
    trialEndsAt?: DateTimeFilter<"ClinicSubscription"> | Date | string
    currentPeriodStart?: DateTimeFilter<"ClinicSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"ClinicSubscription"> | Date | string
    stripeCustomerId?: StringNullableFilter<"ClinicSubscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"ClinicSubscription"> | string | null
    canceledAt?: DateTimeNullableFilter<"ClinicSubscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"ClinicSubscription"> | string | null
    currentDoctorsCount?: IntFilter<"ClinicSubscription"> | number
    currentPatientsCount?: IntFilter<"ClinicSubscription"> | number
    createdAt?: DateTimeFilter<"ClinicSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicSubscription"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    plan?: XOR<ClinicPlanScalarRelationFilter, ClinicPlanWhereInput>
    addOns?: ClinicAddOnSubscriptionListRelationFilter
  }, "id">

  export type ClinicSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    currentDoctorsCount?: SortOrder
    currentPatientsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicSubscriptionCountOrderByAggregateInput
    _avg?: ClinicSubscriptionAvgOrderByAggregateInput
    _max?: ClinicSubscriptionMaxOrderByAggregateInput
    _min?: ClinicSubscriptionMinOrderByAggregateInput
    _sum?: ClinicSubscriptionSumOrderByAggregateInput
  }

  export type ClinicSubscriptionScalarWhereWithAggregatesInput = {
    AND?: ClinicSubscriptionScalarWhereWithAggregatesInput | ClinicSubscriptionScalarWhereWithAggregatesInput[]
    OR?: ClinicSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: ClinicSubscriptionScalarWhereWithAggregatesInput | ClinicSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicSubscription"> | string
    clinicId?: StringWithAggregatesFilter<"ClinicSubscription"> | string
    planId?: StringWithAggregatesFilter<"ClinicSubscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"ClinicSubscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeWithAggregatesFilter<"ClinicSubscription"> | Date | string
    trialEndsAt?: DateTimeWithAggregatesFilter<"ClinicSubscription"> | Date | string
    currentPeriodStart?: DateTimeWithAggregatesFilter<"ClinicSubscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"ClinicSubscription"> | Date | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"ClinicSubscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"ClinicSubscription"> | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"ClinicSubscription"> | Date | string | null
    cancelReason?: StringNullableWithAggregatesFilter<"ClinicSubscription"> | string | null
    currentDoctorsCount?: IntWithAggregatesFilter<"ClinicSubscription"> | number
    currentPatientsCount?: IntWithAggregatesFilter<"ClinicSubscription"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ClinicSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClinicSubscription"> | Date | string
  }

  export type ClinicAddOnSubscriptionWhereInput = {
    AND?: ClinicAddOnSubscriptionWhereInput | ClinicAddOnSubscriptionWhereInput[]
    OR?: ClinicAddOnSubscriptionWhereInput[]
    NOT?: ClinicAddOnSubscriptionWhereInput | ClinicAddOnSubscriptionWhereInput[]
    id?: StringFilter<"ClinicAddOnSubscription"> | string
    subscriptionId?: StringFilter<"ClinicAddOnSubscription"> | string
    addOnId?: StringFilter<"ClinicAddOnSubscription"> | string
    quantity?: IntFilter<"ClinicAddOnSubscription"> | number
    startDate?: DateTimeFilter<"ClinicAddOnSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"ClinicAddOnSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"ClinicAddOnSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicAddOnSubscription"> | Date | string
    subscription?: XOR<ClinicSubscriptionScalarRelationFilter, ClinicSubscriptionWhereInput>
    addOn?: XOR<ClinicAddOnScalarRelationFilter, ClinicAddOnWhereInput>
  }

  export type ClinicAddOnSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    addOnId?: SortOrder
    quantity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: ClinicSubscriptionOrderByWithRelationInput
    addOn?: ClinicAddOnOrderByWithRelationInput
  }

  export type ClinicAddOnSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicAddOnSubscriptionWhereInput | ClinicAddOnSubscriptionWhereInput[]
    OR?: ClinicAddOnSubscriptionWhereInput[]
    NOT?: ClinicAddOnSubscriptionWhereInput | ClinicAddOnSubscriptionWhereInput[]
    subscriptionId?: StringFilter<"ClinicAddOnSubscription"> | string
    addOnId?: StringFilter<"ClinicAddOnSubscription"> | string
    quantity?: IntFilter<"ClinicAddOnSubscription"> | number
    startDate?: DateTimeFilter<"ClinicAddOnSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"ClinicAddOnSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"ClinicAddOnSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicAddOnSubscription"> | Date | string
    subscription?: XOR<ClinicSubscriptionScalarRelationFilter, ClinicSubscriptionWhereInput>
    addOn?: XOR<ClinicAddOnScalarRelationFilter, ClinicAddOnWhereInput>
  }, "id">

  export type ClinicAddOnSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    addOnId?: SortOrder
    quantity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicAddOnSubscriptionCountOrderByAggregateInput
    _avg?: ClinicAddOnSubscriptionAvgOrderByAggregateInput
    _max?: ClinicAddOnSubscriptionMaxOrderByAggregateInput
    _min?: ClinicAddOnSubscriptionMinOrderByAggregateInput
    _sum?: ClinicAddOnSubscriptionSumOrderByAggregateInput
  }

  export type ClinicAddOnSubscriptionScalarWhereWithAggregatesInput = {
    AND?: ClinicAddOnSubscriptionScalarWhereWithAggregatesInput | ClinicAddOnSubscriptionScalarWhereWithAggregatesInput[]
    OR?: ClinicAddOnSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: ClinicAddOnSubscriptionScalarWhereWithAggregatesInput | ClinicAddOnSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicAddOnSubscription"> | string
    subscriptionId?: StringWithAggregatesFilter<"ClinicAddOnSubscription"> | string
    addOnId?: StringWithAggregatesFilter<"ClinicAddOnSubscription"> | string
    quantity?: IntWithAggregatesFilter<"ClinicAddOnSubscription"> | number
    startDate?: DateTimeWithAggregatesFilter<"ClinicAddOnSubscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"ClinicAddOnSubscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClinicAddOnSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClinicAddOnSubscription"> | Date | string
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    slug?: StringNullableFilter<"ProductCategory"> | string | null
    doctorId?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    products?: ProductListRelationFilter
    categories?: CategoriesOnProductsListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctor?: UserOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    categories?: CategoriesOnProductsOrderByRelationAggregateInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    doctorId_name?: ProductCategoryDoctorIdNameCompoundUniqueInput
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    name?: StringFilter<"ProductCategory"> | string
    doctorId?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    products?: ProductListRelationFilter
    categories?: CategoriesOnProductsListRelationFilter
  }, "id" | "slug" | "doctorId_name">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCategory"> | string
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    slug?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    doctorId?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    subtitle?: StringNullableFilter<"Product"> | string | null
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    priority?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    doctorId?: StringNullableFilter<"Product"> | string | null
    clinicId?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    confirmationUrl?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    interval?: EnumSubscriptionIntervalNullableFilter<"Product"> | $Enums.SubscriptionInterval | null
    intervalCount?: IntNullableFilter<"Product"> | number | null
    trialDays?: IntNullableFilter<"Product"> | number | null
    providerPlanId?: StringNullableFilter<"Product"> | string | null
    providerPlanData?: JsonNullableFilter<"Product">
    autoRenew?: BoolNullableFilter<"Product"> | boolean | null
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    productCategory?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    purchases?: PurchaseListRelationFilter
    categories?: CategoriesOnProductsListRelationFilter
    offers?: OfferListRelationFilter
    integrations?: ProductIntegrationListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    creditsPerUnit?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    confirmationUrl?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    type?: SortOrder
    interval?: SortOrderInput | SortOrder
    intervalCount?: SortOrderInput | SortOrder
    trialDays?: SortOrderInput | SortOrder
    providerPlanId?: SortOrderInput | SortOrder
    providerPlanData?: SortOrderInput | SortOrder
    autoRenew?: SortOrderInput | SortOrder
    doctor?: UserOrderByWithRelationInput
    clinic?: ClinicOrderByWithRelationInput
    productCategory?: ProductCategoryOrderByWithRelationInput
    purchases?: PurchaseOrderByRelationAggregateInput
    categories?: CategoriesOnProductsOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
    integrations?: ProductIntegrationOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    subtitle?: StringNullableFilter<"Product"> | string | null
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    priority?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    doctorId?: StringNullableFilter<"Product"> | string | null
    clinicId?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    confirmationUrl?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    interval?: EnumSubscriptionIntervalNullableFilter<"Product"> | $Enums.SubscriptionInterval | null
    intervalCount?: IntNullableFilter<"Product"> | number | null
    trialDays?: IntNullableFilter<"Product"> | number | null
    providerPlanId?: StringNullableFilter<"Product"> | string | null
    providerPlanData?: JsonNullableFilter<"Product">
    autoRenew?: BoolNullableFilter<"Product"> | boolean | null
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    productCategory?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    purchases?: PurchaseListRelationFilter
    categories?: CategoriesOnProductsListRelationFilter
    offers?: OfferListRelationFilter
    integrations?: ProductIntegrationListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    creditsPerUnit?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    confirmationUrl?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    type?: SortOrder
    interval?: SortOrderInput | SortOrder
    intervalCount?: SortOrderInput | SortOrder
    trialDays?: SortOrderInput | SortOrder
    providerPlanId?: SortOrderInput | SortOrder
    providerPlanData?: SortOrderInput | SortOrder
    autoRenew?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    subtitle?: StringNullableWithAggregatesFilter<"Product"> | string | null
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    category?: StringWithAggregatesFilter<"Product"> | string
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    priority?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    doctorId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    clinicId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    confirmationUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    type?: EnumProductTypeWithAggregatesFilter<"Product"> | $Enums.ProductType
    interval?: EnumSubscriptionIntervalNullableWithAggregatesFilter<"Product"> | $Enums.SubscriptionInterval | null
    intervalCount?: IntNullableWithAggregatesFilter<"Product"> | number | null
    trialDays?: IntNullableWithAggregatesFilter<"Product"> | number | null
    providerPlanId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    providerPlanData?: JsonNullableWithAggregatesFilter<"Product">
    autoRenew?: BoolNullableWithAggregatesFilter<"Product"> | boolean | null
  }

  export type CategoriesOnProductsWhereInput = {
    AND?: CategoriesOnProductsWhereInput | CategoriesOnProductsWhereInput[]
    OR?: CategoriesOnProductsWhereInput[]
    NOT?: CategoriesOnProductsWhereInput | CategoriesOnProductsWhereInput[]
    productId?: StringFilter<"CategoriesOnProducts"> | string
    categoryId?: StringFilter<"CategoriesOnProducts"> | string
    assignedAt?: DateTimeFilter<"CategoriesOnProducts"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    category?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
  }

  export type CategoriesOnProductsOrderByWithRelationInput = {
    productId?: SortOrder
    categoryId?: SortOrder
    assignedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    category?: ProductCategoryOrderByWithRelationInput
  }

  export type CategoriesOnProductsWhereUniqueInput = Prisma.AtLeast<{
    productId_categoryId?: CategoriesOnProductsProductIdCategoryIdCompoundUniqueInput
    AND?: CategoriesOnProductsWhereInput | CategoriesOnProductsWhereInput[]
    OR?: CategoriesOnProductsWhereInput[]
    NOT?: CategoriesOnProductsWhereInput | CategoriesOnProductsWhereInput[]
    productId?: StringFilter<"CategoriesOnProducts"> | string
    categoryId?: StringFilter<"CategoriesOnProducts"> | string
    assignedAt?: DateTimeFilter<"CategoriesOnProducts"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    category?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
  }, "productId_categoryId">

  export type CategoriesOnProductsOrderByWithAggregationInput = {
    productId?: SortOrder
    categoryId?: SortOrder
    assignedAt?: SortOrder
    _count?: CategoriesOnProductsCountOrderByAggregateInput
    _max?: CategoriesOnProductsMaxOrderByAggregateInput
    _min?: CategoriesOnProductsMinOrderByAggregateInput
  }

  export type CategoriesOnProductsScalarWhereWithAggregatesInput = {
    AND?: CategoriesOnProductsScalarWhereWithAggregatesInput | CategoriesOnProductsScalarWhereWithAggregatesInput[]
    OR?: CategoriesOnProductsScalarWhereWithAggregatesInput[]
    NOT?: CategoriesOnProductsScalarWhereWithAggregatesInput | CategoriesOnProductsScalarWhereWithAggregatesInput[]
    productId?: StringWithAggregatesFilter<"CategoriesOnProducts"> | string
    categoryId?: StringWithAggregatesFilter<"CategoriesOnProducts"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"CategoriesOnProducts"> | Date | string
  }

  export type OfferWhereInput = {
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    id?: StringFilter<"Offer"> | string
    productId?: StringFilter<"Offer"> | string
    name?: StringFilter<"Offer"> | string
    description?: StringNullableFilter<"Offer"> | string | null
    currency?: EnumCurrencyFilter<"Offer"> | $Enums.Currency
    priceCents?: IntFilter<"Offer"> | number
    preferredProvider?: EnumPaymentProviderNullableFilter<"Offer"> | $Enums.PaymentProvider | null
    maxInstallments?: IntNullableFilter<"Offer"> | number | null
    installmentMinCents?: IntNullableFilter<"Offer"> | number | null
    active?: BoolFilter<"Offer"> | boolean
    isSubscription?: BoolFilter<"Offer"> | boolean
    intervalCount?: IntNullableFilter<"Offer"> | number | null
    intervalUnit?: EnumSubscriptionIntervalNullableFilter<"Offer"> | $Enums.SubscriptionInterval | null
    trialDays?: IntNullableFilter<"Offer"> | number | null
    checkoutUrl?: StringNullableFilter<"Offer"> | string | null
    providerConfig?: JsonNullableFilter<"Offer">
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    paymentMethods?: OfferPaymentMethodListRelationFilter
    prices?: OfferPriceListRelationFilter
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    currency?: SortOrder
    priceCents?: SortOrder
    preferredProvider?: SortOrderInput | SortOrder
    maxInstallments?: SortOrderInput | SortOrder
    installmentMinCents?: SortOrderInput | SortOrder
    active?: SortOrder
    isSubscription?: SortOrder
    intervalCount?: SortOrderInput | SortOrder
    intervalUnit?: SortOrderInput | SortOrder
    trialDays?: SortOrderInput | SortOrder
    checkoutUrl?: SortOrderInput | SortOrder
    providerConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    paymentMethods?: OfferPaymentMethodOrderByRelationAggregateInput
    prices?: OfferPriceOrderByRelationAggregateInput
  }

  export type OfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    productId?: StringFilter<"Offer"> | string
    name?: StringFilter<"Offer"> | string
    description?: StringNullableFilter<"Offer"> | string | null
    currency?: EnumCurrencyFilter<"Offer"> | $Enums.Currency
    priceCents?: IntFilter<"Offer"> | number
    preferredProvider?: EnumPaymentProviderNullableFilter<"Offer"> | $Enums.PaymentProvider | null
    maxInstallments?: IntNullableFilter<"Offer"> | number | null
    installmentMinCents?: IntNullableFilter<"Offer"> | number | null
    active?: BoolFilter<"Offer"> | boolean
    isSubscription?: BoolFilter<"Offer"> | boolean
    intervalCount?: IntNullableFilter<"Offer"> | number | null
    intervalUnit?: EnumSubscriptionIntervalNullableFilter<"Offer"> | $Enums.SubscriptionInterval | null
    trialDays?: IntNullableFilter<"Offer"> | number | null
    checkoutUrl?: StringNullableFilter<"Offer"> | string | null
    providerConfig?: JsonNullableFilter<"Offer">
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    paymentMethods?: OfferPaymentMethodListRelationFilter
    prices?: OfferPriceListRelationFilter
  }, "id">

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    currency?: SortOrder
    priceCents?: SortOrder
    preferredProvider?: SortOrderInput | SortOrder
    maxInstallments?: SortOrderInput | SortOrder
    installmentMinCents?: SortOrderInput | SortOrder
    active?: SortOrder
    isSubscription?: SortOrder
    intervalCount?: SortOrderInput | SortOrder
    intervalUnit?: SortOrderInput | SortOrder
    trialDays?: SortOrderInput | SortOrder
    checkoutUrl?: SortOrderInput | SortOrder
    providerConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    OR?: OfferScalarWhereWithAggregatesInput[]
    NOT?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Offer"> | string
    productId?: StringWithAggregatesFilter<"Offer"> | string
    name?: StringWithAggregatesFilter<"Offer"> | string
    description?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    currency?: EnumCurrencyWithAggregatesFilter<"Offer"> | $Enums.Currency
    priceCents?: IntWithAggregatesFilter<"Offer"> | number
    preferredProvider?: EnumPaymentProviderNullableWithAggregatesFilter<"Offer"> | $Enums.PaymentProvider | null
    maxInstallments?: IntNullableWithAggregatesFilter<"Offer"> | number | null
    installmentMinCents?: IntNullableWithAggregatesFilter<"Offer"> | number | null
    active?: BoolWithAggregatesFilter<"Offer"> | boolean
    isSubscription?: BoolWithAggregatesFilter<"Offer"> | boolean
    intervalCount?: IntNullableWithAggregatesFilter<"Offer"> | number | null
    intervalUnit?: EnumSubscriptionIntervalNullableWithAggregatesFilter<"Offer"> | $Enums.SubscriptionInterval | null
    trialDays?: IntNullableWithAggregatesFilter<"Offer"> | number | null
    checkoutUrl?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    providerConfig?: JsonNullableWithAggregatesFilter<"Offer">
    createdAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
  }

  export type OfferPriceWhereInput = {
    AND?: OfferPriceWhereInput | OfferPriceWhereInput[]
    OR?: OfferPriceWhereInput[]
    NOT?: OfferPriceWhereInput | OfferPriceWhereInput[]
    id?: StringFilter<"OfferPrice"> | string
    offerId?: StringFilter<"OfferPrice"> | string
    country?: StringFilter<"OfferPrice"> | string
    currency?: EnumCurrencyFilter<"OfferPrice"> | $Enums.Currency
    provider?: EnumPaymentProviderFilter<"OfferPrice"> | $Enums.PaymentProvider
    amountCents?: IntFilter<"OfferPrice"> | number
    externalPriceId?: StringNullableFilter<"OfferPrice"> | string | null
    active?: BoolFilter<"OfferPrice"> | boolean
    createdAt?: DateTimeFilter<"OfferPrice"> | Date | string
    updatedAt?: DateTimeFilter<"OfferPrice"> | Date | string
    offer?: XOR<OfferScalarRelationFilter, OfferWhereInput>
  }

  export type OfferPriceOrderByWithRelationInput = {
    id?: SortOrder
    offerId?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    externalPriceId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offer?: OfferOrderByWithRelationInput
  }

  export type OfferPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    offerId_country_currency_provider?: OfferPriceOfferIdCountryCurrencyProviderCompoundUniqueInput
    AND?: OfferPriceWhereInput | OfferPriceWhereInput[]
    OR?: OfferPriceWhereInput[]
    NOT?: OfferPriceWhereInput | OfferPriceWhereInput[]
    offerId?: StringFilter<"OfferPrice"> | string
    country?: StringFilter<"OfferPrice"> | string
    currency?: EnumCurrencyFilter<"OfferPrice"> | $Enums.Currency
    provider?: EnumPaymentProviderFilter<"OfferPrice"> | $Enums.PaymentProvider
    amountCents?: IntFilter<"OfferPrice"> | number
    externalPriceId?: StringNullableFilter<"OfferPrice"> | string | null
    active?: BoolFilter<"OfferPrice"> | boolean
    createdAt?: DateTimeFilter<"OfferPrice"> | Date | string
    updatedAt?: DateTimeFilter<"OfferPrice"> | Date | string
    offer?: XOR<OfferScalarRelationFilter, OfferWhereInput>
  }, "id" | "offerId_country_currency_provider">

  export type OfferPriceOrderByWithAggregationInput = {
    id?: SortOrder
    offerId?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    externalPriceId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfferPriceCountOrderByAggregateInput
    _avg?: OfferPriceAvgOrderByAggregateInput
    _max?: OfferPriceMaxOrderByAggregateInput
    _min?: OfferPriceMinOrderByAggregateInput
    _sum?: OfferPriceSumOrderByAggregateInput
  }

  export type OfferPriceScalarWhereWithAggregatesInput = {
    AND?: OfferPriceScalarWhereWithAggregatesInput | OfferPriceScalarWhereWithAggregatesInput[]
    OR?: OfferPriceScalarWhereWithAggregatesInput[]
    NOT?: OfferPriceScalarWhereWithAggregatesInput | OfferPriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferPrice"> | string
    offerId?: StringWithAggregatesFilter<"OfferPrice"> | string
    country?: StringWithAggregatesFilter<"OfferPrice"> | string
    currency?: EnumCurrencyWithAggregatesFilter<"OfferPrice"> | $Enums.Currency
    provider?: EnumPaymentProviderWithAggregatesFilter<"OfferPrice"> | $Enums.PaymentProvider
    amountCents?: IntWithAggregatesFilter<"OfferPrice"> | number
    externalPriceId?: StringNullableWithAggregatesFilter<"OfferPrice"> | string | null
    active?: BoolWithAggregatesFilter<"OfferPrice"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OfferPrice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OfferPrice"> | Date | string
  }

  export type OfferPaymentMethodWhereInput = {
    AND?: OfferPaymentMethodWhereInput | OfferPaymentMethodWhereInput[]
    OR?: OfferPaymentMethodWhereInput[]
    NOT?: OfferPaymentMethodWhereInput | OfferPaymentMethodWhereInput[]
    id?: StringFilter<"OfferPaymentMethod"> | string
    offerId?: StringFilter<"OfferPaymentMethod"> | string
    method?: EnumPaymentMethodFilter<"OfferPaymentMethod"> | $Enums.PaymentMethod
    active?: BoolFilter<"OfferPaymentMethod"> | boolean
    feePercent?: FloatNullableFilter<"OfferPaymentMethod"> | number | null
    offer?: XOR<OfferScalarRelationFilter, OfferWhereInput>
  }

  export type OfferPaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    offerId?: SortOrder
    method?: SortOrder
    active?: SortOrder
    feePercent?: SortOrderInput | SortOrder
    offer?: OfferOrderByWithRelationInput
  }

  export type OfferPaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    offerId_method?: OfferPaymentMethodOfferIdMethodCompoundUniqueInput
    AND?: OfferPaymentMethodWhereInput | OfferPaymentMethodWhereInput[]
    OR?: OfferPaymentMethodWhereInput[]
    NOT?: OfferPaymentMethodWhereInput | OfferPaymentMethodWhereInput[]
    offerId?: StringFilter<"OfferPaymentMethod"> | string
    method?: EnumPaymentMethodFilter<"OfferPaymentMethod"> | $Enums.PaymentMethod
    active?: BoolFilter<"OfferPaymentMethod"> | boolean
    feePercent?: FloatNullableFilter<"OfferPaymentMethod"> | number | null
    offer?: XOR<OfferScalarRelationFilter, OfferWhereInput>
  }, "id" | "offerId_method">

  export type OfferPaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    offerId?: SortOrder
    method?: SortOrder
    active?: SortOrder
    feePercent?: SortOrderInput | SortOrder
    _count?: OfferPaymentMethodCountOrderByAggregateInput
    _avg?: OfferPaymentMethodAvgOrderByAggregateInput
    _max?: OfferPaymentMethodMaxOrderByAggregateInput
    _min?: OfferPaymentMethodMinOrderByAggregateInput
    _sum?: OfferPaymentMethodSumOrderByAggregateInput
  }

  export type OfferPaymentMethodScalarWhereWithAggregatesInput = {
    AND?: OfferPaymentMethodScalarWhereWithAggregatesInput | OfferPaymentMethodScalarWhereWithAggregatesInput[]
    OR?: OfferPaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: OfferPaymentMethodScalarWhereWithAggregatesInput | OfferPaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferPaymentMethod"> | string
    offerId?: StringWithAggregatesFilter<"OfferPaymentMethod"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"OfferPaymentMethod"> | $Enums.PaymentMethod
    active?: BoolWithAggregatesFilter<"OfferPaymentMethod"> | boolean
    feePercent?: FloatNullableWithAggregatesFilter<"OfferPaymentMethod"> | number | null
  }

  export type ProductIntegrationWhereInput = {
    AND?: ProductIntegrationWhereInput | ProductIntegrationWhereInput[]
    OR?: ProductIntegrationWhereInput[]
    NOT?: ProductIntegrationWhereInput | ProductIntegrationWhereInput[]
    id?: StringFilter<"ProductIntegration"> | string
    productId?: StringFilter<"ProductIntegration"> | string
    provider?: EnumPaymentProviderFilter<"ProductIntegration"> | $Enums.PaymentProvider
    externalProductId?: StringFilter<"ProductIntegration"> | string
    metadata?: JsonNullableFilter<"ProductIntegration">
    createdAt?: DateTimeFilter<"ProductIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"ProductIntegration"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    provider?: SortOrder
    externalProductId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_provider?: ProductIntegrationProductIdProviderCompoundUniqueInput
    AND?: ProductIntegrationWhereInput | ProductIntegrationWhereInput[]
    OR?: ProductIntegrationWhereInput[]
    NOT?: ProductIntegrationWhereInput | ProductIntegrationWhereInput[]
    productId?: StringFilter<"ProductIntegration"> | string
    provider?: EnumPaymentProviderFilter<"ProductIntegration"> | $Enums.PaymentProvider
    externalProductId?: StringFilter<"ProductIntegration"> | string
    metadata?: JsonNullableFilter<"ProductIntegration">
    createdAt?: DateTimeFilter<"ProductIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"ProductIntegration"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "productId_provider">

  export type ProductIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    provider?: SortOrder
    externalProductId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductIntegrationCountOrderByAggregateInput
    _max?: ProductIntegrationMaxOrderByAggregateInput
    _min?: ProductIntegrationMinOrderByAggregateInput
  }

  export type ProductIntegrationScalarWhereWithAggregatesInput = {
    AND?: ProductIntegrationScalarWhereWithAggregatesInput | ProductIntegrationScalarWhereWithAggregatesInput[]
    OR?: ProductIntegrationScalarWhereWithAggregatesInput[]
    NOT?: ProductIntegrationScalarWhereWithAggregatesInput | ProductIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductIntegration"> | string
    productId?: StringWithAggregatesFilter<"ProductIntegration"> | string
    provider?: EnumPaymentProviderWithAggregatesFilter<"ProductIntegration"> | $Enums.PaymentProvider
    externalProductId?: StringWithAggregatesFilter<"ProductIntegration"> | string
    metadata?: JsonNullableWithAggregatesFilter<"ProductIntegration">
    createdAt?: DateTimeWithAggregatesFilter<"ProductIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductIntegration"> | Date | string
  }

  export type CheckoutSessionWhereInput = {
    AND?: CheckoutSessionWhereInput | CheckoutSessionWhereInput[]
    OR?: CheckoutSessionWhereInput[]
    NOT?: CheckoutSessionWhereInput | CheckoutSessionWhereInput[]
    id?: StringFilter<"CheckoutSession"> | string
    resumeToken?: StringFilter<"CheckoutSession"> | string
    clinicId?: StringNullableFilter<"CheckoutSession"> | string | null
    productId?: StringNullableFilter<"CheckoutSession"> | string | null
    offerId?: StringNullableFilter<"CheckoutSession"> | string | null
    slug?: StringNullableFilter<"CheckoutSession"> | string | null
    provider?: EnumPaymentProviderNullableFilter<"CheckoutSession"> | $Enums.PaymentProvider | null
    country?: StringNullableFilter<"CheckoutSession"> | string | null
    locale?: StringNullableFilter<"CheckoutSession"> | string | null
    status?: EnumCheckoutSessionStatusFilter<"CheckoutSession"> | $Enums.CheckoutSessionStatus
    paymentMethod?: EnumCheckoutPaymentMethodNullableFilter<"CheckoutSession"> | $Enums.CheckoutPaymentMethod | null
    orderId?: StringNullableFilter<"CheckoutSession"> | string | null
    pixOrderId?: StringNullableFilter<"CheckoutSession"> | string | null
    pixExpiresAt?: DateTimeNullableFilter<"CheckoutSession"> | Date | string | null
    paymentTransactionId?: StringNullableFilter<"CheckoutSession"> | string | null
    email?: StringNullableFilter<"CheckoutSession"> | string | null
    phone?: StringNullableFilter<"CheckoutSession"> | string | null
    document?: StringNullableFilter<"CheckoutSession"> | string | null
    utmSource?: StringNullableFilter<"CheckoutSession"> | string | null
    utmMedium?: StringNullableFilter<"CheckoutSession"> | string | null
    utmCampaign?: StringNullableFilter<"CheckoutSession"> | string | null
    utmTerm?: StringNullableFilter<"CheckoutSession"> | string | null
    utmContent?: StringNullableFilter<"CheckoutSession"> | string | null
    referrer?: StringNullableFilter<"CheckoutSession"> | string | null
    ip?: StringNullableFilter<"CheckoutSession"> | string | null
    userAgent?: StringNullableFilter<"CheckoutSession"> | string | null
    selectedInstallments?: IntNullableFilter<"CheckoutSession"> | number | null
    selectedBank?: StringNullableFilter<"CheckoutSession"> | string | null
    paymentMethodsAllowed?: JsonNullableFilter<"CheckoutSession">
    metadata?: JsonNullableFilter<"CheckoutSession">
    startedAt?: DateTimeFilter<"CheckoutSession"> | Date | string
    createdAt?: DateTimeFilter<"CheckoutSession"> | Date | string
    updatedAt?: DateTimeFilter<"CheckoutSession"> | Date | string
    lastHeartbeatAt?: DateTimeNullableFilter<"CheckoutSession"> | Date | string | null
    lastStep?: StringNullableFilter<"CheckoutSession"> | string | null
    reminders?: JsonNullableFilter<"CheckoutSession">
    reminderExpiringSentAt?: DateTimeNullableFilter<"CheckoutSession"> | Date | string | null
    reminderExpiredSentAt?: DateTimeNullableFilter<"CheckoutSession"> | Date | string | null
    conversionLikelihood?: FloatNullableFilter<"CheckoutSession"> | number | null
    origin?: StringNullableFilter<"CheckoutSession"> | string | null
    createdBy?: StringNullableFilter<"CheckoutSession"> | string | null
    paymentTransaction?: XOR<PaymentTransactionNullableScalarRelationFilter, PaymentTransactionWhereInput> | null
  }

  export type CheckoutSessionOrderByWithRelationInput = {
    id?: SortOrder
    resumeToken?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    offerId?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    pixOrderId?: SortOrderInput | SortOrder
    pixExpiresAt?: SortOrderInput | SortOrder
    paymentTransactionId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    utmSource?: SortOrderInput | SortOrder
    utmMedium?: SortOrderInput | SortOrder
    utmCampaign?: SortOrderInput | SortOrder
    utmTerm?: SortOrderInput | SortOrder
    utmContent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    selectedInstallments?: SortOrderInput | SortOrder
    selectedBank?: SortOrderInput | SortOrder
    paymentMethodsAllowed?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastHeartbeatAt?: SortOrderInput | SortOrder
    lastStep?: SortOrderInput | SortOrder
    reminders?: SortOrderInput | SortOrder
    reminderExpiringSentAt?: SortOrderInput | SortOrder
    reminderExpiredSentAt?: SortOrderInput | SortOrder
    conversionLikelihood?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    paymentTransaction?: PaymentTransactionOrderByWithRelationInput
  }

  export type CheckoutSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    resumeToken?: string
    paymentTransactionId?: string
    AND?: CheckoutSessionWhereInput | CheckoutSessionWhereInput[]
    OR?: CheckoutSessionWhereInput[]
    NOT?: CheckoutSessionWhereInput | CheckoutSessionWhereInput[]
    clinicId?: StringNullableFilter<"CheckoutSession"> | string | null
    productId?: StringNullableFilter<"CheckoutSession"> | string | null
    offerId?: StringNullableFilter<"CheckoutSession"> | string | null
    slug?: StringNullableFilter<"CheckoutSession"> | string | null
    provider?: EnumPaymentProviderNullableFilter<"CheckoutSession"> | $Enums.PaymentProvider | null
    country?: StringNullableFilter<"CheckoutSession"> | string | null
    locale?: StringNullableFilter<"CheckoutSession"> | string | null
    status?: EnumCheckoutSessionStatusFilter<"CheckoutSession"> | $Enums.CheckoutSessionStatus
    paymentMethod?: EnumCheckoutPaymentMethodNullableFilter<"CheckoutSession"> | $Enums.CheckoutPaymentMethod | null
    orderId?: StringNullableFilter<"CheckoutSession"> | string | null
    pixOrderId?: StringNullableFilter<"CheckoutSession"> | string | null
    pixExpiresAt?: DateTimeNullableFilter<"CheckoutSession"> | Date | string | null
    email?: StringNullableFilter<"CheckoutSession"> | string | null
    phone?: StringNullableFilter<"CheckoutSession"> | string | null
    document?: StringNullableFilter<"CheckoutSession"> | string | null
    utmSource?: StringNullableFilter<"CheckoutSession"> | string | null
    utmMedium?: StringNullableFilter<"CheckoutSession"> | string | null
    utmCampaign?: StringNullableFilter<"CheckoutSession"> | string | null
    utmTerm?: StringNullableFilter<"CheckoutSession"> | string | null
    utmContent?: StringNullableFilter<"CheckoutSession"> | string | null
    referrer?: StringNullableFilter<"CheckoutSession"> | string | null
    ip?: StringNullableFilter<"CheckoutSession"> | string | null
    userAgent?: StringNullableFilter<"CheckoutSession"> | string | null
    selectedInstallments?: IntNullableFilter<"CheckoutSession"> | number | null
    selectedBank?: StringNullableFilter<"CheckoutSession"> | string | null
    paymentMethodsAllowed?: JsonNullableFilter<"CheckoutSession">
    metadata?: JsonNullableFilter<"CheckoutSession">
    startedAt?: DateTimeFilter<"CheckoutSession"> | Date | string
    createdAt?: DateTimeFilter<"CheckoutSession"> | Date | string
    updatedAt?: DateTimeFilter<"CheckoutSession"> | Date | string
    lastHeartbeatAt?: DateTimeNullableFilter<"CheckoutSession"> | Date | string | null
    lastStep?: StringNullableFilter<"CheckoutSession"> | string | null
    reminders?: JsonNullableFilter<"CheckoutSession">
    reminderExpiringSentAt?: DateTimeNullableFilter<"CheckoutSession"> | Date | string | null
    reminderExpiredSentAt?: DateTimeNullableFilter<"CheckoutSession"> | Date | string | null
    conversionLikelihood?: FloatNullableFilter<"CheckoutSession"> | number | null
    origin?: StringNullableFilter<"CheckoutSession"> | string | null
    createdBy?: StringNullableFilter<"CheckoutSession"> | string | null
    paymentTransaction?: XOR<PaymentTransactionNullableScalarRelationFilter, PaymentTransactionWhereInput> | null
  }, "id" | "resumeToken" | "paymentTransactionId">

  export type CheckoutSessionOrderByWithAggregationInput = {
    id?: SortOrder
    resumeToken?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    offerId?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    pixOrderId?: SortOrderInput | SortOrder
    pixExpiresAt?: SortOrderInput | SortOrder
    paymentTransactionId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    utmSource?: SortOrderInput | SortOrder
    utmMedium?: SortOrderInput | SortOrder
    utmCampaign?: SortOrderInput | SortOrder
    utmTerm?: SortOrderInput | SortOrder
    utmContent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    selectedInstallments?: SortOrderInput | SortOrder
    selectedBank?: SortOrderInput | SortOrder
    paymentMethodsAllowed?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastHeartbeatAt?: SortOrderInput | SortOrder
    lastStep?: SortOrderInput | SortOrder
    reminders?: SortOrderInput | SortOrder
    reminderExpiringSentAt?: SortOrderInput | SortOrder
    reminderExpiredSentAt?: SortOrderInput | SortOrder
    conversionLikelihood?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: CheckoutSessionCountOrderByAggregateInput
    _avg?: CheckoutSessionAvgOrderByAggregateInput
    _max?: CheckoutSessionMaxOrderByAggregateInput
    _min?: CheckoutSessionMinOrderByAggregateInput
    _sum?: CheckoutSessionSumOrderByAggregateInput
  }

  export type CheckoutSessionScalarWhereWithAggregatesInput = {
    AND?: CheckoutSessionScalarWhereWithAggregatesInput | CheckoutSessionScalarWhereWithAggregatesInput[]
    OR?: CheckoutSessionScalarWhereWithAggregatesInput[]
    NOT?: CheckoutSessionScalarWhereWithAggregatesInput | CheckoutSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CheckoutSession"> | string
    resumeToken?: StringWithAggregatesFilter<"CheckoutSession"> | string
    clinicId?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    productId?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    offerId?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    slug?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    provider?: EnumPaymentProviderNullableWithAggregatesFilter<"CheckoutSession"> | $Enums.PaymentProvider | null
    country?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    locale?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    status?: EnumCheckoutSessionStatusWithAggregatesFilter<"CheckoutSession"> | $Enums.CheckoutSessionStatus
    paymentMethod?: EnumCheckoutPaymentMethodNullableWithAggregatesFilter<"CheckoutSession"> | $Enums.CheckoutPaymentMethod | null
    orderId?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    pixOrderId?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    pixExpiresAt?: DateTimeNullableWithAggregatesFilter<"CheckoutSession"> | Date | string | null
    paymentTransactionId?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    email?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    phone?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    document?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    utmSource?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    utmMedium?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    utmCampaign?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    utmTerm?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    utmContent?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    referrer?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    ip?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    selectedInstallments?: IntNullableWithAggregatesFilter<"CheckoutSession"> | number | null
    selectedBank?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    paymentMethodsAllowed?: JsonNullableWithAggregatesFilter<"CheckoutSession">
    metadata?: JsonNullableWithAggregatesFilter<"CheckoutSession">
    startedAt?: DateTimeWithAggregatesFilter<"CheckoutSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CheckoutSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CheckoutSession"> | Date | string
    lastHeartbeatAt?: DateTimeNullableWithAggregatesFilter<"CheckoutSession"> | Date | string | null
    lastStep?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    reminders?: JsonNullableWithAggregatesFilter<"CheckoutSession">
    reminderExpiringSentAt?: DateTimeNullableWithAggregatesFilter<"CheckoutSession"> | Date | string | null
    reminderExpiredSentAt?: DateTimeNullableWithAggregatesFilter<"CheckoutSession"> | Date | string | null
    conversionLikelihood?: FloatNullableWithAggregatesFilter<"CheckoutSession"> | number | null
    origin?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"CheckoutSession"> | string | null
  }

  export type PaymentTransactionWhereInput = {
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    id?: StringFilter<"PaymentTransaction"> | string
    provider?: StringFilter<"PaymentTransaction"> | string
    providerOrderId?: StringNullableFilter<"PaymentTransaction"> | string | null
    providerChargeId?: StringNullableFilter<"PaymentTransaction"> | string | null
    doctorId?: StringNullableFilter<"PaymentTransaction"> | string | null
    patientProfileId?: StringNullableFilter<"PaymentTransaction"> | string | null
    clinicId?: StringNullableFilter<"PaymentTransaction"> | string | null
    merchantId?: StringNullableFilter<"PaymentTransaction"> | string | null
    productId?: StringNullableFilter<"PaymentTransaction"> | string | null
    amountCents?: IntFilter<"PaymentTransaction"> | number
    currency?: StringFilter<"PaymentTransaction"> | string
    installments?: IntNullableFilter<"PaymentTransaction"> | number | null
    paymentMethodType?: StringNullableFilter<"PaymentTransaction"> | string | null
    status?: StringFilter<"PaymentTransaction"> | string
    status_v2?: EnumPaymentStatusNullableFilter<"PaymentTransaction"> | $Enums.PaymentStatus | null
    rawPayload?: JsonNullableFilter<"PaymentTransaction">
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    paidAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    capturedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    refundStatus?: StringNullableFilter<"PaymentTransaction"> | string | null
    refundedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    routedProvider?: StringNullableFilter<"PaymentTransaction"> | string | null
    customerId?: StringNullableFilter<"PaymentTransaction"> | string | null
    customerProviderId?: StringNullableFilter<"PaymentTransaction"> | string | null
    customerPaymentMethodId?: StringNullableFilter<"PaymentTransaction"> | string | null
    customerSubscriptionId?: StringNullableFilter<"PaymentTransaction"> | string | null
    billingPeriodStart?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    billingPeriodEnd?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    provider_v2?: EnumPaymentProviderNullableFilter<"PaymentTransaction"> | $Enums.PaymentProvider | null
    checkoutSession?: XOR<CheckoutSessionNullableScalarRelationFilter, CheckoutSessionWhereInput> | null
  }

  export type PaymentTransactionOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    providerOrderId?: SortOrderInput | SortOrder
    providerChargeId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    patientProfileId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    installments?: SortOrderInput | SortOrder
    paymentMethodType?: SortOrderInput | SortOrder
    status?: SortOrder
    status_v2?: SortOrderInput | SortOrder
    rawPayload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    capturedAt?: SortOrderInput | SortOrder
    refundStatus?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    routedProvider?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerProviderId?: SortOrderInput | SortOrder
    customerPaymentMethodId?: SortOrderInput | SortOrder
    customerSubscriptionId?: SortOrderInput | SortOrder
    billingPeriodStart?: SortOrderInput | SortOrder
    billingPeriodEnd?: SortOrderInput | SortOrder
    provider_v2?: SortOrderInput | SortOrder
    checkoutSession?: CheckoutSessionOrderByWithRelationInput
  }

  export type PaymentTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    provider?: StringFilter<"PaymentTransaction"> | string
    providerOrderId?: StringNullableFilter<"PaymentTransaction"> | string | null
    providerChargeId?: StringNullableFilter<"PaymentTransaction"> | string | null
    doctorId?: StringNullableFilter<"PaymentTransaction"> | string | null
    patientProfileId?: StringNullableFilter<"PaymentTransaction"> | string | null
    clinicId?: StringNullableFilter<"PaymentTransaction"> | string | null
    merchantId?: StringNullableFilter<"PaymentTransaction"> | string | null
    productId?: StringNullableFilter<"PaymentTransaction"> | string | null
    amountCents?: IntFilter<"PaymentTransaction"> | number
    currency?: StringFilter<"PaymentTransaction"> | string
    installments?: IntNullableFilter<"PaymentTransaction"> | number | null
    paymentMethodType?: StringNullableFilter<"PaymentTransaction"> | string | null
    status?: StringFilter<"PaymentTransaction"> | string
    status_v2?: EnumPaymentStatusNullableFilter<"PaymentTransaction"> | $Enums.PaymentStatus | null
    rawPayload?: JsonNullableFilter<"PaymentTransaction">
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    paidAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    capturedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    refundStatus?: StringNullableFilter<"PaymentTransaction"> | string | null
    refundedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    routedProvider?: StringNullableFilter<"PaymentTransaction"> | string | null
    customerId?: StringNullableFilter<"PaymentTransaction"> | string | null
    customerProviderId?: StringNullableFilter<"PaymentTransaction"> | string | null
    customerPaymentMethodId?: StringNullableFilter<"PaymentTransaction"> | string | null
    customerSubscriptionId?: StringNullableFilter<"PaymentTransaction"> | string | null
    billingPeriodStart?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    billingPeriodEnd?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    provider_v2?: EnumPaymentProviderNullableFilter<"PaymentTransaction"> | $Enums.PaymentProvider | null
    checkoutSession?: XOR<CheckoutSessionNullableScalarRelationFilter, CheckoutSessionWhereInput> | null
  }, "id">

  export type PaymentTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    providerOrderId?: SortOrderInput | SortOrder
    providerChargeId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    patientProfileId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    installments?: SortOrderInput | SortOrder
    paymentMethodType?: SortOrderInput | SortOrder
    status?: SortOrder
    status_v2?: SortOrderInput | SortOrder
    rawPayload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    capturedAt?: SortOrderInput | SortOrder
    refundStatus?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    routedProvider?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerProviderId?: SortOrderInput | SortOrder
    customerPaymentMethodId?: SortOrderInput | SortOrder
    customerSubscriptionId?: SortOrderInput | SortOrder
    billingPeriodStart?: SortOrderInput | SortOrder
    billingPeriodEnd?: SortOrderInput | SortOrder
    provider_v2?: SortOrderInput | SortOrder
    _count?: PaymentTransactionCountOrderByAggregateInput
    _avg?: PaymentTransactionAvgOrderByAggregateInput
    _max?: PaymentTransactionMaxOrderByAggregateInput
    _min?: PaymentTransactionMinOrderByAggregateInput
    _sum?: PaymentTransactionSumOrderByAggregateInput
  }

  export type PaymentTransactionScalarWhereWithAggregatesInput = {
    AND?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    OR?: PaymentTransactionScalarWhereWithAggregatesInput[]
    NOT?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    provider?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    providerOrderId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    providerChargeId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    doctorId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    patientProfileId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    clinicId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    merchantId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    productId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    amountCents?: IntWithAggregatesFilter<"PaymentTransaction"> | number
    currency?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    installments?: IntNullableWithAggregatesFilter<"PaymentTransaction"> | number | null
    paymentMethodType?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    status?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    status_v2?: EnumPaymentStatusNullableWithAggregatesFilter<"PaymentTransaction"> | $Enums.PaymentStatus | null
    rawPayload?: JsonNullableWithAggregatesFilter<"PaymentTransaction">
    createdAt?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"PaymentTransaction"> | Date | string | null
    capturedAt?: DateTimeNullableWithAggregatesFilter<"PaymentTransaction"> | Date | string | null
    refundStatus?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    refundedAt?: DateTimeNullableWithAggregatesFilter<"PaymentTransaction"> | Date | string | null
    routedProvider?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    customerProviderId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    customerPaymentMethodId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    customerSubscriptionId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    billingPeriodStart?: DateTimeNullableWithAggregatesFilter<"PaymentTransaction"> | Date | string | null
    billingPeriodEnd?: DateTimeNullableWithAggregatesFilter<"PaymentTransaction"> | Date | string | null
    provider_v2?: EnumPaymentProviderNullableWithAggregatesFilter<"PaymentTransaction"> | $Enums.PaymentProvider | null
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    userId?: StringFilter<"Purchase"> | string
    doctorId?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    quantity?: IntFilter<"Purchase"> | number
    unitPrice?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Purchase"> | string
    externalIdempotencyKey?: StringNullableFilter<"Purchase"> | string | null
    notes?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    pointsAwarded?: SortOrder
    status?: SortOrder
    externalIdempotencyKey?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    userId?: StringFilter<"Purchase"> | string
    doctorId?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    quantity?: IntFilter<"Purchase"> | number
    unitPrice?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Purchase"> | string
    externalIdempotencyKey?: StringNullableFilter<"Purchase"> | string | null
    notes?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    pointsAwarded?: SortOrder
    status?: SortOrder
    externalIdempotencyKey?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    userId?: StringWithAggregatesFilter<"Purchase"> | string
    doctorId?: StringWithAggregatesFilter<"Purchase"> | string
    productId?: StringWithAggregatesFilter<"Purchase"> | string
    quantity?: IntWithAggregatesFilter<"Purchase"> | number
    unitPrice?: DecimalWithAggregatesFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalWithAggregatesFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Purchase"> | string
    externalIdempotencyKey?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    merchantId?: StringFilter<"Customer"> | string
    name?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    document?: StringNullableFilter<"Customer"> | string | null
    address?: JsonNullableFilter<"Customer">
    metadata?: JsonNullableFilter<"Customer">
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    providers?: CustomerProviderListRelationFilter
    paymentMethods?: CustomerPaymentMethodListRelationFilter
    subscriptions?: CustomerSubscriptionListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    providers?: CustomerProviderOrderByRelationAggregateInput
    paymentMethods?: CustomerPaymentMethodOrderByRelationAggregateInput
    subscriptions?: CustomerSubscriptionOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    merchantId_email?: CustomerMerchantIdEmailCompoundUniqueInput
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    merchantId?: StringFilter<"Customer"> | string
    name?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    document?: StringNullableFilter<"Customer"> | string | null
    address?: JsonNullableFilter<"Customer">
    metadata?: JsonNullableFilter<"Customer">
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    providers?: CustomerProviderListRelationFilter
    paymentMethods?: CustomerPaymentMethodListRelationFilter
    subscriptions?: CustomerSubscriptionListRelationFilter
  }, "id" | "merchantId_email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    merchantId?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    document?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: JsonNullableWithAggregatesFilter<"Customer">
    metadata?: JsonNullableWithAggregatesFilter<"Customer">
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type CustomerProviderWhereInput = {
    AND?: CustomerProviderWhereInput | CustomerProviderWhereInput[]
    OR?: CustomerProviderWhereInput[]
    NOT?: CustomerProviderWhereInput | CustomerProviderWhereInput[]
    id?: StringFilter<"CustomerProvider"> | string
    customerId?: StringFilter<"CustomerProvider"> | string
    provider?: EnumPaymentProviderFilter<"CustomerProvider"> | $Enums.PaymentProvider
    accountId?: StringNullableFilter<"CustomerProvider"> | string | null
    providerCustomerId?: StringNullableFilter<"CustomerProvider"> | string | null
    metadata?: JsonNullableFilter<"CustomerProvider">
    createdAt?: DateTimeFilter<"CustomerProvider"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerProvider"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    paymentMethods?: CustomerPaymentMethodListRelationFilter
    subscriptions?: CustomerSubscriptionListRelationFilter
  }

  export type CustomerProviderOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    provider?: SortOrder
    accountId?: SortOrderInput | SortOrder
    providerCustomerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    paymentMethods?: CustomerPaymentMethodOrderByRelationAggregateInput
    subscriptions?: CustomerSubscriptionOrderByRelationAggregateInput
  }

  export type CustomerProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_accountId_providerCustomerId?: CustomerProviderProviderAccountIdProviderCustomerIdCompoundUniqueInput
    customerId_provider_accountId?: CustomerProviderCustomerIdProviderAccountIdCompoundUniqueInput
    AND?: CustomerProviderWhereInput | CustomerProviderWhereInput[]
    OR?: CustomerProviderWhereInput[]
    NOT?: CustomerProviderWhereInput | CustomerProviderWhereInput[]
    customerId?: StringFilter<"CustomerProvider"> | string
    provider?: EnumPaymentProviderFilter<"CustomerProvider"> | $Enums.PaymentProvider
    accountId?: StringNullableFilter<"CustomerProvider"> | string | null
    providerCustomerId?: StringNullableFilter<"CustomerProvider"> | string | null
    metadata?: JsonNullableFilter<"CustomerProvider">
    createdAt?: DateTimeFilter<"CustomerProvider"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerProvider"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    paymentMethods?: CustomerPaymentMethodListRelationFilter
    subscriptions?: CustomerSubscriptionListRelationFilter
  }, "id" | "provider_accountId_providerCustomerId" | "customerId_provider_accountId">

  export type CustomerProviderOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    provider?: SortOrder
    accountId?: SortOrderInput | SortOrder
    providerCustomerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerProviderCountOrderByAggregateInput
    _max?: CustomerProviderMaxOrderByAggregateInput
    _min?: CustomerProviderMinOrderByAggregateInput
  }

  export type CustomerProviderScalarWhereWithAggregatesInput = {
    AND?: CustomerProviderScalarWhereWithAggregatesInput | CustomerProviderScalarWhereWithAggregatesInput[]
    OR?: CustomerProviderScalarWhereWithAggregatesInput[]
    NOT?: CustomerProviderScalarWhereWithAggregatesInput | CustomerProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerProvider"> | string
    customerId?: StringWithAggregatesFilter<"CustomerProvider"> | string
    provider?: EnumPaymentProviderWithAggregatesFilter<"CustomerProvider"> | $Enums.PaymentProvider
    accountId?: StringNullableWithAggregatesFilter<"CustomerProvider"> | string | null
    providerCustomerId?: StringNullableWithAggregatesFilter<"CustomerProvider"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"CustomerProvider">
    createdAt?: DateTimeWithAggregatesFilter<"CustomerProvider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerProvider"> | Date | string
  }

  export type CustomerPaymentMethodWhereInput = {
    AND?: CustomerPaymentMethodWhereInput | CustomerPaymentMethodWhereInput[]
    OR?: CustomerPaymentMethodWhereInput[]
    NOT?: CustomerPaymentMethodWhereInput | CustomerPaymentMethodWhereInput[]
    id?: StringFilter<"CustomerPaymentMethod"> | string
    customerId?: StringFilter<"CustomerPaymentMethod"> | string
    customerProviderId?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    provider?: EnumPaymentProviderFilter<"CustomerPaymentMethod"> | $Enums.PaymentProvider
    accountId?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    providerPaymentMethodId?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    brand?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    last4?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    expMonth?: IntNullableFilter<"CustomerPaymentMethod"> | number | null
    expYear?: IntNullableFilter<"CustomerPaymentMethod"> | number | null
    isDefault?: BoolFilter<"CustomerPaymentMethod"> | boolean
    status?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    fingerprint?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    metadata?: JsonNullableFilter<"CustomerPaymentMethod">
    createdAt?: DateTimeFilter<"CustomerPaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPaymentMethod"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    customerProvider?: XOR<CustomerProviderNullableScalarRelationFilter, CustomerProviderWhereInput> | null
  }

  export type CustomerPaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerProviderId?: SortOrderInput | SortOrder
    provider?: SortOrder
    accountId?: SortOrderInput | SortOrder
    providerPaymentMethodId?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    last4?: SortOrderInput | SortOrder
    expMonth?: SortOrderInput | SortOrder
    expYear?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    status?: SortOrderInput | SortOrder
    fingerprint?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    customerProvider?: CustomerProviderOrderByWithRelationInput
  }

  export type CustomerPaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_accountId_providerPaymentMethodId?: CustomerPaymentMethodProviderAccountIdProviderPaymentMethodIdCompoundUniqueInput
    AND?: CustomerPaymentMethodWhereInput | CustomerPaymentMethodWhereInput[]
    OR?: CustomerPaymentMethodWhereInput[]
    NOT?: CustomerPaymentMethodWhereInput | CustomerPaymentMethodWhereInput[]
    customerId?: StringFilter<"CustomerPaymentMethod"> | string
    customerProviderId?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    provider?: EnumPaymentProviderFilter<"CustomerPaymentMethod"> | $Enums.PaymentProvider
    accountId?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    providerPaymentMethodId?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    brand?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    last4?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    expMonth?: IntNullableFilter<"CustomerPaymentMethod"> | number | null
    expYear?: IntNullableFilter<"CustomerPaymentMethod"> | number | null
    isDefault?: BoolFilter<"CustomerPaymentMethod"> | boolean
    status?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    fingerprint?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    metadata?: JsonNullableFilter<"CustomerPaymentMethod">
    createdAt?: DateTimeFilter<"CustomerPaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPaymentMethod"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    customerProvider?: XOR<CustomerProviderNullableScalarRelationFilter, CustomerProviderWhereInput> | null
  }, "id" | "provider_accountId_providerPaymentMethodId">

  export type CustomerPaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerProviderId?: SortOrderInput | SortOrder
    provider?: SortOrder
    accountId?: SortOrderInput | SortOrder
    providerPaymentMethodId?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    last4?: SortOrderInput | SortOrder
    expMonth?: SortOrderInput | SortOrder
    expYear?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    status?: SortOrderInput | SortOrder
    fingerprint?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerPaymentMethodCountOrderByAggregateInput
    _avg?: CustomerPaymentMethodAvgOrderByAggregateInput
    _max?: CustomerPaymentMethodMaxOrderByAggregateInput
    _min?: CustomerPaymentMethodMinOrderByAggregateInput
    _sum?: CustomerPaymentMethodSumOrderByAggregateInput
  }

  export type CustomerPaymentMethodScalarWhereWithAggregatesInput = {
    AND?: CustomerPaymentMethodScalarWhereWithAggregatesInput | CustomerPaymentMethodScalarWhereWithAggregatesInput[]
    OR?: CustomerPaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: CustomerPaymentMethodScalarWhereWithAggregatesInput | CustomerPaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerPaymentMethod"> | string
    customerId?: StringWithAggregatesFilter<"CustomerPaymentMethod"> | string
    customerProviderId?: StringNullableWithAggregatesFilter<"CustomerPaymentMethod"> | string | null
    provider?: EnumPaymentProviderWithAggregatesFilter<"CustomerPaymentMethod"> | $Enums.PaymentProvider
    accountId?: StringNullableWithAggregatesFilter<"CustomerPaymentMethod"> | string | null
    providerPaymentMethodId?: StringNullableWithAggregatesFilter<"CustomerPaymentMethod"> | string | null
    brand?: StringNullableWithAggregatesFilter<"CustomerPaymentMethod"> | string | null
    last4?: StringNullableWithAggregatesFilter<"CustomerPaymentMethod"> | string | null
    expMonth?: IntNullableWithAggregatesFilter<"CustomerPaymentMethod"> | number | null
    expYear?: IntNullableWithAggregatesFilter<"CustomerPaymentMethod"> | number | null
    isDefault?: BoolWithAggregatesFilter<"CustomerPaymentMethod"> | boolean
    status?: StringNullableWithAggregatesFilter<"CustomerPaymentMethod"> | string | null
    fingerprint?: StringNullableWithAggregatesFilter<"CustomerPaymentMethod"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"CustomerPaymentMethod">
    createdAt?: DateTimeWithAggregatesFilter<"CustomerPaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerPaymentMethod"> | Date | string
  }

  export type CustomerSubscriptionWhereInput = {
    AND?: CustomerSubscriptionWhereInput | CustomerSubscriptionWhereInput[]
    OR?: CustomerSubscriptionWhereInput[]
    NOT?: CustomerSubscriptionWhereInput | CustomerSubscriptionWhereInput[]
    id?: StringFilter<"CustomerSubscription"> | string
    customerId?: StringFilter<"CustomerSubscription"> | string
    merchantId?: StringFilter<"CustomerSubscription"> | string
    productId?: StringFilter<"CustomerSubscription"> | string
    offerId?: StringNullableFilter<"CustomerSubscription"> | string | null
    provider?: EnumPaymentProviderFilter<"CustomerSubscription"> | $Enums.PaymentProvider
    accountId?: StringNullableFilter<"CustomerSubscription"> | string | null
    isNative?: BoolFilter<"CustomerSubscription"> | boolean
    customerProviderId?: StringNullableFilter<"CustomerSubscription"> | string | null
    providerSubscriptionId?: StringNullableFilter<"CustomerSubscription"> | string | null
    vaultPaymentMethodId?: StringNullableFilter<"CustomerSubscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"CustomerSubscription"> | $Enums.SubscriptionStatus
    startAt?: DateTimeFilter<"CustomerSubscription"> | Date | string
    trialEndsAt?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    cancelAt?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    priceCents?: IntFilter<"CustomerSubscription"> | number
    currency?: EnumCurrencyFilter<"CustomerSubscription"> | $Enums.Currency
    metadata?: JsonNullableFilter<"CustomerSubscription">
    createdAt?: DateTimeFilter<"CustomerSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerSubscription"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    customerProvider?: XOR<CustomerProviderNullableScalarRelationFilter, CustomerProviderWhereInput> | null
  }

  export type CustomerSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrder
    offerId?: SortOrderInput | SortOrder
    provider?: SortOrder
    accountId?: SortOrderInput | SortOrder
    isNative?: SortOrder
    customerProviderId?: SortOrderInput | SortOrder
    providerSubscriptionId?: SortOrderInput | SortOrder
    vaultPaymentMethodId?: SortOrderInput | SortOrder
    status?: SortOrder
    startAt?: SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    customerProvider?: CustomerProviderOrderByWithRelationInput
  }

  export type CustomerSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerSubscriptionWhereInput | CustomerSubscriptionWhereInput[]
    OR?: CustomerSubscriptionWhereInput[]
    NOT?: CustomerSubscriptionWhereInput | CustomerSubscriptionWhereInput[]
    customerId?: StringFilter<"CustomerSubscription"> | string
    merchantId?: StringFilter<"CustomerSubscription"> | string
    productId?: StringFilter<"CustomerSubscription"> | string
    offerId?: StringNullableFilter<"CustomerSubscription"> | string | null
    provider?: EnumPaymentProviderFilter<"CustomerSubscription"> | $Enums.PaymentProvider
    accountId?: StringNullableFilter<"CustomerSubscription"> | string | null
    isNative?: BoolFilter<"CustomerSubscription"> | boolean
    customerProviderId?: StringNullableFilter<"CustomerSubscription"> | string | null
    providerSubscriptionId?: StringNullableFilter<"CustomerSubscription"> | string | null
    vaultPaymentMethodId?: StringNullableFilter<"CustomerSubscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"CustomerSubscription"> | $Enums.SubscriptionStatus
    startAt?: DateTimeFilter<"CustomerSubscription"> | Date | string
    trialEndsAt?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    cancelAt?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    priceCents?: IntFilter<"CustomerSubscription"> | number
    currency?: EnumCurrencyFilter<"CustomerSubscription"> | $Enums.Currency
    metadata?: JsonNullableFilter<"CustomerSubscription">
    createdAt?: DateTimeFilter<"CustomerSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerSubscription"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    customerProvider?: XOR<CustomerProviderNullableScalarRelationFilter, CustomerProviderWhereInput> | null
  }, "id">

  export type CustomerSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrder
    offerId?: SortOrderInput | SortOrder
    provider?: SortOrder
    accountId?: SortOrderInput | SortOrder
    isNative?: SortOrder
    customerProviderId?: SortOrderInput | SortOrder
    providerSubscriptionId?: SortOrderInput | SortOrder
    vaultPaymentMethodId?: SortOrderInput | SortOrder
    status?: SortOrder
    startAt?: SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerSubscriptionCountOrderByAggregateInput
    _avg?: CustomerSubscriptionAvgOrderByAggregateInput
    _max?: CustomerSubscriptionMaxOrderByAggregateInput
    _min?: CustomerSubscriptionMinOrderByAggregateInput
    _sum?: CustomerSubscriptionSumOrderByAggregateInput
  }

  export type CustomerSubscriptionScalarWhereWithAggregatesInput = {
    AND?: CustomerSubscriptionScalarWhereWithAggregatesInput | CustomerSubscriptionScalarWhereWithAggregatesInput[]
    OR?: CustomerSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: CustomerSubscriptionScalarWhereWithAggregatesInput | CustomerSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerSubscription"> | string
    customerId?: StringWithAggregatesFilter<"CustomerSubscription"> | string
    merchantId?: StringWithAggregatesFilter<"CustomerSubscription"> | string
    productId?: StringWithAggregatesFilter<"CustomerSubscription"> | string
    offerId?: StringNullableWithAggregatesFilter<"CustomerSubscription"> | string | null
    provider?: EnumPaymentProviderWithAggregatesFilter<"CustomerSubscription"> | $Enums.PaymentProvider
    accountId?: StringNullableWithAggregatesFilter<"CustomerSubscription"> | string | null
    isNative?: BoolWithAggregatesFilter<"CustomerSubscription"> | boolean
    customerProviderId?: StringNullableWithAggregatesFilter<"CustomerSubscription"> | string | null
    providerSubscriptionId?: StringNullableWithAggregatesFilter<"CustomerSubscription"> | string | null
    vaultPaymentMethodId?: StringNullableWithAggregatesFilter<"CustomerSubscription"> | string | null
    status?: EnumSubscriptionStatusWithAggregatesFilter<"CustomerSubscription"> | $Enums.SubscriptionStatus
    startAt?: DateTimeWithAggregatesFilter<"CustomerSubscription"> | Date | string
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"CustomerSubscription"> | Date | string | null
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"CustomerSubscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"CustomerSubscription"> | Date | string | null
    cancelAt?: DateTimeNullableWithAggregatesFilter<"CustomerSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"CustomerSubscription"> | Date | string | null
    priceCents?: IntWithAggregatesFilter<"CustomerSubscription"> | number
    currency?: EnumCurrencyWithAggregatesFilter<"CustomerSubscription"> | $Enums.Currency
    metadata?: JsonNullableWithAggregatesFilter<"CustomerSubscription">
    createdAt?: DateTimeWithAggregatesFilter<"CustomerSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerSubscription"> | Date | string
  }

  export type PaymentCustomerWhereInput = {
    AND?: PaymentCustomerWhereInput | PaymentCustomerWhereInput[]
    OR?: PaymentCustomerWhereInput[]
    NOT?: PaymentCustomerWhereInput | PaymentCustomerWhereInput[]
    id?: StringFilter<"PaymentCustomer"> | string
    userId?: StringNullableFilter<"PaymentCustomer"> | string | null
    clinicId?: StringNullableFilter<"PaymentCustomer"> | string | null
    email?: StringNullableFilter<"PaymentCustomer"> | string | null
    document?: StringNullableFilter<"PaymentCustomer"> | string | null
    fullName?: StringNullableFilter<"PaymentCustomer"> | string | null
    phones?: StringNullableFilter<"PaymentCustomer"> | string | null
    createdAt?: DateTimeFilter<"PaymentCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentCustomer"> | Date | string
  }

  export type PaymentCustomerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    phones?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentCustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentCustomerWhereInput | PaymentCustomerWhereInput[]
    OR?: PaymentCustomerWhereInput[]
    NOT?: PaymentCustomerWhereInput | PaymentCustomerWhereInput[]
    userId?: StringNullableFilter<"PaymentCustomer"> | string | null
    clinicId?: StringNullableFilter<"PaymentCustomer"> | string | null
    email?: StringNullableFilter<"PaymentCustomer"> | string | null
    document?: StringNullableFilter<"PaymentCustomer"> | string | null
    fullName?: StringNullableFilter<"PaymentCustomer"> | string | null
    phones?: StringNullableFilter<"PaymentCustomer"> | string | null
    createdAt?: DateTimeFilter<"PaymentCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentCustomer"> | Date | string
  }, "id">

  export type PaymentCustomerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    phones?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCustomerCountOrderByAggregateInput
    _max?: PaymentCustomerMaxOrderByAggregateInput
    _min?: PaymentCustomerMinOrderByAggregateInput
  }

  export type PaymentCustomerScalarWhereWithAggregatesInput = {
    AND?: PaymentCustomerScalarWhereWithAggregatesInput | PaymentCustomerScalarWhereWithAggregatesInput[]
    OR?: PaymentCustomerScalarWhereWithAggregatesInput[]
    NOT?: PaymentCustomerScalarWhereWithAggregatesInput | PaymentCustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentCustomer"> | string
    userId?: StringNullableWithAggregatesFilter<"PaymentCustomer"> | string | null
    clinicId?: StringNullableWithAggregatesFilter<"PaymentCustomer"> | string | null
    email?: StringNullableWithAggregatesFilter<"PaymentCustomer"> | string | null
    document?: StringNullableWithAggregatesFilter<"PaymentCustomer"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"PaymentCustomer"> | string | null
    phones?: StringNullableWithAggregatesFilter<"PaymentCustomer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentCustomer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentCustomer"> | Date | string
  }

  export type MessageTemplateWhereInput = {
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    id?: StringFilter<"MessageTemplate"> | string
    doctorId?: StringFilter<"MessageTemplate"> | string
    name?: StringFilter<"MessageTemplate"> | string
    channel?: StringFilter<"MessageTemplate"> | string
    subject?: StringNullableFilter<"MessageTemplate"> | string | null
    html?: StringNullableFilter<"MessageTemplate"> | string | null
    text?: StringNullableFilter<"MessageTemplate"> | string | null
    mjml?: StringNullableFilter<"MessageTemplate"> | string | null
    renderStrategy?: StringNullableFilter<"MessageTemplate"> | string | null
    fromName?: StringNullableFilter<"MessageTemplate"> | string | null
    fromEmail?: StringNullableFilter<"MessageTemplate"> | string | null
    replyTo?: StringNullableFilter<"MessageTemplate"> | string | null
    provider?: StringNullableFilter<"MessageTemplate"> | string | null
    waTemplateName?: StringNullableFilter<"MessageTemplate"> | string | null
    waLanguage?: StringNullableFilter<"MessageTemplate"> | string | null
    waCategory?: StringNullableFilter<"MessageTemplate"> | string | null
    waComponents?: JsonNullableFilter<"MessageTemplate">
    waStatus?: StringNullableFilter<"MessageTemplate"> | string | null
    waProviderId?: StringNullableFilter<"MessageTemplate"> | string | null
    isActive?: BoolFilter<"MessageTemplate"> | boolean
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    variablesSchema?: JsonNullableFilter<"MessageTemplate">
    sampleVariables?: JsonNullableFilter<"MessageTemplate">
    tags?: StringNullableListFilter<"MessageTemplate">
    smsMaxSegments?: IntNullableFilter<"MessageTemplate"> | number | null
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    steps?: MessageSequenceStepListRelationFilter
  }

  export type MessageTemplateOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    name?: SortOrder
    channel?: SortOrder
    subject?: SortOrderInput | SortOrder
    html?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    mjml?: SortOrderInput | SortOrder
    renderStrategy?: SortOrderInput | SortOrder
    fromName?: SortOrderInput | SortOrder
    fromEmail?: SortOrderInput | SortOrder
    replyTo?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    waTemplateName?: SortOrderInput | SortOrder
    waLanguage?: SortOrderInput | SortOrder
    waCategory?: SortOrderInput | SortOrder
    waComponents?: SortOrderInput | SortOrder
    waStatus?: SortOrderInput | SortOrder
    waProviderId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variablesSchema?: SortOrderInput | SortOrder
    sampleVariables?: SortOrderInput | SortOrder
    tags?: SortOrder
    smsMaxSegments?: SortOrderInput | SortOrder
    doctor?: UserOrderByWithRelationInput
    steps?: MessageSequenceStepOrderByRelationAggregateInput
  }

  export type MessageTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    doctorId_name?: MessageTemplateDoctorIdNameCompoundUniqueInput
    doctorId_channel_waTemplateName_waLanguage?: MessageTemplateDoctorIdChannelWaTemplateNameWaLanguageCompoundUniqueInput
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    doctorId?: StringFilter<"MessageTemplate"> | string
    name?: StringFilter<"MessageTemplate"> | string
    channel?: StringFilter<"MessageTemplate"> | string
    subject?: StringNullableFilter<"MessageTemplate"> | string | null
    html?: StringNullableFilter<"MessageTemplate"> | string | null
    text?: StringNullableFilter<"MessageTemplate"> | string | null
    mjml?: StringNullableFilter<"MessageTemplate"> | string | null
    renderStrategy?: StringNullableFilter<"MessageTemplate"> | string | null
    fromName?: StringNullableFilter<"MessageTemplate"> | string | null
    fromEmail?: StringNullableFilter<"MessageTemplate"> | string | null
    replyTo?: StringNullableFilter<"MessageTemplate"> | string | null
    provider?: StringNullableFilter<"MessageTemplate"> | string | null
    waTemplateName?: StringNullableFilter<"MessageTemplate"> | string | null
    waLanguage?: StringNullableFilter<"MessageTemplate"> | string | null
    waCategory?: StringNullableFilter<"MessageTemplate"> | string | null
    waComponents?: JsonNullableFilter<"MessageTemplate">
    waStatus?: StringNullableFilter<"MessageTemplate"> | string | null
    waProviderId?: StringNullableFilter<"MessageTemplate"> | string | null
    isActive?: BoolFilter<"MessageTemplate"> | boolean
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    variablesSchema?: JsonNullableFilter<"MessageTemplate">
    sampleVariables?: JsonNullableFilter<"MessageTemplate">
    tags?: StringNullableListFilter<"MessageTemplate">
    smsMaxSegments?: IntNullableFilter<"MessageTemplate"> | number | null
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    steps?: MessageSequenceStepListRelationFilter
  }, "id" | "doctorId_name" | "doctorId_channel_waTemplateName_waLanguage">

  export type MessageTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    name?: SortOrder
    channel?: SortOrder
    subject?: SortOrderInput | SortOrder
    html?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    mjml?: SortOrderInput | SortOrder
    renderStrategy?: SortOrderInput | SortOrder
    fromName?: SortOrderInput | SortOrder
    fromEmail?: SortOrderInput | SortOrder
    replyTo?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    waTemplateName?: SortOrderInput | SortOrder
    waLanguage?: SortOrderInput | SortOrder
    waCategory?: SortOrderInput | SortOrder
    waComponents?: SortOrderInput | SortOrder
    waStatus?: SortOrderInput | SortOrder
    waProviderId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variablesSchema?: SortOrderInput | SortOrder
    sampleVariables?: SortOrderInput | SortOrder
    tags?: SortOrder
    smsMaxSegments?: SortOrderInput | SortOrder
    _count?: MessageTemplateCountOrderByAggregateInput
    _avg?: MessageTemplateAvgOrderByAggregateInput
    _max?: MessageTemplateMaxOrderByAggregateInput
    _min?: MessageTemplateMinOrderByAggregateInput
    _sum?: MessageTemplateSumOrderByAggregateInput
  }

  export type MessageTemplateScalarWhereWithAggregatesInput = {
    AND?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    OR?: MessageTemplateScalarWhereWithAggregatesInput[]
    NOT?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageTemplate"> | string
    doctorId?: StringWithAggregatesFilter<"MessageTemplate"> | string
    name?: StringWithAggregatesFilter<"MessageTemplate"> | string
    channel?: StringWithAggregatesFilter<"MessageTemplate"> | string
    subject?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    html?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    text?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    mjml?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    renderStrategy?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    fromName?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    fromEmail?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    replyTo?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    provider?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    waTemplateName?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    waLanguage?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    waCategory?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    waComponents?: JsonNullableWithAggregatesFilter<"MessageTemplate">
    waStatus?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    waProviderId?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    isActive?: BoolWithAggregatesFilter<"MessageTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageTemplate"> | Date | string
    variablesSchema?: JsonNullableWithAggregatesFilter<"MessageTemplate">
    sampleVariables?: JsonNullableWithAggregatesFilter<"MessageTemplate">
    tags?: StringNullableListFilter<"MessageTemplate">
    smsMaxSegments?: IntNullableWithAggregatesFilter<"MessageTemplate"> | number | null
  }

  export type MessageSequenceWhereInput = {
    AND?: MessageSequenceWhereInput | MessageSequenceWhereInput[]
    OR?: MessageSequenceWhereInput[]
    NOT?: MessageSequenceWhereInput | MessageSequenceWhereInput[]
    id?: StringFilter<"MessageSequence"> | string
    doctorId?: StringFilter<"MessageSequence"> | string
    name?: StringFilter<"MessageSequence"> | string
    description?: StringNullableFilter<"MessageSequence"> | string | null
    isActive?: BoolFilter<"MessageSequence"> | boolean
    createdAt?: DateTimeFilter<"MessageSequence"> | Date | string
    updatedAt?: DateTimeFilter<"MessageSequence"> | Date | string
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    steps?: MessageSequenceStepListRelationFilter
  }

  export type MessageSequenceOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctor?: UserOrderByWithRelationInput
    steps?: MessageSequenceStepOrderByRelationAggregateInput
  }

  export type MessageSequenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    doctorId_name?: MessageSequenceDoctorIdNameCompoundUniqueInput
    AND?: MessageSequenceWhereInput | MessageSequenceWhereInput[]
    OR?: MessageSequenceWhereInput[]
    NOT?: MessageSequenceWhereInput | MessageSequenceWhereInput[]
    doctorId?: StringFilter<"MessageSequence"> | string
    name?: StringFilter<"MessageSequence"> | string
    description?: StringNullableFilter<"MessageSequence"> | string | null
    isActive?: BoolFilter<"MessageSequence"> | boolean
    createdAt?: DateTimeFilter<"MessageSequence"> | Date | string
    updatedAt?: DateTimeFilter<"MessageSequence"> | Date | string
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    steps?: MessageSequenceStepListRelationFilter
  }, "id" | "doctorId_name">

  export type MessageSequenceOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageSequenceCountOrderByAggregateInput
    _max?: MessageSequenceMaxOrderByAggregateInput
    _min?: MessageSequenceMinOrderByAggregateInput
  }

  export type MessageSequenceScalarWhereWithAggregatesInput = {
    AND?: MessageSequenceScalarWhereWithAggregatesInput | MessageSequenceScalarWhereWithAggregatesInput[]
    OR?: MessageSequenceScalarWhereWithAggregatesInput[]
    NOT?: MessageSequenceScalarWhereWithAggregatesInput | MessageSequenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageSequence"> | string
    doctorId?: StringWithAggregatesFilter<"MessageSequence"> | string
    name?: StringWithAggregatesFilter<"MessageSequence"> | string
    description?: StringNullableWithAggregatesFilter<"MessageSequence"> | string | null
    isActive?: BoolWithAggregatesFilter<"MessageSequence"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MessageSequence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageSequence"> | Date | string
  }

  export type MessageSequenceStepWhereInput = {
    AND?: MessageSequenceStepWhereInput | MessageSequenceStepWhereInput[]
    OR?: MessageSequenceStepWhereInput[]
    NOT?: MessageSequenceStepWhereInput | MessageSequenceStepWhereInput[]
    id?: StringFilter<"MessageSequenceStep"> | string
    sequenceId?: StringFilter<"MessageSequenceStep"> | string
    orderIndex?: IntFilter<"MessageSequenceStep"> | number
    delayAmount?: IntFilter<"MessageSequenceStep"> | number
    delayUnit?: StringFilter<"MessageSequenceStep"> | string
    templateId?: StringFilter<"MessageSequenceStep"> | string
    createdAt?: DateTimeFilter<"MessageSequenceStep"> | Date | string
    updatedAt?: DateTimeFilter<"MessageSequenceStep"> | Date | string
    sequence?: XOR<MessageSequenceScalarRelationFilter, MessageSequenceWhereInput>
    template?: XOR<MessageTemplateScalarRelationFilter, MessageTemplateWhereInput>
  }

  export type MessageSequenceStepOrderByWithRelationInput = {
    id?: SortOrder
    sequenceId?: SortOrder
    orderIndex?: SortOrder
    delayAmount?: SortOrder
    delayUnit?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sequence?: MessageSequenceOrderByWithRelationInput
    template?: MessageTemplateOrderByWithRelationInput
  }

  export type MessageSequenceStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sequenceId_orderIndex?: MessageSequenceStepSequenceIdOrderIndexCompoundUniqueInput
    AND?: MessageSequenceStepWhereInput | MessageSequenceStepWhereInput[]
    OR?: MessageSequenceStepWhereInput[]
    NOT?: MessageSequenceStepWhereInput | MessageSequenceStepWhereInput[]
    sequenceId?: StringFilter<"MessageSequenceStep"> | string
    orderIndex?: IntFilter<"MessageSequenceStep"> | number
    delayAmount?: IntFilter<"MessageSequenceStep"> | number
    delayUnit?: StringFilter<"MessageSequenceStep"> | string
    templateId?: StringFilter<"MessageSequenceStep"> | string
    createdAt?: DateTimeFilter<"MessageSequenceStep"> | Date | string
    updatedAt?: DateTimeFilter<"MessageSequenceStep"> | Date | string
    sequence?: XOR<MessageSequenceScalarRelationFilter, MessageSequenceWhereInput>
    template?: XOR<MessageTemplateScalarRelationFilter, MessageTemplateWhereInput>
  }, "id" | "sequenceId_orderIndex">

  export type MessageSequenceStepOrderByWithAggregationInput = {
    id?: SortOrder
    sequenceId?: SortOrder
    orderIndex?: SortOrder
    delayAmount?: SortOrder
    delayUnit?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageSequenceStepCountOrderByAggregateInput
    _avg?: MessageSequenceStepAvgOrderByAggregateInput
    _max?: MessageSequenceStepMaxOrderByAggregateInput
    _min?: MessageSequenceStepMinOrderByAggregateInput
    _sum?: MessageSequenceStepSumOrderByAggregateInput
  }

  export type MessageSequenceStepScalarWhereWithAggregatesInput = {
    AND?: MessageSequenceStepScalarWhereWithAggregatesInput | MessageSequenceStepScalarWhereWithAggregatesInput[]
    OR?: MessageSequenceStepScalarWhereWithAggregatesInput[]
    NOT?: MessageSequenceStepScalarWhereWithAggregatesInput | MessageSequenceStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageSequenceStep"> | string
    sequenceId?: StringWithAggregatesFilter<"MessageSequenceStep"> | string
    orderIndex?: IntWithAggregatesFilter<"MessageSequenceStep"> | number
    delayAmount?: IntWithAggregatesFilter<"MessageSequenceStep"> | number
    delayUnit?: StringWithAggregatesFilter<"MessageSequenceStep"> | string
    templateId?: StringWithAggregatesFilter<"MessageSequenceStep"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageSequenceStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageSequenceStep"> | Date | string
  }

  export type CampaignJobWhereInput = {
    AND?: CampaignJobWhereInput | CampaignJobWhereInput[]
    OR?: CampaignJobWhereInput[]
    NOT?: CampaignJobWhereInput | CampaignJobWhereInput[]
    id?: StringFilter<"CampaignJob"> | string
    doctorId?: StringFilter<"CampaignJob"> | string
    campaignId?: StringFilter<"CampaignJob"> | string
    channel?: StringFilter<"CampaignJob"> | string
    trigger?: StringNullableFilter<"CampaignJob"> | string | null
    scheduleAt?: DateTimeFilter<"CampaignJob"> | Date | string
    createdAt?: DateTimeFilter<"CampaignJob"> | Date | string
    status?: StringFilter<"CampaignJob"> | string
    lastError?: StringNullableFilter<"CampaignJob"> | string | null
  }

  export type CampaignJobOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    campaignId?: SortOrder
    channel?: SortOrder
    trigger?: SortOrderInput | SortOrder
    scheduleAt?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    lastError?: SortOrderInput | SortOrder
  }

  export type CampaignJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignJobWhereInput | CampaignJobWhereInput[]
    OR?: CampaignJobWhereInput[]
    NOT?: CampaignJobWhereInput | CampaignJobWhereInput[]
    doctorId?: StringFilter<"CampaignJob"> | string
    campaignId?: StringFilter<"CampaignJob"> | string
    channel?: StringFilter<"CampaignJob"> | string
    trigger?: StringNullableFilter<"CampaignJob"> | string | null
    scheduleAt?: DateTimeFilter<"CampaignJob"> | Date | string
    createdAt?: DateTimeFilter<"CampaignJob"> | Date | string
    status?: StringFilter<"CampaignJob"> | string
    lastError?: StringNullableFilter<"CampaignJob"> | string | null
  }, "id">

  export type CampaignJobOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    campaignId?: SortOrder
    channel?: SortOrder
    trigger?: SortOrderInput | SortOrder
    scheduleAt?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    lastError?: SortOrderInput | SortOrder
    _count?: CampaignJobCountOrderByAggregateInput
    _max?: CampaignJobMaxOrderByAggregateInput
    _min?: CampaignJobMinOrderByAggregateInput
  }

  export type CampaignJobScalarWhereWithAggregatesInput = {
    AND?: CampaignJobScalarWhereWithAggregatesInput | CampaignJobScalarWhereWithAggregatesInput[]
    OR?: CampaignJobScalarWhereWithAggregatesInput[]
    NOT?: CampaignJobScalarWhereWithAggregatesInput | CampaignJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignJob"> | string
    doctorId?: StringWithAggregatesFilter<"CampaignJob"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignJob"> | string
    channel?: StringWithAggregatesFilter<"CampaignJob"> | string
    trigger?: StringNullableWithAggregatesFilter<"CampaignJob"> | string | null
    scheduleAt?: DateTimeWithAggregatesFilter<"CampaignJob"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CampaignJob"> | Date | string
    status?: StringWithAggregatesFilter<"CampaignJob"> | string
    lastError?: StringNullableWithAggregatesFilter<"CampaignJob"> | string | null
  }

  export type OpenFinanceLinkWhereInput = {
    AND?: OpenFinanceLinkWhereInput | OpenFinanceLinkWhereInput[]
    OR?: OpenFinanceLinkWhereInput[]
    NOT?: OpenFinanceLinkWhereInput | OpenFinanceLinkWhereInput[]
    id?: StringFilter<"OpenFinanceLink"> | string
    userId?: StringFilter<"OpenFinanceLink"> | string
    clinicId?: StringNullableFilter<"OpenFinanceLink"> | string | null
    organisationId?: StringFilter<"OpenFinanceLink"> | string
    authorisationServerId?: StringFilter<"OpenFinanceLink"> | string
    enrollmentId?: StringFilter<"OpenFinanceLink"> | string
    status?: StringFilter<"OpenFinanceLink"> | string
    deviceBinding?: JsonNullableFilter<"OpenFinanceLink">
    createdAt?: DateTimeFilter<"OpenFinanceLink"> | Date | string
    updatedAt?: DateTimeFilter<"OpenFinanceLink"> | Date | string
    consent?: XOR<OpenFinanceConsentNullableScalarRelationFilter, OpenFinanceConsentWhereInput> | null
  }

  export type OpenFinanceLinkOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    enrollmentId?: SortOrder
    status?: SortOrder
    deviceBinding?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consent?: OpenFinanceConsentOrderByWithRelationInput
  }

  export type OpenFinanceLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OpenFinanceLinkWhereInput | OpenFinanceLinkWhereInput[]
    OR?: OpenFinanceLinkWhereInput[]
    NOT?: OpenFinanceLinkWhereInput | OpenFinanceLinkWhereInput[]
    userId?: StringFilter<"OpenFinanceLink"> | string
    clinicId?: StringNullableFilter<"OpenFinanceLink"> | string | null
    organisationId?: StringFilter<"OpenFinanceLink"> | string
    authorisationServerId?: StringFilter<"OpenFinanceLink"> | string
    enrollmentId?: StringFilter<"OpenFinanceLink"> | string
    status?: StringFilter<"OpenFinanceLink"> | string
    deviceBinding?: JsonNullableFilter<"OpenFinanceLink">
    createdAt?: DateTimeFilter<"OpenFinanceLink"> | Date | string
    updatedAt?: DateTimeFilter<"OpenFinanceLink"> | Date | string
    consent?: XOR<OpenFinanceConsentNullableScalarRelationFilter, OpenFinanceConsentWhereInput> | null
  }, "id">

  export type OpenFinanceLinkOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    enrollmentId?: SortOrder
    status?: SortOrder
    deviceBinding?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OpenFinanceLinkCountOrderByAggregateInput
    _max?: OpenFinanceLinkMaxOrderByAggregateInput
    _min?: OpenFinanceLinkMinOrderByAggregateInput
  }

  export type OpenFinanceLinkScalarWhereWithAggregatesInput = {
    AND?: OpenFinanceLinkScalarWhereWithAggregatesInput | OpenFinanceLinkScalarWhereWithAggregatesInput[]
    OR?: OpenFinanceLinkScalarWhereWithAggregatesInput[]
    NOT?: OpenFinanceLinkScalarWhereWithAggregatesInput | OpenFinanceLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OpenFinanceLink"> | string
    userId?: StringWithAggregatesFilter<"OpenFinanceLink"> | string
    clinicId?: StringNullableWithAggregatesFilter<"OpenFinanceLink"> | string | null
    organisationId?: StringWithAggregatesFilter<"OpenFinanceLink"> | string
    authorisationServerId?: StringWithAggregatesFilter<"OpenFinanceLink"> | string
    enrollmentId?: StringWithAggregatesFilter<"OpenFinanceLink"> | string
    status?: StringWithAggregatesFilter<"OpenFinanceLink"> | string
    deviceBinding?: JsonNullableWithAggregatesFilter<"OpenFinanceLink">
    createdAt?: DateTimeWithAggregatesFilter<"OpenFinanceLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OpenFinanceLink"> | Date | string
  }

  export type OpenFinanceConsentWhereInput = {
    AND?: OpenFinanceConsentWhereInput | OpenFinanceConsentWhereInput[]
    OR?: OpenFinanceConsentWhereInput[]
    NOT?: OpenFinanceConsentWhereInput | OpenFinanceConsentWhereInput[]
    id?: StringFilter<"OpenFinanceConsent"> | string
    linkId?: StringFilter<"OpenFinanceConsent"> | string
    consentId?: StringFilter<"OpenFinanceConsent"> | string
    contractId?: StringFilter<"OpenFinanceConsent"> | string
    status?: StringFilter<"OpenFinanceConsent"> | string
    amountCents?: IntFilter<"OpenFinanceConsent"> | number
    periodicity?: StringFilter<"OpenFinanceConsent"> | string
    nextExecutionAt?: DateTimeNullableFilter<"OpenFinanceConsent"> | Date | string | null
    metadata?: JsonNullableFilter<"OpenFinanceConsent">
    createdAt?: DateTimeFilter<"OpenFinanceConsent"> | Date | string
    updatedAt?: DateTimeFilter<"OpenFinanceConsent"> | Date | string
    link?: XOR<OpenFinanceLinkScalarRelationFilter, OpenFinanceLinkWhereInput>
  }

  export type OpenFinanceConsentOrderByWithRelationInput = {
    id?: SortOrder
    linkId?: SortOrder
    consentId?: SortOrder
    contractId?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    periodicity?: SortOrder
    nextExecutionAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    link?: OpenFinanceLinkOrderByWithRelationInput
  }

  export type OpenFinanceConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    linkId?: string
    AND?: OpenFinanceConsentWhereInput | OpenFinanceConsentWhereInput[]
    OR?: OpenFinanceConsentWhereInput[]
    NOT?: OpenFinanceConsentWhereInput | OpenFinanceConsentWhereInput[]
    consentId?: StringFilter<"OpenFinanceConsent"> | string
    contractId?: StringFilter<"OpenFinanceConsent"> | string
    status?: StringFilter<"OpenFinanceConsent"> | string
    amountCents?: IntFilter<"OpenFinanceConsent"> | number
    periodicity?: StringFilter<"OpenFinanceConsent"> | string
    nextExecutionAt?: DateTimeNullableFilter<"OpenFinanceConsent"> | Date | string | null
    metadata?: JsonNullableFilter<"OpenFinanceConsent">
    createdAt?: DateTimeFilter<"OpenFinanceConsent"> | Date | string
    updatedAt?: DateTimeFilter<"OpenFinanceConsent"> | Date | string
    link?: XOR<OpenFinanceLinkScalarRelationFilter, OpenFinanceLinkWhereInput>
  }, "id" | "linkId">

  export type OpenFinanceConsentOrderByWithAggregationInput = {
    id?: SortOrder
    linkId?: SortOrder
    consentId?: SortOrder
    contractId?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    periodicity?: SortOrder
    nextExecutionAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OpenFinanceConsentCountOrderByAggregateInput
    _avg?: OpenFinanceConsentAvgOrderByAggregateInput
    _max?: OpenFinanceConsentMaxOrderByAggregateInput
    _min?: OpenFinanceConsentMinOrderByAggregateInput
    _sum?: OpenFinanceConsentSumOrderByAggregateInput
  }

  export type OpenFinanceConsentScalarWhereWithAggregatesInput = {
    AND?: OpenFinanceConsentScalarWhereWithAggregatesInput | OpenFinanceConsentScalarWhereWithAggregatesInput[]
    OR?: OpenFinanceConsentScalarWhereWithAggregatesInput[]
    NOT?: OpenFinanceConsentScalarWhereWithAggregatesInput | OpenFinanceConsentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OpenFinanceConsent"> | string
    linkId?: StringWithAggregatesFilter<"OpenFinanceConsent"> | string
    consentId?: StringWithAggregatesFilter<"OpenFinanceConsent"> | string
    contractId?: StringWithAggregatesFilter<"OpenFinanceConsent"> | string
    status?: StringWithAggregatesFilter<"OpenFinanceConsent"> | string
    amountCents?: IntWithAggregatesFilter<"OpenFinanceConsent"> | number
    periodicity?: StringWithAggregatesFilter<"OpenFinanceConsent"> | string
    nextExecutionAt?: DateTimeNullableWithAggregatesFilter<"OpenFinanceConsent"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"OpenFinanceConsent">
    createdAt?: DateTimeWithAggregatesFilter<"OpenFinanceConsent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OpenFinanceConsent"> | Date | string
  }

  export type OpenBankingPaymentWhereInput = {
    AND?: OpenBankingPaymentWhereInput | OpenBankingPaymentWhereInput[]
    OR?: OpenBankingPaymentWhereInput[]
    NOT?: OpenBankingPaymentWhereInput | OpenBankingPaymentWhereInput[]
    id?: UuidFilter<"OpenBankingPayment"> | string
    providerPaymentId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    consentId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    amountCents?: IntNullableFilter<"OpenBankingPayment"> | number | null
    currency?: StringNullableFilter<"OpenBankingPayment"> | string | null
    status?: EnumPaymentStatusOBNullableFilter<"OpenBankingPayment"> | $Enums.PaymentStatusOB | null
    createdAt?: DateTimeFilter<"OpenBankingPayment"> | Date | string
    updatedAt?: DateTimeFilter<"OpenBankingPayment"> | Date | string
    enrollmentId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    transactionIdentification?: StringNullableFilter<"OpenBankingPayment"> | string | null
    payerId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    payerDocument?: StringNullableFilter<"OpenBankingPayment"> | string | null
    payerEmail?: StringNullableFilter<"OpenBankingPayment"> | string | null
    payerName?: StringNullableFilter<"OpenBankingPayment"> | string | null
    creditorName?: StringNullableFilter<"OpenBankingPayment"> | string | null
    creditorCpfCnpj?: StringNullableFilter<"OpenBankingPayment"> | string | null
    clinicId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    productId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    purchaseId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    type?: EnumPaymentTypeOBNullableFilter<"OpenBankingPayment"> | $Enums.PaymentTypeOB | null
    executedAt?: DateTimeNullableFilter<"OpenBankingPayment"> | Date | string | null
    settledAt?: DateTimeNullableFilter<"OpenBankingPayment"> | Date | string | null
    recurrenceType?: StringNullableFilter<"OpenBankingPayment"> | string | null
    subscriptionId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    executionOrder?: IntNullableFilter<"OpenBankingPayment"> | number | null
    providerResponse?: JsonNullableFilter<"OpenBankingPayment">
    fidoAssertion?: JsonNullableFilter<"OpenBankingPayment">
    riskSignals?: JsonNullableFilter<"OpenBankingPayment">
    paymentLinkId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    userId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    orderRef?: StringNullableFilter<"OpenBankingPayment"> | string | null
    redirectUri?: StringNullableFilter<"OpenBankingPayment"> | string | null
    transactionId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    expiresAt?: DateTimeNullableFilter<"OpenBankingPayment"> | Date | string | null
    metadata?: JsonNullableFilter<"OpenBankingPayment">
  }

  export type OpenBankingPaymentOrderByWithRelationInput = {
    id?: SortOrder
    providerPaymentId?: SortOrderInput | SortOrder
    consentId?: SortOrderInput | SortOrder
    amountCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enrollmentId?: SortOrderInput | SortOrder
    transactionIdentification?: SortOrderInput | SortOrder
    payerId?: SortOrderInput | SortOrder
    payerDocument?: SortOrderInput | SortOrder
    payerEmail?: SortOrderInput | SortOrder
    payerName?: SortOrderInput | SortOrder
    creditorName?: SortOrderInput | SortOrder
    creditorCpfCnpj?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    purchaseId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    settledAt?: SortOrderInput | SortOrder
    recurrenceType?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    executionOrder?: SortOrderInput | SortOrder
    providerResponse?: SortOrderInput | SortOrder
    fidoAssertion?: SortOrderInput | SortOrder
    riskSignals?: SortOrderInput | SortOrder
    paymentLinkId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    orderRef?: SortOrderInput | SortOrder
    redirectUri?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type OpenBankingPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentLinkId?: string
    AND?: OpenBankingPaymentWhereInput | OpenBankingPaymentWhereInput[]
    OR?: OpenBankingPaymentWhereInput[]
    NOT?: OpenBankingPaymentWhereInput | OpenBankingPaymentWhereInput[]
    providerPaymentId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    consentId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    amountCents?: IntNullableFilter<"OpenBankingPayment"> | number | null
    currency?: StringNullableFilter<"OpenBankingPayment"> | string | null
    status?: EnumPaymentStatusOBNullableFilter<"OpenBankingPayment"> | $Enums.PaymentStatusOB | null
    createdAt?: DateTimeFilter<"OpenBankingPayment"> | Date | string
    updatedAt?: DateTimeFilter<"OpenBankingPayment"> | Date | string
    enrollmentId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    transactionIdentification?: StringNullableFilter<"OpenBankingPayment"> | string | null
    payerId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    payerDocument?: StringNullableFilter<"OpenBankingPayment"> | string | null
    payerEmail?: StringNullableFilter<"OpenBankingPayment"> | string | null
    payerName?: StringNullableFilter<"OpenBankingPayment"> | string | null
    creditorName?: StringNullableFilter<"OpenBankingPayment"> | string | null
    creditorCpfCnpj?: StringNullableFilter<"OpenBankingPayment"> | string | null
    clinicId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    productId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    purchaseId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    type?: EnumPaymentTypeOBNullableFilter<"OpenBankingPayment"> | $Enums.PaymentTypeOB | null
    executedAt?: DateTimeNullableFilter<"OpenBankingPayment"> | Date | string | null
    settledAt?: DateTimeNullableFilter<"OpenBankingPayment"> | Date | string | null
    recurrenceType?: StringNullableFilter<"OpenBankingPayment"> | string | null
    subscriptionId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    executionOrder?: IntNullableFilter<"OpenBankingPayment"> | number | null
    providerResponse?: JsonNullableFilter<"OpenBankingPayment">
    fidoAssertion?: JsonNullableFilter<"OpenBankingPayment">
    riskSignals?: JsonNullableFilter<"OpenBankingPayment">
    userId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    orderRef?: StringNullableFilter<"OpenBankingPayment"> | string | null
    redirectUri?: StringNullableFilter<"OpenBankingPayment"> | string | null
    transactionId?: StringNullableFilter<"OpenBankingPayment"> | string | null
    expiresAt?: DateTimeNullableFilter<"OpenBankingPayment"> | Date | string | null
    metadata?: JsonNullableFilter<"OpenBankingPayment">
  }, "id" | "paymentLinkId">

  export type OpenBankingPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    providerPaymentId?: SortOrderInput | SortOrder
    consentId?: SortOrderInput | SortOrder
    amountCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enrollmentId?: SortOrderInput | SortOrder
    transactionIdentification?: SortOrderInput | SortOrder
    payerId?: SortOrderInput | SortOrder
    payerDocument?: SortOrderInput | SortOrder
    payerEmail?: SortOrderInput | SortOrder
    payerName?: SortOrderInput | SortOrder
    creditorName?: SortOrderInput | SortOrder
    creditorCpfCnpj?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    purchaseId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    settledAt?: SortOrderInput | SortOrder
    recurrenceType?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    executionOrder?: SortOrderInput | SortOrder
    providerResponse?: SortOrderInput | SortOrder
    fidoAssertion?: SortOrderInput | SortOrder
    riskSignals?: SortOrderInput | SortOrder
    paymentLinkId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    orderRef?: SortOrderInput | SortOrder
    redirectUri?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: OpenBankingPaymentCountOrderByAggregateInput
    _avg?: OpenBankingPaymentAvgOrderByAggregateInput
    _max?: OpenBankingPaymentMaxOrderByAggregateInput
    _min?: OpenBankingPaymentMinOrderByAggregateInput
    _sum?: OpenBankingPaymentSumOrderByAggregateInput
  }

  export type OpenBankingPaymentScalarWhereWithAggregatesInput = {
    AND?: OpenBankingPaymentScalarWhereWithAggregatesInput | OpenBankingPaymentScalarWhereWithAggregatesInput[]
    OR?: OpenBankingPaymentScalarWhereWithAggregatesInput[]
    NOT?: OpenBankingPaymentScalarWhereWithAggregatesInput | OpenBankingPaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OpenBankingPayment"> | string
    providerPaymentId?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    consentId?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    amountCents?: IntNullableWithAggregatesFilter<"OpenBankingPayment"> | number | null
    currency?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    status?: EnumPaymentStatusOBNullableWithAggregatesFilter<"OpenBankingPayment"> | $Enums.PaymentStatusOB | null
    createdAt?: DateTimeWithAggregatesFilter<"OpenBankingPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OpenBankingPayment"> | Date | string
    enrollmentId?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    transactionIdentification?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    payerId?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    payerDocument?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    payerEmail?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    payerName?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    creditorName?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    creditorCpfCnpj?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    clinicId?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    productId?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    purchaseId?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    type?: EnumPaymentTypeOBNullableWithAggregatesFilter<"OpenBankingPayment"> | $Enums.PaymentTypeOB | null
    executedAt?: DateTimeNullableWithAggregatesFilter<"OpenBankingPayment"> | Date | string | null
    settledAt?: DateTimeNullableWithAggregatesFilter<"OpenBankingPayment"> | Date | string | null
    recurrenceType?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    subscriptionId?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    executionOrder?: IntNullableWithAggregatesFilter<"OpenBankingPayment"> | number | null
    providerResponse?: JsonNullableWithAggregatesFilter<"OpenBankingPayment">
    fidoAssertion?: JsonNullableWithAggregatesFilter<"OpenBankingPayment">
    riskSignals?: JsonNullableWithAggregatesFilter<"OpenBankingPayment">
    paymentLinkId?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    userId?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    orderRef?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    redirectUri?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"OpenBankingPayment"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"OpenBankingPayment"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"OpenBankingPayment">
  }

  export type OpenBankingConsentWhereInput = {
    AND?: OpenBankingConsentWhereInput | OpenBankingConsentWhereInput[]
    OR?: OpenBankingConsentWhereInput[]
    NOT?: OpenBankingConsentWhereInput | OpenBankingConsentWhereInput[]
    id?: UuidFilter<"OpenBankingConsent"> | string
    enrollmentId?: StringNullableFilter<"OpenBankingConsent"> | string | null
    consentId?: StringFilter<"OpenBankingConsent"> | string
    amountCents?: IntNullableFilter<"OpenBankingConsent"> | number | null
    currency?: StringNullableFilter<"OpenBankingConsent"> | string | null
    creditorName?: StringNullableFilter<"OpenBankingConsent"> | string | null
    creditorCpfCnpj?: StringNullableFilter<"OpenBankingConsent"> | string | null
    productId?: StringNullableFilter<"OpenBankingConsent"> | string | null
    clinicId?: StringNullableFilter<"OpenBankingConsent"> | string | null
    status?: EnumConsentStatusOBNullableFilter<"OpenBankingConsent"> | $Enums.ConsentStatusOB | null
    providerResponse?: JsonNullableFilter<"OpenBankingConsent">
    createdAt?: DateTimeFilter<"OpenBankingConsent"> | Date | string
    updatedAt?: DateTimeFilter<"OpenBankingConsent"> | Date | string
  }

  export type OpenBankingConsentOrderByWithRelationInput = {
    id?: SortOrder
    enrollmentId?: SortOrderInput | SortOrder
    consentId?: SortOrder
    amountCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    creditorName?: SortOrderInput | SortOrder
    creditorCpfCnpj?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    providerResponse?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpenBankingConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    consentId?: string
    AND?: OpenBankingConsentWhereInput | OpenBankingConsentWhereInput[]
    OR?: OpenBankingConsentWhereInput[]
    NOT?: OpenBankingConsentWhereInput | OpenBankingConsentWhereInput[]
    enrollmentId?: StringNullableFilter<"OpenBankingConsent"> | string | null
    amountCents?: IntNullableFilter<"OpenBankingConsent"> | number | null
    currency?: StringNullableFilter<"OpenBankingConsent"> | string | null
    creditorName?: StringNullableFilter<"OpenBankingConsent"> | string | null
    creditorCpfCnpj?: StringNullableFilter<"OpenBankingConsent"> | string | null
    productId?: StringNullableFilter<"OpenBankingConsent"> | string | null
    clinicId?: StringNullableFilter<"OpenBankingConsent"> | string | null
    status?: EnumConsentStatusOBNullableFilter<"OpenBankingConsent"> | $Enums.ConsentStatusOB | null
    providerResponse?: JsonNullableFilter<"OpenBankingConsent">
    createdAt?: DateTimeFilter<"OpenBankingConsent"> | Date | string
    updatedAt?: DateTimeFilter<"OpenBankingConsent"> | Date | string
  }, "id" | "consentId">

  export type OpenBankingConsentOrderByWithAggregationInput = {
    id?: SortOrder
    enrollmentId?: SortOrderInput | SortOrder
    consentId?: SortOrder
    amountCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    creditorName?: SortOrderInput | SortOrder
    creditorCpfCnpj?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    providerResponse?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OpenBankingConsentCountOrderByAggregateInput
    _avg?: OpenBankingConsentAvgOrderByAggregateInput
    _max?: OpenBankingConsentMaxOrderByAggregateInput
    _min?: OpenBankingConsentMinOrderByAggregateInput
    _sum?: OpenBankingConsentSumOrderByAggregateInput
  }

  export type OpenBankingConsentScalarWhereWithAggregatesInput = {
    AND?: OpenBankingConsentScalarWhereWithAggregatesInput | OpenBankingConsentScalarWhereWithAggregatesInput[]
    OR?: OpenBankingConsentScalarWhereWithAggregatesInput[]
    NOT?: OpenBankingConsentScalarWhereWithAggregatesInput | OpenBankingConsentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OpenBankingConsent"> | string
    enrollmentId?: StringNullableWithAggregatesFilter<"OpenBankingConsent"> | string | null
    consentId?: StringWithAggregatesFilter<"OpenBankingConsent"> | string
    amountCents?: IntNullableWithAggregatesFilter<"OpenBankingConsent"> | number | null
    currency?: StringNullableWithAggregatesFilter<"OpenBankingConsent"> | string | null
    creditorName?: StringNullableWithAggregatesFilter<"OpenBankingConsent"> | string | null
    creditorCpfCnpj?: StringNullableWithAggregatesFilter<"OpenBankingConsent"> | string | null
    productId?: StringNullableWithAggregatesFilter<"OpenBankingConsent"> | string | null
    clinicId?: StringNullableWithAggregatesFilter<"OpenBankingConsent"> | string | null
    status?: EnumConsentStatusOBNullableWithAggregatesFilter<"OpenBankingConsent"> | $Enums.ConsentStatusOB | null
    providerResponse?: JsonNullableWithAggregatesFilter<"OpenBankingConsent">
    createdAt?: DateTimeWithAggregatesFilter<"OpenBankingConsent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OpenBankingConsent"> | Date | string
  }

  export type EnrollmentContextWhereInput = {
    AND?: EnrollmentContextWhereInput | EnrollmentContextWhereInput[]
    OR?: EnrollmentContextWhereInput[]
    NOT?: EnrollmentContextWhereInput | EnrollmentContextWhereInput[]
    id?: UuidFilter<"EnrollmentContext"> | string
    userId?: StringFilter<"EnrollmentContext"> | string
    sessionId?: StringNullableFilter<"EnrollmentContext"> | string | null
    enrollmentId?: StringFilter<"EnrollmentContext"> | string
    organisationId?: StringFilter<"EnrollmentContext"> | string
    authorisationServerId?: StringFilter<"EnrollmentContext"> | string
    fallbackUsed?: BoolFilter<"EnrollmentContext"> | boolean
    createdAt?: DateTimeFilter<"EnrollmentContext"> | Date | string
    updatedAt?: DateTimeFilter<"EnrollmentContext"> | Date | string
    status?: EnumEnrollmentStatusOBNullableFilter<"EnrollmentContext"> | $Enums.EnrollmentStatusOB | null
    deviceRegistered?: BoolFilter<"EnrollmentContext"> | boolean
    expiresAt?: DateTimeNullableFilter<"EnrollmentContext"> | Date | string | null
    clinicId?: StringNullableFilter<"EnrollmentContext"> | string | null
    payerEmail?: StringNullableFilter<"EnrollmentContext"> | string | null
    payerDocument?: StringNullableFilter<"EnrollmentContext"> | string | null
    payerName?: StringNullableFilter<"EnrollmentContext"> | string | null
    recurringEnabled?: BoolNullableFilter<"EnrollmentContext"> | boolean | null
    deviceBinding?: JsonNullableFilter<"EnrollmentContext">
    providerResponse?: JsonNullableFilter<"EnrollmentContext">
  }

  export type EnrollmentContextOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    enrollmentId?: SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    fallbackUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrderInput | SortOrder
    deviceRegistered?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    payerEmail?: SortOrderInput | SortOrder
    payerDocument?: SortOrderInput | SortOrder
    payerName?: SortOrderInput | SortOrder
    recurringEnabled?: SortOrderInput | SortOrder
    deviceBinding?: SortOrderInput | SortOrder
    providerResponse?: SortOrderInput | SortOrder
  }

  export type EnrollmentContextWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_organisationId?: EnrollmentContextUserIdOrganisationIdCompoundUniqueInput
    AND?: EnrollmentContextWhereInput | EnrollmentContextWhereInput[]
    OR?: EnrollmentContextWhereInput[]
    NOT?: EnrollmentContextWhereInput | EnrollmentContextWhereInput[]
    userId?: StringFilter<"EnrollmentContext"> | string
    sessionId?: StringNullableFilter<"EnrollmentContext"> | string | null
    enrollmentId?: StringFilter<"EnrollmentContext"> | string
    organisationId?: StringFilter<"EnrollmentContext"> | string
    authorisationServerId?: StringFilter<"EnrollmentContext"> | string
    fallbackUsed?: BoolFilter<"EnrollmentContext"> | boolean
    createdAt?: DateTimeFilter<"EnrollmentContext"> | Date | string
    updatedAt?: DateTimeFilter<"EnrollmentContext"> | Date | string
    status?: EnumEnrollmentStatusOBNullableFilter<"EnrollmentContext"> | $Enums.EnrollmentStatusOB | null
    deviceRegistered?: BoolFilter<"EnrollmentContext"> | boolean
    expiresAt?: DateTimeNullableFilter<"EnrollmentContext"> | Date | string | null
    clinicId?: StringNullableFilter<"EnrollmentContext"> | string | null
    payerEmail?: StringNullableFilter<"EnrollmentContext"> | string | null
    payerDocument?: StringNullableFilter<"EnrollmentContext"> | string | null
    payerName?: StringNullableFilter<"EnrollmentContext"> | string | null
    recurringEnabled?: BoolNullableFilter<"EnrollmentContext"> | boolean | null
    deviceBinding?: JsonNullableFilter<"EnrollmentContext">
    providerResponse?: JsonNullableFilter<"EnrollmentContext">
  }, "id" | "userId_organisationId">

  export type EnrollmentContextOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    enrollmentId?: SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    fallbackUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrderInput | SortOrder
    deviceRegistered?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    payerEmail?: SortOrderInput | SortOrder
    payerDocument?: SortOrderInput | SortOrder
    payerName?: SortOrderInput | SortOrder
    recurringEnabled?: SortOrderInput | SortOrder
    deviceBinding?: SortOrderInput | SortOrder
    providerResponse?: SortOrderInput | SortOrder
    _count?: EnrollmentContextCountOrderByAggregateInput
    _max?: EnrollmentContextMaxOrderByAggregateInput
    _min?: EnrollmentContextMinOrderByAggregateInput
  }

  export type EnrollmentContextScalarWhereWithAggregatesInput = {
    AND?: EnrollmentContextScalarWhereWithAggregatesInput | EnrollmentContextScalarWhereWithAggregatesInput[]
    OR?: EnrollmentContextScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentContextScalarWhereWithAggregatesInput | EnrollmentContextScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EnrollmentContext"> | string
    userId?: StringWithAggregatesFilter<"EnrollmentContext"> | string
    sessionId?: StringNullableWithAggregatesFilter<"EnrollmentContext"> | string | null
    enrollmentId?: StringWithAggregatesFilter<"EnrollmentContext"> | string
    organisationId?: StringWithAggregatesFilter<"EnrollmentContext"> | string
    authorisationServerId?: StringWithAggregatesFilter<"EnrollmentContext"> | string
    fallbackUsed?: BoolWithAggregatesFilter<"EnrollmentContext"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EnrollmentContext"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EnrollmentContext"> | Date | string
    status?: EnumEnrollmentStatusOBNullableWithAggregatesFilter<"EnrollmentContext"> | $Enums.EnrollmentStatusOB | null
    deviceRegistered?: BoolWithAggregatesFilter<"EnrollmentContext"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"EnrollmentContext"> | Date | string | null
    clinicId?: StringNullableWithAggregatesFilter<"EnrollmentContext"> | string | null
    payerEmail?: StringNullableWithAggregatesFilter<"EnrollmentContext"> | string | null
    payerDocument?: StringNullableWithAggregatesFilter<"EnrollmentContext"> | string | null
    payerName?: StringNullableWithAggregatesFilter<"EnrollmentContext"> | string | null
    recurringEnabled?: BoolNullableWithAggregatesFilter<"EnrollmentContext"> | boolean | null
    deviceBinding?: JsonNullableWithAggregatesFilter<"EnrollmentContext">
    providerResponse?: JsonNullableWithAggregatesFilter<"EnrollmentContext">
  }

  export type PaymentConsentWhereInput = {
    AND?: PaymentConsentWhereInput | PaymentConsentWhereInput[]
    OR?: PaymentConsentWhereInput[]
    NOT?: PaymentConsentWhereInput | PaymentConsentWhereInput[]
    id?: UuidFilter<"PaymentConsent"> | string
    tenantId?: StringNullableFilter<"PaymentConsent"> | string | null
    consentId?: StringFilter<"PaymentConsent"> | string
    status?: StringNullableFilter<"PaymentConsent"> | string | null
    createdAt?: DateTimeFilter<"PaymentConsent"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentConsent"> | Date | string
  }

  export type PaymentConsentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    consentId?: SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    consentId?: string
    AND?: PaymentConsentWhereInput | PaymentConsentWhereInput[]
    OR?: PaymentConsentWhereInput[]
    NOT?: PaymentConsentWhereInput | PaymentConsentWhereInput[]
    tenantId?: StringNullableFilter<"PaymentConsent"> | string | null
    status?: StringNullableFilter<"PaymentConsent"> | string | null
    createdAt?: DateTimeFilter<"PaymentConsent"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentConsent"> | Date | string
  }, "id" | "consentId">

  export type PaymentConsentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    consentId?: SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentConsentCountOrderByAggregateInput
    _max?: PaymentConsentMaxOrderByAggregateInput
    _min?: PaymentConsentMinOrderByAggregateInput
  }

  export type PaymentConsentScalarWhereWithAggregatesInput = {
    AND?: PaymentConsentScalarWhereWithAggregatesInput | PaymentConsentScalarWhereWithAggregatesInput[]
    OR?: PaymentConsentScalarWhereWithAggregatesInput[]
    NOT?: PaymentConsentScalarWhereWithAggregatesInput | PaymentConsentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PaymentConsent"> | string
    tenantId?: StringNullableWithAggregatesFilter<"PaymentConsent"> | string | null
    consentId?: StringWithAggregatesFilter<"PaymentConsent"> | string
    status?: StringNullableWithAggregatesFilter<"PaymentConsent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentConsent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentConsent"> | Date | string
  }

  export type OAuthStateWhereInput = {
    AND?: OAuthStateWhereInput | OAuthStateWhereInput[]
    OR?: OAuthStateWhereInput[]
    NOT?: OAuthStateWhereInput | OAuthStateWhereInput[]
    id?: UuidFilter<"OAuthState"> | string
    state?: StringFilter<"OAuthState"> | string
    nonce?: StringNullableFilter<"OAuthState"> | string | null
    codeVerifier?: StringNullableFilter<"OAuthState"> | string | null
    tenantId?: StringNullableFilter<"OAuthState"> | string | null
    createdAt?: DateTimeFilter<"OAuthState"> | Date | string
    usedAt?: DateTimeNullableFilter<"OAuthState"> | Date | string | null
  }

  export type OAuthStateOrderByWithRelationInput = {
    id?: SortOrder
    state?: SortOrder
    nonce?: SortOrderInput | SortOrder
    codeVerifier?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
  }

  export type OAuthStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    state?: string
    AND?: OAuthStateWhereInput | OAuthStateWhereInput[]
    OR?: OAuthStateWhereInput[]
    NOT?: OAuthStateWhereInput | OAuthStateWhereInput[]
    nonce?: StringNullableFilter<"OAuthState"> | string | null
    codeVerifier?: StringNullableFilter<"OAuthState"> | string | null
    tenantId?: StringNullableFilter<"OAuthState"> | string | null
    createdAt?: DateTimeFilter<"OAuthState"> | Date | string
    usedAt?: DateTimeNullableFilter<"OAuthState"> | Date | string | null
  }, "id" | "state">

  export type OAuthStateOrderByWithAggregationInput = {
    id?: SortOrder
    state?: SortOrder
    nonce?: SortOrderInput | SortOrder
    codeVerifier?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    _count?: OAuthStateCountOrderByAggregateInput
    _max?: OAuthStateMaxOrderByAggregateInput
    _min?: OAuthStateMinOrderByAggregateInput
  }

  export type OAuthStateScalarWhereWithAggregatesInput = {
    AND?: OAuthStateScalarWhereWithAggregatesInput | OAuthStateScalarWhereWithAggregatesInput[]
    OR?: OAuthStateScalarWhereWithAggregatesInput[]
    NOT?: OAuthStateScalarWhereWithAggregatesInput | OAuthStateScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OAuthState"> | string
    state?: StringWithAggregatesFilter<"OAuthState"> | string
    nonce?: StringNullableWithAggregatesFilter<"OAuthState"> | string | null
    codeVerifier?: StringNullableWithAggregatesFilter<"OAuthState"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"OAuthState"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OAuthState"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"OAuthState"> | Date | string | null
  }

  export type OAuthStateMetaWhereInput = {
    AND?: OAuthStateMetaWhereInput | OAuthStateMetaWhereInput[]
    OR?: OAuthStateMetaWhereInput[]
    NOT?: OAuthStateMetaWhereInput | OAuthStateMetaWhereInput[]
    state?: StringFilter<"OAuthStateMeta"> | string
    organisationId?: StringNullableFilter<"OAuthStateMeta"> | string | null
    authorisationServerId?: StringNullableFilter<"OAuthStateMeta"> | string | null
    createdAt?: DateTimeFilter<"OAuthStateMeta"> | Date | string
    productId?: StringNullableFilter<"OAuthStateMeta"> | string | null
    amountCents?: IntNullableFilter<"OAuthStateMeta"> | number | null
    currency?: StringNullableFilter<"OAuthStateMeta"> | string | null
    orderRef?: StringNullableFilter<"OAuthStateMeta"> | string | null
  }

  export type OAuthStateMetaOrderByWithRelationInput = {
    state?: SortOrder
    organisationId?: SortOrderInput | SortOrder
    authorisationServerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    amountCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    orderRef?: SortOrderInput | SortOrder
  }

  export type OAuthStateMetaWhereUniqueInput = Prisma.AtLeast<{
    state?: string
    AND?: OAuthStateMetaWhereInput | OAuthStateMetaWhereInput[]
    OR?: OAuthStateMetaWhereInput[]
    NOT?: OAuthStateMetaWhereInput | OAuthStateMetaWhereInput[]
    organisationId?: StringNullableFilter<"OAuthStateMeta"> | string | null
    authorisationServerId?: StringNullableFilter<"OAuthStateMeta"> | string | null
    createdAt?: DateTimeFilter<"OAuthStateMeta"> | Date | string
    productId?: StringNullableFilter<"OAuthStateMeta"> | string | null
    amountCents?: IntNullableFilter<"OAuthStateMeta"> | number | null
    currency?: StringNullableFilter<"OAuthStateMeta"> | string | null
    orderRef?: StringNullableFilter<"OAuthStateMeta"> | string | null
  }, "state">

  export type OAuthStateMetaOrderByWithAggregationInput = {
    state?: SortOrder
    organisationId?: SortOrderInput | SortOrder
    authorisationServerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    amountCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    orderRef?: SortOrderInput | SortOrder
    _count?: OAuthStateMetaCountOrderByAggregateInput
    _avg?: OAuthStateMetaAvgOrderByAggregateInput
    _max?: OAuthStateMetaMaxOrderByAggregateInput
    _min?: OAuthStateMetaMinOrderByAggregateInput
    _sum?: OAuthStateMetaSumOrderByAggregateInput
  }

  export type OAuthStateMetaScalarWhereWithAggregatesInput = {
    AND?: OAuthStateMetaScalarWhereWithAggregatesInput | OAuthStateMetaScalarWhereWithAggregatesInput[]
    OR?: OAuthStateMetaScalarWhereWithAggregatesInput[]
    NOT?: OAuthStateMetaScalarWhereWithAggregatesInput | OAuthStateMetaScalarWhereWithAggregatesInput[]
    state?: StringWithAggregatesFilter<"OAuthStateMeta"> | string
    organisationId?: StringNullableWithAggregatesFilter<"OAuthStateMeta"> | string | null
    authorisationServerId?: StringNullableWithAggregatesFilter<"OAuthStateMeta"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OAuthStateMeta"> | Date | string
    productId?: StringNullableWithAggregatesFilter<"OAuthStateMeta"> | string | null
    amountCents?: IntNullableWithAggregatesFilter<"OAuthStateMeta"> | number | null
    currency?: StringNullableWithAggregatesFilter<"OAuthStateMeta"> | string | null
    orderRef?: StringNullableWithAggregatesFilter<"OAuthStateMeta"> | string | null
  }

  export type OAuthTokenWhereInput = {
    AND?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    OR?: OAuthTokenWhereInput[]
    NOT?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    id?: UuidFilter<"OAuthToken"> | string
    tenantId?: StringNullableFilter<"OAuthToken"> | string | null
    provider?: StringFilter<"OAuthToken"> | string
    accessToken?: StringFilter<"OAuthToken"> | string
    refreshToken?: StringNullableFilter<"OAuthToken"> | string | null
    scope?: StringNullableFilter<"OAuthToken"> | string | null
    expiresAt?: DateTimeNullableFilter<"OAuthToken"> | Date | string | null
    createdAt?: DateTimeFilter<"OAuthToken"> | Date | string
  }

  export type OAuthTokenOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type OAuthTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    OR?: OAuthTokenWhereInput[]
    NOT?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    tenantId?: StringNullableFilter<"OAuthToken"> | string | null
    provider?: StringFilter<"OAuthToken"> | string
    accessToken?: StringFilter<"OAuthToken"> | string
    refreshToken?: StringNullableFilter<"OAuthToken"> | string | null
    scope?: StringNullableFilter<"OAuthToken"> | string | null
    expiresAt?: DateTimeNullableFilter<"OAuthToken"> | Date | string | null
    createdAt?: DateTimeFilter<"OAuthToken"> | Date | string
  }, "id">

  export type OAuthTokenOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OAuthTokenCountOrderByAggregateInput
    _max?: OAuthTokenMaxOrderByAggregateInput
    _min?: OAuthTokenMinOrderByAggregateInput
  }

  export type OAuthTokenScalarWhereWithAggregatesInput = {
    AND?: OAuthTokenScalarWhereWithAggregatesInput | OAuthTokenScalarWhereWithAggregatesInput[]
    OR?: OAuthTokenScalarWhereWithAggregatesInput[]
    NOT?: OAuthTokenScalarWhereWithAggregatesInput | OAuthTokenScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OAuthToken"> | string
    tenantId?: StringNullableWithAggregatesFilter<"OAuthToken"> | string | null
    provider?: StringWithAggregatesFilter<"OAuthToken"> | string
    accessToken?: StringWithAggregatesFilter<"OAuthToken"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"OAuthToken"> | string | null
    scope?: StringNullableWithAggregatesFilter<"OAuthToken"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"OAuthToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OAuthToken"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    eventId?: StringNullableFilter<"Event"> | string | null
    eventType?: EnumEventTypeFilter<"Event"> | $Enums.EventType
    customerId?: StringNullableFilter<"Event"> | string | null
    clinicId?: StringFilter<"Event"> | string
    actor?: EnumEventActorFilter<"Event"> | $Enums.EventActor
    timestamp?: DateTimeFilter<"Event"> | Date | string
    metadata?: JsonFilter<"Event">
    createdAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    customerId?: SortOrderInput | SortOrder
    clinicId?: SortOrder
    actor?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    eventType?: EnumEventTypeFilter<"Event"> | $Enums.EventType
    customerId?: StringNullableFilter<"Event"> | string | null
    clinicId?: StringFilter<"Event"> | string
    actor?: EnumEventActorFilter<"Event"> | $Enums.EventActor
    timestamp?: DateTimeFilter<"Event"> | Date | string
    metadata?: JsonFilter<"Event">
    createdAt?: DateTimeFilter<"Event"> | Date | string
  }, "id" | "eventId">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    customerId?: SortOrderInput | SortOrder
    clinicId?: SortOrder
    actor?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    eventId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    eventType?: EnumEventTypeWithAggregatesFilter<"Event"> | $Enums.EventType
    customerId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    clinicId?: StringWithAggregatesFilter<"Event"> | string
    actor?: EnumEventActorWithAggregatesFilter<"Event"> | $Enums.EventActor
    timestamp?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    metadata?: JsonWithAggregatesFilter<"Event">
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type WebhookEventWhereInput = {
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    id?: UuidFilter<"WebhookEvent"> | string
    provider?: StringFilter<"WebhookEvent"> | string
    hook_id?: StringFilter<"WebhookEvent"> | string
    type?: StringFilter<"WebhookEvent"> | string
    resource_order_id?: StringNullableFilter<"WebhookEvent"> | string | null
    resource_charge_id?: StringNullableFilter<"WebhookEvent"> | string | null
    status?: StringNullableFilter<"WebhookEvent"> | string | null
    received_at?: DateTimeFilter<"WebhookEvent"> | Date | string
    processed_at?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    attempts?: IntNullableFilter<"WebhookEvent"> | number | null
    raw?: JsonFilter<"WebhookEvent">
    provider_event_id?: StringNullableFilter<"WebhookEvent"> | string | null
    processed?: BoolFilter<"WebhookEvent"> | boolean
    processing_error?: StringNullableFilter<"WebhookEvent"> | string | null
    retry_count?: IntFilter<"WebhookEvent"> | number
    max_retries?: IntFilter<"WebhookEvent"> | number
    next_retry_at?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    last_retry_at?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    error_type?: StringNullableFilter<"WebhookEvent"> | string | null
    is_retryable?: BoolFilter<"WebhookEvent"> | boolean
    moved_dead_letter?: BoolFilter<"WebhookEvent"> | boolean
    dead_letter_reason?: StringNullableFilter<"WebhookEvent"> | string | null
  }

  export type WebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    hook_id?: SortOrder
    type?: SortOrder
    resource_order_id?: SortOrderInput | SortOrder
    resource_charge_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    received_at?: SortOrder
    processed_at?: SortOrderInput | SortOrder
    attempts?: SortOrderInput | SortOrder
    raw?: SortOrder
    provider_event_id?: SortOrderInput | SortOrder
    processed?: SortOrder
    processing_error?: SortOrderInput | SortOrder
    retry_count?: SortOrder
    max_retries?: SortOrder
    next_retry_at?: SortOrderInput | SortOrder
    last_retry_at?: SortOrderInput | SortOrder
    error_type?: SortOrderInput | SortOrder
    is_retryable?: SortOrder
    moved_dead_letter?: SortOrder
    dead_letter_reason?: SortOrderInput | SortOrder
  }

  export type WebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_hook_id?: WebhookEventProviderHook_idCompoundUniqueInput
    provider_provider_event_id?: WebhookEventProviderProvider_event_idCompoundUniqueInput
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    provider?: StringFilter<"WebhookEvent"> | string
    hook_id?: StringFilter<"WebhookEvent"> | string
    type?: StringFilter<"WebhookEvent"> | string
    resource_order_id?: StringNullableFilter<"WebhookEvent"> | string | null
    resource_charge_id?: StringNullableFilter<"WebhookEvent"> | string | null
    status?: StringNullableFilter<"WebhookEvent"> | string | null
    received_at?: DateTimeFilter<"WebhookEvent"> | Date | string
    processed_at?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    attempts?: IntNullableFilter<"WebhookEvent"> | number | null
    raw?: JsonFilter<"WebhookEvent">
    provider_event_id?: StringNullableFilter<"WebhookEvent"> | string | null
    processed?: BoolFilter<"WebhookEvent"> | boolean
    processing_error?: StringNullableFilter<"WebhookEvent"> | string | null
    retry_count?: IntFilter<"WebhookEvent"> | number
    max_retries?: IntFilter<"WebhookEvent"> | number
    next_retry_at?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    last_retry_at?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    error_type?: StringNullableFilter<"WebhookEvent"> | string | null
    is_retryable?: BoolFilter<"WebhookEvent"> | boolean
    moved_dead_letter?: BoolFilter<"WebhookEvent"> | boolean
    dead_letter_reason?: StringNullableFilter<"WebhookEvent"> | string | null
  }, "id" | "provider_hook_id" | "provider_provider_event_id">

  export type WebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    hook_id?: SortOrder
    type?: SortOrder
    resource_order_id?: SortOrderInput | SortOrder
    resource_charge_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    received_at?: SortOrder
    processed_at?: SortOrderInput | SortOrder
    attempts?: SortOrderInput | SortOrder
    raw?: SortOrder
    provider_event_id?: SortOrderInput | SortOrder
    processed?: SortOrder
    processing_error?: SortOrderInput | SortOrder
    retry_count?: SortOrder
    max_retries?: SortOrder
    next_retry_at?: SortOrderInput | SortOrder
    last_retry_at?: SortOrderInput | SortOrder
    error_type?: SortOrderInput | SortOrder
    is_retryable?: SortOrder
    moved_dead_letter?: SortOrder
    dead_letter_reason?: SortOrderInput | SortOrder
    _count?: WebhookEventCountOrderByAggregateInput
    _avg?: WebhookEventAvgOrderByAggregateInput
    _max?: WebhookEventMaxOrderByAggregateInput
    _min?: WebhookEventMinOrderByAggregateInput
    _sum?: WebhookEventSumOrderByAggregateInput
  }

  export type WebhookEventScalarWhereWithAggregatesInput = {
    AND?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    OR?: WebhookEventScalarWhereWithAggregatesInput[]
    NOT?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WebhookEvent"> | string
    provider?: StringWithAggregatesFilter<"WebhookEvent"> | string
    hook_id?: StringWithAggregatesFilter<"WebhookEvent"> | string
    type?: StringWithAggregatesFilter<"WebhookEvent"> | string
    resource_order_id?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    resource_charge_id?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    status?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    received_at?: DateTimeWithAggregatesFilter<"WebhookEvent"> | Date | string
    processed_at?: DateTimeNullableWithAggregatesFilter<"WebhookEvent"> | Date | string | null
    attempts?: IntNullableWithAggregatesFilter<"WebhookEvent"> | number | null
    raw?: JsonWithAggregatesFilter<"WebhookEvent">
    provider_event_id?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    processed?: BoolWithAggregatesFilter<"WebhookEvent"> | boolean
    processing_error?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    retry_count?: IntWithAggregatesFilter<"WebhookEvent"> | number
    max_retries?: IntWithAggregatesFilter<"WebhookEvent"> | number
    next_retry_at?: DateTimeNullableWithAggregatesFilter<"WebhookEvent"> | Date | string | null
    last_retry_at?: DateTimeNullableWithAggregatesFilter<"WebhookEvent"> | Date | string | null
    error_type?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    is_retryable?: BoolWithAggregatesFilter<"WebhookEvent"> | boolean
    moved_dead_letter?: BoolWithAggregatesFilter<"WebhookEvent"> | boolean
    dead_letter_reason?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
  }

  export type WebhookEndpointWhereInput = {
    AND?: WebhookEndpointWhereInput | WebhookEndpointWhereInput[]
    OR?: WebhookEndpointWhereInput[]
    NOT?: WebhookEndpointWhereInput | WebhookEndpointWhereInput[]
    id?: StringFilter<"WebhookEndpoint"> | string
    clinicId?: StringFilter<"WebhookEndpoint"> | string
    name?: StringFilter<"WebhookEndpoint"> | string
    url?: StringFilter<"WebhookEndpoint"> | string
    secret?: StringFilter<"WebhookEndpoint"> | string
    events?: StringNullableListFilter<"WebhookEndpoint">
    enabled?: BoolFilter<"WebhookEndpoint"> | boolean
    maxConcurrentDeliveries?: IntFilter<"WebhookEndpoint"> | number
    categoryFilter?: StringFilter<"WebhookEndpoint"> | string
    statusFilters?: StringNullableListFilter<"WebhookEndpoint">
    productFilters?: StringNullableListFilter<"WebhookEndpoint">
    createdAt?: DateTimeFilter<"WebhookEndpoint"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookEndpoint"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    deliveries?: OutboundWebhookDeliveryListRelationFilter
  }

  export type WebhookEndpointOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    enabled?: SortOrder
    maxConcurrentDeliveries?: SortOrder
    categoryFilter?: SortOrder
    statusFilters?: SortOrder
    productFilters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    deliveries?: OutboundWebhookDeliveryOrderByRelationAggregateInput
  }

  export type WebhookEndpointWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookEndpointWhereInput | WebhookEndpointWhereInput[]
    OR?: WebhookEndpointWhereInput[]
    NOT?: WebhookEndpointWhereInput | WebhookEndpointWhereInput[]
    clinicId?: StringFilter<"WebhookEndpoint"> | string
    name?: StringFilter<"WebhookEndpoint"> | string
    url?: StringFilter<"WebhookEndpoint"> | string
    secret?: StringFilter<"WebhookEndpoint"> | string
    events?: StringNullableListFilter<"WebhookEndpoint">
    enabled?: BoolFilter<"WebhookEndpoint"> | boolean
    maxConcurrentDeliveries?: IntFilter<"WebhookEndpoint"> | number
    categoryFilter?: StringFilter<"WebhookEndpoint"> | string
    statusFilters?: StringNullableListFilter<"WebhookEndpoint">
    productFilters?: StringNullableListFilter<"WebhookEndpoint">
    createdAt?: DateTimeFilter<"WebhookEndpoint"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookEndpoint"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    deliveries?: OutboundWebhookDeliveryListRelationFilter
  }, "id">

  export type WebhookEndpointOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    enabled?: SortOrder
    maxConcurrentDeliveries?: SortOrder
    categoryFilter?: SortOrder
    statusFilters?: SortOrder
    productFilters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookEndpointCountOrderByAggregateInput
    _avg?: WebhookEndpointAvgOrderByAggregateInput
    _max?: WebhookEndpointMaxOrderByAggregateInput
    _min?: WebhookEndpointMinOrderByAggregateInput
    _sum?: WebhookEndpointSumOrderByAggregateInput
  }

  export type WebhookEndpointScalarWhereWithAggregatesInput = {
    AND?: WebhookEndpointScalarWhereWithAggregatesInput | WebhookEndpointScalarWhereWithAggregatesInput[]
    OR?: WebhookEndpointScalarWhereWithAggregatesInput[]
    NOT?: WebhookEndpointScalarWhereWithAggregatesInput | WebhookEndpointScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookEndpoint"> | string
    clinicId?: StringWithAggregatesFilter<"WebhookEndpoint"> | string
    name?: StringWithAggregatesFilter<"WebhookEndpoint"> | string
    url?: StringWithAggregatesFilter<"WebhookEndpoint"> | string
    secret?: StringWithAggregatesFilter<"WebhookEndpoint"> | string
    events?: StringNullableListFilter<"WebhookEndpoint">
    enabled?: BoolWithAggregatesFilter<"WebhookEndpoint"> | boolean
    maxConcurrentDeliveries?: IntWithAggregatesFilter<"WebhookEndpoint"> | number
    categoryFilter?: StringWithAggregatesFilter<"WebhookEndpoint"> | string
    statusFilters?: StringNullableListFilter<"WebhookEndpoint">
    productFilters?: StringNullableListFilter<"WebhookEndpoint">
    createdAt?: DateTimeWithAggregatesFilter<"WebhookEndpoint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebhookEndpoint"> | Date | string
  }

  export type OutboundWebhookEventWhereInput = {
    AND?: OutboundWebhookEventWhereInput | OutboundWebhookEventWhereInput[]
    OR?: OutboundWebhookEventWhereInput[]
    NOT?: OutboundWebhookEventWhereInput | OutboundWebhookEventWhereInput[]
    id?: StringFilter<"OutboundWebhookEvent"> | string
    clinicId?: StringFilter<"OutboundWebhookEvent"> | string
    type?: StringFilter<"OutboundWebhookEvent"> | string
    resource?: StringFilter<"OutboundWebhookEvent"> | string
    resourceId?: StringFilter<"OutboundWebhookEvent"> | string
    payload?: JsonFilter<"OutboundWebhookEvent">
    createdAt?: DateTimeFilter<"OutboundWebhookEvent"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    deliveries?: OutboundWebhookDeliveryListRelationFilter
  }

  export type OutboundWebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    deliveries?: OutboundWebhookDeliveryOrderByRelationAggregateInput
  }

  export type OutboundWebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutboundWebhookEventWhereInput | OutboundWebhookEventWhereInput[]
    OR?: OutboundWebhookEventWhereInput[]
    NOT?: OutboundWebhookEventWhereInput | OutboundWebhookEventWhereInput[]
    clinicId?: StringFilter<"OutboundWebhookEvent"> | string
    type?: StringFilter<"OutboundWebhookEvent"> | string
    resource?: StringFilter<"OutboundWebhookEvent"> | string
    resourceId?: StringFilter<"OutboundWebhookEvent"> | string
    payload?: JsonFilter<"OutboundWebhookEvent">
    createdAt?: DateTimeFilter<"OutboundWebhookEvent"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    deliveries?: OutboundWebhookDeliveryListRelationFilter
  }, "id">

  export type OutboundWebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
    _count?: OutboundWebhookEventCountOrderByAggregateInput
    _max?: OutboundWebhookEventMaxOrderByAggregateInput
    _min?: OutboundWebhookEventMinOrderByAggregateInput
  }

  export type OutboundWebhookEventScalarWhereWithAggregatesInput = {
    AND?: OutboundWebhookEventScalarWhereWithAggregatesInput | OutboundWebhookEventScalarWhereWithAggregatesInput[]
    OR?: OutboundWebhookEventScalarWhereWithAggregatesInput[]
    NOT?: OutboundWebhookEventScalarWhereWithAggregatesInput | OutboundWebhookEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutboundWebhookEvent"> | string
    clinicId?: StringWithAggregatesFilter<"OutboundWebhookEvent"> | string
    type?: StringWithAggregatesFilter<"OutboundWebhookEvent"> | string
    resource?: StringWithAggregatesFilter<"OutboundWebhookEvent"> | string
    resourceId?: StringWithAggregatesFilter<"OutboundWebhookEvent"> | string
    payload?: JsonWithAggregatesFilter<"OutboundWebhookEvent">
    createdAt?: DateTimeWithAggregatesFilter<"OutboundWebhookEvent"> | Date | string
  }

  export type OutboundWebhookDeliveryWhereInput = {
    AND?: OutboundWebhookDeliveryWhereInput | OutboundWebhookDeliveryWhereInput[]
    OR?: OutboundWebhookDeliveryWhereInput[]
    NOT?: OutboundWebhookDeliveryWhereInput | OutboundWebhookDeliveryWhereInput[]
    id?: StringFilter<"OutboundWebhookDelivery"> | string
    endpointId?: StringFilter<"OutboundWebhookDelivery"> | string
    eventId?: StringFilter<"OutboundWebhookDelivery"> | string
    status?: StringFilter<"OutboundWebhookDelivery"> | string
    attempts?: IntFilter<"OutboundWebhookDelivery"> | number
    lastCode?: IntNullableFilter<"OutboundWebhookDelivery"> | number | null
    lastError?: StringNullableFilter<"OutboundWebhookDelivery"> | string | null
    nextAttemptAt?: DateTimeNullableFilter<"OutboundWebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"OutboundWebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"OutboundWebhookDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"OutboundWebhookDelivery"> | Date | string
    endpoint?: XOR<WebhookEndpointScalarRelationFilter, WebhookEndpointWhereInput>
    event?: XOR<OutboundWebhookEventScalarRelationFilter, OutboundWebhookEventWhereInput>
  }

  export type OutboundWebhookDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    endpointId?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastCode?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    nextAttemptAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endpoint?: WebhookEndpointOrderByWithRelationInput
    event?: OutboundWebhookEventOrderByWithRelationInput
  }

  export type OutboundWebhookDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutboundWebhookDeliveryWhereInput | OutboundWebhookDeliveryWhereInput[]
    OR?: OutboundWebhookDeliveryWhereInput[]
    NOT?: OutboundWebhookDeliveryWhereInput | OutboundWebhookDeliveryWhereInput[]
    endpointId?: StringFilter<"OutboundWebhookDelivery"> | string
    eventId?: StringFilter<"OutboundWebhookDelivery"> | string
    status?: StringFilter<"OutboundWebhookDelivery"> | string
    attempts?: IntFilter<"OutboundWebhookDelivery"> | number
    lastCode?: IntNullableFilter<"OutboundWebhookDelivery"> | number | null
    lastError?: StringNullableFilter<"OutboundWebhookDelivery"> | string | null
    nextAttemptAt?: DateTimeNullableFilter<"OutboundWebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"OutboundWebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"OutboundWebhookDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"OutboundWebhookDelivery"> | Date | string
    endpoint?: XOR<WebhookEndpointScalarRelationFilter, WebhookEndpointWhereInput>
    event?: XOR<OutboundWebhookEventScalarRelationFilter, OutboundWebhookEventWhereInput>
  }, "id">

  export type OutboundWebhookDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    endpointId?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastCode?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    nextAttemptAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutboundWebhookDeliveryCountOrderByAggregateInput
    _avg?: OutboundWebhookDeliveryAvgOrderByAggregateInput
    _max?: OutboundWebhookDeliveryMaxOrderByAggregateInput
    _min?: OutboundWebhookDeliveryMinOrderByAggregateInput
    _sum?: OutboundWebhookDeliverySumOrderByAggregateInput
  }

  export type OutboundWebhookDeliveryScalarWhereWithAggregatesInput = {
    AND?: OutboundWebhookDeliveryScalarWhereWithAggregatesInput | OutboundWebhookDeliveryScalarWhereWithAggregatesInput[]
    OR?: OutboundWebhookDeliveryScalarWhereWithAggregatesInput[]
    NOT?: OutboundWebhookDeliveryScalarWhereWithAggregatesInput | OutboundWebhookDeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutboundWebhookDelivery"> | string
    endpointId?: StringWithAggregatesFilter<"OutboundWebhookDelivery"> | string
    eventId?: StringWithAggregatesFilter<"OutboundWebhookDelivery"> | string
    status?: StringWithAggregatesFilter<"OutboundWebhookDelivery"> | string
    attempts?: IntWithAggregatesFilter<"OutboundWebhookDelivery"> | number
    lastCode?: IntNullableWithAggregatesFilter<"OutboundWebhookDelivery"> | number | null
    lastError?: StringNullableWithAggregatesFilter<"OutboundWebhookDelivery"> | string | null
    nextAttemptAt?: DateTimeNullableWithAggregatesFilter<"OutboundWebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"OutboundWebhookDelivery"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OutboundWebhookDelivery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OutboundWebhookDelivery"> | Date | string
  }

  export type UserCreateInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeCreateInput = {
    id?: string
    code: string
    type: string
    created_at?: Date | string
    expires_at: Date | string
    used_at?: Date | string | null
    user: UserCreateNestedOneWithoutUser_verification_codesInput
    doctor: UserCreateNestedOneWithoutDoctor_verification_codesInput
  }

  export type VerificationCodeUncheckedCreateInput = {
    id?: string
    code: string
    user_id: string
    doctor_id: string
    type: string
    created_at?: Date | string
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type VerificationCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUser_verification_codesNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctor_verification_codesNestedInput
  }

  export type VerificationCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCodeCreateManyInput = {
    id?: string
    code: string
    user_id: string
    doctor_id: string
    type: string
    created_at?: Date | string
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type VerificationCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientProfileCreateInput = {
    id?: string
    name?: string | null
    phone?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPoints?: number
    currentPoints?: number
    doctor: UserCreateNestedOneWithoutDoctor_profilesInput
    patient: UserCreateNestedOneWithoutPatient_profilesInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutPatientProfileInput
  }

  export type PatientProfileUncheckedCreateInput = {
    id?: string
    doctorId: string
    userId: string
    name?: string | null
    phone?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPoints?: number
    currentPoints?: number
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutPatientProfileInput
  }

  export type PatientProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
    doctor?: UserUpdateOneRequiredWithoutDoctor_profilesNestedInput
    patient?: UserUpdateOneRequiredWithoutPatient_profilesNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutPatientProfileNestedInput
  }

  export type PatientProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutPatientProfileNestedInput
  }

  export type PatientProfileCreateManyInput = {
    id?: string
    doctorId: string
    userId: string
    name?: string | null
    phone?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPoints?: number
    currentPoints?: number
  }

  export type PatientProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
  }

  export type PatientProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
  }

  export type PointsLedgerCreateInput = {
    id?: string
    sourceType: string
    sourceId: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPointsLedgerInput
    patientProfile?: PatientProfileCreateNestedOneWithoutPointsLedgerInput
  }

  export type PointsLedgerUncheckedCreateInput = {
    id?: string
    userId: string
    patientProfileId?: string | null
    sourceType: string
    sourceId: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    createdAt?: Date | string
  }

  export type PointsLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPointsLedgerNestedInput
    patientProfile?: PatientProfileUpdateOneWithoutPointsLedgerNestedInput
  }

  export type PointsLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patientProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerCreateManyInput = {
    id?: string
    userId: string
    patientProfileId?: string | null
    sourceType: string
    sourceId: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    createdAt?: Date | string
  }

  export type PointsLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patientProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberCreateNestedManyWithoutClinicInput
    owner: UserCreateNestedOneWithoutOwned_clinicsInput
    subscriptions?: ClinicSubscriptionCreateNestedManyWithoutClinicInput
    products?: ProductCreateNestedManyWithoutClinicInput
    merchant?: MerchantCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberUncheckedCreateNestedManyWithoutClinicInput
    subscriptions?: ClinicSubscriptionUncheckedCreateNestedManyWithoutClinicInput
    products?: ProductUncheckedCreateNestedManyWithoutClinicInput
    merchant?: MerchantUncheckedCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationUncheckedCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointUncheckedCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUpdateManyWithoutClinicNestedInput
    owner?: UserUpdateOneRequiredWithoutOwned_clinicsNestedInput
    subscriptions?: ClinicSubscriptionUpdateManyWithoutClinicNestedInput
    products?: ProductUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUncheckedUpdateManyWithoutClinicNestedInput
    subscriptions?: ClinicSubscriptionUncheckedUpdateManyWithoutClinicNestedInput
    products?: ProductUncheckedUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUncheckedUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUncheckedUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUncheckedUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClinicCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
  }

  export type ClinicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClinicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClinicMemberCreateInput = {
    id?: string
    role?: $Enums.ClinicRole
    isActive?: boolean
    joinedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutClinic_membershipsInput
  }

  export type ClinicMemberUncheckedCreateInput = {
    id?: string
    clinicId: string
    userId: string
    role?: $Enums.ClinicRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type ClinicMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumClinicRoleFieldUpdateOperationsInput | $Enums.ClinicRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutClinic_membershipsNestedInput
  }

  export type ClinicMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumClinicRoleFieldUpdateOperationsInput | $Enums.ClinicRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicMemberCreateManyInput = {
    id?: string
    clinicId: string
    userId: string
    role?: $Enums.ClinicRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type ClinicMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumClinicRoleFieldUpdateOperationsInput | $Enums.ClinicRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumClinicRoleFieldUpdateOperationsInput | $Enums.ClinicRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantCreateInput = {
    id?: string
    status?: $Enums.MerchantStatus
    recipientId?: string | null
    externalAccountId?: string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: number
    platformFeeBps?: number
    transactionFeeCents?: number | null
    transactionFeeType?: string | null
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutMerchantInput
    integrations?: MerchantIntegrationCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateInput = {
    id?: string
    clinicId: string
    status?: $Enums.MerchantStatus
    recipientId?: string | null
    externalAccountId?: string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: number
    platformFeeBps?: number
    transactionFeeCents?: number | null
    transactionFeeType?: string | null
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    integrations?: MerchantIntegrationUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMerchantStatusFieldUpdateOperationsInput | $Enums.MerchantStatus
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    externalAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: IntFieldUpdateOperationsInput | number
    platformFeeBps?: IntFieldUpdateOperationsInput | number
    transactionFeeCents?: NullableIntFieldUpdateOperationsInput | number | null
    transactionFeeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutMerchantNestedInput
    integrations?: MerchantIntegrationUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    status?: EnumMerchantStatusFieldUpdateOperationsInput | $Enums.MerchantStatus
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    externalAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: IntFieldUpdateOperationsInput | number
    platformFeeBps?: IntFieldUpdateOperationsInput | number
    transactionFeeCents?: NullableIntFieldUpdateOperationsInput | number | null
    transactionFeeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrations?: MerchantIntegrationUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantCreateManyInput = {
    id?: string
    clinicId: string
    status?: $Enums.MerchantStatus
    recipientId?: string | null
    externalAccountId?: string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: number
    platformFeeBps?: number
    transactionFeeCents?: number | null
    transactionFeeType?: string | null
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MerchantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMerchantStatusFieldUpdateOperationsInput | $Enums.MerchantStatus
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    externalAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: IntFieldUpdateOperationsInput | number
    platformFeeBps?: IntFieldUpdateOperationsInput | number
    transactionFeeCents?: NullableIntFieldUpdateOperationsInput | number | null
    transactionFeeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    status?: EnumMerchantStatusFieldUpdateOperationsInput | $Enums.MerchantStatus
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    externalAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: IntFieldUpdateOperationsInput | number
    platformFeeBps?: IntFieldUpdateOperationsInput | number
    transactionFeeCents?: NullableIntFieldUpdateOperationsInput | number | null
    transactionFeeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantApplicationCreateInput = {
    id?: string
    type?: $Enums.MerchantType
    businessName?: string | null
    fullName?: string | null
    documentNumber?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: string | null
    status?: $Enums.MerchantAppStatus
    reviewNotes?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutMerchantApplicationInput
    documents?: MerchantDocumentCreateNestedManyWithoutApplicationInput
  }

  export type MerchantApplicationUncheckedCreateInput = {
    id?: string
    clinicId: string
    type?: $Enums.MerchantType
    businessName?: string | null
    fullName?: string | null
    documentNumber?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: string | null
    status?: $Enums.MerchantAppStatus
    reviewNotes?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: MerchantDocumentUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type MerchantApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMerchantTypeFieldUpdateOperationsInput | $Enums.MerchantType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMerchantAppStatusFieldUpdateOperationsInput | $Enums.MerchantAppStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutMerchantApplicationNestedInput
    documents?: MerchantDocumentUpdateManyWithoutApplicationNestedInput
  }

  export type MerchantApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    type?: EnumMerchantTypeFieldUpdateOperationsInput | $Enums.MerchantType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMerchantAppStatusFieldUpdateOperationsInput | $Enums.MerchantAppStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: MerchantDocumentUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type MerchantApplicationCreateManyInput = {
    id?: string
    clinicId: string
    type?: $Enums.MerchantType
    businessName?: string | null
    fullName?: string | null
    documentNumber?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: string | null
    status?: $Enums.MerchantAppStatus
    reviewNotes?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MerchantApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMerchantTypeFieldUpdateOperationsInput | $Enums.MerchantType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMerchantAppStatusFieldUpdateOperationsInput | $Enums.MerchantAppStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    type?: EnumMerchantTypeFieldUpdateOperationsInput | $Enums.MerchantType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMerchantAppStatusFieldUpdateOperationsInput | $Enums.MerchantAppStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantDocumentCreateInput = {
    id?: string
    type: $Enums.DocumentType
    fileUrl: string
    status?: $Enums.DocumentStatus
    notes?: string | null
    uploadedAt?: Date | string
    reviewedAt?: Date | string | null
    application: MerchantApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type MerchantDocumentUncheckedCreateInput = {
    id?: string
    applicationId: string
    type: $Enums.DocumentType
    fileUrl: string
    status?: $Enums.DocumentStatus
    notes?: string | null
    uploadedAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type MerchantDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    application?: MerchantApplicationUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type MerchantDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantDocumentCreateManyInput = {
    id?: string
    applicationId: string
    type: $Enums.DocumentType
    fileUrl: string
    status?: $Enums.DocumentStatus
    notes?: string | null
    uploadedAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type MerchantDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantIntegrationCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    credentials: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPrimary?: boolean
    connectedAt?: Date | string
    lastUsedAt?: Date | string | null
    lastError?: string | null
    lastErrorAt?: Date | string | null
    merchant: MerchantCreateNestedOneWithoutIntegrationsInput
  }

  export type MerchantIntegrationUncheckedCreateInput = {
    id?: string
    merchantId: string
    provider: $Enums.PaymentProvider
    credentials: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPrimary?: boolean
    connectedAt?: Date | string
    lastUsedAt?: Date | string | null
    lastError?: string | null
    lastErrorAt?: Date | string | null
  }

  export type MerchantIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    credentials?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastErrorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchant?: MerchantUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type MerchantIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    credentials?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastErrorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantIntegrationCreateManyInput = {
    id?: string
    merchantId: string
    provider: $Enums.PaymentProvider
    credentials: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPrimary?: boolean
    connectedAt?: Date | string
    lastUsedAt?: Date | string | null
    lastError?: string | null
    lastErrorAt?: Date | string | null
  }

  export type MerchantIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    credentials?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastErrorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    credentials?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastErrorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentRoutingRuleCreateInput = {
    id?: string
    merchantId: string
    productId?: string | null
    offerId?: string | null
    country?: string | null
    method?: $Enums.PaymentMethod | null
    provider: $Enums.PaymentProvider
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRoutingRuleUncheckedCreateInput = {
    id?: string
    merchantId: string
    productId?: string | null
    offerId?: string | null
    country?: string | null
    method?: $Enums.PaymentMethod | null
    provider: $Enums.PaymentProvider
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRoutingRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRoutingRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRoutingRuleCreateManyInput = {
    id?: string
    merchantId: string
    productId?: string | null
    offerId?: string | null
    country?: string | null
    method?: $Enums.PaymentMethod | null
    provider: $Enums.PaymentProvider
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRoutingRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRoutingRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicPlanCreateInput = {
    id?: string
    name: string
    tier: $Enums.PlanTier
    description?: string | null
    monthlyPrice: Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: number
    features?: JsonNullValueInput | InputJsonValue
    trialDays?: number
    requireCard?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: ClinicSubscriptionCreateNestedManyWithoutPlanInput
  }

  export type ClinicPlanUncheckedCreateInput = {
    id?: string
    name: string
    tier: $Enums.PlanTier
    description?: string | null
    monthlyPrice: Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: number
    features?: JsonNullValueInput | InputJsonValue
    trialDays?: number
    requireCard?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: ClinicSubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type ClinicPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    requireCard?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: ClinicSubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type ClinicPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    requireCard?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: ClinicSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type ClinicPlanCreateManyInput = {
    id?: string
    name: string
    tier: $Enums.PlanTier
    description?: string | null
    monthlyPrice: Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: number
    features?: JsonNullValueInput | InputJsonValue
    trialDays?: number
    requireCard?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    requireCard?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    requireCard?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnCreateInput = {
    id?: string
    type: $Enums.AddOnType
    name: string
    description?: string | null
    monthlyPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: ClinicAddOnSubscriptionCreateNestedManyWithoutAddOnInput
  }

  export type ClinicAddOnUncheckedCreateInput = {
    id?: string
    type: $Enums.AddOnType
    name: string
    description?: string | null
    monthlyPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: ClinicAddOnSubscriptionUncheckedCreateNestedManyWithoutAddOnInput
  }

  export type ClinicAddOnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: ClinicAddOnSubscriptionUpdateManyWithoutAddOnNestedInput
  }

  export type ClinicAddOnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: ClinicAddOnSubscriptionUncheckedUpdateManyWithoutAddOnNestedInput
  }

  export type ClinicAddOnCreateManyInput = {
    id?: string
    type: $Enums.AddOnType
    name: string
    description?: string | null
    monthlyPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicAddOnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicSubscriptionCreateInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    trialEndsAt: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    canceledAt?: Date | string | null
    cancelReason?: string | null
    currentDoctorsCount?: number
    currentPatientsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutSubscriptionsInput
    plan: ClinicPlanCreateNestedOneWithoutSubscriptionsInput
    addOns?: ClinicAddOnSubscriptionCreateNestedManyWithoutSubscriptionInput
  }

  export type ClinicSubscriptionUncheckedCreateInput = {
    id?: string
    clinicId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    trialEndsAt: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    canceledAt?: Date | string | null
    cancelReason?: string | null
    currentDoctorsCount?: number
    currentPatientsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addOns?: ClinicAddOnSubscriptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type ClinicSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: ClinicPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    addOns?: ClinicAddOnSubscriptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type ClinicSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOns?: ClinicAddOnSubscriptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type ClinicSubscriptionCreateManyInput = {
    id?: string
    clinicId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    trialEndsAt: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    canceledAt?: Date | string | null
    cancelReason?: string | null
    currentDoctorsCount?: number
    currentPatientsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnSubscriptionCreateInput = {
    id?: string
    quantity: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: ClinicSubscriptionCreateNestedOneWithoutAddOnsInput
    addOn: ClinicAddOnCreateNestedOneWithoutSubscriptionsInput
  }

  export type ClinicAddOnSubscriptionUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    addOnId: string
    quantity: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicAddOnSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: ClinicSubscriptionUpdateOneRequiredWithoutAddOnsNestedInput
    addOn?: ClinicAddOnUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type ClinicAddOnSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnSubscriptionCreateManyInput = {
    id?: string
    subscriptionId: string
    addOnId: string
    quantity: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicAddOnSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateInput = {
    id?: string
    name: string
    slug?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor?: UserCreateNestedOneWithoutCreated_categoriesInput
    products?: ProductCreateNestedManyWithoutProductCategoryInput
    categories?: CategoriesOnProductsCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    doctorId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
    categories?: CategoriesOnProductsUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneWithoutCreated_categoriesNestedInput
    products?: ProductUpdateManyWithoutProductCategoryNestedInput
    categories?: CategoriesOnProductsUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
    categories?: CategoriesOnProductsUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
    doctorId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    confirmationUrl?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    doctor?: UserCreateNestedOneWithoutCreated_productsInput
    clinic?: ClinicCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsCreateNestedManyWithoutProductInput
    offers?: OfferCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
    clinicId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    categoryId?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsUncheckedCreateNestedManyWithoutProductInput
    offers?: OfferUncheckedCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doctor?: UserUpdateOneWithoutCreated_productsNestedInput
    clinic?: ClinicUpdateOneWithoutProductsNestedInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUpdateManyWithoutProductNestedInput
    offers?: OfferUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUncheckedUpdateManyWithoutProductNestedInput
    offers?: OfferUncheckedUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
    clinicId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    categoryId?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CategoriesOnProductsCreateInput = {
    assignedAt?: Date | string
    product: ProductCreateNestedOneWithoutCategoriesInput
    category: ProductCategoryCreateNestedOneWithoutCategoriesInput
  }

  export type CategoriesOnProductsUncheckedCreateInput = {
    productId: string
    categoryId: string
    assignedAt?: Date | string
  }

  export type CategoriesOnProductsUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCategoriesNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CategoriesOnProductsUncheckedUpdateInput = {
    productId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriesOnProductsCreateManyInput = {
    productId: string
    categoryId: string
    assignedAt?: Date | string
  }

  export type CategoriesOnProductsUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriesOnProductsUncheckedUpdateManyInput = {
    productId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferCreateInput = {
    id?: string
    name: string
    description?: string | null
    currency?: $Enums.Currency
    priceCents: number
    preferredProvider?: $Enums.PaymentProvider | null
    maxInstallments?: number | null
    installmentMinCents?: number | null
    active?: boolean
    isSubscription?: boolean
    intervalCount?: number | null
    intervalUnit?: $Enums.SubscriptionInterval | null
    trialDays?: number | null
    checkoutUrl?: string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutOffersInput
    paymentMethods?: OfferPaymentMethodCreateNestedManyWithoutOfferInput
    prices?: OfferPriceCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateInput = {
    id?: string
    productId: string
    name: string
    description?: string | null
    currency?: $Enums.Currency
    priceCents: number
    preferredProvider?: $Enums.PaymentProvider | null
    maxInstallments?: number | null
    installmentMinCents?: number | null
    active?: boolean
    isSubscription?: boolean
    intervalCount?: number | null
    intervalUnit?: $Enums.SubscriptionInterval | null
    trialDays?: number | null
    checkoutUrl?: string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: OfferPaymentMethodUncheckedCreateNestedManyWithoutOfferInput
    prices?: OfferPriceUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    priceCents?: IntFieldUpdateOperationsInput | number
    preferredProvider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    maxInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    installmentMinCents?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    intervalUnit?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    checkoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOffersNestedInput
    paymentMethods?: OfferPaymentMethodUpdateManyWithoutOfferNestedInput
    prices?: OfferPriceUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    priceCents?: IntFieldUpdateOperationsInput | number
    preferredProvider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    maxInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    installmentMinCents?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    intervalUnit?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    checkoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: OfferPaymentMethodUncheckedUpdateManyWithoutOfferNestedInput
    prices?: OfferPriceUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferCreateManyInput = {
    id?: string
    productId: string
    name: string
    description?: string | null
    currency?: $Enums.Currency
    priceCents: number
    preferredProvider?: $Enums.PaymentProvider | null
    maxInstallments?: number | null
    installmentMinCents?: number | null
    active?: boolean
    isSubscription?: boolean
    intervalCount?: number | null
    intervalUnit?: $Enums.SubscriptionInterval | null
    trialDays?: number | null
    checkoutUrl?: string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    priceCents?: IntFieldUpdateOperationsInput | number
    preferredProvider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    maxInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    installmentMinCents?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    intervalUnit?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    checkoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    priceCents?: IntFieldUpdateOperationsInput | number
    preferredProvider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    maxInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    installmentMinCents?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    intervalUnit?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    checkoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferPriceCreateInput = {
    id?: string
    country: string
    currency: $Enums.Currency
    provider: $Enums.PaymentProvider
    amountCents?: number
    externalPriceId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    offer: OfferCreateNestedOneWithoutPricesInput
  }

  export type OfferPriceUncheckedCreateInput = {
    id?: string
    offerId: string
    country: string
    currency: $Enums.Currency
    provider: $Enums.PaymentProvider
    amountCents?: number
    externalPriceId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferPriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amountCents?: IntFieldUpdateOperationsInput | number
    externalPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: OfferUpdateOneRequiredWithoutPricesNestedInput
  }

  export type OfferPriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amountCents?: IntFieldUpdateOperationsInput | number
    externalPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferPriceCreateManyInput = {
    id?: string
    offerId: string
    country: string
    currency: $Enums.Currency
    provider: $Enums.PaymentProvider
    amountCents?: number
    externalPriceId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferPriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amountCents?: IntFieldUpdateOperationsInput | number
    externalPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferPriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amountCents?: IntFieldUpdateOperationsInput | number
    externalPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferPaymentMethodCreateInput = {
    id?: string
    method: $Enums.PaymentMethod
    active?: boolean
    feePercent?: number | null
    offer: OfferCreateNestedOneWithoutPaymentMethodsInput
  }

  export type OfferPaymentMethodUncheckedCreateInput = {
    id?: string
    offerId: string
    method: $Enums.PaymentMethod
    active?: boolean
    feePercent?: number | null
  }

  export type OfferPaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    active?: BoolFieldUpdateOperationsInput | boolean
    feePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    offer?: OfferUpdateOneRequiredWithoutPaymentMethodsNestedInput
  }

  export type OfferPaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    active?: BoolFieldUpdateOperationsInput | boolean
    feePercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OfferPaymentMethodCreateManyInput = {
    id?: string
    offerId: string
    method: $Enums.PaymentMethod
    active?: boolean
    feePercent?: number | null
  }

  export type OfferPaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    active?: BoolFieldUpdateOperationsInput | boolean
    feePercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OfferPaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    active?: BoolFieldUpdateOperationsInput | boolean
    feePercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProductIntegrationCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    externalProductId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutIntegrationsInput
  }

  export type ProductIntegrationUncheckedCreateInput = {
    id?: string
    productId: string
    provider: $Enums.PaymentProvider
    externalProductId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    externalProductId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type ProductIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    externalProductId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductIntegrationCreateManyInput = {
    id?: string
    productId: string
    provider: $Enums.PaymentProvider
    externalProductId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    externalProductId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    externalProductId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckoutSessionCreateInput = {
    id?: string
    resumeToken: string
    clinicId?: string | null
    productId?: string | null
    offerId?: string | null
    slug?: string | null
    provider?: $Enums.PaymentProvider | null
    country?: string | null
    locale?: string | null
    status?: $Enums.CheckoutSessionStatus
    paymentMethod?: $Enums.CheckoutPaymentMethod | null
    orderId?: string | null
    pixOrderId?: string | null
    pixExpiresAt?: Date | string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmTerm?: string | null
    utmContent?: string | null
    referrer?: string | null
    ip?: string | null
    userAgent?: string | null
    selectedInstallments?: number | null
    selectedBank?: string | null
    paymentMethodsAllowed?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastHeartbeatAt?: Date | string | null
    lastStep?: string | null
    reminders?: NullableJsonNullValueInput | InputJsonValue
    reminderExpiringSentAt?: Date | string | null
    reminderExpiredSentAt?: Date | string | null
    conversionLikelihood?: number | null
    origin?: string | null
    createdBy?: string | null
    paymentTransaction?: PaymentTransactionCreateNestedOneWithoutCheckoutSessionInput
  }

  export type CheckoutSessionUncheckedCreateInput = {
    id?: string
    resumeToken: string
    clinicId?: string | null
    productId?: string | null
    offerId?: string | null
    slug?: string | null
    provider?: $Enums.PaymentProvider | null
    country?: string | null
    locale?: string | null
    status?: $Enums.CheckoutSessionStatus
    paymentMethod?: $Enums.CheckoutPaymentMethod | null
    orderId?: string | null
    pixOrderId?: string | null
    pixExpiresAt?: Date | string | null
    paymentTransactionId?: string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmTerm?: string | null
    utmContent?: string | null
    referrer?: string | null
    ip?: string | null
    userAgent?: string | null
    selectedInstallments?: number | null
    selectedBank?: string | null
    paymentMethodsAllowed?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastHeartbeatAt?: Date | string | null
    lastStep?: string | null
    reminders?: NullableJsonNullValueInput | InputJsonValue
    reminderExpiringSentAt?: Date | string | null
    reminderExpiredSentAt?: Date | string | null
    conversionLikelihood?: number | null
    origin?: string | null
    createdBy?: string | null
  }

  export type CheckoutSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeToken?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckoutSessionStatusFieldUpdateOperationsInput | $Enums.CheckoutSessionStatus
    paymentMethod?: NullableEnumCheckoutPaymentMethodFieldUpdateOperationsInput | $Enums.CheckoutPaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmTerm?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    selectedInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    selectedBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethodsAllowed?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStep?: NullableStringFieldUpdateOperationsInput | string | null
    reminders?: NullableJsonNullValueInput | InputJsonValue
    reminderExpiringSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderExpiredSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionLikelihood?: NullableFloatFieldUpdateOperationsInput | number | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTransaction?: PaymentTransactionUpdateOneWithoutCheckoutSessionNestedInput
  }

  export type CheckoutSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeToken?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckoutSessionStatusFieldUpdateOperationsInput | $Enums.CheckoutSessionStatus
    paymentMethod?: NullableEnumCheckoutPaymentMethodFieldUpdateOperationsInput | $Enums.CheckoutPaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmTerm?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    selectedInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    selectedBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethodsAllowed?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStep?: NullableStringFieldUpdateOperationsInput | string | null
    reminders?: NullableJsonNullValueInput | InputJsonValue
    reminderExpiringSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderExpiredSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionLikelihood?: NullableFloatFieldUpdateOperationsInput | number | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckoutSessionCreateManyInput = {
    id?: string
    resumeToken: string
    clinicId?: string | null
    productId?: string | null
    offerId?: string | null
    slug?: string | null
    provider?: $Enums.PaymentProvider | null
    country?: string | null
    locale?: string | null
    status?: $Enums.CheckoutSessionStatus
    paymentMethod?: $Enums.CheckoutPaymentMethod | null
    orderId?: string | null
    pixOrderId?: string | null
    pixExpiresAt?: Date | string | null
    paymentTransactionId?: string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmTerm?: string | null
    utmContent?: string | null
    referrer?: string | null
    ip?: string | null
    userAgent?: string | null
    selectedInstallments?: number | null
    selectedBank?: string | null
    paymentMethodsAllowed?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastHeartbeatAt?: Date | string | null
    lastStep?: string | null
    reminders?: NullableJsonNullValueInput | InputJsonValue
    reminderExpiringSentAt?: Date | string | null
    reminderExpiredSentAt?: Date | string | null
    conversionLikelihood?: number | null
    origin?: string | null
    createdBy?: string | null
  }

  export type CheckoutSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeToken?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckoutSessionStatusFieldUpdateOperationsInput | $Enums.CheckoutSessionStatus
    paymentMethod?: NullableEnumCheckoutPaymentMethodFieldUpdateOperationsInput | $Enums.CheckoutPaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmTerm?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    selectedInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    selectedBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethodsAllowed?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStep?: NullableStringFieldUpdateOperationsInput | string | null
    reminders?: NullableJsonNullValueInput | InputJsonValue
    reminderExpiringSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderExpiredSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionLikelihood?: NullableFloatFieldUpdateOperationsInput | number | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckoutSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeToken?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckoutSessionStatusFieldUpdateOperationsInput | $Enums.CheckoutSessionStatus
    paymentMethod?: NullableEnumCheckoutPaymentMethodFieldUpdateOperationsInput | $Enums.CheckoutPaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmTerm?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    selectedInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    selectedBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethodsAllowed?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStep?: NullableStringFieldUpdateOperationsInput | string | null
    reminders?: NullableJsonNullValueInput | InputJsonValue
    reminderExpiringSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderExpiredSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionLikelihood?: NullableFloatFieldUpdateOperationsInput | number | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentTransactionCreateInput = {
    id: string
    provider: string
    providerOrderId?: string | null
    providerChargeId?: string | null
    doctorId?: string | null
    patientProfileId?: string | null
    clinicId?: string | null
    merchantId?: string | null
    productId?: string | null
    amountCents?: number
    currency?: string
    installments?: number | null
    paymentMethodType?: string | null
    status?: string
    status_v2?: $Enums.PaymentStatus | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    capturedAt?: Date | string | null
    refundStatus?: string | null
    refundedAt?: Date | string | null
    routedProvider?: string | null
    customerId?: string | null
    customerProviderId?: string | null
    customerPaymentMethodId?: string | null
    customerSubscriptionId?: string | null
    billingPeriodStart?: Date | string | null
    billingPeriodEnd?: Date | string | null
    provider_v2?: $Enums.PaymentProvider | null
    checkoutSession?: CheckoutSessionCreateNestedOneWithoutPaymentTransactionInput
  }

  export type PaymentTransactionUncheckedCreateInput = {
    id: string
    provider: string
    providerOrderId?: string | null
    providerChargeId?: string | null
    doctorId?: string | null
    patientProfileId?: string | null
    clinicId?: string | null
    merchantId?: string | null
    productId?: string | null
    amountCents?: number
    currency?: string
    installments?: number | null
    paymentMethodType?: string | null
    status?: string
    status_v2?: $Enums.PaymentStatus | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    capturedAt?: Date | string | null
    refundStatus?: string | null
    refundedAt?: Date | string | null
    routedProvider?: string | null
    customerId?: string | null
    customerProviderId?: string | null
    customerPaymentMethodId?: string | null
    customerSubscriptionId?: string | null
    billingPeriodStart?: Date | string | null
    billingPeriodEnd?: Date | string | null
    provider_v2?: $Enums.PaymentProvider | null
    checkoutSession?: CheckoutSessionUncheckedCreateNestedOneWithoutPaymentTransactionInput
  }

  export type PaymentTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    providerChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    patientProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    installments?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethodType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    status_v2?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routedProvider?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    customerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_v2?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    checkoutSession?: CheckoutSessionUpdateOneWithoutPaymentTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    providerChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    patientProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    installments?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethodType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    status_v2?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routedProvider?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    customerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_v2?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    checkoutSession?: CheckoutSessionUncheckedUpdateOneWithoutPaymentTransactionNestedInput
  }

  export type PaymentTransactionCreateManyInput = {
    id: string
    provider: string
    providerOrderId?: string | null
    providerChargeId?: string | null
    doctorId?: string | null
    patientProfileId?: string | null
    clinicId?: string | null
    merchantId?: string | null
    productId?: string | null
    amountCents?: number
    currency?: string
    installments?: number | null
    paymentMethodType?: string | null
    status?: string
    status_v2?: $Enums.PaymentStatus | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    capturedAt?: Date | string | null
    refundStatus?: string | null
    refundedAt?: Date | string | null
    routedProvider?: string | null
    customerId?: string | null
    customerProviderId?: string | null
    customerPaymentMethodId?: string | null
    customerSubscriptionId?: string | null
    billingPeriodStart?: Date | string | null
    billingPeriodEnd?: Date | string | null
    provider_v2?: $Enums.PaymentProvider | null
  }

  export type PaymentTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    providerChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    patientProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    installments?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethodType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    status_v2?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routedProvider?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    customerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_v2?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
  }

  export type PaymentTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    providerChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    patientProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    installments?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethodType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    status_v2?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routedProvider?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    customerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_v2?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
  }

  export type PurchaseCreateInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPurchasesInput
    doctor: UserCreateNestedOneWithoutDoctorPurchasesInput
    product: ProductCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    userId: string
    doctorId: string
    productId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorPurchasesNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManyInput = {
    id?: string
    userId: string
    doctorId: string
    productId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    merchantId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    providers?: CustomerProviderCreateNestedManyWithoutCustomerInput
    paymentMethods?: CustomerPaymentMethodCreateNestedManyWithoutCustomerInput
    subscriptions?: CustomerSubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    merchantId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    providers?: CustomerProviderUncheckedCreateNestedManyWithoutCustomerInput
    paymentMethods?: CustomerPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: CustomerSubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: CustomerProviderUpdateManyWithoutCustomerNestedInput
    paymentMethods?: CustomerPaymentMethodUpdateManyWithoutCustomerNestedInput
    subscriptions?: CustomerSubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: CustomerProviderUncheckedUpdateManyWithoutCustomerNestedInput
    paymentMethods?: CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: CustomerSubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    merchantId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProviderCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerCustomerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutProvidersInput
    paymentMethods?: CustomerPaymentMethodCreateNestedManyWithoutCustomerProviderInput
    subscriptions?: CustomerSubscriptionCreateNestedManyWithoutCustomerProviderInput
  }

  export type CustomerProviderUncheckedCreateInput = {
    id?: string
    customerId: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerCustomerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: CustomerPaymentMethodUncheckedCreateNestedManyWithoutCustomerProviderInput
    subscriptions?: CustomerSubscriptionUncheckedCreateNestedManyWithoutCustomerProviderInput
  }

  export type CustomerProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutProvidersNestedInput
    paymentMethods?: CustomerPaymentMethodUpdateManyWithoutCustomerProviderNestedInput
    subscriptions?: CustomerSubscriptionUpdateManyWithoutCustomerProviderNestedInput
  }

  export type CustomerProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerProviderNestedInput
    subscriptions?: CustomerSubscriptionUncheckedUpdateManyWithoutCustomerProviderNestedInput
  }

  export type CustomerProviderCreateManyInput = {
    id?: string
    customerId: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerCustomerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentMethodCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerPaymentMethodId?: string | null
    brand?: string | null
    last4?: string | null
    expMonth?: number | null
    expYear?: number | null
    isDefault?: boolean
    status?: string | null
    fingerprint?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutPaymentMethodsInput
    customerProvider?: CustomerProviderCreateNestedOneWithoutPaymentMethodsInput
  }

  export type CustomerPaymentMethodUncheckedCreateInput = {
    id?: string
    customerId: string
    customerProviderId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerPaymentMethodId?: string | null
    brand?: string | null
    last4?: string | null
    expMonth?: number | null
    expYear?: number | null
    isDefault?: boolean
    status?: string | null
    fingerprint?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutPaymentMethodsNestedInput
    customerProvider?: CustomerProviderUpdateOneWithoutPaymentMethodsNestedInput
  }

  export type CustomerPaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentMethodCreateManyInput = {
    id?: string
    customerId: string
    customerProviderId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerPaymentMethodId?: string | null
    brand?: string | null
    last4?: string | null
    expMonth?: number | null
    expYear?: number | null
    isDefault?: boolean
    status?: string | null
    fingerprint?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSubscriptionCreateInput = {
    id?: string
    merchantId: string
    productId: string
    offerId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    isNative?: boolean
    providerSubscriptionId?: string | null
    vaultPaymentMethodId?: string | null
    status?: $Enums.SubscriptionStatus
    startAt?: Date | string
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    priceCents: number
    currency: $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
    customerProvider?: CustomerProviderCreateNestedOneWithoutSubscriptionsInput
  }

  export type CustomerSubscriptionUncheckedCreateInput = {
    id?: string
    customerId: string
    merchantId: string
    productId: string
    offerId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    isNative?: boolean
    customerProviderId?: string | null
    providerSubscriptionId?: string | null
    vaultPaymentMethodId?: string | null
    status?: $Enums.SubscriptionStatus
    startAt?: Date | string
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    priceCents: number
    currency: $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    isNative?: BoolFieldUpdateOperationsInput | boolean
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
    customerProvider?: CustomerProviderUpdateOneWithoutSubscriptionsNestedInput
  }

  export type CustomerSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    isNative?: BoolFieldUpdateOperationsInput | boolean
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSubscriptionCreateManyInput = {
    id?: string
    customerId: string
    merchantId: string
    productId: string
    offerId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    isNative?: boolean
    customerProviderId?: string | null
    providerSubscriptionId?: string | null
    vaultPaymentMethodId?: string | null
    status?: $Enums.SubscriptionStatus
    startAt?: Date | string
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    priceCents: number
    currency: $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    isNative?: BoolFieldUpdateOperationsInput | boolean
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    isNative?: BoolFieldUpdateOperationsInput | boolean
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCustomerCreateInput = {
    id?: string
    userId?: string | null
    clinicId?: string | null
    email?: string | null
    document?: string | null
    fullName?: string | null
    phones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCustomerUncheckedCreateInput = {
    id?: string
    userId?: string | null
    clinicId?: string | null
    email?: string | null
    document?: string | null
    fullName?: string | null
    phones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    phones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    phones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCustomerCreateManyInput = {
    id?: string
    userId?: string | null
    clinicId?: string | null
    email?: string | null
    document?: string | null
    fullName?: string | null
    phones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    phones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    phones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateCreateInput = {
    id?: string
    name: string
    channel: string
    subject?: string | null
    html?: string | null
    text?: string | null
    mjml?: string | null
    renderStrategy?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    provider?: string | null
    waTemplateName?: string | null
    waLanguage?: string | null
    waCategory?: string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: string | null
    waProviderId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateCreatetagsInput | string[]
    smsMaxSegments?: number | null
    doctor: UserCreateNestedOneWithoutMessage_templatesInput
    steps?: MessageSequenceStepCreateNestedManyWithoutTemplateInput
  }

  export type MessageTemplateUncheckedCreateInput = {
    id?: string
    doctorId: string
    name: string
    channel: string
    subject?: string | null
    html?: string | null
    text?: string | null
    mjml?: string | null
    renderStrategy?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    provider?: string | null
    waTemplateName?: string | null
    waLanguage?: string | null
    waCategory?: string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: string | null
    waProviderId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateCreatetagsInput | string[]
    smsMaxSegments?: number | null
    steps?: MessageSequenceStepUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type MessageTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mjml?: NullableStringFieldUpdateOperationsInput | string | null
    renderStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    waTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    waLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    waCategory?: NullableStringFieldUpdateOperationsInput | string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: NullableStringFieldUpdateOperationsInput | string | null
    waProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateUpdatetagsInput | string[]
    smsMaxSegments?: NullableIntFieldUpdateOperationsInput | number | null
    doctor?: UserUpdateOneRequiredWithoutMessage_templatesNestedInput
    steps?: MessageSequenceStepUpdateManyWithoutTemplateNestedInput
  }

  export type MessageTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mjml?: NullableStringFieldUpdateOperationsInput | string | null
    renderStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    waTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    waLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    waCategory?: NullableStringFieldUpdateOperationsInput | string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: NullableStringFieldUpdateOperationsInput | string | null
    waProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateUpdatetagsInput | string[]
    smsMaxSegments?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: MessageSequenceStepUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type MessageTemplateCreateManyInput = {
    id?: string
    doctorId: string
    name: string
    channel: string
    subject?: string | null
    html?: string | null
    text?: string | null
    mjml?: string | null
    renderStrategy?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    provider?: string | null
    waTemplateName?: string | null
    waLanguage?: string | null
    waCategory?: string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: string | null
    waProviderId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateCreatetagsInput | string[]
    smsMaxSegments?: number | null
  }

  export type MessageTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mjml?: NullableStringFieldUpdateOperationsInput | string | null
    renderStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    waTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    waLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    waCategory?: NullableStringFieldUpdateOperationsInput | string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: NullableStringFieldUpdateOperationsInput | string | null
    waProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateUpdatetagsInput | string[]
    smsMaxSegments?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MessageTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mjml?: NullableStringFieldUpdateOperationsInput | string | null
    renderStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    waTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    waLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    waCategory?: NullableStringFieldUpdateOperationsInput | string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: NullableStringFieldUpdateOperationsInput | string | null
    waProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateUpdatetagsInput | string[]
    smsMaxSegments?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MessageSequenceCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: UserCreateNestedOneWithoutMessage_sequencesInput
    steps?: MessageSequenceStepCreateNestedManyWithoutSequenceInput
  }

  export type MessageSequenceUncheckedCreateInput = {
    id?: string
    doctorId: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: MessageSequenceStepUncheckedCreateNestedManyWithoutSequenceInput
  }

  export type MessageSequenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutMessage_sequencesNestedInput
    steps?: MessageSequenceStepUpdateManyWithoutSequenceNestedInput
  }

  export type MessageSequenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: MessageSequenceStepUncheckedUpdateManyWithoutSequenceNestedInput
  }

  export type MessageSequenceCreateManyInput = {
    id?: string
    doctorId: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageSequenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageSequenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageSequenceStepCreateInput = {
    id?: string
    orderIndex?: number
    delayAmount?: number
    delayUnit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sequence: MessageSequenceCreateNestedOneWithoutStepsInput
    template: MessageTemplateCreateNestedOneWithoutStepsInput
  }

  export type MessageSequenceStepUncheckedCreateInput = {
    id?: string
    sequenceId: string
    orderIndex?: number
    delayAmount?: number
    delayUnit?: string
    templateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageSequenceStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    delayAmount?: IntFieldUpdateOperationsInput | number
    delayUnit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequence?: MessageSequenceUpdateOneRequiredWithoutStepsNestedInput
    template?: MessageTemplateUpdateOneRequiredWithoutStepsNestedInput
  }

  export type MessageSequenceStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceId?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    delayAmount?: IntFieldUpdateOperationsInput | number
    delayUnit?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageSequenceStepCreateManyInput = {
    id?: string
    sequenceId: string
    orderIndex?: number
    delayAmount?: number
    delayUnit?: string
    templateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageSequenceStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    delayAmount?: IntFieldUpdateOperationsInput | number
    delayUnit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageSequenceStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceId?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    delayAmount?: IntFieldUpdateOperationsInput | number
    delayUnit?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignJobCreateInput = {
    id: string
    doctorId: string
    campaignId: string
    channel: string
    trigger?: string | null
    scheduleAt: Date | string
    createdAt?: Date | string
    status: string
    lastError?: string | null
  }

  export type CampaignJobUncheckedCreateInput = {
    id: string
    doctorId: string
    campaignId: string
    channel: string
    trigger?: string | null
    scheduleAt: Date | string
    createdAt?: Date | string
    status: string
    lastError?: string | null
  }

  export type CampaignJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    trigger?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    trigger?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignJobCreateManyInput = {
    id: string
    doctorId: string
    campaignId: string
    channel: string
    trigger?: string | null
    scheduleAt: Date | string
    createdAt?: Date | string
    status: string
    lastError?: string | null
  }

  export type CampaignJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    trigger?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    trigger?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpenFinanceLinkCreateInput = {
    id?: string
    userId: string
    clinicId?: string | null
    organisationId: string
    authorisationServerId: string
    enrollmentId: string
    status?: string
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    consent?: OpenFinanceConsentCreateNestedOneWithoutLinkInput
  }

  export type OpenFinanceLinkUncheckedCreateInput = {
    id?: string
    userId: string
    clinicId?: string | null
    organisationId: string
    authorisationServerId: string
    enrollmentId: string
    status?: string
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    consent?: OpenFinanceConsentUncheckedCreateNestedOneWithoutLinkInput
  }

  export type OpenFinanceLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: StringFieldUpdateOperationsInput | string
    authorisationServerId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consent?: OpenFinanceConsentUpdateOneWithoutLinkNestedInput
  }

  export type OpenFinanceLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: StringFieldUpdateOperationsInput | string
    authorisationServerId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consent?: OpenFinanceConsentUncheckedUpdateOneWithoutLinkNestedInput
  }

  export type OpenFinanceLinkCreateManyInput = {
    id?: string
    userId: string
    clinicId?: string | null
    organisationId: string
    authorisationServerId: string
    enrollmentId: string
    status?: string
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpenFinanceLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: StringFieldUpdateOperationsInput | string
    authorisationServerId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenFinanceLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: StringFieldUpdateOperationsInput | string
    authorisationServerId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenFinanceConsentCreateInput = {
    id?: string
    consentId: string
    contractId: string
    status?: string
    amountCents: number
    periodicity: string
    nextExecutionAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    link: OpenFinanceLinkCreateNestedOneWithoutConsentInput
  }

  export type OpenFinanceConsentUncheckedCreateInput = {
    id?: string
    linkId: string
    consentId: string
    contractId: string
    status?: string
    amountCents: number
    periodicity: string
    nextExecutionAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpenFinanceConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    periodicity?: StringFieldUpdateOperationsInput | string
    nextExecutionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: OpenFinanceLinkUpdateOneRequiredWithoutConsentNestedInput
  }

  export type OpenFinanceConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    periodicity?: StringFieldUpdateOperationsInput | string
    nextExecutionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenFinanceConsentCreateManyInput = {
    id?: string
    linkId: string
    consentId: string
    contractId: string
    status?: string
    amountCents: number
    periodicity: string
    nextExecutionAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpenFinanceConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    periodicity?: StringFieldUpdateOperationsInput | string
    nextExecutionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenFinanceConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    periodicity?: StringFieldUpdateOperationsInput | string
    nextExecutionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenBankingPaymentCreateInput = {
    id?: string
    providerPaymentId?: string | null
    consentId?: string | null
    amountCents?: number | null
    currency?: string | null
    status?: $Enums.PaymentStatusOB | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollmentId?: string | null
    transactionIdentification?: string | null
    payerId?: string | null
    payerDocument?: string | null
    payerEmail?: string | null
    payerName?: string | null
    creditorName?: string | null
    creditorCpfCnpj?: string | null
    clinicId?: string | null
    productId?: string | null
    purchaseId?: string | null
    type?: $Enums.PaymentTypeOB | null
    executedAt?: Date | string | null
    settledAt?: Date | string | null
    recurrenceType?: string | null
    subscriptionId?: string | null
    executionOrder?: number | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    fidoAssertion?: NullableJsonNullValueInput | InputJsonValue
    riskSignals?: NullableJsonNullValueInput | InputJsonValue
    paymentLinkId?: string | null
    userId?: string | null
    orderRef?: string | null
    redirectUri?: string | null
    transactionId?: string | null
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OpenBankingPaymentUncheckedCreateInput = {
    id?: string
    providerPaymentId?: string | null
    consentId?: string | null
    amountCents?: number | null
    currency?: string | null
    status?: $Enums.PaymentStatusOB | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollmentId?: string | null
    transactionIdentification?: string | null
    payerId?: string | null
    payerDocument?: string | null
    payerEmail?: string | null
    payerName?: string | null
    creditorName?: string | null
    creditorCpfCnpj?: string | null
    clinicId?: string | null
    productId?: string | null
    purchaseId?: string | null
    type?: $Enums.PaymentTypeOB | null
    executedAt?: Date | string | null
    settledAt?: Date | string | null
    recurrenceType?: string | null
    subscriptionId?: string | null
    executionOrder?: number | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    fidoAssertion?: NullableJsonNullValueInput | InputJsonValue
    riskSignals?: NullableJsonNullValueInput | InputJsonValue
    paymentLinkId?: string | null
    userId?: string | null
    orderRef?: string | null
    redirectUri?: string | null
    transactionId?: string | null
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OpenBankingPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaymentStatusOBFieldUpdateOperationsInput | $Enums.PaymentStatusOB | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionIdentification?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: NullableStringFieldUpdateOperationsInput | string | null
    payerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    payerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorCpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumPaymentTypeOBFieldUpdateOperationsInput | $Enums.PaymentTypeOB | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    executionOrder?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    fidoAssertion?: NullableJsonNullValueInput | InputJsonValue
    riskSignals?: NullableJsonNullValueInput | InputJsonValue
    paymentLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OpenBankingPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaymentStatusOBFieldUpdateOperationsInput | $Enums.PaymentStatusOB | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionIdentification?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: NullableStringFieldUpdateOperationsInput | string | null
    payerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    payerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorCpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumPaymentTypeOBFieldUpdateOperationsInput | $Enums.PaymentTypeOB | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    executionOrder?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    fidoAssertion?: NullableJsonNullValueInput | InputJsonValue
    riskSignals?: NullableJsonNullValueInput | InputJsonValue
    paymentLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OpenBankingPaymentCreateManyInput = {
    id?: string
    providerPaymentId?: string | null
    consentId?: string | null
    amountCents?: number | null
    currency?: string | null
    status?: $Enums.PaymentStatusOB | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollmentId?: string | null
    transactionIdentification?: string | null
    payerId?: string | null
    payerDocument?: string | null
    payerEmail?: string | null
    payerName?: string | null
    creditorName?: string | null
    creditorCpfCnpj?: string | null
    clinicId?: string | null
    productId?: string | null
    purchaseId?: string | null
    type?: $Enums.PaymentTypeOB | null
    executedAt?: Date | string | null
    settledAt?: Date | string | null
    recurrenceType?: string | null
    subscriptionId?: string | null
    executionOrder?: number | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    fidoAssertion?: NullableJsonNullValueInput | InputJsonValue
    riskSignals?: NullableJsonNullValueInput | InputJsonValue
    paymentLinkId?: string | null
    userId?: string | null
    orderRef?: string | null
    redirectUri?: string | null
    transactionId?: string | null
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OpenBankingPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaymentStatusOBFieldUpdateOperationsInput | $Enums.PaymentStatusOB | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionIdentification?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: NullableStringFieldUpdateOperationsInput | string | null
    payerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    payerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorCpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumPaymentTypeOBFieldUpdateOperationsInput | $Enums.PaymentTypeOB | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    executionOrder?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    fidoAssertion?: NullableJsonNullValueInput | InputJsonValue
    riskSignals?: NullableJsonNullValueInput | InputJsonValue
    paymentLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OpenBankingPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaymentStatusOBFieldUpdateOperationsInput | $Enums.PaymentStatusOB | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionIdentification?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: NullableStringFieldUpdateOperationsInput | string | null
    payerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    payerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorCpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumPaymentTypeOBFieldUpdateOperationsInput | $Enums.PaymentTypeOB | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    executionOrder?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    fidoAssertion?: NullableJsonNullValueInput | InputJsonValue
    riskSignals?: NullableJsonNullValueInput | InputJsonValue
    paymentLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OpenBankingConsentCreateInput = {
    id?: string
    enrollmentId?: string | null
    consentId: string
    amountCents?: number | null
    currency?: string | null
    creditorName?: string | null
    creditorCpfCnpj?: string | null
    productId?: string | null
    clinicId?: string | null
    status?: $Enums.ConsentStatusOB | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpenBankingConsentUncheckedCreateInput = {
    id?: string
    enrollmentId?: string | null
    consentId: string
    amountCents?: number | null
    currency?: string | null
    creditorName?: string | null
    creditorCpfCnpj?: string | null
    productId?: string | null
    clinicId?: string | null
    status?: $Enums.ConsentStatusOB | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpenBankingConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    creditorName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorCpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumConsentStatusOBFieldUpdateOperationsInput | $Enums.ConsentStatusOB | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenBankingConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    creditorName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorCpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumConsentStatusOBFieldUpdateOperationsInput | $Enums.ConsentStatusOB | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenBankingConsentCreateManyInput = {
    id?: string
    enrollmentId?: string | null
    consentId: string
    amountCents?: number | null
    currency?: string | null
    creditorName?: string | null
    creditorCpfCnpj?: string | null
    productId?: string | null
    clinicId?: string | null
    status?: $Enums.ConsentStatusOB | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpenBankingConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    creditorName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorCpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumConsentStatusOBFieldUpdateOperationsInput | $Enums.ConsentStatusOB | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenBankingConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    creditorName?: NullableStringFieldUpdateOperationsInput | string | null
    creditorCpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumConsentStatusOBFieldUpdateOperationsInput | $Enums.ConsentStatusOB | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentContextCreateInput = {
    id?: string
    userId: string
    sessionId?: string | null
    enrollmentId: string
    organisationId: string
    authorisationServerId: string
    fallbackUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.EnrollmentStatusOB | null
    deviceRegistered?: boolean
    expiresAt?: Date | string | null
    clinicId?: string | null
    payerEmail?: string | null
    payerDocument?: string | null
    payerName?: string | null
    recurringEnabled?: boolean | null
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EnrollmentContextUncheckedCreateInput = {
    id?: string
    userId: string
    sessionId?: string | null
    enrollmentId: string
    organisationId: string
    authorisationServerId: string
    fallbackUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.EnrollmentStatusOB | null
    deviceRegistered?: boolean
    expiresAt?: Date | string | null
    clinicId?: string | null
    payerEmail?: string | null
    payerDocument?: string | null
    payerName?: string | null
    recurringEnabled?: boolean | null
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EnrollmentContextUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: StringFieldUpdateOperationsInput | string
    organisationId?: StringFieldUpdateOperationsInput | string
    authorisationServerId?: StringFieldUpdateOperationsInput | string
    fallbackUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumEnrollmentStatusOBFieldUpdateOperationsInput | $Enums.EnrollmentStatusOB | null
    deviceRegistered?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    payerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    recurringEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EnrollmentContextUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: StringFieldUpdateOperationsInput | string
    organisationId?: StringFieldUpdateOperationsInput | string
    authorisationServerId?: StringFieldUpdateOperationsInput | string
    fallbackUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumEnrollmentStatusOBFieldUpdateOperationsInput | $Enums.EnrollmentStatusOB | null
    deviceRegistered?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    payerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    recurringEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EnrollmentContextCreateManyInput = {
    id?: string
    userId: string
    sessionId?: string | null
    enrollmentId: string
    organisationId: string
    authorisationServerId: string
    fallbackUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.EnrollmentStatusOB | null
    deviceRegistered?: boolean
    expiresAt?: Date | string | null
    clinicId?: string | null
    payerEmail?: string | null
    payerDocument?: string | null
    payerName?: string | null
    recurringEnabled?: boolean | null
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EnrollmentContextUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: StringFieldUpdateOperationsInput | string
    organisationId?: StringFieldUpdateOperationsInput | string
    authorisationServerId?: StringFieldUpdateOperationsInput | string
    fallbackUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumEnrollmentStatusOBFieldUpdateOperationsInput | $Enums.EnrollmentStatusOB | null
    deviceRegistered?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    payerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    recurringEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EnrollmentContextUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: StringFieldUpdateOperationsInput | string
    organisationId?: StringFieldUpdateOperationsInput | string
    authorisationServerId?: StringFieldUpdateOperationsInput | string
    fallbackUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumEnrollmentStatusOBFieldUpdateOperationsInput | $Enums.EnrollmentStatusOB | null
    deviceRegistered?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    payerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    recurringEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentConsentCreateInput = {
    id?: string
    tenantId?: string | null
    consentId: string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentConsentUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    consentId: string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentConsentCreateManyInput = {
    id?: string
    tenantId?: string | null
    consentId: string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    consentId?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthStateCreateInput = {
    id?: string
    state: string
    nonce?: string | null
    codeVerifier?: string | null
    tenantId?: string | null
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type OAuthStateUncheckedCreateInput = {
    id?: string
    state: string
    nonce?: string | null
    codeVerifier?: string | null
    tenantId?: string | null
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type OAuthStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    nonce?: NullableStringFieldUpdateOperationsInput | string | null
    codeVerifier?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    nonce?: NullableStringFieldUpdateOperationsInput | string | null
    codeVerifier?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthStateCreateManyInput = {
    id?: string
    state: string
    nonce?: string | null
    codeVerifier?: string | null
    tenantId?: string | null
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type OAuthStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    nonce?: NullableStringFieldUpdateOperationsInput | string | null
    codeVerifier?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    nonce?: NullableStringFieldUpdateOperationsInput | string | null
    codeVerifier?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthStateMetaCreateInput = {
    state: string
    organisationId?: string | null
    authorisationServerId?: string | null
    createdAt?: Date | string
    productId?: string | null
    amountCents?: number | null
    currency?: string | null
    orderRef?: string | null
  }

  export type OAuthStateMetaUncheckedCreateInput = {
    state: string
    organisationId?: string | null
    authorisationServerId?: string | null
    createdAt?: Date | string
    productId?: string | null
    amountCents?: number | null
    currency?: string | null
    orderRef?: string | null
  }

  export type OAuthStateMetaUpdateInput = {
    state?: StringFieldUpdateOperationsInput | string
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    authorisationServerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OAuthStateMetaUncheckedUpdateInput = {
    state?: StringFieldUpdateOperationsInput | string
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    authorisationServerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OAuthStateMetaCreateManyInput = {
    state: string
    organisationId?: string | null
    authorisationServerId?: string | null
    createdAt?: Date | string
    productId?: string | null
    amountCents?: number | null
    currency?: string | null
    orderRef?: string | null
  }

  export type OAuthStateMetaUpdateManyMutationInput = {
    state?: StringFieldUpdateOperationsInput | string
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    authorisationServerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OAuthStateMetaUncheckedUpdateManyInput = {
    state?: StringFieldUpdateOperationsInput | string
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    authorisationServerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OAuthTokenCreateInput = {
    id?: string
    tenantId?: string | null
    provider?: string
    accessToken: string
    refreshToken?: string | null
    scope?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OAuthTokenUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    provider?: string
    accessToken: string
    refreshToken?: string | null
    scope?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OAuthTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenCreateManyInput = {
    id?: string
    tenantId?: string | null
    provider?: string
    accessToken: string
    refreshToken?: string | null
    scope?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OAuthTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    eventId?: string | null
    eventType: $Enums.EventType
    customerId?: string | null
    clinicId: string
    actor: $Enums.EventActor
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventUncheckedCreateInput = {
    id?: string
    eventId?: string | null
    eventType: $Enums.EventType
    customerId?: string | null
    clinicId: string
    actor: $Enums.EventActor
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: StringFieldUpdateOperationsInput | string
    actor?: EnumEventActorFieldUpdateOperationsInput | $Enums.EventActor
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: StringFieldUpdateOperationsInput | string
    actor?: EnumEventActorFieldUpdateOperationsInput | $Enums.EventActor
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: string
    eventId?: string | null
    eventType: $Enums.EventType
    customerId?: string | null
    clinicId: string
    actor: $Enums.EventActor
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: StringFieldUpdateOperationsInput | string
    actor?: EnumEventActorFieldUpdateOperationsInput | $Enums.EventActor
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: StringFieldUpdateOperationsInput | string
    actor?: EnumEventActorFieldUpdateOperationsInput | $Enums.EventActor
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateInput = {
    id?: string
    provider: string
    hook_id: string
    type: string
    resource_order_id?: string | null
    resource_charge_id?: string | null
    status?: string | null
    received_at?: Date | string
    processed_at?: Date | string | null
    attempts?: number | null
    raw: JsonNullValueInput | InputJsonValue
    provider_event_id?: string | null
    processed?: boolean
    processing_error?: string | null
    retry_count?: number
    max_retries?: number
    next_retry_at?: Date | string | null
    last_retry_at?: Date | string | null
    error_type?: string | null
    is_retryable?: boolean
    moved_dead_letter?: boolean
    dead_letter_reason?: string | null
  }

  export type WebhookEventUncheckedCreateInput = {
    id?: string
    provider: string
    hook_id: string
    type: string
    resource_order_id?: string | null
    resource_charge_id?: string | null
    status?: string | null
    received_at?: Date | string
    processed_at?: Date | string | null
    attempts?: number | null
    raw: JsonNullValueInput | InputJsonValue
    provider_event_id?: string | null
    processed?: boolean
    processing_error?: string | null
    retry_count?: number
    max_retries?: number
    next_retry_at?: Date | string | null
    last_retry_at?: Date | string | null
    error_type?: string | null
    is_retryable?: boolean
    moved_dead_letter?: boolean
    dead_letter_reason?: string | null
  }

  export type WebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    hook_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    resource_charge_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    received_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: JsonNullValueInput | InputJsonValue
    provider_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    processing_error?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
    max_retries?: IntFieldUpdateOperationsInput | number
    next_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_retryable?: BoolFieldUpdateOperationsInput | boolean
    moved_dead_letter?: BoolFieldUpdateOperationsInput | boolean
    dead_letter_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    hook_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    resource_charge_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    received_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: JsonNullValueInput | InputJsonValue
    provider_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    processing_error?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
    max_retries?: IntFieldUpdateOperationsInput | number
    next_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_retryable?: BoolFieldUpdateOperationsInput | boolean
    moved_dead_letter?: BoolFieldUpdateOperationsInput | boolean
    dead_letter_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookEventCreateManyInput = {
    id?: string
    provider: string
    hook_id: string
    type: string
    resource_order_id?: string | null
    resource_charge_id?: string | null
    status?: string | null
    received_at?: Date | string
    processed_at?: Date | string | null
    attempts?: number | null
    raw: JsonNullValueInput | InputJsonValue
    provider_event_id?: string | null
    processed?: boolean
    processing_error?: string | null
    retry_count?: number
    max_retries?: number
    next_retry_at?: Date | string | null
    last_retry_at?: Date | string | null
    error_type?: string | null
    is_retryable?: boolean
    moved_dead_letter?: boolean
    dead_letter_reason?: string | null
  }

  export type WebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    hook_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    resource_charge_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    received_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: JsonNullValueInput | InputJsonValue
    provider_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    processing_error?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
    max_retries?: IntFieldUpdateOperationsInput | number
    next_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_retryable?: BoolFieldUpdateOperationsInput | boolean
    moved_dead_letter?: BoolFieldUpdateOperationsInput | boolean
    dead_letter_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    hook_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    resource_charge_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    received_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: JsonNullValueInput | InputJsonValue
    provider_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    processing_error?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
    max_retries?: IntFieldUpdateOperationsInput | number
    next_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_retry_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_retryable?: BoolFieldUpdateOperationsInput | boolean
    moved_dead_letter?: BoolFieldUpdateOperationsInput | boolean
    dead_letter_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookEndpointCreateInput = {
    id?: string
    name: string
    url: string
    secret: string
    events?: WebhookEndpointCreateeventsInput | string[]
    enabled?: boolean
    maxConcurrentDeliveries?: number
    categoryFilter?: string
    statusFilters?: WebhookEndpointCreatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointCreateproductFiltersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutWebhookEndpointsInput
    deliveries?: OutboundWebhookDeliveryCreateNestedManyWithoutEndpointInput
  }

  export type WebhookEndpointUncheckedCreateInput = {
    id?: string
    clinicId: string
    name: string
    url: string
    secret: string
    events?: WebhookEndpointCreateeventsInput | string[]
    enabled?: boolean
    maxConcurrentDeliveries?: number
    categoryFilter?: string
    statusFilters?: WebhookEndpointCreatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointCreateproductFiltersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: OutboundWebhookDeliveryUncheckedCreateNestedManyWithoutEndpointInput
  }

  export type WebhookEndpointUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookEndpointUpdateeventsInput | string[]
    enabled?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentDeliveries?: IntFieldUpdateOperationsInput | number
    categoryFilter?: StringFieldUpdateOperationsInput | string
    statusFilters?: WebhookEndpointUpdatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointUpdateproductFiltersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutWebhookEndpointsNestedInput
    deliveries?: OutboundWebhookDeliveryUpdateManyWithoutEndpointNestedInput
  }

  export type WebhookEndpointUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookEndpointUpdateeventsInput | string[]
    enabled?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentDeliveries?: IntFieldUpdateOperationsInput | number
    categoryFilter?: StringFieldUpdateOperationsInput | string
    statusFilters?: WebhookEndpointUpdatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointUpdateproductFiltersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: OutboundWebhookDeliveryUncheckedUpdateManyWithoutEndpointNestedInput
  }

  export type WebhookEndpointCreateManyInput = {
    id?: string
    clinicId: string
    name: string
    url: string
    secret: string
    events?: WebhookEndpointCreateeventsInput | string[]
    enabled?: boolean
    maxConcurrentDeliveries?: number
    categoryFilter?: string
    statusFilters?: WebhookEndpointCreatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointCreateproductFiltersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookEndpointUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookEndpointUpdateeventsInput | string[]
    enabled?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentDeliveries?: IntFieldUpdateOperationsInput | number
    categoryFilter?: StringFieldUpdateOperationsInput | string
    statusFilters?: WebhookEndpointUpdatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointUpdateproductFiltersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEndpointUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookEndpointUpdateeventsInput | string[]
    enabled?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentDeliveries?: IntFieldUpdateOperationsInput | number
    categoryFilter?: StringFieldUpdateOperationsInput | string
    statusFilters?: WebhookEndpointUpdatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointUpdateproductFiltersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundWebhookEventCreateInput = {
    id?: string
    type: string
    resource: string
    resourceId: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutOutboundEventsInput
    deliveries?: OutboundWebhookDeliveryCreateNestedManyWithoutEventInput
  }

  export type OutboundWebhookEventUncheckedCreateInput = {
    id?: string
    clinicId: string
    type: string
    resource: string
    resourceId: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    deliveries?: OutboundWebhookDeliveryUncheckedCreateNestedManyWithoutEventInput
  }

  export type OutboundWebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutOutboundEventsNestedInput
    deliveries?: OutboundWebhookDeliveryUpdateManyWithoutEventNestedInput
  }

  export type OutboundWebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: OutboundWebhookDeliveryUncheckedUpdateManyWithoutEventNestedInput
  }

  export type OutboundWebhookEventCreateManyInput = {
    id?: string
    clinicId: string
    type: string
    resource: string
    resourceId: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OutboundWebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundWebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundWebhookDeliveryCreateInput = {
    id?: string
    status?: string
    attempts?: number
    lastCode?: number | null
    lastError?: string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    endpoint: WebhookEndpointCreateNestedOneWithoutDeliveriesInput
    event: OutboundWebhookEventCreateNestedOneWithoutDeliveriesInput
  }

  export type OutboundWebhookDeliveryUncheckedCreateInput = {
    id?: string
    endpointId: string
    eventId: string
    status?: string
    attempts?: number
    lastCode?: number | null
    lastError?: string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundWebhookDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastCode?: NullableIntFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endpoint?: WebhookEndpointUpdateOneRequiredWithoutDeliveriesNestedInput
    event?: OutboundWebhookEventUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type OutboundWebhookDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpointId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastCode?: NullableIntFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundWebhookDeliveryCreateManyInput = {
    id?: string
    endpointId: string
    eventId: string
    status?: string
    attempts?: number
    lastCode?: number | null
    lastError?: string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundWebhookDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastCode?: NullableIntFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundWebhookDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpointId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastCode?: NullableIntFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ClinicMemberListRelationFilter = {
    every?: ClinicMemberWhereInput
    some?: ClinicMemberWhereInput
    none?: ClinicMemberWhereInput
  }

  export type ClinicListRelationFilter = {
    every?: ClinicWhereInput
    some?: ClinicWhereInput
    none?: ClinicWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type VerificationCodeListRelationFilter = {
    every?: VerificationCodeWhereInput
    some?: VerificationCodeWhereInput
    none?: VerificationCodeWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type PointsLedgerListRelationFilter = {
    every?: PointsLedgerWhereInput
    some?: PointsLedgerWhereInput
    none?: PointsLedgerWhereInput
  }

  export type PatientProfileListRelationFilter = {
    every?: PatientProfileWhereInput
    some?: PatientProfileWhereInput
    none?: PatientProfileWhereInput
  }

  export type MessageTemplateListRelationFilter = {
    every?: MessageTemplateWhereInput
    some?: MessageTemplateWhereInput
    none?: MessageTemplateWhereInput
  }

  export type MessageSequenceListRelationFilter = {
    every?: MessageSequenceWhereInput
    some?: MessageSequenceWhereInput
    none?: MessageSequenceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerificationCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointsLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageSequenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    public_cover_image_url?: SortOrder
    doctor_slug?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verified?: SortOrder
    password?: SortOrder
    reset_token?: SortOrder
    reset_token_expiry?: SortOrder
    verification_code?: SortOrder
    verification_code_expiry?: SortOrder
    doctor_id?: SortOrder
    referral_code?: SortOrder
    phone?: SortOrder
    birth_date?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    emergency_contact?: SortOrder
    emergency_phone?: SortOrder
    medical_history?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    notes?: SortOrder
    google_review_link?: SortOrder
    stripe_connect_id?: SortOrder
    accessGranted?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    public_cover_image_url?: SortOrder
    doctor_slug?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verified?: SortOrder
    password?: SortOrder
    reset_token?: SortOrder
    reset_token_expiry?: SortOrder
    verification_code?: SortOrder
    verification_code_expiry?: SortOrder
    doctor_id?: SortOrder
    referral_code?: SortOrder
    phone?: SortOrder
    birth_date?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    emergency_contact?: SortOrder
    emergency_phone?: SortOrder
    medical_history?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    notes?: SortOrder
    google_review_link?: SortOrder
    stripe_connect_id?: SortOrder
    accessGranted?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    public_cover_image_url?: SortOrder
    doctor_slug?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verified?: SortOrder
    password?: SortOrder
    reset_token?: SortOrder
    reset_token_expiry?: SortOrder
    verification_code?: SortOrder
    verification_code_expiry?: SortOrder
    doctor_id?: SortOrder
    referral_code?: SortOrder
    phone?: SortOrder
    birth_date?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    emergency_contact?: SortOrder
    emergency_phone?: SortOrder
    medical_history?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    notes?: SortOrder
    google_review_link?: SortOrder
    stripe_connect_id?: SortOrder
    accessGranted?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    user_id?: SortOrder
    doctor_id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
  }

  export type VerificationCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    user_id?: SortOrder
    doctor_id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
  }

  export type VerificationCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    user_id?: SortOrder
    doctor_id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PatientProfileDoctorIdUserIdCompoundUniqueInput = {
    doctorId: string
    userId: string
  }

  export type PatientProfileCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    emergency_contact?: SortOrder
    emergency_phone?: SortOrder
    medical_history?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalPoints?: SortOrder
    currentPoints?: SortOrder
  }

  export type PatientProfileAvgOrderByAggregateInput = {
    totalPoints?: SortOrder
    currentPoints?: SortOrder
  }

  export type PatientProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    emergency_contact?: SortOrder
    emergency_phone?: SortOrder
    medical_history?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalPoints?: SortOrder
    currentPoints?: SortOrder
  }

  export type PatientProfileMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    emergency_contact?: SortOrder
    emergency_phone?: SortOrder
    medical_history?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalPoints?: SortOrder
    currentPoints?: SortOrder
  }

  export type PatientProfileSumOrderByAggregateInput = {
    totalPoints?: SortOrder
    currentPoints?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PatientProfileNullableScalarRelationFilter = {
    is?: PatientProfileWhereInput | null
    isNot?: PatientProfileWhereInput | null
  }

  export type PointsLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patientProfileId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PointsLedgerAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PointsLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patientProfileId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PointsLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patientProfileId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PointsLedgerSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumClinicThemeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicTheme | EnumClinicThemeFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicTheme[] | ListEnumClinicThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicTheme[] | ListEnumClinicThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicThemeFilter<$PrismaModel> | $Enums.ClinicTheme
  }

  export type ClinicSubscriptionListRelationFilter = {
    every?: ClinicSubscriptionWhereInput
    some?: ClinicSubscriptionWhereInput
    none?: ClinicSubscriptionWhereInput
  }

  export type MerchantNullableScalarRelationFilter = {
    is?: MerchantWhereInput | null
    isNot?: MerchantWhereInput | null
  }

  export type MerchantApplicationNullableScalarRelationFilter = {
    is?: MerchantApplicationWhereInput | null
    isNot?: MerchantApplicationWhereInput | null
  }

  export type WebhookEndpointListRelationFilter = {
    every?: WebhookEndpointWhereInput
    some?: WebhookEndpointWhereInput
    none?: WebhookEndpointWhereInput
  }

  export type OutboundWebhookEventListRelationFilter = {
    every?: OutboundWebhookEventWhereInput
    some?: OutboundWebhookEventWhereInput
    none?: OutboundWebhookEventWhereInput
  }

  export type ClinicSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookEndpointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutboundWebhookEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    slug?: SortOrder
    subdomain?: SortOrder
    monthlyRevenueRange?: SortOrder
    currentGateway?: SortOrder
    theme?: SortOrder
    buttonColor?: SortOrder
    buttonTextColor?: SortOrder
  }

  export type ClinicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    slug?: SortOrder
    subdomain?: SortOrder
    monthlyRevenueRange?: SortOrder
    currentGateway?: SortOrder
    theme?: SortOrder
    buttonColor?: SortOrder
    buttonTextColor?: SortOrder
  }

  export type ClinicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    slug?: SortOrder
    subdomain?: SortOrder
    monthlyRevenueRange?: SortOrder
    currentGateway?: SortOrder
    theme?: SortOrder
    buttonColor?: SortOrder
    buttonTextColor?: SortOrder
  }

  export type EnumClinicThemeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicTheme | EnumClinicThemeFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicTheme[] | ListEnumClinicThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicTheme[] | ListEnumClinicThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicThemeWithAggregatesFilter<$PrismaModel> | $Enums.ClinicTheme
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClinicThemeFilter<$PrismaModel>
    _max?: NestedEnumClinicThemeFilter<$PrismaModel>
  }

  export type EnumClinicRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicRole | EnumClinicRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicRole[] | ListEnumClinicRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicRole[] | ListEnumClinicRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicRoleFilter<$PrismaModel> | $Enums.ClinicRole
  }

  export type ClinicScalarRelationFilter = {
    is?: ClinicWhereInput
    isNot?: ClinicWhereInput
  }

  export type ClinicMemberClinicIdUserIdCompoundUniqueInput = {
    clinicId: string
    userId: string
  }

  export type ClinicMemberCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
  }

  export type ClinicMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
  }

  export type ClinicMemberMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumClinicRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicRole | EnumClinicRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicRole[] | ListEnumClinicRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicRole[] | ListEnumClinicRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicRoleWithAggregatesFilter<$PrismaModel> | $Enums.ClinicRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClinicRoleFilter<$PrismaModel>
    _max?: NestedEnumClinicRoleFilter<$PrismaModel>
  }

  export type EnumMerchantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantStatus | EnumMerchantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantStatus[] | ListEnumMerchantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantStatus[] | ListEnumMerchantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantStatusFilter<$PrismaModel> | $Enums.MerchantStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MerchantIntegrationListRelationFilter = {
    every?: MerchantIntegrationWhereInput
    some?: MerchantIntegrationWhereInput
    none?: MerchantIntegrationWhereInput
  }

  export type MerchantIntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MerchantCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    externalAccountId?: SortOrder
    onboardingState?: SortOrder
    splitPercent?: SortOrder
    platformFeeBps?: SortOrder
    transactionFeeCents?: SortOrder
    transactionFeeType?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantAvgOrderByAggregateInput = {
    splitPercent?: SortOrder
    platformFeeBps?: SortOrder
    transactionFeeCents?: SortOrder
  }

  export type MerchantMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    externalAccountId?: SortOrder
    splitPercent?: SortOrder
    platformFeeBps?: SortOrder
    transactionFeeCents?: SortOrder
    transactionFeeType?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    externalAccountId?: SortOrder
    splitPercent?: SortOrder
    platformFeeBps?: SortOrder
    transactionFeeCents?: SortOrder
    transactionFeeType?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantSumOrderByAggregateInput = {
    splitPercent?: SortOrder
    platformFeeBps?: SortOrder
    transactionFeeCents?: SortOrder
  }

  export type EnumMerchantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantStatus | EnumMerchantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantStatus[] | ListEnumMerchantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantStatus[] | ListEnumMerchantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantStatusWithAggregatesFilter<$PrismaModel> | $Enums.MerchantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMerchantStatusFilter<$PrismaModel>
    _max?: NestedEnumMerchantStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumMerchantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantType | EnumMerchantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantType[] | ListEnumMerchantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantType[] | ListEnumMerchantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantTypeFilter<$PrismaModel> | $Enums.MerchantType
  }

  export type EnumMerchantAppStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantAppStatus | EnumMerchantAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantAppStatus[] | ListEnumMerchantAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantAppStatus[] | ListEnumMerchantAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantAppStatusFilter<$PrismaModel> | $Enums.MerchantAppStatus
  }

  export type MerchantDocumentListRelationFilter = {
    every?: MerchantDocumentWhereInput
    some?: MerchantDocumentWhereInput
    none?: MerchantDocumentWhereInput
  }

  export type MerchantDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MerchantApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    businessName?: SortOrder
    fullName?: SortOrder
    documentNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    bankAccount?: SortOrder
    recipientId?: SortOrder
    status?: SortOrder
    reviewNotes?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    businessName?: SortOrder
    fullName?: SortOrder
    documentNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    recipientId?: SortOrder
    status?: SortOrder
    reviewNotes?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    businessName?: SortOrder
    fullName?: SortOrder
    documentNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    recipientId?: SortOrder
    status?: SortOrder
    reviewNotes?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMerchantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantType | EnumMerchantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantType[] | ListEnumMerchantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantType[] | ListEnumMerchantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantTypeWithAggregatesFilter<$PrismaModel> | $Enums.MerchantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMerchantTypeFilter<$PrismaModel>
    _max?: NestedEnumMerchantTypeFilter<$PrismaModel>
  }

  export type EnumMerchantAppStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantAppStatus | EnumMerchantAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantAppStatus[] | ListEnumMerchantAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantAppStatus[] | ListEnumMerchantAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantAppStatusWithAggregatesFilter<$PrismaModel> | $Enums.MerchantAppStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMerchantAppStatusFilter<$PrismaModel>
    _max?: NestedEnumMerchantAppStatusFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type EnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type MerchantApplicationScalarRelationFilter = {
    is?: MerchantApplicationWhereInput
    isNot?: MerchantApplicationWhereInput
  }

  export type MerchantDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    uploadedAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type MerchantDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    uploadedAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type MerchantDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    uploadedAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MerchantScalarRelationFilter = {
    is?: MerchantWhereInput
    isNot?: MerchantWhereInput
  }

  export type MerchantIntegrationMerchantIdProviderCompoundUniqueInput = {
    merchantId: string
    provider: $Enums.PaymentProvider
  }

  export type MerchantIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    connectedAt?: SortOrder
    lastUsedAt?: SortOrder
    lastError?: SortOrder
    lastErrorAt?: SortOrder
  }

  export type MerchantIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    provider?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    connectedAt?: SortOrder
    lastUsedAt?: SortOrder
    lastError?: SortOrder
    lastErrorAt?: SortOrder
  }

  export type MerchantIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    provider?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    connectedAt?: SortOrder
    lastUsedAt?: SortOrder
    lastError?: SortOrder
    lastErrorAt?: SortOrder
  }

  export type EnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type PaymentRoutingRuleCountOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrder
    offerId?: SortOrder
    country?: SortOrder
    method?: SortOrder
    provider?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRoutingRuleAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type PaymentRoutingRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrder
    offerId?: SortOrder
    country?: SortOrder
    method?: SortOrder
    provider?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRoutingRuleMinOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrder
    offerId?: SortOrder
    country?: SortOrder
    method?: SortOrder
    provider?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRoutingRuleSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type EnumPlanTierFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanTier | EnumPlanTierFieldRefInput<$PrismaModel>
    in?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTierFilter<$PrismaModel> | $Enums.PlanTier
  }

  export type ClinicPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tier?: SortOrder
    description?: SortOrder
    monthlyPrice?: SortOrder
    monthlyTxLimit?: SortOrder
    features?: SortOrder
    trialDays?: SortOrder
    requireCard?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicPlanAvgOrderByAggregateInput = {
    monthlyPrice?: SortOrder
    monthlyTxLimit?: SortOrder
    trialDays?: SortOrder
  }

  export type ClinicPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tier?: SortOrder
    description?: SortOrder
    monthlyPrice?: SortOrder
    monthlyTxLimit?: SortOrder
    trialDays?: SortOrder
    requireCard?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tier?: SortOrder
    description?: SortOrder
    monthlyPrice?: SortOrder
    monthlyTxLimit?: SortOrder
    trialDays?: SortOrder
    requireCard?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicPlanSumOrderByAggregateInput = {
    monthlyPrice?: SortOrder
    monthlyTxLimit?: SortOrder
    trialDays?: SortOrder
  }

  export type EnumPlanTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanTier | EnumPlanTierFieldRefInput<$PrismaModel>
    in?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTierWithAggregatesFilter<$PrismaModel> | $Enums.PlanTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTierFilter<$PrismaModel>
    _max?: NestedEnumPlanTierFilter<$PrismaModel>
  }

  export type EnumAddOnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddOnTypeFilter<$PrismaModel> | $Enums.AddOnType
  }

  export type ClinicAddOnSubscriptionListRelationFilter = {
    every?: ClinicAddOnSubscriptionWhereInput
    some?: ClinicAddOnSubscriptionWhereInput
    none?: ClinicAddOnSubscriptionWhereInput
  }

  export type ClinicAddOnSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicAddOnCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    monthlyPrice?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicAddOnAvgOrderByAggregateInput = {
    monthlyPrice?: SortOrder
    quantity?: SortOrder
  }

  export type ClinicAddOnMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    monthlyPrice?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicAddOnMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    monthlyPrice?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicAddOnSumOrderByAggregateInput = {
    monthlyPrice?: SortOrder
    quantity?: SortOrder
  }

  export type EnumAddOnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddOnTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddOnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddOnTypeFilter<$PrismaModel>
    _max?: NestedEnumAddOnTypeFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type ClinicPlanScalarRelationFilter = {
    is?: ClinicPlanWhereInput
    isNot?: ClinicPlanWhereInput
  }

  export type ClinicSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    canceledAt?: SortOrder
    cancelReason?: SortOrder
    currentDoctorsCount?: SortOrder
    currentPatientsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicSubscriptionAvgOrderByAggregateInput = {
    currentDoctorsCount?: SortOrder
    currentPatientsCount?: SortOrder
  }

  export type ClinicSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    canceledAt?: SortOrder
    cancelReason?: SortOrder
    currentDoctorsCount?: SortOrder
    currentPatientsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    canceledAt?: SortOrder
    cancelReason?: SortOrder
    currentDoctorsCount?: SortOrder
    currentPatientsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicSubscriptionSumOrderByAggregateInput = {
    currentDoctorsCount?: SortOrder
    currentPatientsCount?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type ClinicSubscriptionScalarRelationFilter = {
    is?: ClinicSubscriptionWhereInput
    isNot?: ClinicSubscriptionWhereInput
  }

  export type ClinicAddOnScalarRelationFilter = {
    is?: ClinicAddOnWhereInput
    isNot?: ClinicAddOnWhereInput
  }

  export type ClinicAddOnSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    addOnId?: SortOrder
    quantity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicAddOnSubscriptionAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ClinicAddOnSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    addOnId?: SortOrder
    quantity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicAddOnSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    addOnId?: SortOrder
    quantity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicAddOnSubscriptionSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CategoriesOnProductsListRelationFilter = {
    every?: CategoriesOnProductsWhereInput
    some?: CategoriesOnProductsWhereInput
    none?: CategoriesOnProductsWhereInput
  }

  export type CategoriesOnProductsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryDoctorIdNameCompoundUniqueInput = {
    doctorId: string
    name: string
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    doctorId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    doctorId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    doctorId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type EnumSubscriptionIntervalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionIntervalNullableFilter<$PrismaModel> | $Enums.SubscriptionInterval | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ClinicNullableScalarRelationFilter = {
    is?: ClinicWhereInput | null
    isNot?: ClinicWhereInput | null
  }

  export type ProductCategoryNullableScalarRelationFilter = {
    is?: ProductCategoryWhereInput | null
    isNot?: ProductCategoryWhereInput | null
  }

  export type OfferListRelationFilter = {
    every?: OfferWhereInput
    some?: OfferWhereInput
    none?: OfferWhereInput
  }

  export type ProductIntegrationListRelationFilter = {
    every?: ProductIntegrationWhereInput
    some?: ProductIntegrationWhereInput
    none?: ProductIntegrationWhereInput
  }

  export type OfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductIntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    price?: SortOrder
    creditsPerUnit?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorId?: SortOrder
    clinicId?: SortOrder
    imageUrl?: SortOrder
    confirmationUrl?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialDays?: SortOrder
    providerPlanId?: SortOrder
    providerPlanData?: SortOrder
    autoRenew?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    creditsPerUnit?: SortOrder
    priority?: SortOrder
    intervalCount?: SortOrder
    trialDays?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    price?: SortOrder
    creditsPerUnit?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorId?: SortOrder
    clinicId?: SortOrder
    imageUrl?: SortOrder
    confirmationUrl?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialDays?: SortOrder
    providerPlanId?: SortOrder
    autoRenew?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    price?: SortOrder
    creditsPerUnit?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorId?: SortOrder
    clinicId?: SortOrder
    imageUrl?: SortOrder
    confirmationUrl?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialDays?: SortOrder
    providerPlanId?: SortOrder
    autoRenew?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    creditsPerUnit?: SortOrder
    priority?: SortOrder
    intervalCount?: SortOrder
    trialDays?: SortOrder
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type EnumSubscriptionIntervalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionIntervalNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionInterval | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionIntervalNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionIntervalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductCategoryScalarRelationFilter = {
    is?: ProductCategoryWhereInput
    isNot?: ProductCategoryWhereInput
  }

  export type CategoriesOnProductsProductIdCategoryIdCompoundUniqueInput = {
    productId: string
    categoryId: string
  }

  export type CategoriesOnProductsCountOrderByAggregateInput = {
    productId?: SortOrder
    categoryId?: SortOrder
    assignedAt?: SortOrder
  }

  export type CategoriesOnProductsMaxOrderByAggregateInput = {
    productId?: SortOrder
    categoryId?: SortOrder
    assignedAt?: SortOrder
  }

  export type CategoriesOnProductsMinOrderByAggregateInput = {
    productId?: SortOrder
    categoryId?: SortOrder
    assignedAt?: SortOrder
  }

  export type EnumCurrencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyFilter<$PrismaModel> | $Enums.Currency
  }

  export type EnumPaymentProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentProviderNullableFilter<$PrismaModel> | $Enums.PaymentProvider | null
  }

  export type OfferPaymentMethodListRelationFilter = {
    every?: OfferPaymentMethodWhereInput
    some?: OfferPaymentMethodWhereInput
    none?: OfferPaymentMethodWhereInput
  }

  export type OfferPriceListRelationFilter = {
    every?: OfferPriceWhereInput
    some?: OfferPriceWhereInput
    none?: OfferPriceWhereInput
  }

  export type OfferPaymentMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    currency?: SortOrder
    priceCents?: SortOrder
    preferredProvider?: SortOrder
    maxInstallments?: SortOrder
    installmentMinCents?: SortOrder
    active?: SortOrder
    isSubscription?: SortOrder
    intervalCount?: SortOrder
    intervalUnit?: SortOrder
    trialDays?: SortOrder
    checkoutUrl?: SortOrder
    providerConfig?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    priceCents?: SortOrder
    maxInstallments?: SortOrder
    installmentMinCents?: SortOrder
    intervalCount?: SortOrder
    trialDays?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    currency?: SortOrder
    priceCents?: SortOrder
    preferredProvider?: SortOrder
    maxInstallments?: SortOrder
    installmentMinCents?: SortOrder
    active?: SortOrder
    isSubscription?: SortOrder
    intervalCount?: SortOrder
    intervalUnit?: SortOrder
    trialDays?: SortOrder
    checkoutUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    currency?: SortOrder
    priceCents?: SortOrder
    preferredProvider?: SortOrder
    maxInstallments?: SortOrder
    installmentMinCents?: SortOrder
    active?: SortOrder
    isSubscription?: SortOrder
    intervalCount?: SortOrder
    intervalUnit?: SortOrder
    trialDays?: SortOrder
    checkoutUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    priceCents?: SortOrder
    maxInstallments?: SortOrder
    installmentMinCents?: SortOrder
    intervalCount?: SortOrder
    trialDays?: SortOrder
  }

  export type EnumCurrencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyWithAggregatesFilter<$PrismaModel> | $Enums.Currency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyFilter<$PrismaModel>
    _max?: NestedEnumCurrencyFilter<$PrismaModel>
  }

  export type EnumPaymentProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderNullableFilter<$PrismaModel>
  }

  export type OfferScalarRelationFilter = {
    is?: OfferWhereInput
    isNot?: OfferWhereInput
  }

  export type OfferPriceOfferIdCountryCurrencyProviderCompoundUniqueInput = {
    offerId: string
    country: string
    currency: $Enums.Currency
    provider: $Enums.PaymentProvider
  }

  export type OfferPriceCountOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    externalPriceId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferPriceAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type OfferPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    externalPriceId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferPriceMinOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    externalPriceId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferPriceSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type OfferPaymentMethodOfferIdMethodCompoundUniqueInput = {
    offerId: string
    method: $Enums.PaymentMethod
  }

  export type OfferPaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    method?: SortOrder
    active?: SortOrder
    feePercent?: SortOrder
  }

  export type OfferPaymentMethodAvgOrderByAggregateInput = {
    feePercent?: SortOrder
  }

  export type OfferPaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    method?: SortOrder
    active?: SortOrder
    feePercent?: SortOrder
  }

  export type OfferPaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    method?: SortOrder
    active?: SortOrder
    feePercent?: SortOrder
  }

  export type OfferPaymentMethodSumOrderByAggregateInput = {
    feePercent?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProductIntegrationProductIdProviderCompoundUniqueInput = {
    productId: string
    provider: $Enums.PaymentProvider
  }

  export type ProductIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    provider?: SortOrder
    externalProductId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    provider?: SortOrder
    externalProductId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    provider?: SortOrder
    externalProductId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCheckoutSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckoutSessionStatus | EnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CheckoutSessionStatus[] | ListEnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckoutSessionStatus[] | ListEnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckoutSessionStatusFilter<$PrismaModel> | $Enums.CheckoutSessionStatus
  }

  export type EnumCheckoutPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckoutPaymentMethod | EnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.CheckoutPaymentMethod[] | ListEnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CheckoutPaymentMethod[] | ListEnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCheckoutPaymentMethodNullableFilter<$PrismaModel> | $Enums.CheckoutPaymentMethod | null
  }

  export type PaymentTransactionNullableScalarRelationFilter = {
    is?: PaymentTransactionWhereInput | null
    isNot?: PaymentTransactionWhereInput | null
  }

  export type CheckoutSessionCountOrderByAggregateInput = {
    id?: SortOrder
    resumeToken?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
    offerId?: SortOrder
    slug?: SortOrder
    provider?: SortOrder
    country?: SortOrder
    locale?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    orderId?: SortOrder
    pixOrderId?: SortOrder
    pixExpiresAt?: SortOrder
    paymentTransactionId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    document?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    utmTerm?: SortOrder
    utmContent?: SortOrder
    referrer?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    selectedInstallments?: SortOrder
    selectedBank?: SortOrder
    paymentMethodsAllowed?: SortOrder
    metadata?: SortOrder
    startedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    lastStep?: SortOrder
    reminders?: SortOrder
    reminderExpiringSentAt?: SortOrder
    reminderExpiredSentAt?: SortOrder
    conversionLikelihood?: SortOrder
    origin?: SortOrder
    createdBy?: SortOrder
  }

  export type CheckoutSessionAvgOrderByAggregateInput = {
    selectedInstallments?: SortOrder
    conversionLikelihood?: SortOrder
  }

  export type CheckoutSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    resumeToken?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
    offerId?: SortOrder
    slug?: SortOrder
    provider?: SortOrder
    country?: SortOrder
    locale?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    orderId?: SortOrder
    pixOrderId?: SortOrder
    pixExpiresAt?: SortOrder
    paymentTransactionId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    document?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    utmTerm?: SortOrder
    utmContent?: SortOrder
    referrer?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    selectedInstallments?: SortOrder
    selectedBank?: SortOrder
    startedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    lastStep?: SortOrder
    reminderExpiringSentAt?: SortOrder
    reminderExpiredSentAt?: SortOrder
    conversionLikelihood?: SortOrder
    origin?: SortOrder
    createdBy?: SortOrder
  }

  export type CheckoutSessionMinOrderByAggregateInput = {
    id?: SortOrder
    resumeToken?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
    offerId?: SortOrder
    slug?: SortOrder
    provider?: SortOrder
    country?: SortOrder
    locale?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    orderId?: SortOrder
    pixOrderId?: SortOrder
    pixExpiresAt?: SortOrder
    paymentTransactionId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    document?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    utmTerm?: SortOrder
    utmContent?: SortOrder
    referrer?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    selectedInstallments?: SortOrder
    selectedBank?: SortOrder
    startedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    lastStep?: SortOrder
    reminderExpiringSentAt?: SortOrder
    reminderExpiredSentAt?: SortOrder
    conversionLikelihood?: SortOrder
    origin?: SortOrder
    createdBy?: SortOrder
  }

  export type CheckoutSessionSumOrderByAggregateInput = {
    selectedInstallments?: SortOrder
    conversionLikelihood?: SortOrder
  }

  export type EnumCheckoutSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckoutSessionStatus | EnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CheckoutSessionStatus[] | ListEnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckoutSessionStatus[] | ListEnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckoutSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CheckoutSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCheckoutSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumCheckoutSessionStatusFilter<$PrismaModel>
  }

  export type EnumCheckoutPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckoutPaymentMethod | EnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.CheckoutPaymentMethod[] | ListEnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CheckoutPaymentMethod[] | ListEnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCheckoutPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.CheckoutPaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCheckoutPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumCheckoutPaymentMethodNullableFilter<$PrismaModel>
  }

  export type EnumPaymentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableFilter<$PrismaModel> | $Enums.PaymentStatus | null
  }

  export type CheckoutSessionNullableScalarRelationFilter = {
    is?: CheckoutSessionWhereInput | null
    isNot?: CheckoutSessionWhereInput | null
  }

  export type PaymentTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerOrderId?: SortOrder
    providerChargeId?: SortOrder
    doctorId?: SortOrder
    patientProfileId?: SortOrder
    clinicId?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    installments?: SortOrder
    paymentMethodType?: SortOrder
    status?: SortOrder
    status_v2?: SortOrder
    rawPayload?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
    capturedAt?: SortOrder
    refundStatus?: SortOrder
    refundedAt?: SortOrder
    routedProvider?: SortOrder
    customerId?: SortOrder
    customerProviderId?: SortOrder
    customerPaymentMethodId?: SortOrder
    customerSubscriptionId?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    provider_v2?: SortOrder
  }

  export type PaymentTransactionAvgOrderByAggregateInput = {
    amountCents?: SortOrder
    installments?: SortOrder
  }

  export type PaymentTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerOrderId?: SortOrder
    providerChargeId?: SortOrder
    doctorId?: SortOrder
    patientProfileId?: SortOrder
    clinicId?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    installments?: SortOrder
    paymentMethodType?: SortOrder
    status?: SortOrder
    status_v2?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
    capturedAt?: SortOrder
    refundStatus?: SortOrder
    refundedAt?: SortOrder
    routedProvider?: SortOrder
    customerId?: SortOrder
    customerProviderId?: SortOrder
    customerPaymentMethodId?: SortOrder
    customerSubscriptionId?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    provider_v2?: SortOrder
  }

  export type PaymentTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerOrderId?: SortOrder
    providerChargeId?: SortOrder
    doctorId?: SortOrder
    patientProfileId?: SortOrder
    clinicId?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    installments?: SortOrder
    paymentMethodType?: SortOrder
    status?: SortOrder
    status_v2?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
    capturedAt?: SortOrder
    refundStatus?: SortOrder
    refundedAt?: SortOrder
    routedProvider?: SortOrder
    customerId?: SortOrder
    customerProviderId?: SortOrder
    customerPaymentMethodId?: SortOrder
    customerSubscriptionId?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    provider_v2?: SortOrder
  }

  export type PaymentTransactionSumOrderByAggregateInput = {
    amountCents?: SortOrder
    installments?: SortOrder
  }

  export type EnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    pointsAwarded?: SortOrder
    status?: SortOrder
    externalIdempotencyKey?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    pointsAwarded?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    pointsAwarded?: SortOrder
    status?: SortOrder
    externalIdempotencyKey?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    pointsAwarded?: SortOrder
    status?: SortOrder
    externalIdempotencyKey?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    pointsAwarded?: SortOrder
  }

  export type CustomerProviderListRelationFilter = {
    every?: CustomerProviderWhereInput
    some?: CustomerProviderWhereInput
    none?: CustomerProviderWhereInput
  }

  export type CustomerPaymentMethodListRelationFilter = {
    every?: CustomerPaymentMethodWhereInput
    some?: CustomerPaymentMethodWhereInput
    none?: CustomerPaymentMethodWhereInput
  }

  export type CustomerSubscriptionListRelationFilter = {
    every?: CustomerSubscriptionWhereInput
    some?: CustomerSubscriptionWhereInput
    none?: CustomerSubscriptionWhereInput
  }

  export type CustomerProviderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerPaymentMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerMerchantIdEmailCompoundUniqueInput = {
    merchantId: string
    email: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    document?: SortOrder
    address?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    document?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    document?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CustomerProviderProviderAccountIdProviderCustomerIdCompoundUniqueInput = {
    provider: $Enums.PaymentProvider
    accountId: string
    providerCustomerId: string
  }

  export type CustomerProviderCustomerIdProviderAccountIdCompoundUniqueInput = {
    customerId: string
    provider: $Enums.PaymentProvider
    accountId: string
  }

  export type CustomerProviderCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    provider?: SortOrder
    accountId?: SortOrder
    providerCustomerId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    provider?: SortOrder
    accountId?: SortOrder
    providerCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProviderMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    provider?: SortOrder
    accountId?: SortOrder
    providerCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProviderNullableScalarRelationFilter = {
    is?: CustomerProviderWhereInput | null
    isNot?: CustomerProviderWhereInput | null
  }

  export type CustomerPaymentMethodProviderAccountIdProviderPaymentMethodIdCompoundUniqueInput = {
    provider: $Enums.PaymentProvider
    accountId: string
    providerPaymentMethodId: string
  }

  export type CustomerPaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerProviderId?: SortOrder
    provider?: SortOrder
    accountId?: SortOrder
    providerPaymentMethodId?: SortOrder
    brand?: SortOrder
    last4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    isDefault?: SortOrder
    status?: SortOrder
    fingerprint?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPaymentMethodAvgOrderByAggregateInput = {
    expMonth?: SortOrder
    expYear?: SortOrder
  }

  export type CustomerPaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerProviderId?: SortOrder
    provider?: SortOrder
    accountId?: SortOrder
    providerPaymentMethodId?: SortOrder
    brand?: SortOrder
    last4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    isDefault?: SortOrder
    status?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerProviderId?: SortOrder
    provider?: SortOrder
    accountId?: SortOrder
    providerPaymentMethodId?: SortOrder
    brand?: SortOrder
    last4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    isDefault?: SortOrder
    status?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPaymentMethodSumOrderByAggregateInput = {
    expMonth?: SortOrder
    expYear?: SortOrder
  }

  export type CustomerSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrder
    offerId?: SortOrder
    provider?: SortOrder
    accountId?: SortOrder
    isNative?: SortOrder
    customerProviderId?: SortOrder
    providerSubscriptionId?: SortOrder
    vaultPaymentMethodId?: SortOrder
    status?: SortOrder
    startAt?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAt?: SortOrder
    canceledAt?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSubscriptionAvgOrderByAggregateInput = {
    priceCents?: SortOrder
  }

  export type CustomerSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrder
    offerId?: SortOrder
    provider?: SortOrder
    accountId?: SortOrder
    isNative?: SortOrder
    customerProviderId?: SortOrder
    providerSubscriptionId?: SortOrder
    vaultPaymentMethodId?: SortOrder
    status?: SortOrder
    startAt?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAt?: SortOrder
    canceledAt?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    productId?: SortOrder
    offerId?: SortOrder
    provider?: SortOrder
    accountId?: SortOrder
    isNative?: SortOrder
    customerProviderId?: SortOrder
    providerSubscriptionId?: SortOrder
    vaultPaymentMethodId?: SortOrder
    status?: SortOrder
    startAt?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAt?: SortOrder
    canceledAt?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSubscriptionSumOrderByAggregateInput = {
    priceCents?: SortOrder
  }

  export type PaymentCustomerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    email?: SortOrder
    document?: SortOrder
    fullName?: SortOrder
    phones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentCustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    email?: SortOrder
    document?: SortOrder
    fullName?: SortOrder
    phones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentCustomerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    email?: SortOrder
    document?: SortOrder
    fullName?: SortOrder
    phones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type MessageSequenceStepListRelationFilter = {
    every?: MessageSequenceStepWhereInput
    some?: MessageSequenceStepWhereInput
    none?: MessageSequenceStepWhereInput
  }

  export type MessageSequenceStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageTemplateDoctorIdNameCompoundUniqueInput = {
    doctorId: string
    name: string
  }

  export type MessageTemplateDoctorIdChannelWaTemplateNameWaLanguageCompoundUniqueInput = {
    doctorId: string
    channel: string
    waTemplateName: string
    waLanguage: string
  }

  export type MessageTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    name?: SortOrder
    channel?: SortOrder
    subject?: SortOrder
    html?: SortOrder
    text?: SortOrder
    mjml?: SortOrder
    renderStrategy?: SortOrder
    fromName?: SortOrder
    fromEmail?: SortOrder
    replyTo?: SortOrder
    provider?: SortOrder
    waTemplateName?: SortOrder
    waLanguage?: SortOrder
    waCategory?: SortOrder
    waComponents?: SortOrder
    waStatus?: SortOrder
    waProviderId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variablesSchema?: SortOrder
    sampleVariables?: SortOrder
    tags?: SortOrder
    smsMaxSegments?: SortOrder
  }

  export type MessageTemplateAvgOrderByAggregateInput = {
    smsMaxSegments?: SortOrder
  }

  export type MessageTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    name?: SortOrder
    channel?: SortOrder
    subject?: SortOrder
    html?: SortOrder
    text?: SortOrder
    mjml?: SortOrder
    renderStrategy?: SortOrder
    fromName?: SortOrder
    fromEmail?: SortOrder
    replyTo?: SortOrder
    provider?: SortOrder
    waTemplateName?: SortOrder
    waLanguage?: SortOrder
    waCategory?: SortOrder
    waStatus?: SortOrder
    waProviderId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    smsMaxSegments?: SortOrder
  }

  export type MessageTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    name?: SortOrder
    channel?: SortOrder
    subject?: SortOrder
    html?: SortOrder
    text?: SortOrder
    mjml?: SortOrder
    renderStrategy?: SortOrder
    fromName?: SortOrder
    fromEmail?: SortOrder
    replyTo?: SortOrder
    provider?: SortOrder
    waTemplateName?: SortOrder
    waLanguage?: SortOrder
    waCategory?: SortOrder
    waStatus?: SortOrder
    waProviderId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    smsMaxSegments?: SortOrder
  }

  export type MessageTemplateSumOrderByAggregateInput = {
    smsMaxSegments?: SortOrder
  }

  export type MessageSequenceDoctorIdNameCompoundUniqueInput = {
    doctorId: string
    name: string
  }

  export type MessageSequenceCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageSequenceMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageSequenceMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageSequenceScalarRelationFilter = {
    is?: MessageSequenceWhereInput
    isNot?: MessageSequenceWhereInput
  }

  export type MessageTemplateScalarRelationFilter = {
    is?: MessageTemplateWhereInput
    isNot?: MessageTemplateWhereInput
  }

  export type MessageSequenceStepSequenceIdOrderIndexCompoundUniqueInput = {
    sequenceId: string
    orderIndex: number
  }

  export type MessageSequenceStepCountOrderByAggregateInput = {
    id?: SortOrder
    sequenceId?: SortOrder
    orderIndex?: SortOrder
    delayAmount?: SortOrder
    delayUnit?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageSequenceStepAvgOrderByAggregateInput = {
    orderIndex?: SortOrder
    delayAmount?: SortOrder
  }

  export type MessageSequenceStepMaxOrderByAggregateInput = {
    id?: SortOrder
    sequenceId?: SortOrder
    orderIndex?: SortOrder
    delayAmount?: SortOrder
    delayUnit?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageSequenceStepMinOrderByAggregateInput = {
    id?: SortOrder
    sequenceId?: SortOrder
    orderIndex?: SortOrder
    delayAmount?: SortOrder
    delayUnit?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageSequenceStepSumOrderByAggregateInput = {
    orderIndex?: SortOrder
    delayAmount?: SortOrder
  }

  export type CampaignJobCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    campaignId?: SortOrder
    channel?: SortOrder
    trigger?: SortOrder
    scheduleAt?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    lastError?: SortOrder
  }

  export type CampaignJobMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    campaignId?: SortOrder
    channel?: SortOrder
    trigger?: SortOrder
    scheduleAt?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    lastError?: SortOrder
  }

  export type CampaignJobMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    campaignId?: SortOrder
    channel?: SortOrder
    trigger?: SortOrder
    scheduleAt?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    lastError?: SortOrder
  }

  export type OpenFinanceConsentNullableScalarRelationFilter = {
    is?: OpenFinanceConsentWhereInput | null
    isNot?: OpenFinanceConsentWhereInput | null
  }

  export type OpenFinanceLinkCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    enrollmentId?: SortOrder
    status?: SortOrder
    deviceBinding?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpenFinanceLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    enrollmentId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpenFinanceLinkMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    enrollmentId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpenFinanceLinkScalarRelationFilter = {
    is?: OpenFinanceLinkWhereInput
    isNot?: OpenFinanceLinkWhereInput
  }

  export type OpenFinanceConsentCountOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    consentId?: SortOrder
    contractId?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    periodicity?: SortOrder
    nextExecutionAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpenFinanceConsentAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type OpenFinanceConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    consentId?: SortOrder
    contractId?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    periodicity?: SortOrder
    nextExecutionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpenFinanceConsentMinOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    consentId?: SortOrder
    contractId?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    periodicity?: SortOrder
    nextExecutionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpenFinanceConsentSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type EnumPaymentStatusOBNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusOB | EnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatusOB[] | ListEnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatusOB[] | ListEnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusOBNullableFilter<$PrismaModel> | $Enums.PaymentStatusOB | null
  }

  export type EnumPaymentTypeOBNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentTypeOB | EnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentTypeOB[] | ListEnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentTypeOB[] | ListEnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentTypeOBNullableFilter<$PrismaModel> | $Enums.PaymentTypeOB | null
  }

  export type OpenBankingPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    providerPaymentId?: SortOrder
    consentId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enrollmentId?: SortOrder
    transactionIdentification?: SortOrder
    payerId?: SortOrder
    payerDocument?: SortOrder
    payerEmail?: SortOrder
    payerName?: SortOrder
    creditorName?: SortOrder
    creditorCpfCnpj?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
    purchaseId?: SortOrder
    type?: SortOrder
    executedAt?: SortOrder
    settledAt?: SortOrder
    recurrenceType?: SortOrder
    subscriptionId?: SortOrder
    executionOrder?: SortOrder
    providerResponse?: SortOrder
    fidoAssertion?: SortOrder
    riskSignals?: SortOrder
    paymentLinkId?: SortOrder
    userId?: SortOrder
    orderRef?: SortOrder
    redirectUri?: SortOrder
    transactionId?: SortOrder
    expiresAt?: SortOrder
    metadata?: SortOrder
  }

  export type OpenBankingPaymentAvgOrderByAggregateInput = {
    amountCents?: SortOrder
    executionOrder?: SortOrder
  }

  export type OpenBankingPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    providerPaymentId?: SortOrder
    consentId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enrollmentId?: SortOrder
    transactionIdentification?: SortOrder
    payerId?: SortOrder
    payerDocument?: SortOrder
    payerEmail?: SortOrder
    payerName?: SortOrder
    creditorName?: SortOrder
    creditorCpfCnpj?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
    purchaseId?: SortOrder
    type?: SortOrder
    executedAt?: SortOrder
    settledAt?: SortOrder
    recurrenceType?: SortOrder
    subscriptionId?: SortOrder
    executionOrder?: SortOrder
    paymentLinkId?: SortOrder
    userId?: SortOrder
    orderRef?: SortOrder
    redirectUri?: SortOrder
    transactionId?: SortOrder
    expiresAt?: SortOrder
  }

  export type OpenBankingPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    providerPaymentId?: SortOrder
    consentId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enrollmentId?: SortOrder
    transactionIdentification?: SortOrder
    payerId?: SortOrder
    payerDocument?: SortOrder
    payerEmail?: SortOrder
    payerName?: SortOrder
    creditorName?: SortOrder
    creditorCpfCnpj?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
    purchaseId?: SortOrder
    type?: SortOrder
    executedAt?: SortOrder
    settledAt?: SortOrder
    recurrenceType?: SortOrder
    subscriptionId?: SortOrder
    executionOrder?: SortOrder
    paymentLinkId?: SortOrder
    userId?: SortOrder
    orderRef?: SortOrder
    redirectUri?: SortOrder
    transactionId?: SortOrder
    expiresAt?: SortOrder
  }

  export type OpenBankingPaymentSumOrderByAggregateInput = {
    amountCents?: SortOrder
    executionOrder?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumPaymentStatusOBNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusOB | EnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatusOB[] | ListEnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatusOB[] | ListEnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusOBNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatusOB | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusOBNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusOBNullableFilter<$PrismaModel>
  }

  export type EnumPaymentTypeOBNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentTypeOB | EnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentTypeOB[] | ListEnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentTypeOB[] | ListEnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentTypeOBNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentTypeOB | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeOBNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeOBNullableFilter<$PrismaModel>
  }

  export type EnumConsentStatusOBNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatusOB | EnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConsentStatusOB[] | ListEnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConsentStatusOB[] | ListEnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConsentStatusOBNullableFilter<$PrismaModel> | $Enums.ConsentStatusOB | null
  }

  export type OpenBankingConsentCountOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    consentId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    creditorName?: SortOrder
    creditorCpfCnpj?: SortOrder
    productId?: SortOrder
    clinicId?: SortOrder
    status?: SortOrder
    providerResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpenBankingConsentAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type OpenBankingConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    consentId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    creditorName?: SortOrder
    creditorCpfCnpj?: SortOrder
    productId?: SortOrder
    clinicId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpenBankingConsentMinOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    consentId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    creditorName?: SortOrder
    creditorCpfCnpj?: SortOrder
    productId?: SortOrder
    clinicId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpenBankingConsentSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type EnumConsentStatusOBNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatusOB | EnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConsentStatusOB[] | ListEnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConsentStatusOB[] | ListEnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConsentStatusOBNullableWithAggregatesFilter<$PrismaModel> | $Enums.ConsentStatusOB | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumConsentStatusOBNullableFilter<$PrismaModel>
    _max?: NestedEnumConsentStatusOBNullableFilter<$PrismaModel>
  }

  export type EnumEnrollmentStatusOBNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatusOB | EnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnrollmentStatusOB[] | ListEnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnrollmentStatusOB[] | ListEnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnrollmentStatusOBNullableFilter<$PrismaModel> | $Enums.EnrollmentStatusOB | null
  }

  export type EnrollmentContextUserIdOrganisationIdCompoundUniqueInput = {
    userId: string
    organisationId: string
  }

  export type EnrollmentContextCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    enrollmentId?: SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    fallbackUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    deviceRegistered?: SortOrder
    expiresAt?: SortOrder
    clinicId?: SortOrder
    payerEmail?: SortOrder
    payerDocument?: SortOrder
    payerName?: SortOrder
    recurringEnabled?: SortOrder
    deviceBinding?: SortOrder
    providerResponse?: SortOrder
  }

  export type EnrollmentContextMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    enrollmentId?: SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    fallbackUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    deviceRegistered?: SortOrder
    expiresAt?: SortOrder
    clinicId?: SortOrder
    payerEmail?: SortOrder
    payerDocument?: SortOrder
    payerName?: SortOrder
    recurringEnabled?: SortOrder
  }

  export type EnrollmentContextMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    enrollmentId?: SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    fallbackUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    deviceRegistered?: SortOrder
    expiresAt?: SortOrder
    clinicId?: SortOrder
    payerEmail?: SortOrder
    payerDocument?: SortOrder
    payerName?: SortOrder
    recurringEnabled?: SortOrder
  }

  export type EnumEnrollmentStatusOBNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatusOB | EnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnrollmentStatusOB[] | ListEnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnrollmentStatusOB[] | ListEnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnrollmentStatusOBNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnrollmentStatusOB | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnrollmentStatusOBNullableFilter<$PrismaModel>
    _max?: NestedEnumEnrollmentStatusOBNullableFilter<$PrismaModel>
  }

  export type PaymentConsentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    consentId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    consentId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentConsentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    consentId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthStateCountOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    nonce?: SortOrder
    codeVerifier?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrder
  }

  export type OAuthStateMaxOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    nonce?: SortOrder
    codeVerifier?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrder
  }

  export type OAuthStateMinOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    nonce?: SortOrder
    codeVerifier?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrder
  }

  export type OAuthStateMetaCountOrderByAggregateInput = {
    state?: SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    orderRef?: SortOrder
  }

  export type OAuthStateMetaAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type OAuthStateMetaMaxOrderByAggregateInput = {
    state?: SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    orderRef?: SortOrder
  }

  export type OAuthStateMetaMinOrderByAggregateInput = {
    state?: SortOrder
    organisationId?: SortOrder
    authorisationServerId?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    orderRef?: SortOrder
  }

  export type OAuthStateMetaSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type OAuthTokenCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthTokenMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type EnumEventActorFilter<$PrismaModel = never> = {
    equals?: $Enums.EventActor | EnumEventActorFieldRefInput<$PrismaModel>
    in?: $Enums.EventActor[] | ListEnumEventActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventActor[] | ListEnumEventActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEventActorFilter<$PrismaModel> | $Enums.EventActor
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    customerId?: SortOrder
    clinicId?: SortOrder
    actor?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    customerId?: SortOrder
    clinicId?: SortOrder
    actor?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    customerId?: SortOrder
    clinicId?: SortOrder
    actor?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type EnumEventActorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventActor | EnumEventActorFieldRefInput<$PrismaModel>
    in?: $Enums.EventActor[] | ListEnumEventActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventActor[] | ListEnumEventActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEventActorWithAggregatesFilter<$PrismaModel> | $Enums.EventActor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventActorFilter<$PrismaModel>
    _max?: NestedEnumEventActorFilter<$PrismaModel>
  }

  export type WebhookEventProviderHook_idCompoundUniqueInput = {
    provider: string
    hook_id: string
  }

  export type WebhookEventProviderProvider_event_idCompoundUniqueInput = {
    provider: string
    provider_event_id: string
  }

  export type WebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    hook_id?: SortOrder
    type?: SortOrder
    resource_order_id?: SortOrder
    resource_charge_id?: SortOrder
    status?: SortOrder
    received_at?: SortOrder
    processed_at?: SortOrder
    attempts?: SortOrder
    raw?: SortOrder
    provider_event_id?: SortOrder
    processed?: SortOrder
    processing_error?: SortOrder
    retry_count?: SortOrder
    max_retries?: SortOrder
    next_retry_at?: SortOrder
    last_retry_at?: SortOrder
    error_type?: SortOrder
    is_retryable?: SortOrder
    moved_dead_letter?: SortOrder
    dead_letter_reason?: SortOrder
  }

  export type WebhookEventAvgOrderByAggregateInput = {
    attempts?: SortOrder
    retry_count?: SortOrder
    max_retries?: SortOrder
  }

  export type WebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    hook_id?: SortOrder
    type?: SortOrder
    resource_order_id?: SortOrder
    resource_charge_id?: SortOrder
    status?: SortOrder
    received_at?: SortOrder
    processed_at?: SortOrder
    attempts?: SortOrder
    provider_event_id?: SortOrder
    processed?: SortOrder
    processing_error?: SortOrder
    retry_count?: SortOrder
    max_retries?: SortOrder
    next_retry_at?: SortOrder
    last_retry_at?: SortOrder
    error_type?: SortOrder
    is_retryable?: SortOrder
    moved_dead_letter?: SortOrder
    dead_letter_reason?: SortOrder
  }

  export type WebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    hook_id?: SortOrder
    type?: SortOrder
    resource_order_id?: SortOrder
    resource_charge_id?: SortOrder
    status?: SortOrder
    received_at?: SortOrder
    processed_at?: SortOrder
    attempts?: SortOrder
    provider_event_id?: SortOrder
    processed?: SortOrder
    processing_error?: SortOrder
    retry_count?: SortOrder
    max_retries?: SortOrder
    next_retry_at?: SortOrder
    last_retry_at?: SortOrder
    error_type?: SortOrder
    is_retryable?: SortOrder
    moved_dead_letter?: SortOrder
    dead_letter_reason?: SortOrder
  }

  export type WebhookEventSumOrderByAggregateInput = {
    attempts?: SortOrder
    retry_count?: SortOrder
    max_retries?: SortOrder
  }

  export type OutboundWebhookDeliveryListRelationFilter = {
    every?: OutboundWebhookDeliveryWhereInput
    some?: OutboundWebhookDeliveryWhereInput
    none?: OutboundWebhookDeliveryWhereInput
  }

  export type OutboundWebhookDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookEndpointCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    enabled?: SortOrder
    maxConcurrentDeliveries?: SortOrder
    categoryFilter?: SortOrder
    statusFilters?: SortOrder
    productFilters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookEndpointAvgOrderByAggregateInput = {
    maxConcurrentDeliveries?: SortOrder
  }

  export type WebhookEndpointMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    enabled?: SortOrder
    maxConcurrentDeliveries?: SortOrder
    categoryFilter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookEndpointMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    enabled?: SortOrder
    maxConcurrentDeliveries?: SortOrder
    categoryFilter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookEndpointSumOrderByAggregateInput = {
    maxConcurrentDeliveries?: SortOrder
  }

  export type OutboundWebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
  }

  export type OutboundWebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
  }

  export type OutboundWebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookEndpointScalarRelationFilter = {
    is?: WebhookEndpointWhereInput
    isNot?: WebhookEndpointWhereInput
  }

  export type OutboundWebhookEventScalarRelationFilter = {
    is?: OutboundWebhookEventWhereInput
    isNot?: OutboundWebhookEventWhereInput
  }

  export type OutboundWebhookDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    endpointId?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastCode?: SortOrder
    lastError?: SortOrder
    nextAttemptAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboundWebhookDeliveryAvgOrderByAggregateInput = {
    attempts?: SortOrder
    lastCode?: SortOrder
  }

  export type OutboundWebhookDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    endpointId?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastCode?: SortOrder
    lastError?: SortOrder
    nextAttemptAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboundWebhookDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    endpointId?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastCode?: SortOrder
    lastError?: SortOrder
    nextAttemptAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboundWebhookDeliverySumOrderByAggregateInput = {
    attempts?: SortOrder
    lastCode?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOther_usersInput = {
    create?: XOR<UserCreateWithoutOther_usersInput, UserUncheckedCreateWithoutOther_usersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOther_usersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput> | UserCreateWithoutUserInput[] | UserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserInput | UserCreateOrConnectWithoutUserInput[]
    createMany?: UserCreateManyUserInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClinicMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ClinicMemberCreateWithoutUserInput, ClinicMemberUncheckedCreateWithoutUserInput> | ClinicMemberCreateWithoutUserInput[] | ClinicMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicMemberCreateOrConnectWithoutUserInput | ClinicMemberCreateOrConnectWithoutUserInput[]
    createMany?: ClinicMemberCreateManyUserInputEnvelope
    connect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
  }

  export type ClinicCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ClinicCreateWithoutOwnerInput, ClinicUncheckedCreateWithoutOwnerInput> | ClinicCreateWithoutOwnerInput[] | ClinicUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClinicCreateOrConnectWithoutOwnerInput | ClinicCreateOrConnectWithoutOwnerInput[]
    createMany?: ClinicCreateManyOwnerInputEnvelope
    connect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ProductCreateWithoutDoctorInput, ProductUncheckedCreateWithoutDoctorInput> | ProductCreateWithoutDoctorInput[] | ProductUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDoctorInput | ProductCreateOrConnectWithoutDoctorInput[]
    createMany?: ProductCreateManyDoctorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ProductCategoryCreateWithoutDoctorInput, ProductCategoryUncheckedCreateWithoutDoctorInput> | ProductCategoryCreateWithoutDoctorInput[] | ProductCategoryUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutDoctorInput | ProductCategoryCreateOrConnectWithoutDoctorInput[]
    createMany?: ProductCategoryCreateManyDoctorInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type VerificationCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput> | VerificationCodeCreateWithoutUserInput[] | VerificationCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput | VerificationCodeCreateOrConnectWithoutUserInput[]
    createMany?: VerificationCodeCreateManyUserInputEnvelope
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
  }

  export type VerificationCodeCreateNestedManyWithoutDoctorInput = {
    create?: XOR<VerificationCodeCreateWithoutDoctorInput, VerificationCodeUncheckedCreateWithoutDoctorInput> | VerificationCodeCreateWithoutDoctorInput[] | VerificationCodeUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutDoctorInput | VerificationCodeCreateOrConnectWithoutDoctorInput[]
    createMany?: VerificationCodeCreateManyDoctorInputEnvelope
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PurchaseCreateWithoutDoctorInput, PurchaseUncheckedCreateWithoutDoctorInput> | PurchaseCreateWithoutDoctorInput[] | PurchaseUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutDoctorInput | PurchaseCreateOrConnectWithoutDoctorInput[]
    createMany?: PurchaseCreateManyDoctorInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PointsLedgerCreateNestedManyWithoutUserInput = {
    create?: XOR<PointsLedgerCreateWithoutUserInput, PointsLedgerUncheckedCreateWithoutUserInput> | PointsLedgerCreateWithoutUserInput[] | PointsLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsLedgerCreateOrConnectWithoutUserInput | PointsLedgerCreateOrConnectWithoutUserInput[]
    createMany?: PointsLedgerCreateManyUserInputEnvelope
    connect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
  }

  export type PatientProfileCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PatientProfileCreateWithoutDoctorInput, PatientProfileUncheckedCreateWithoutDoctorInput> | PatientProfileCreateWithoutDoctorInput[] | PatientProfileUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PatientProfileCreateOrConnectWithoutDoctorInput | PatientProfileCreateOrConnectWithoutDoctorInput[]
    createMany?: PatientProfileCreateManyDoctorInputEnvelope
    connect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
  }

  export type PatientProfileCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientProfileCreateWithoutPatientInput, PatientProfileUncheckedCreateWithoutPatientInput> | PatientProfileCreateWithoutPatientInput[] | PatientProfileUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientProfileCreateOrConnectWithoutPatientInput | PatientProfileCreateOrConnectWithoutPatientInput[]
    createMany?: PatientProfileCreateManyPatientInputEnvelope
    connect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
  }

  export type MessageTemplateCreateNestedManyWithoutDoctorInput = {
    create?: XOR<MessageTemplateCreateWithoutDoctorInput, MessageTemplateUncheckedCreateWithoutDoctorInput> | MessageTemplateCreateWithoutDoctorInput[] | MessageTemplateUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutDoctorInput | MessageTemplateCreateOrConnectWithoutDoctorInput[]
    createMany?: MessageTemplateCreateManyDoctorInputEnvelope
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
  }

  export type MessageSequenceCreateNestedManyWithoutDoctorInput = {
    create?: XOR<MessageSequenceCreateWithoutDoctorInput, MessageSequenceUncheckedCreateWithoutDoctorInput> | MessageSequenceCreateWithoutDoctorInput[] | MessageSequenceUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MessageSequenceCreateOrConnectWithoutDoctorInput | MessageSequenceCreateOrConnectWithoutDoctorInput[]
    createMany?: MessageSequenceCreateManyDoctorInputEnvelope
    connect?: MessageSequenceWhereUniqueInput | MessageSequenceWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput> | UserCreateWithoutUserInput[] | UserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserInput | UserCreateOrConnectWithoutUserInput[]
    createMany?: UserCreateManyUserInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClinicMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClinicMemberCreateWithoutUserInput, ClinicMemberUncheckedCreateWithoutUserInput> | ClinicMemberCreateWithoutUserInput[] | ClinicMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicMemberCreateOrConnectWithoutUserInput | ClinicMemberCreateOrConnectWithoutUserInput[]
    createMany?: ClinicMemberCreateManyUserInputEnvelope
    connect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
  }

  export type ClinicUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ClinicCreateWithoutOwnerInput, ClinicUncheckedCreateWithoutOwnerInput> | ClinicCreateWithoutOwnerInput[] | ClinicUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClinicCreateOrConnectWithoutOwnerInput | ClinicCreateOrConnectWithoutOwnerInput[]
    createMany?: ClinicCreateManyOwnerInputEnvelope
    connect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ProductCreateWithoutDoctorInput, ProductUncheckedCreateWithoutDoctorInput> | ProductCreateWithoutDoctorInput[] | ProductUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDoctorInput | ProductCreateOrConnectWithoutDoctorInput[]
    createMany?: ProductCreateManyDoctorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ProductCategoryCreateWithoutDoctorInput, ProductCategoryUncheckedCreateWithoutDoctorInput> | ProductCategoryCreateWithoutDoctorInput[] | ProductCategoryUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutDoctorInput | ProductCategoryCreateOrConnectWithoutDoctorInput[]
    createMany?: ProductCategoryCreateManyDoctorInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type VerificationCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput> | VerificationCodeCreateWithoutUserInput[] | VerificationCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput | VerificationCodeCreateOrConnectWithoutUserInput[]
    createMany?: VerificationCodeCreateManyUserInputEnvelope
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
  }

  export type VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<VerificationCodeCreateWithoutDoctorInput, VerificationCodeUncheckedCreateWithoutDoctorInput> | VerificationCodeCreateWithoutDoctorInput[] | VerificationCodeUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutDoctorInput | VerificationCodeCreateOrConnectWithoutDoctorInput[]
    createMany?: VerificationCodeCreateManyDoctorInputEnvelope
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PurchaseCreateWithoutDoctorInput, PurchaseUncheckedCreateWithoutDoctorInput> | PurchaseCreateWithoutDoctorInput[] | PurchaseUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutDoctorInput | PurchaseCreateOrConnectWithoutDoctorInput[]
    createMany?: PurchaseCreateManyDoctorInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PointsLedgerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PointsLedgerCreateWithoutUserInput, PointsLedgerUncheckedCreateWithoutUserInput> | PointsLedgerCreateWithoutUserInput[] | PointsLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsLedgerCreateOrConnectWithoutUserInput | PointsLedgerCreateOrConnectWithoutUserInput[]
    createMany?: PointsLedgerCreateManyUserInputEnvelope
    connect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
  }

  export type PatientProfileUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PatientProfileCreateWithoutDoctorInput, PatientProfileUncheckedCreateWithoutDoctorInput> | PatientProfileCreateWithoutDoctorInput[] | PatientProfileUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PatientProfileCreateOrConnectWithoutDoctorInput | PatientProfileCreateOrConnectWithoutDoctorInput[]
    createMany?: PatientProfileCreateManyDoctorInputEnvelope
    connect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
  }

  export type PatientProfileUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientProfileCreateWithoutPatientInput, PatientProfileUncheckedCreateWithoutPatientInput> | PatientProfileCreateWithoutPatientInput[] | PatientProfileUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientProfileCreateOrConnectWithoutPatientInput | PatientProfileCreateOrConnectWithoutPatientInput[]
    createMany?: PatientProfileCreateManyPatientInputEnvelope
    connect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
  }

  export type MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<MessageTemplateCreateWithoutDoctorInput, MessageTemplateUncheckedCreateWithoutDoctorInput> | MessageTemplateCreateWithoutDoctorInput[] | MessageTemplateUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutDoctorInput | MessageTemplateCreateOrConnectWithoutDoctorInput[]
    createMany?: MessageTemplateCreateManyDoctorInputEnvelope
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
  }

  export type MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<MessageSequenceCreateWithoutDoctorInput, MessageSequenceUncheckedCreateWithoutDoctorInput> | MessageSequenceCreateWithoutDoctorInput[] | MessageSequenceUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MessageSequenceCreateOrConnectWithoutDoctorInput | MessageSequenceCreateOrConnectWithoutDoctorInput[]
    createMany?: MessageSequenceCreateManyDoctorInputEnvelope
    connect?: MessageSequenceWhereUniqueInput | MessageSequenceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserUpdateOneWithoutOther_usersNestedInput = {
    create?: XOR<UserCreateWithoutOther_usersInput, UserUncheckedCreateWithoutOther_usersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOther_usersInput
    upsert?: UserUpsertWithoutOther_usersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOther_usersInput, UserUpdateWithoutOther_usersInput>, UserUncheckedUpdateWithoutOther_usersInput>
  }

  export type UserUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput> | UserCreateWithoutUserInput[] | UserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserInput | UserCreateOrConnectWithoutUserInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUserInput | UserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCreateManyUserInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUserInput | UserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUserInput | UserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClinicMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClinicMemberCreateWithoutUserInput, ClinicMemberUncheckedCreateWithoutUserInput> | ClinicMemberCreateWithoutUserInput[] | ClinicMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicMemberCreateOrConnectWithoutUserInput | ClinicMemberCreateOrConnectWithoutUserInput[]
    upsert?: ClinicMemberUpsertWithWhereUniqueWithoutUserInput | ClinicMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClinicMemberCreateManyUserInputEnvelope
    set?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    disconnect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    delete?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    connect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    update?: ClinicMemberUpdateWithWhereUniqueWithoutUserInput | ClinicMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClinicMemberUpdateManyWithWhereWithoutUserInput | ClinicMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClinicMemberScalarWhereInput | ClinicMemberScalarWhereInput[]
  }

  export type ClinicUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ClinicCreateWithoutOwnerInput, ClinicUncheckedCreateWithoutOwnerInput> | ClinicCreateWithoutOwnerInput[] | ClinicUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClinicCreateOrConnectWithoutOwnerInput | ClinicCreateOrConnectWithoutOwnerInput[]
    upsert?: ClinicUpsertWithWhereUniqueWithoutOwnerInput | ClinicUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ClinicCreateManyOwnerInputEnvelope
    set?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    disconnect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    delete?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    connect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    update?: ClinicUpdateWithWhereUniqueWithoutOwnerInput | ClinicUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ClinicUpdateManyWithWhereWithoutOwnerInput | ClinicUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ClinicScalarWhereInput | ClinicScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ProductCreateWithoutDoctorInput, ProductUncheckedCreateWithoutDoctorInput> | ProductCreateWithoutDoctorInput[] | ProductUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDoctorInput | ProductCreateOrConnectWithoutDoctorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutDoctorInput | ProductUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ProductCreateManyDoctorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutDoctorInput | ProductUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutDoctorInput | ProductUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutDoctorInput, ProductCategoryUncheckedCreateWithoutDoctorInput> | ProductCategoryCreateWithoutDoctorInput[] | ProductCategoryUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutDoctorInput | ProductCategoryCreateOrConnectWithoutDoctorInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutDoctorInput | ProductCategoryUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ProductCategoryCreateManyDoctorInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutDoctorInput | ProductCategoryUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutDoctorInput | ProductCategoryUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type VerificationCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput> | VerificationCodeCreateWithoutUserInput[] | VerificationCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput | VerificationCodeCreateOrConnectWithoutUserInput[]
    upsert?: VerificationCodeUpsertWithWhereUniqueWithoutUserInput | VerificationCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationCodeCreateManyUserInputEnvelope
    set?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    disconnect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    delete?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    update?: VerificationCodeUpdateWithWhereUniqueWithoutUserInput | VerificationCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationCodeUpdateManyWithWhereWithoutUserInput | VerificationCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationCodeScalarWhereInput | VerificationCodeScalarWhereInput[]
  }

  export type VerificationCodeUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<VerificationCodeCreateWithoutDoctorInput, VerificationCodeUncheckedCreateWithoutDoctorInput> | VerificationCodeCreateWithoutDoctorInput[] | VerificationCodeUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutDoctorInput | VerificationCodeCreateOrConnectWithoutDoctorInput[]
    upsert?: VerificationCodeUpsertWithWhereUniqueWithoutDoctorInput | VerificationCodeUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: VerificationCodeCreateManyDoctorInputEnvelope
    set?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    disconnect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    delete?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    update?: VerificationCodeUpdateWithWhereUniqueWithoutDoctorInput | VerificationCodeUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: VerificationCodeUpdateManyWithWhereWithoutDoctorInput | VerificationCodeUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: VerificationCodeScalarWhereInput | VerificationCodeScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutUserInput | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutUserInput | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutUserInput | PurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PurchaseCreateWithoutDoctorInput, PurchaseUncheckedCreateWithoutDoctorInput> | PurchaseCreateWithoutDoctorInput[] | PurchaseUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutDoctorInput | PurchaseCreateOrConnectWithoutDoctorInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutDoctorInput | PurchaseUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PurchaseCreateManyDoctorInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutDoctorInput | PurchaseUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutDoctorInput | PurchaseUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PointsLedgerUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointsLedgerCreateWithoutUserInput, PointsLedgerUncheckedCreateWithoutUserInput> | PointsLedgerCreateWithoutUserInput[] | PointsLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsLedgerCreateOrConnectWithoutUserInput | PointsLedgerCreateOrConnectWithoutUserInput[]
    upsert?: PointsLedgerUpsertWithWhereUniqueWithoutUserInput | PointsLedgerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointsLedgerCreateManyUserInputEnvelope
    set?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    disconnect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    delete?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    connect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    update?: PointsLedgerUpdateWithWhereUniqueWithoutUserInput | PointsLedgerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointsLedgerUpdateManyWithWhereWithoutUserInput | PointsLedgerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointsLedgerScalarWhereInput | PointsLedgerScalarWhereInput[]
  }

  export type PatientProfileUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PatientProfileCreateWithoutDoctorInput, PatientProfileUncheckedCreateWithoutDoctorInput> | PatientProfileCreateWithoutDoctorInput[] | PatientProfileUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PatientProfileCreateOrConnectWithoutDoctorInput | PatientProfileCreateOrConnectWithoutDoctorInput[]
    upsert?: PatientProfileUpsertWithWhereUniqueWithoutDoctorInput | PatientProfileUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PatientProfileCreateManyDoctorInputEnvelope
    set?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    disconnect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    delete?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    connect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    update?: PatientProfileUpdateWithWhereUniqueWithoutDoctorInput | PatientProfileUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PatientProfileUpdateManyWithWhereWithoutDoctorInput | PatientProfileUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PatientProfileScalarWhereInput | PatientProfileScalarWhereInput[]
  }

  export type PatientProfileUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientProfileCreateWithoutPatientInput, PatientProfileUncheckedCreateWithoutPatientInput> | PatientProfileCreateWithoutPatientInput[] | PatientProfileUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientProfileCreateOrConnectWithoutPatientInput | PatientProfileCreateOrConnectWithoutPatientInput[]
    upsert?: PatientProfileUpsertWithWhereUniqueWithoutPatientInput | PatientProfileUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientProfileCreateManyPatientInputEnvelope
    set?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    disconnect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    delete?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    connect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    update?: PatientProfileUpdateWithWhereUniqueWithoutPatientInput | PatientProfileUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientProfileUpdateManyWithWhereWithoutPatientInput | PatientProfileUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientProfileScalarWhereInput | PatientProfileScalarWhereInput[]
  }

  export type MessageTemplateUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutDoctorInput, MessageTemplateUncheckedCreateWithoutDoctorInput> | MessageTemplateCreateWithoutDoctorInput[] | MessageTemplateUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutDoctorInput | MessageTemplateCreateOrConnectWithoutDoctorInput[]
    upsert?: MessageTemplateUpsertWithWhereUniqueWithoutDoctorInput | MessageTemplateUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: MessageTemplateCreateManyDoctorInputEnvelope
    set?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    disconnect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    delete?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    update?: MessageTemplateUpdateWithWhereUniqueWithoutDoctorInput | MessageTemplateUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: MessageTemplateUpdateManyWithWhereWithoutDoctorInput | MessageTemplateUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
  }

  export type MessageSequenceUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<MessageSequenceCreateWithoutDoctorInput, MessageSequenceUncheckedCreateWithoutDoctorInput> | MessageSequenceCreateWithoutDoctorInput[] | MessageSequenceUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MessageSequenceCreateOrConnectWithoutDoctorInput | MessageSequenceCreateOrConnectWithoutDoctorInput[]
    upsert?: MessageSequenceUpsertWithWhereUniqueWithoutDoctorInput | MessageSequenceUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: MessageSequenceCreateManyDoctorInputEnvelope
    set?: MessageSequenceWhereUniqueInput | MessageSequenceWhereUniqueInput[]
    disconnect?: MessageSequenceWhereUniqueInput | MessageSequenceWhereUniqueInput[]
    delete?: MessageSequenceWhereUniqueInput | MessageSequenceWhereUniqueInput[]
    connect?: MessageSequenceWhereUniqueInput | MessageSequenceWhereUniqueInput[]
    update?: MessageSequenceUpdateWithWhereUniqueWithoutDoctorInput | MessageSequenceUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: MessageSequenceUpdateManyWithWhereWithoutDoctorInput | MessageSequenceUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: MessageSequenceScalarWhereInput | MessageSequenceScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput> | UserCreateWithoutUserInput[] | UserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserInput | UserCreateOrConnectWithoutUserInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUserInput | UserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCreateManyUserInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUserInput | UserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUserInput | UserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClinicMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClinicMemberCreateWithoutUserInput, ClinicMemberUncheckedCreateWithoutUserInput> | ClinicMemberCreateWithoutUserInput[] | ClinicMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicMemberCreateOrConnectWithoutUserInput | ClinicMemberCreateOrConnectWithoutUserInput[]
    upsert?: ClinicMemberUpsertWithWhereUniqueWithoutUserInput | ClinicMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClinicMemberCreateManyUserInputEnvelope
    set?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    disconnect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    delete?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    connect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    update?: ClinicMemberUpdateWithWhereUniqueWithoutUserInput | ClinicMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClinicMemberUpdateManyWithWhereWithoutUserInput | ClinicMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClinicMemberScalarWhereInput | ClinicMemberScalarWhereInput[]
  }

  export type ClinicUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ClinicCreateWithoutOwnerInput, ClinicUncheckedCreateWithoutOwnerInput> | ClinicCreateWithoutOwnerInput[] | ClinicUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClinicCreateOrConnectWithoutOwnerInput | ClinicCreateOrConnectWithoutOwnerInput[]
    upsert?: ClinicUpsertWithWhereUniqueWithoutOwnerInput | ClinicUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ClinicCreateManyOwnerInputEnvelope
    set?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    disconnect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    delete?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    connect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    update?: ClinicUpdateWithWhereUniqueWithoutOwnerInput | ClinicUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ClinicUpdateManyWithWhereWithoutOwnerInput | ClinicUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ClinicScalarWhereInput | ClinicScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ProductCreateWithoutDoctorInput, ProductUncheckedCreateWithoutDoctorInput> | ProductCreateWithoutDoctorInput[] | ProductUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDoctorInput | ProductCreateOrConnectWithoutDoctorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutDoctorInput | ProductUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ProductCreateManyDoctorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutDoctorInput | ProductUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutDoctorInput | ProductUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutDoctorInput, ProductCategoryUncheckedCreateWithoutDoctorInput> | ProductCategoryCreateWithoutDoctorInput[] | ProductCategoryUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutDoctorInput | ProductCategoryCreateOrConnectWithoutDoctorInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutDoctorInput | ProductCategoryUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ProductCategoryCreateManyDoctorInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutDoctorInput | ProductCategoryUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutDoctorInput | ProductCategoryUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type VerificationCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput> | VerificationCodeCreateWithoutUserInput[] | VerificationCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput | VerificationCodeCreateOrConnectWithoutUserInput[]
    upsert?: VerificationCodeUpsertWithWhereUniqueWithoutUserInput | VerificationCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationCodeCreateManyUserInputEnvelope
    set?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    disconnect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    delete?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    update?: VerificationCodeUpdateWithWhereUniqueWithoutUserInput | VerificationCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationCodeUpdateManyWithWhereWithoutUserInput | VerificationCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationCodeScalarWhereInput | VerificationCodeScalarWhereInput[]
  }

  export type VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<VerificationCodeCreateWithoutDoctorInput, VerificationCodeUncheckedCreateWithoutDoctorInput> | VerificationCodeCreateWithoutDoctorInput[] | VerificationCodeUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutDoctorInput | VerificationCodeCreateOrConnectWithoutDoctorInput[]
    upsert?: VerificationCodeUpsertWithWhereUniqueWithoutDoctorInput | VerificationCodeUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: VerificationCodeCreateManyDoctorInputEnvelope
    set?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    disconnect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    delete?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    update?: VerificationCodeUpdateWithWhereUniqueWithoutDoctorInput | VerificationCodeUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: VerificationCodeUpdateManyWithWhereWithoutDoctorInput | VerificationCodeUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: VerificationCodeScalarWhereInput | VerificationCodeScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutUserInput | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutUserInput | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutUserInput | PurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PurchaseCreateWithoutDoctorInput, PurchaseUncheckedCreateWithoutDoctorInput> | PurchaseCreateWithoutDoctorInput[] | PurchaseUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutDoctorInput | PurchaseCreateOrConnectWithoutDoctorInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutDoctorInput | PurchaseUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PurchaseCreateManyDoctorInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutDoctorInput | PurchaseUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutDoctorInput | PurchaseUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PointsLedgerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointsLedgerCreateWithoutUserInput, PointsLedgerUncheckedCreateWithoutUserInput> | PointsLedgerCreateWithoutUserInput[] | PointsLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsLedgerCreateOrConnectWithoutUserInput | PointsLedgerCreateOrConnectWithoutUserInput[]
    upsert?: PointsLedgerUpsertWithWhereUniqueWithoutUserInput | PointsLedgerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointsLedgerCreateManyUserInputEnvelope
    set?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    disconnect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    delete?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    connect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    update?: PointsLedgerUpdateWithWhereUniqueWithoutUserInput | PointsLedgerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointsLedgerUpdateManyWithWhereWithoutUserInput | PointsLedgerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointsLedgerScalarWhereInput | PointsLedgerScalarWhereInput[]
  }

  export type PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PatientProfileCreateWithoutDoctorInput, PatientProfileUncheckedCreateWithoutDoctorInput> | PatientProfileCreateWithoutDoctorInput[] | PatientProfileUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PatientProfileCreateOrConnectWithoutDoctorInput | PatientProfileCreateOrConnectWithoutDoctorInput[]
    upsert?: PatientProfileUpsertWithWhereUniqueWithoutDoctorInput | PatientProfileUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PatientProfileCreateManyDoctorInputEnvelope
    set?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    disconnect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    delete?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    connect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    update?: PatientProfileUpdateWithWhereUniqueWithoutDoctorInput | PatientProfileUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PatientProfileUpdateManyWithWhereWithoutDoctorInput | PatientProfileUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PatientProfileScalarWhereInput | PatientProfileScalarWhereInput[]
  }

  export type PatientProfileUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientProfileCreateWithoutPatientInput, PatientProfileUncheckedCreateWithoutPatientInput> | PatientProfileCreateWithoutPatientInput[] | PatientProfileUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientProfileCreateOrConnectWithoutPatientInput | PatientProfileCreateOrConnectWithoutPatientInput[]
    upsert?: PatientProfileUpsertWithWhereUniqueWithoutPatientInput | PatientProfileUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientProfileCreateManyPatientInputEnvelope
    set?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    disconnect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    delete?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    connect?: PatientProfileWhereUniqueInput | PatientProfileWhereUniqueInput[]
    update?: PatientProfileUpdateWithWhereUniqueWithoutPatientInput | PatientProfileUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientProfileUpdateManyWithWhereWithoutPatientInput | PatientProfileUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientProfileScalarWhereInput | PatientProfileScalarWhereInput[]
  }

  export type MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutDoctorInput, MessageTemplateUncheckedCreateWithoutDoctorInput> | MessageTemplateCreateWithoutDoctorInput[] | MessageTemplateUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutDoctorInput | MessageTemplateCreateOrConnectWithoutDoctorInput[]
    upsert?: MessageTemplateUpsertWithWhereUniqueWithoutDoctorInput | MessageTemplateUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: MessageTemplateCreateManyDoctorInputEnvelope
    set?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    disconnect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    delete?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    update?: MessageTemplateUpdateWithWhereUniqueWithoutDoctorInput | MessageTemplateUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: MessageTemplateUpdateManyWithWhereWithoutDoctorInput | MessageTemplateUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
  }

  export type MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<MessageSequenceCreateWithoutDoctorInput, MessageSequenceUncheckedCreateWithoutDoctorInput> | MessageSequenceCreateWithoutDoctorInput[] | MessageSequenceUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MessageSequenceCreateOrConnectWithoutDoctorInput | MessageSequenceCreateOrConnectWithoutDoctorInput[]
    upsert?: MessageSequenceUpsertWithWhereUniqueWithoutDoctorInput | MessageSequenceUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: MessageSequenceCreateManyDoctorInputEnvelope
    set?: MessageSequenceWhereUniqueInput | MessageSequenceWhereUniqueInput[]
    disconnect?: MessageSequenceWhereUniqueInput | MessageSequenceWhereUniqueInput[]
    delete?: MessageSequenceWhereUniqueInput | MessageSequenceWhereUniqueInput[]
    connect?: MessageSequenceWhereUniqueInput | MessageSequenceWhereUniqueInput[]
    update?: MessageSequenceUpdateWithWhereUniqueWithoutDoctorInput | MessageSequenceUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: MessageSequenceUpdateManyWithWhereWithoutDoctorInput | MessageSequenceUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: MessageSequenceScalarWhereInput | MessageSequenceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutUser_verification_codesInput = {
    create?: XOR<UserCreateWithoutUser_verification_codesInput, UserUncheckedCreateWithoutUser_verification_codesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_verification_codesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDoctor_verification_codesInput = {
    create?: XOR<UserCreateWithoutDoctor_verification_codesInput, UserUncheckedCreateWithoutDoctor_verification_codesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctor_verification_codesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUser_verification_codesNestedInput = {
    create?: XOR<UserCreateWithoutUser_verification_codesInput, UserUncheckedCreateWithoutUser_verification_codesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_verification_codesInput
    upsert?: UserUpsertWithoutUser_verification_codesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_verification_codesInput, UserUpdateWithoutUser_verification_codesInput>, UserUncheckedUpdateWithoutUser_verification_codesInput>
  }

  export type UserUpdateOneRequiredWithoutDoctor_verification_codesNestedInput = {
    create?: XOR<UserCreateWithoutDoctor_verification_codesInput, UserUncheckedCreateWithoutDoctor_verification_codesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctor_verification_codesInput
    upsert?: UserUpsertWithoutDoctor_verification_codesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctor_verification_codesInput, UserUpdateWithoutDoctor_verification_codesInput>, UserUncheckedUpdateWithoutDoctor_verification_codesInput>
  }

  export type UserCreateNestedOneWithoutDoctor_profilesInput = {
    create?: XOR<UserCreateWithoutDoctor_profilesInput, UserUncheckedCreateWithoutDoctor_profilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctor_profilesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPatient_profilesInput = {
    create?: XOR<UserCreateWithoutPatient_profilesInput, UserUncheckedCreateWithoutPatient_profilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatient_profilesInput
    connect?: UserWhereUniqueInput
  }

  export type PointsLedgerCreateNestedManyWithoutPatientProfileInput = {
    create?: XOR<PointsLedgerCreateWithoutPatientProfileInput, PointsLedgerUncheckedCreateWithoutPatientProfileInput> | PointsLedgerCreateWithoutPatientProfileInput[] | PointsLedgerUncheckedCreateWithoutPatientProfileInput[]
    connectOrCreate?: PointsLedgerCreateOrConnectWithoutPatientProfileInput | PointsLedgerCreateOrConnectWithoutPatientProfileInput[]
    createMany?: PointsLedgerCreateManyPatientProfileInputEnvelope
    connect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
  }

  export type PointsLedgerUncheckedCreateNestedManyWithoutPatientProfileInput = {
    create?: XOR<PointsLedgerCreateWithoutPatientProfileInput, PointsLedgerUncheckedCreateWithoutPatientProfileInput> | PointsLedgerCreateWithoutPatientProfileInput[] | PointsLedgerUncheckedCreateWithoutPatientProfileInput[]
    connectOrCreate?: PointsLedgerCreateOrConnectWithoutPatientProfileInput | PointsLedgerCreateOrConnectWithoutPatientProfileInput[]
    createMany?: PointsLedgerCreateManyPatientProfileInputEnvelope
    connect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDoctor_profilesNestedInput = {
    create?: XOR<UserCreateWithoutDoctor_profilesInput, UserUncheckedCreateWithoutDoctor_profilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctor_profilesInput
    upsert?: UserUpsertWithoutDoctor_profilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctor_profilesInput, UserUpdateWithoutDoctor_profilesInput>, UserUncheckedUpdateWithoutDoctor_profilesInput>
  }

  export type UserUpdateOneRequiredWithoutPatient_profilesNestedInput = {
    create?: XOR<UserCreateWithoutPatient_profilesInput, UserUncheckedCreateWithoutPatient_profilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatient_profilesInput
    upsert?: UserUpsertWithoutPatient_profilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPatient_profilesInput, UserUpdateWithoutPatient_profilesInput>, UserUncheckedUpdateWithoutPatient_profilesInput>
  }

  export type PointsLedgerUpdateManyWithoutPatientProfileNestedInput = {
    create?: XOR<PointsLedgerCreateWithoutPatientProfileInput, PointsLedgerUncheckedCreateWithoutPatientProfileInput> | PointsLedgerCreateWithoutPatientProfileInput[] | PointsLedgerUncheckedCreateWithoutPatientProfileInput[]
    connectOrCreate?: PointsLedgerCreateOrConnectWithoutPatientProfileInput | PointsLedgerCreateOrConnectWithoutPatientProfileInput[]
    upsert?: PointsLedgerUpsertWithWhereUniqueWithoutPatientProfileInput | PointsLedgerUpsertWithWhereUniqueWithoutPatientProfileInput[]
    createMany?: PointsLedgerCreateManyPatientProfileInputEnvelope
    set?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    disconnect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    delete?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    connect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    update?: PointsLedgerUpdateWithWhereUniqueWithoutPatientProfileInput | PointsLedgerUpdateWithWhereUniqueWithoutPatientProfileInput[]
    updateMany?: PointsLedgerUpdateManyWithWhereWithoutPatientProfileInput | PointsLedgerUpdateManyWithWhereWithoutPatientProfileInput[]
    deleteMany?: PointsLedgerScalarWhereInput | PointsLedgerScalarWhereInput[]
  }

  export type PointsLedgerUncheckedUpdateManyWithoutPatientProfileNestedInput = {
    create?: XOR<PointsLedgerCreateWithoutPatientProfileInput, PointsLedgerUncheckedCreateWithoutPatientProfileInput> | PointsLedgerCreateWithoutPatientProfileInput[] | PointsLedgerUncheckedCreateWithoutPatientProfileInput[]
    connectOrCreate?: PointsLedgerCreateOrConnectWithoutPatientProfileInput | PointsLedgerCreateOrConnectWithoutPatientProfileInput[]
    upsert?: PointsLedgerUpsertWithWhereUniqueWithoutPatientProfileInput | PointsLedgerUpsertWithWhereUniqueWithoutPatientProfileInput[]
    createMany?: PointsLedgerCreateManyPatientProfileInputEnvelope
    set?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    disconnect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    delete?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    connect?: PointsLedgerWhereUniqueInput | PointsLedgerWhereUniqueInput[]
    update?: PointsLedgerUpdateWithWhereUniqueWithoutPatientProfileInput | PointsLedgerUpdateWithWhereUniqueWithoutPatientProfileInput[]
    updateMany?: PointsLedgerUpdateManyWithWhereWithoutPatientProfileInput | PointsLedgerUpdateManyWithWhereWithoutPatientProfileInput[]
    deleteMany?: PointsLedgerScalarWhereInput | PointsLedgerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPointsLedgerInput = {
    create?: XOR<UserCreateWithoutPointsLedgerInput, UserUncheckedCreateWithoutPointsLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointsLedgerInput
    connect?: UserWhereUniqueInput
  }

  export type PatientProfileCreateNestedOneWithoutPointsLedgerInput = {
    create?: XOR<PatientProfileCreateWithoutPointsLedgerInput, PatientProfileUncheckedCreateWithoutPointsLedgerInput>
    connectOrCreate?: PatientProfileCreateOrConnectWithoutPointsLedgerInput
    connect?: PatientProfileWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutPointsLedgerNestedInput = {
    create?: XOR<UserCreateWithoutPointsLedgerInput, UserUncheckedCreateWithoutPointsLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointsLedgerInput
    upsert?: UserUpsertWithoutPointsLedgerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPointsLedgerInput, UserUpdateWithoutPointsLedgerInput>, UserUncheckedUpdateWithoutPointsLedgerInput>
  }

  export type PatientProfileUpdateOneWithoutPointsLedgerNestedInput = {
    create?: XOR<PatientProfileCreateWithoutPointsLedgerInput, PatientProfileUncheckedCreateWithoutPointsLedgerInput>
    connectOrCreate?: PatientProfileCreateOrConnectWithoutPointsLedgerInput
    upsert?: PatientProfileUpsertWithoutPointsLedgerInput
    disconnect?: PatientProfileWhereInput | boolean
    delete?: PatientProfileWhereInput | boolean
    connect?: PatientProfileWhereUniqueInput
    update?: XOR<XOR<PatientProfileUpdateToOneWithWhereWithoutPointsLedgerInput, PatientProfileUpdateWithoutPointsLedgerInput>, PatientProfileUncheckedUpdateWithoutPointsLedgerInput>
  }

  export type ClinicMemberCreateNestedManyWithoutClinicInput = {
    create?: XOR<ClinicMemberCreateWithoutClinicInput, ClinicMemberUncheckedCreateWithoutClinicInput> | ClinicMemberCreateWithoutClinicInput[] | ClinicMemberUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicMemberCreateOrConnectWithoutClinicInput | ClinicMemberCreateOrConnectWithoutClinicInput[]
    createMany?: ClinicMemberCreateManyClinicInputEnvelope
    connect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOwned_clinicsInput = {
    create?: XOR<UserCreateWithoutOwned_clinicsInput, UserUncheckedCreateWithoutOwned_clinicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwned_clinicsInput
    connect?: UserWhereUniqueInput
  }

  export type ClinicSubscriptionCreateNestedManyWithoutClinicInput = {
    create?: XOR<ClinicSubscriptionCreateWithoutClinicInput, ClinicSubscriptionUncheckedCreateWithoutClinicInput> | ClinicSubscriptionCreateWithoutClinicInput[] | ClinicSubscriptionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicSubscriptionCreateOrConnectWithoutClinicInput | ClinicSubscriptionCreateOrConnectWithoutClinicInput[]
    createMany?: ClinicSubscriptionCreateManyClinicInputEnvelope
    connect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutClinicInput = {
    create?: XOR<ProductCreateWithoutClinicInput, ProductUncheckedCreateWithoutClinicInput> | ProductCreateWithoutClinicInput[] | ProductUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutClinicInput | ProductCreateOrConnectWithoutClinicInput[]
    createMany?: ProductCreateManyClinicInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type MerchantCreateNestedOneWithoutClinicInput = {
    create?: XOR<MerchantCreateWithoutClinicInput, MerchantUncheckedCreateWithoutClinicInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutClinicInput
    connect?: MerchantWhereUniqueInput
  }

  export type MerchantApplicationCreateNestedOneWithoutClinicInput = {
    create?: XOR<MerchantApplicationCreateWithoutClinicInput, MerchantApplicationUncheckedCreateWithoutClinicInput>
    connectOrCreate?: MerchantApplicationCreateOrConnectWithoutClinicInput
    connect?: MerchantApplicationWhereUniqueInput
  }

  export type WebhookEndpointCreateNestedManyWithoutClinicInput = {
    create?: XOR<WebhookEndpointCreateWithoutClinicInput, WebhookEndpointUncheckedCreateWithoutClinicInput> | WebhookEndpointCreateWithoutClinicInput[] | WebhookEndpointUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: WebhookEndpointCreateOrConnectWithoutClinicInput | WebhookEndpointCreateOrConnectWithoutClinicInput[]
    createMany?: WebhookEndpointCreateManyClinicInputEnvelope
    connect?: WebhookEndpointWhereUniqueInput | WebhookEndpointWhereUniqueInput[]
  }

  export type OutboundWebhookEventCreateNestedManyWithoutClinicInput = {
    create?: XOR<OutboundWebhookEventCreateWithoutClinicInput, OutboundWebhookEventUncheckedCreateWithoutClinicInput> | OutboundWebhookEventCreateWithoutClinicInput[] | OutboundWebhookEventUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: OutboundWebhookEventCreateOrConnectWithoutClinicInput | OutboundWebhookEventCreateOrConnectWithoutClinicInput[]
    createMany?: OutboundWebhookEventCreateManyClinicInputEnvelope
    connect?: OutboundWebhookEventWhereUniqueInput | OutboundWebhookEventWhereUniqueInput[]
  }

  export type ClinicMemberUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<ClinicMemberCreateWithoutClinicInput, ClinicMemberUncheckedCreateWithoutClinicInput> | ClinicMemberCreateWithoutClinicInput[] | ClinicMemberUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicMemberCreateOrConnectWithoutClinicInput | ClinicMemberCreateOrConnectWithoutClinicInput[]
    createMany?: ClinicMemberCreateManyClinicInputEnvelope
    connect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
  }

  export type ClinicSubscriptionUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<ClinicSubscriptionCreateWithoutClinicInput, ClinicSubscriptionUncheckedCreateWithoutClinicInput> | ClinicSubscriptionCreateWithoutClinicInput[] | ClinicSubscriptionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicSubscriptionCreateOrConnectWithoutClinicInput | ClinicSubscriptionCreateOrConnectWithoutClinicInput[]
    createMany?: ClinicSubscriptionCreateManyClinicInputEnvelope
    connect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<ProductCreateWithoutClinicInput, ProductUncheckedCreateWithoutClinicInput> | ProductCreateWithoutClinicInput[] | ProductUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutClinicInput | ProductCreateOrConnectWithoutClinicInput[]
    createMany?: ProductCreateManyClinicInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type MerchantUncheckedCreateNestedOneWithoutClinicInput = {
    create?: XOR<MerchantCreateWithoutClinicInput, MerchantUncheckedCreateWithoutClinicInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutClinicInput
    connect?: MerchantWhereUniqueInput
  }

  export type MerchantApplicationUncheckedCreateNestedOneWithoutClinicInput = {
    create?: XOR<MerchantApplicationCreateWithoutClinicInput, MerchantApplicationUncheckedCreateWithoutClinicInput>
    connectOrCreate?: MerchantApplicationCreateOrConnectWithoutClinicInput
    connect?: MerchantApplicationWhereUniqueInput
  }

  export type WebhookEndpointUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<WebhookEndpointCreateWithoutClinicInput, WebhookEndpointUncheckedCreateWithoutClinicInput> | WebhookEndpointCreateWithoutClinicInput[] | WebhookEndpointUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: WebhookEndpointCreateOrConnectWithoutClinicInput | WebhookEndpointCreateOrConnectWithoutClinicInput[]
    createMany?: WebhookEndpointCreateManyClinicInputEnvelope
    connect?: WebhookEndpointWhereUniqueInput | WebhookEndpointWhereUniqueInput[]
  }

  export type OutboundWebhookEventUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<OutboundWebhookEventCreateWithoutClinicInput, OutboundWebhookEventUncheckedCreateWithoutClinicInput> | OutboundWebhookEventCreateWithoutClinicInput[] | OutboundWebhookEventUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: OutboundWebhookEventCreateOrConnectWithoutClinicInput | OutboundWebhookEventCreateOrConnectWithoutClinicInput[]
    createMany?: OutboundWebhookEventCreateManyClinicInputEnvelope
    connect?: OutboundWebhookEventWhereUniqueInput | OutboundWebhookEventWhereUniqueInput[]
  }

  export type EnumClinicThemeFieldUpdateOperationsInput = {
    set?: $Enums.ClinicTheme
  }

  export type ClinicMemberUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ClinicMemberCreateWithoutClinicInput, ClinicMemberUncheckedCreateWithoutClinicInput> | ClinicMemberCreateWithoutClinicInput[] | ClinicMemberUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicMemberCreateOrConnectWithoutClinicInput | ClinicMemberCreateOrConnectWithoutClinicInput[]
    upsert?: ClinicMemberUpsertWithWhereUniqueWithoutClinicInput | ClinicMemberUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ClinicMemberCreateManyClinicInputEnvelope
    set?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    disconnect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    delete?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    connect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    update?: ClinicMemberUpdateWithWhereUniqueWithoutClinicInput | ClinicMemberUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ClinicMemberUpdateManyWithWhereWithoutClinicInput | ClinicMemberUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ClinicMemberScalarWhereInput | ClinicMemberScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutOwned_clinicsNestedInput = {
    create?: XOR<UserCreateWithoutOwned_clinicsInput, UserUncheckedCreateWithoutOwned_clinicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwned_clinicsInput
    upsert?: UserUpsertWithoutOwned_clinicsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwned_clinicsInput, UserUpdateWithoutOwned_clinicsInput>, UserUncheckedUpdateWithoutOwned_clinicsInput>
  }

  export type ClinicSubscriptionUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ClinicSubscriptionCreateWithoutClinicInput, ClinicSubscriptionUncheckedCreateWithoutClinicInput> | ClinicSubscriptionCreateWithoutClinicInput[] | ClinicSubscriptionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicSubscriptionCreateOrConnectWithoutClinicInput | ClinicSubscriptionCreateOrConnectWithoutClinicInput[]
    upsert?: ClinicSubscriptionUpsertWithWhereUniqueWithoutClinicInput | ClinicSubscriptionUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ClinicSubscriptionCreateManyClinicInputEnvelope
    set?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    disconnect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    delete?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    connect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    update?: ClinicSubscriptionUpdateWithWhereUniqueWithoutClinicInput | ClinicSubscriptionUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ClinicSubscriptionUpdateManyWithWhereWithoutClinicInput | ClinicSubscriptionUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ClinicSubscriptionScalarWhereInput | ClinicSubscriptionScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ProductCreateWithoutClinicInput, ProductUncheckedCreateWithoutClinicInput> | ProductCreateWithoutClinicInput[] | ProductUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutClinicInput | ProductCreateOrConnectWithoutClinicInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutClinicInput | ProductUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ProductCreateManyClinicInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutClinicInput | ProductUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutClinicInput | ProductUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MerchantUpdateOneWithoutClinicNestedInput = {
    create?: XOR<MerchantCreateWithoutClinicInput, MerchantUncheckedCreateWithoutClinicInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutClinicInput
    upsert?: MerchantUpsertWithoutClinicInput
    disconnect?: MerchantWhereInput | boolean
    delete?: MerchantWhereInput | boolean
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutClinicInput, MerchantUpdateWithoutClinicInput>, MerchantUncheckedUpdateWithoutClinicInput>
  }

  export type MerchantApplicationUpdateOneWithoutClinicNestedInput = {
    create?: XOR<MerchantApplicationCreateWithoutClinicInput, MerchantApplicationUncheckedCreateWithoutClinicInput>
    connectOrCreate?: MerchantApplicationCreateOrConnectWithoutClinicInput
    upsert?: MerchantApplicationUpsertWithoutClinicInput
    disconnect?: MerchantApplicationWhereInput | boolean
    delete?: MerchantApplicationWhereInput | boolean
    connect?: MerchantApplicationWhereUniqueInput
    update?: XOR<XOR<MerchantApplicationUpdateToOneWithWhereWithoutClinicInput, MerchantApplicationUpdateWithoutClinicInput>, MerchantApplicationUncheckedUpdateWithoutClinicInput>
  }

  export type WebhookEndpointUpdateManyWithoutClinicNestedInput = {
    create?: XOR<WebhookEndpointCreateWithoutClinicInput, WebhookEndpointUncheckedCreateWithoutClinicInput> | WebhookEndpointCreateWithoutClinicInput[] | WebhookEndpointUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: WebhookEndpointCreateOrConnectWithoutClinicInput | WebhookEndpointCreateOrConnectWithoutClinicInput[]
    upsert?: WebhookEndpointUpsertWithWhereUniqueWithoutClinicInput | WebhookEndpointUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: WebhookEndpointCreateManyClinicInputEnvelope
    set?: WebhookEndpointWhereUniqueInput | WebhookEndpointWhereUniqueInput[]
    disconnect?: WebhookEndpointWhereUniqueInput | WebhookEndpointWhereUniqueInput[]
    delete?: WebhookEndpointWhereUniqueInput | WebhookEndpointWhereUniqueInput[]
    connect?: WebhookEndpointWhereUniqueInput | WebhookEndpointWhereUniqueInput[]
    update?: WebhookEndpointUpdateWithWhereUniqueWithoutClinicInput | WebhookEndpointUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: WebhookEndpointUpdateManyWithWhereWithoutClinicInput | WebhookEndpointUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: WebhookEndpointScalarWhereInput | WebhookEndpointScalarWhereInput[]
  }

  export type OutboundWebhookEventUpdateManyWithoutClinicNestedInput = {
    create?: XOR<OutboundWebhookEventCreateWithoutClinicInput, OutboundWebhookEventUncheckedCreateWithoutClinicInput> | OutboundWebhookEventCreateWithoutClinicInput[] | OutboundWebhookEventUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: OutboundWebhookEventCreateOrConnectWithoutClinicInput | OutboundWebhookEventCreateOrConnectWithoutClinicInput[]
    upsert?: OutboundWebhookEventUpsertWithWhereUniqueWithoutClinicInput | OutboundWebhookEventUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: OutboundWebhookEventCreateManyClinicInputEnvelope
    set?: OutboundWebhookEventWhereUniqueInput | OutboundWebhookEventWhereUniqueInput[]
    disconnect?: OutboundWebhookEventWhereUniqueInput | OutboundWebhookEventWhereUniqueInput[]
    delete?: OutboundWebhookEventWhereUniqueInput | OutboundWebhookEventWhereUniqueInput[]
    connect?: OutboundWebhookEventWhereUniqueInput | OutboundWebhookEventWhereUniqueInput[]
    update?: OutboundWebhookEventUpdateWithWhereUniqueWithoutClinicInput | OutboundWebhookEventUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: OutboundWebhookEventUpdateManyWithWhereWithoutClinicInput | OutboundWebhookEventUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: OutboundWebhookEventScalarWhereInput | OutboundWebhookEventScalarWhereInput[]
  }

  export type ClinicMemberUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ClinicMemberCreateWithoutClinicInput, ClinicMemberUncheckedCreateWithoutClinicInput> | ClinicMemberCreateWithoutClinicInput[] | ClinicMemberUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicMemberCreateOrConnectWithoutClinicInput | ClinicMemberCreateOrConnectWithoutClinicInput[]
    upsert?: ClinicMemberUpsertWithWhereUniqueWithoutClinicInput | ClinicMemberUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ClinicMemberCreateManyClinicInputEnvelope
    set?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    disconnect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    delete?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    connect?: ClinicMemberWhereUniqueInput | ClinicMemberWhereUniqueInput[]
    update?: ClinicMemberUpdateWithWhereUniqueWithoutClinicInput | ClinicMemberUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ClinicMemberUpdateManyWithWhereWithoutClinicInput | ClinicMemberUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ClinicMemberScalarWhereInput | ClinicMemberScalarWhereInput[]
  }

  export type ClinicSubscriptionUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ClinicSubscriptionCreateWithoutClinicInput, ClinicSubscriptionUncheckedCreateWithoutClinicInput> | ClinicSubscriptionCreateWithoutClinicInput[] | ClinicSubscriptionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicSubscriptionCreateOrConnectWithoutClinicInput | ClinicSubscriptionCreateOrConnectWithoutClinicInput[]
    upsert?: ClinicSubscriptionUpsertWithWhereUniqueWithoutClinicInput | ClinicSubscriptionUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ClinicSubscriptionCreateManyClinicInputEnvelope
    set?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    disconnect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    delete?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    connect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    update?: ClinicSubscriptionUpdateWithWhereUniqueWithoutClinicInput | ClinicSubscriptionUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ClinicSubscriptionUpdateManyWithWhereWithoutClinicInput | ClinicSubscriptionUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ClinicSubscriptionScalarWhereInput | ClinicSubscriptionScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ProductCreateWithoutClinicInput, ProductUncheckedCreateWithoutClinicInput> | ProductCreateWithoutClinicInput[] | ProductUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutClinicInput | ProductCreateOrConnectWithoutClinicInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutClinicInput | ProductUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ProductCreateManyClinicInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutClinicInput | ProductUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutClinicInput | ProductUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MerchantUncheckedUpdateOneWithoutClinicNestedInput = {
    create?: XOR<MerchantCreateWithoutClinicInput, MerchantUncheckedCreateWithoutClinicInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutClinicInput
    upsert?: MerchantUpsertWithoutClinicInput
    disconnect?: MerchantWhereInput | boolean
    delete?: MerchantWhereInput | boolean
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutClinicInput, MerchantUpdateWithoutClinicInput>, MerchantUncheckedUpdateWithoutClinicInput>
  }

  export type MerchantApplicationUncheckedUpdateOneWithoutClinicNestedInput = {
    create?: XOR<MerchantApplicationCreateWithoutClinicInput, MerchantApplicationUncheckedCreateWithoutClinicInput>
    connectOrCreate?: MerchantApplicationCreateOrConnectWithoutClinicInput
    upsert?: MerchantApplicationUpsertWithoutClinicInput
    disconnect?: MerchantApplicationWhereInput | boolean
    delete?: MerchantApplicationWhereInput | boolean
    connect?: MerchantApplicationWhereUniqueInput
    update?: XOR<XOR<MerchantApplicationUpdateToOneWithWhereWithoutClinicInput, MerchantApplicationUpdateWithoutClinicInput>, MerchantApplicationUncheckedUpdateWithoutClinicInput>
  }

  export type WebhookEndpointUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<WebhookEndpointCreateWithoutClinicInput, WebhookEndpointUncheckedCreateWithoutClinicInput> | WebhookEndpointCreateWithoutClinicInput[] | WebhookEndpointUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: WebhookEndpointCreateOrConnectWithoutClinicInput | WebhookEndpointCreateOrConnectWithoutClinicInput[]
    upsert?: WebhookEndpointUpsertWithWhereUniqueWithoutClinicInput | WebhookEndpointUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: WebhookEndpointCreateManyClinicInputEnvelope
    set?: WebhookEndpointWhereUniqueInput | WebhookEndpointWhereUniqueInput[]
    disconnect?: WebhookEndpointWhereUniqueInput | WebhookEndpointWhereUniqueInput[]
    delete?: WebhookEndpointWhereUniqueInput | WebhookEndpointWhereUniqueInput[]
    connect?: WebhookEndpointWhereUniqueInput | WebhookEndpointWhereUniqueInput[]
    update?: WebhookEndpointUpdateWithWhereUniqueWithoutClinicInput | WebhookEndpointUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: WebhookEndpointUpdateManyWithWhereWithoutClinicInput | WebhookEndpointUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: WebhookEndpointScalarWhereInput | WebhookEndpointScalarWhereInput[]
  }

  export type OutboundWebhookEventUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<OutboundWebhookEventCreateWithoutClinicInput, OutboundWebhookEventUncheckedCreateWithoutClinicInput> | OutboundWebhookEventCreateWithoutClinicInput[] | OutboundWebhookEventUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: OutboundWebhookEventCreateOrConnectWithoutClinicInput | OutboundWebhookEventCreateOrConnectWithoutClinicInput[]
    upsert?: OutboundWebhookEventUpsertWithWhereUniqueWithoutClinicInput | OutboundWebhookEventUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: OutboundWebhookEventCreateManyClinicInputEnvelope
    set?: OutboundWebhookEventWhereUniqueInput | OutboundWebhookEventWhereUniqueInput[]
    disconnect?: OutboundWebhookEventWhereUniqueInput | OutboundWebhookEventWhereUniqueInput[]
    delete?: OutboundWebhookEventWhereUniqueInput | OutboundWebhookEventWhereUniqueInput[]
    connect?: OutboundWebhookEventWhereUniqueInput | OutboundWebhookEventWhereUniqueInput[]
    update?: OutboundWebhookEventUpdateWithWhereUniqueWithoutClinicInput | OutboundWebhookEventUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: OutboundWebhookEventUpdateManyWithWhereWithoutClinicInput | OutboundWebhookEventUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: OutboundWebhookEventScalarWhereInput | OutboundWebhookEventScalarWhereInput[]
  }

  export type ClinicCreateNestedOneWithoutMembersInput = {
    create?: XOR<ClinicCreateWithoutMembersInput, ClinicUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutMembersInput
    connect?: ClinicWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClinic_membershipsInput = {
    create?: XOR<UserCreateWithoutClinic_membershipsInput, UserUncheckedCreateWithoutClinic_membershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinic_membershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumClinicRoleFieldUpdateOperationsInput = {
    set?: $Enums.ClinicRole
  }

  export type ClinicUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ClinicCreateWithoutMembersInput, ClinicUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutMembersInput
    upsert?: ClinicUpsertWithoutMembersInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutMembersInput, ClinicUpdateWithoutMembersInput>, ClinicUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutClinic_membershipsNestedInput = {
    create?: XOR<UserCreateWithoutClinic_membershipsInput, UserUncheckedCreateWithoutClinic_membershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinic_membershipsInput
    upsert?: UserUpsertWithoutClinic_membershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClinic_membershipsInput, UserUpdateWithoutClinic_membershipsInput>, UserUncheckedUpdateWithoutClinic_membershipsInput>
  }

  export type ClinicCreateNestedOneWithoutMerchantInput = {
    create?: XOR<ClinicCreateWithoutMerchantInput, ClinicUncheckedCreateWithoutMerchantInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutMerchantInput
    connect?: ClinicWhereUniqueInput
  }

  export type MerchantIntegrationCreateNestedManyWithoutMerchantInput = {
    create?: XOR<MerchantIntegrationCreateWithoutMerchantInput, MerchantIntegrationUncheckedCreateWithoutMerchantInput> | MerchantIntegrationCreateWithoutMerchantInput[] | MerchantIntegrationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantIntegrationCreateOrConnectWithoutMerchantInput | MerchantIntegrationCreateOrConnectWithoutMerchantInput[]
    createMany?: MerchantIntegrationCreateManyMerchantInputEnvelope
    connect?: MerchantIntegrationWhereUniqueInput | MerchantIntegrationWhereUniqueInput[]
  }

  export type MerchantIntegrationUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<MerchantIntegrationCreateWithoutMerchantInput, MerchantIntegrationUncheckedCreateWithoutMerchantInput> | MerchantIntegrationCreateWithoutMerchantInput[] | MerchantIntegrationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantIntegrationCreateOrConnectWithoutMerchantInput | MerchantIntegrationCreateOrConnectWithoutMerchantInput[]
    createMany?: MerchantIntegrationCreateManyMerchantInputEnvelope
    connect?: MerchantIntegrationWhereUniqueInput | MerchantIntegrationWhereUniqueInput[]
  }

  export type EnumMerchantStatusFieldUpdateOperationsInput = {
    set?: $Enums.MerchantStatus
  }

  export type ClinicUpdateOneRequiredWithoutMerchantNestedInput = {
    create?: XOR<ClinicCreateWithoutMerchantInput, ClinicUncheckedCreateWithoutMerchantInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutMerchantInput
    upsert?: ClinicUpsertWithoutMerchantInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutMerchantInput, ClinicUpdateWithoutMerchantInput>, ClinicUncheckedUpdateWithoutMerchantInput>
  }

  export type MerchantIntegrationUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<MerchantIntegrationCreateWithoutMerchantInput, MerchantIntegrationUncheckedCreateWithoutMerchantInput> | MerchantIntegrationCreateWithoutMerchantInput[] | MerchantIntegrationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantIntegrationCreateOrConnectWithoutMerchantInput | MerchantIntegrationCreateOrConnectWithoutMerchantInput[]
    upsert?: MerchantIntegrationUpsertWithWhereUniqueWithoutMerchantInput | MerchantIntegrationUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: MerchantIntegrationCreateManyMerchantInputEnvelope
    set?: MerchantIntegrationWhereUniqueInput | MerchantIntegrationWhereUniqueInput[]
    disconnect?: MerchantIntegrationWhereUniqueInput | MerchantIntegrationWhereUniqueInput[]
    delete?: MerchantIntegrationWhereUniqueInput | MerchantIntegrationWhereUniqueInput[]
    connect?: MerchantIntegrationWhereUniqueInput | MerchantIntegrationWhereUniqueInput[]
    update?: MerchantIntegrationUpdateWithWhereUniqueWithoutMerchantInput | MerchantIntegrationUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: MerchantIntegrationUpdateManyWithWhereWithoutMerchantInput | MerchantIntegrationUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: MerchantIntegrationScalarWhereInput | MerchantIntegrationScalarWhereInput[]
  }

  export type MerchantIntegrationUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<MerchantIntegrationCreateWithoutMerchantInput, MerchantIntegrationUncheckedCreateWithoutMerchantInput> | MerchantIntegrationCreateWithoutMerchantInput[] | MerchantIntegrationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantIntegrationCreateOrConnectWithoutMerchantInput | MerchantIntegrationCreateOrConnectWithoutMerchantInput[]
    upsert?: MerchantIntegrationUpsertWithWhereUniqueWithoutMerchantInput | MerchantIntegrationUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: MerchantIntegrationCreateManyMerchantInputEnvelope
    set?: MerchantIntegrationWhereUniqueInput | MerchantIntegrationWhereUniqueInput[]
    disconnect?: MerchantIntegrationWhereUniqueInput | MerchantIntegrationWhereUniqueInput[]
    delete?: MerchantIntegrationWhereUniqueInput | MerchantIntegrationWhereUniqueInput[]
    connect?: MerchantIntegrationWhereUniqueInput | MerchantIntegrationWhereUniqueInput[]
    update?: MerchantIntegrationUpdateWithWhereUniqueWithoutMerchantInput | MerchantIntegrationUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: MerchantIntegrationUpdateManyWithWhereWithoutMerchantInput | MerchantIntegrationUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: MerchantIntegrationScalarWhereInput | MerchantIntegrationScalarWhereInput[]
  }

  export type ClinicCreateNestedOneWithoutMerchantApplicationInput = {
    create?: XOR<ClinicCreateWithoutMerchantApplicationInput, ClinicUncheckedCreateWithoutMerchantApplicationInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutMerchantApplicationInput
    connect?: ClinicWhereUniqueInput
  }

  export type MerchantDocumentCreateNestedManyWithoutApplicationInput = {
    create?: XOR<MerchantDocumentCreateWithoutApplicationInput, MerchantDocumentUncheckedCreateWithoutApplicationInput> | MerchantDocumentCreateWithoutApplicationInput[] | MerchantDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: MerchantDocumentCreateOrConnectWithoutApplicationInput | MerchantDocumentCreateOrConnectWithoutApplicationInput[]
    createMany?: MerchantDocumentCreateManyApplicationInputEnvelope
    connect?: MerchantDocumentWhereUniqueInput | MerchantDocumentWhereUniqueInput[]
  }

  export type MerchantDocumentUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<MerchantDocumentCreateWithoutApplicationInput, MerchantDocumentUncheckedCreateWithoutApplicationInput> | MerchantDocumentCreateWithoutApplicationInput[] | MerchantDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: MerchantDocumentCreateOrConnectWithoutApplicationInput | MerchantDocumentCreateOrConnectWithoutApplicationInput[]
    createMany?: MerchantDocumentCreateManyApplicationInputEnvelope
    connect?: MerchantDocumentWhereUniqueInput | MerchantDocumentWhereUniqueInput[]
  }

  export type EnumMerchantTypeFieldUpdateOperationsInput = {
    set?: $Enums.MerchantType
  }

  export type EnumMerchantAppStatusFieldUpdateOperationsInput = {
    set?: $Enums.MerchantAppStatus
  }

  export type ClinicUpdateOneRequiredWithoutMerchantApplicationNestedInput = {
    create?: XOR<ClinicCreateWithoutMerchantApplicationInput, ClinicUncheckedCreateWithoutMerchantApplicationInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutMerchantApplicationInput
    upsert?: ClinicUpsertWithoutMerchantApplicationInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutMerchantApplicationInput, ClinicUpdateWithoutMerchantApplicationInput>, ClinicUncheckedUpdateWithoutMerchantApplicationInput>
  }

  export type MerchantDocumentUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<MerchantDocumentCreateWithoutApplicationInput, MerchantDocumentUncheckedCreateWithoutApplicationInput> | MerchantDocumentCreateWithoutApplicationInput[] | MerchantDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: MerchantDocumentCreateOrConnectWithoutApplicationInput | MerchantDocumentCreateOrConnectWithoutApplicationInput[]
    upsert?: MerchantDocumentUpsertWithWhereUniqueWithoutApplicationInput | MerchantDocumentUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: MerchantDocumentCreateManyApplicationInputEnvelope
    set?: MerchantDocumentWhereUniqueInput | MerchantDocumentWhereUniqueInput[]
    disconnect?: MerchantDocumentWhereUniqueInput | MerchantDocumentWhereUniqueInput[]
    delete?: MerchantDocumentWhereUniqueInput | MerchantDocumentWhereUniqueInput[]
    connect?: MerchantDocumentWhereUniqueInput | MerchantDocumentWhereUniqueInput[]
    update?: MerchantDocumentUpdateWithWhereUniqueWithoutApplicationInput | MerchantDocumentUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: MerchantDocumentUpdateManyWithWhereWithoutApplicationInput | MerchantDocumentUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: MerchantDocumentScalarWhereInput | MerchantDocumentScalarWhereInput[]
  }

  export type MerchantDocumentUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<MerchantDocumentCreateWithoutApplicationInput, MerchantDocumentUncheckedCreateWithoutApplicationInput> | MerchantDocumentCreateWithoutApplicationInput[] | MerchantDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: MerchantDocumentCreateOrConnectWithoutApplicationInput | MerchantDocumentCreateOrConnectWithoutApplicationInput[]
    upsert?: MerchantDocumentUpsertWithWhereUniqueWithoutApplicationInput | MerchantDocumentUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: MerchantDocumentCreateManyApplicationInputEnvelope
    set?: MerchantDocumentWhereUniqueInput | MerchantDocumentWhereUniqueInput[]
    disconnect?: MerchantDocumentWhereUniqueInput | MerchantDocumentWhereUniqueInput[]
    delete?: MerchantDocumentWhereUniqueInput | MerchantDocumentWhereUniqueInput[]
    connect?: MerchantDocumentWhereUniqueInput | MerchantDocumentWhereUniqueInput[]
    update?: MerchantDocumentUpdateWithWhereUniqueWithoutApplicationInput | MerchantDocumentUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: MerchantDocumentUpdateManyWithWhereWithoutApplicationInput | MerchantDocumentUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: MerchantDocumentScalarWhereInput | MerchantDocumentScalarWhereInput[]
  }

  export type MerchantApplicationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<MerchantApplicationCreateWithoutDocumentsInput, MerchantApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: MerchantApplicationCreateOrConnectWithoutDocumentsInput
    connect?: MerchantApplicationWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EnumDocumentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentStatus
  }

  export type MerchantApplicationUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<MerchantApplicationCreateWithoutDocumentsInput, MerchantApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: MerchantApplicationCreateOrConnectWithoutDocumentsInput
    upsert?: MerchantApplicationUpsertWithoutDocumentsInput
    connect?: MerchantApplicationWhereUniqueInput
    update?: XOR<XOR<MerchantApplicationUpdateToOneWithWhereWithoutDocumentsInput, MerchantApplicationUpdateWithoutDocumentsInput>, MerchantApplicationUncheckedUpdateWithoutDocumentsInput>
  }

  export type MerchantCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<MerchantCreateWithoutIntegrationsInput, MerchantUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutIntegrationsInput
    connect?: MerchantWhereUniqueInput
  }

  export type EnumPaymentProviderFieldUpdateOperationsInput = {
    set?: $Enums.PaymentProvider
  }

  export type MerchantUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<MerchantCreateWithoutIntegrationsInput, MerchantUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutIntegrationsInput
    upsert?: MerchantUpsertWithoutIntegrationsInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutIntegrationsInput, MerchantUpdateWithoutIntegrationsInput>, MerchantUncheckedUpdateWithoutIntegrationsInput>
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type ClinicSubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<ClinicSubscriptionCreateWithoutPlanInput, ClinicSubscriptionUncheckedCreateWithoutPlanInput> | ClinicSubscriptionCreateWithoutPlanInput[] | ClinicSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ClinicSubscriptionCreateOrConnectWithoutPlanInput | ClinicSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: ClinicSubscriptionCreateManyPlanInputEnvelope
    connect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
  }

  export type ClinicSubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<ClinicSubscriptionCreateWithoutPlanInput, ClinicSubscriptionUncheckedCreateWithoutPlanInput> | ClinicSubscriptionCreateWithoutPlanInput[] | ClinicSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ClinicSubscriptionCreateOrConnectWithoutPlanInput | ClinicSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: ClinicSubscriptionCreateManyPlanInputEnvelope
    connect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
  }

  export type EnumPlanTierFieldUpdateOperationsInput = {
    set?: $Enums.PlanTier
  }

  export type ClinicSubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<ClinicSubscriptionCreateWithoutPlanInput, ClinicSubscriptionUncheckedCreateWithoutPlanInput> | ClinicSubscriptionCreateWithoutPlanInput[] | ClinicSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ClinicSubscriptionCreateOrConnectWithoutPlanInput | ClinicSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: ClinicSubscriptionUpsertWithWhereUniqueWithoutPlanInput | ClinicSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: ClinicSubscriptionCreateManyPlanInputEnvelope
    set?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    disconnect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    delete?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    connect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    update?: ClinicSubscriptionUpdateWithWhereUniqueWithoutPlanInput | ClinicSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: ClinicSubscriptionUpdateManyWithWhereWithoutPlanInput | ClinicSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: ClinicSubscriptionScalarWhereInput | ClinicSubscriptionScalarWhereInput[]
  }

  export type ClinicSubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<ClinicSubscriptionCreateWithoutPlanInput, ClinicSubscriptionUncheckedCreateWithoutPlanInput> | ClinicSubscriptionCreateWithoutPlanInput[] | ClinicSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ClinicSubscriptionCreateOrConnectWithoutPlanInput | ClinicSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: ClinicSubscriptionUpsertWithWhereUniqueWithoutPlanInput | ClinicSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: ClinicSubscriptionCreateManyPlanInputEnvelope
    set?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    disconnect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    delete?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    connect?: ClinicSubscriptionWhereUniqueInput | ClinicSubscriptionWhereUniqueInput[]
    update?: ClinicSubscriptionUpdateWithWhereUniqueWithoutPlanInput | ClinicSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: ClinicSubscriptionUpdateManyWithWhereWithoutPlanInput | ClinicSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: ClinicSubscriptionScalarWhereInput | ClinicSubscriptionScalarWhereInput[]
  }

  export type ClinicAddOnSubscriptionCreateNestedManyWithoutAddOnInput = {
    create?: XOR<ClinicAddOnSubscriptionCreateWithoutAddOnInput, ClinicAddOnSubscriptionUncheckedCreateWithoutAddOnInput> | ClinicAddOnSubscriptionCreateWithoutAddOnInput[] | ClinicAddOnSubscriptionUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: ClinicAddOnSubscriptionCreateOrConnectWithoutAddOnInput | ClinicAddOnSubscriptionCreateOrConnectWithoutAddOnInput[]
    createMany?: ClinicAddOnSubscriptionCreateManyAddOnInputEnvelope
    connect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
  }

  export type ClinicAddOnSubscriptionUncheckedCreateNestedManyWithoutAddOnInput = {
    create?: XOR<ClinicAddOnSubscriptionCreateWithoutAddOnInput, ClinicAddOnSubscriptionUncheckedCreateWithoutAddOnInput> | ClinicAddOnSubscriptionCreateWithoutAddOnInput[] | ClinicAddOnSubscriptionUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: ClinicAddOnSubscriptionCreateOrConnectWithoutAddOnInput | ClinicAddOnSubscriptionCreateOrConnectWithoutAddOnInput[]
    createMany?: ClinicAddOnSubscriptionCreateManyAddOnInputEnvelope
    connect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
  }

  export type EnumAddOnTypeFieldUpdateOperationsInput = {
    set?: $Enums.AddOnType
  }

  export type ClinicAddOnSubscriptionUpdateManyWithoutAddOnNestedInput = {
    create?: XOR<ClinicAddOnSubscriptionCreateWithoutAddOnInput, ClinicAddOnSubscriptionUncheckedCreateWithoutAddOnInput> | ClinicAddOnSubscriptionCreateWithoutAddOnInput[] | ClinicAddOnSubscriptionUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: ClinicAddOnSubscriptionCreateOrConnectWithoutAddOnInput | ClinicAddOnSubscriptionCreateOrConnectWithoutAddOnInput[]
    upsert?: ClinicAddOnSubscriptionUpsertWithWhereUniqueWithoutAddOnInput | ClinicAddOnSubscriptionUpsertWithWhereUniqueWithoutAddOnInput[]
    createMany?: ClinicAddOnSubscriptionCreateManyAddOnInputEnvelope
    set?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    disconnect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    delete?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    connect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    update?: ClinicAddOnSubscriptionUpdateWithWhereUniqueWithoutAddOnInput | ClinicAddOnSubscriptionUpdateWithWhereUniqueWithoutAddOnInput[]
    updateMany?: ClinicAddOnSubscriptionUpdateManyWithWhereWithoutAddOnInput | ClinicAddOnSubscriptionUpdateManyWithWhereWithoutAddOnInput[]
    deleteMany?: ClinicAddOnSubscriptionScalarWhereInput | ClinicAddOnSubscriptionScalarWhereInput[]
  }

  export type ClinicAddOnSubscriptionUncheckedUpdateManyWithoutAddOnNestedInput = {
    create?: XOR<ClinicAddOnSubscriptionCreateWithoutAddOnInput, ClinicAddOnSubscriptionUncheckedCreateWithoutAddOnInput> | ClinicAddOnSubscriptionCreateWithoutAddOnInput[] | ClinicAddOnSubscriptionUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: ClinicAddOnSubscriptionCreateOrConnectWithoutAddOnInput | ClinicAddOnSubscriptionCreateOrConnectWithoutAddOnInput[]
    upsert?: ClinicAddOnSubscriptionUpsertWithWhereUniqueWithoutAddOnInput | ClinicAddOnSubscriptionUpsertWithWhereUniqueWithoutAddOnInput[]
    createMany?: ClinicAddOnSubscriptionCreateManyAddOnInputEnvelope
    set?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    disconnect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    delete?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    connect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    update?: ClinicAddOnSubscriptionUpdateWithWhereUniqueWithoutAddOnInput | ClinicAddOnSubscriptionUpdateWithWhereUniqueWithoutAddOnInput[]
    updateMany?: ClinicAddOnSubscriptionUpdateManyWithWhereWithoutAddOnInput | ClinicAddOnSubscriptionUpdateManyWithWhereWithoutAddOnInput[]
    deleteMany?: ClinicAddOnSubscriptionScalarWhereInput | ClinicAddOnSubscriptionScalarWhereInput[]
  }

  export type ClinicCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<ClinicCreateWithoutSubscriptionsInput, ClinicUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutSubscriptionsInput
    connect?: ClinicWhereUniqueInput
  }

  export type ClinicPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<ClinicPlanCreateWithoutSubscriptionsInput, ClinicPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ClinicPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: ClinicPlanWhereUniqueInput
  }

  export type ClinicAddOnSubscriptionCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<ClinicAddOnSubscriptionCreateWithoutSubscriptionInput, ClinicAddOnSubscriptionUncheckedCreateWithoutSubscriptionInput> | ClinicAddOnSubscriptionCreateWithoutSubscriptionInput[] | ClinicAddOnSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ClinicAddOnSubscriptionCreateOrConnectWithoutSubscriptionInput | ClinicAddOnSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: ClinicAddOnSubscriptionCreateManySubscriptionInputEnvelope
    connect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
  }

  export type ClinicAddOnSubscriptionUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<ClinicAddOnSubscriptionCreateWithoutSubscriptionInput, ClinicAddOnSubscriptionUncheckedCreateWithoutSubscriptionInput> | ClinicAddOnSubscriptionCreateWithoutSubscriptionInput[] | ClinicAddOnSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ClinicAddOnSubscriptionCreateOrConnectWithoutSubscriptionInput | ClinicAddOnSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: ClinicAddOnSubscriptionCreateManySubscriptionInputEnvelope
    connect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type ClinicUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<ClinicCreateWithoutSubscriptionsInput, ClinicUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutSubscriptionsInput
    upsert?: ClinicUpsertWithoutSubscriptionsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutSubscriptionsInput, ClinicUpdateWithoutSubscriptionsInput>, ClinicUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ClinicPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<ClinicPlanCreateWithoutSubscriptionsInput, ClinicPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ClinicPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: ClinicPlanUpsertWithoutSubscriptionsInput
    connect?: ClinicPlanWhereUniqueInput
    update?: XOR<XOR<ClinicPlanUpdateToOneWithWhereWithoutSubscriptionsInput, ClinicPlanUpdateWithoutSubscriptionsInput>, ClinicPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ClinicAddOnSubscriptionUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<ClinicAddOnSubscriptionCreateWithoutSubscriptionInput, ClinicAddOnSubscriptionUncheckedCreateWithoutSubscriptionInput> | ClinicAddOnSubscriptionCreateWithoutSubscriptionInput[] | ClinicAddOnSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ClinicAddOnSubscriptionCreateOrConnectWithoutSubscriptionInput | ClinicAddOnSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: ClinicAddOnSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput | ClinicAddOnSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: ClinicAddOnSubscriptionCreateManySubscriptionInputEnvelope
    set?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    disconnect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    delete?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    connect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    update?: ClinicAddOnSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput | ClinicAddOnSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: ClinicAddOnSubscriptionUpdateManyWithWhereWithoutSubscriptionInput | ClinicAddOnSubscriptionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: ClinicAddOnSubscriptionScalarWhereInput | ClinicAddOnSubscriptionScalarWhereInput[]
  }

  export type ClinicAddOnSubscriptionUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<ClinicAddOnSubscriptionCreateWithoutSubscriptionInput, ClinicAddOnSubscriptionUncheckedCreateWithoutSubscriptionInput> | ClinicAddOnSubscriptionCreateWithoutSubscriptionInput[] | ClinicAddOnSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ClinicAddOnSubscriptionCreateOrConnectWithoutSubscriptionInput | ClinicAddOnSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: ClinicAddOnSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput | ClinicAddOnSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: ClinicAddOnSubscriptionCreateManySubscriptionInputEnvelope
    set?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    disconnect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    delete?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    connect?: ClinicAddOnSubscriptionWhereUniqueInput | ClinicAddOnSubscriptionWhereUniqueInput[]
    update?: ClinicAddOnSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput | ClinicAddOnSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: ClinicAddOnSubscriptionUpdateManyWithWhereWithoutSubscriptionInput | ClinicAddOnSubscriptionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: ClinicAddOnSubscriptionScalarWhereInput | ClinicAddOnSubscriptionScalarWhereInput[]
  }

  export type ClinicSubscriptionCreateNestedOneWithoutAddOnsInput = {
    create?: XOR<ClinicSubscriptionCreateWithoutAddOnsInput, ClinicSubscriptionUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: ClinicSubscriptionCreateOrConnectWithoutAddOnsInput
    connect?: ClinicSubscriptionWhereUniqueInput
  }

  export type ClinicAddOnCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<ClinicAddOnCreateWithoutSubscriptionsInput, ClinicAddOnUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ClinicAddOnCreateOrConnectWithoutSubscriptionsInput
    connect?: ClinicAddOnWhereUniqueInput
  }

  export type ClinicSubscriptionUpdateOneRequiredWithoutAddOnsNestedInput = {
    create?: XOR<ClinicSubscriptionCreateWithoutAddOnsInput, ClinicSubscriptionUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: ClinicSubscriptionCreateOrConnectWithoutAddOnsInput
    upsert?: ClinicSubscriptionUpsertWithoutAddOnsInput
    connect?: ClinicSubscriptionWhereUniqueInput
    update?: XOR<XOR<ClinicSubscriptionUpdateToOneWithWhereWithoutAddOnsInput, ClinicSubscriptionUpdateWithoutAddOnsInput>, ClinicSubscriptionUncheckedUpdateWithoutAddOnsInput>
  }

  export type ClinicAddOnUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<ClinicAddOnCreateWithoutSubscriptionsInput, ClinicAddOnUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ClinicAddOnCreateOrConnectWithoutSubscriptionsInput
    upsert?: ClinicAddOnUpsertWithoutSubscriptionsInput
    connect?: ClinicAddOnWhereUniqueInput
    update?: XOR<XOR<ClinicAddOnUpdateToOneWithWhereWithoutSubscriptionsInput, ClinicAddOnUpdateWithoutSubscriptionsInput>, ClinicAddOnUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserCreateNestedOneWithoutCreated_categoriesInput = {
    create?: XOR<UserCreateWithoutCreated_categoriesInput, UserUncheckedCreateWithoutCreated_categoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreated_categoriesInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoriesOnProductsCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoriesOnProductsCreateWithoutCategoryInput, CategoriesOnProductsUncheckedCreateWithoutCategoryInput> | CategoriesOnProductsCreateWithoutCategoryInput[] | CategoriesOnProductsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoriesOnProductsCreateOrConnectWithoutCategoryInput | CategoriesOnProductsCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoriesOnProductsCreateManyCategoryInputEnvelope
    connect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoriesOnProductsUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoriesOnProductsCreateWithoutCategoryInput, CategoriesOnProductsUncheckedCreateWithoutCategoryInput> | CategoriesOnProductsCreateWithoutCategoryInput[] | CategoriesOnProductsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoriesOnProductsCreateOrConnectWithoutCategoryInput | CategoriesOnProductsCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoriesOnProductsCreateManyCategoryInputEnvelope
    connect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCreated_categoriesNestedInput = {
    create?: XOR<UserCreateWithoutCreated_categoriesInput, UserUncheckedCreateWithoutCreated_categoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreated_categoriesInput
    upsert?: UserUpsertWithoutCreated_categoriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreated_categoriesInput, UserUpdateWithoutCreated_categoriesInput>, UserUncheckedUpdateWithoutCreated_categoriesInput>
  }

  export type ProductUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductCategoryInput | ProductUpsertWithWhereUniqueWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductCategoryInput | ProductUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductCategoryInput | ProductUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoriesOnProductsUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoriesOnProductsCreateWithoutCategoryInput, CategoriesOnProductsUncheckedCreateWithoutCategoryInput> | CategoriesOnProductsCreateWithoutCategoryInput[] | CategoriesOnProductsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoriesOnProductsCreateOrConnectWithoutCategoryInput | CategoriesOnProductsCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoriesOnProductsUpsertWithWhereUniqueWithoutCategoryInput | CategoriesOnProductsUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoriesOnProductsCreateManyCategoryInputEnvelope
    set?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    disconnect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    delete?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    connect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    update?: CategoriesOnProductsUpdateWithWhereUniqueWithoutCategoryInput | CategoriesOnProductsUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoriesOnProductsUpdateManyWithWhereWithoutCategoryInput | CategoriesOnProductsUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoriesOnProductsScalarWhereInput | CategoriesOnProductsScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductCategoryInput | ProductUpsertWithWhereUniqueWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductCategoryInput | ProductUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductCategoryInput | ProductUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoriesOnProductsUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoriesOnProductsCreateWithoutCategoryInput, CategoriesOnProductsUncheckedCreateWithoutCategoryInput> | CategoriesOnProductsCreateWithoutCategoryInput[] | CategoriesOnProductsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoriesOnProductsCreateOrConnectWithoutCategoryInput | CategoriesOnProductsCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoriesOnProductsUpsertWithWhereUniqueWithoutCategoryInput | CategoriesOnProductsUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoriesOnProductsCreateManyCategoryInputEnvelope
    set?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    disconnect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    delete?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    connect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    update?: CategoriesOnProductsUpdateWithWhereUniqueWithoutCategoryInput | CategoriesOnProductsUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoriesOnProductsUpdateManyWithWhereWithoutCategoryInput | CategoriesOnProductsUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoriesOnProductsScalarWhereInput | CategoriesOnProductsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCreated_productsInput = {
    create?: XOR<UserCreateWithoutCreated_productsInput, UserUncheckedCreateWithoutCreated_productsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreated_productsInput
    connect?: UserWhereUniqueInput
  }

  export type ClinicCreateNestedOneWithoutProductsInput = {
    create?: XOR<ClinicCreateWithoutProductsInput, ClinicUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutProductsInput
    connect?: ClinicWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type PurchaseCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type CategoriesOnProductsCreateNestedManyWithoutProductInput = {
    create?: XOR<CategoriesOnProductsCreateWithoutProductInput, CategoriesOnProductsUncheckedCreateWithoutProductInput> | CategoriesOnProductsCreateWithoutProductInput[] | CategoriesOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CategoriesOnProductsCreateOrConnectWithoutProductInput | CategoriesOnProductsCreateOrConnectWithoutProductInput[]
    createMany?: CategoriesOnProductsCreateManyProductInputEnvelope
    connect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
  }

  export type OfferCreateNestedManyWithoutProductInput = {
    create?: XOR<OfferCreateWithoutProductInput, OfferUncheckedCreateWithoutProductInput> | OfferCreateWithoutProductInput[] | OfferUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutProductInput | OfferCreateOrConnectWithoutProductInput[]
    createMany?: OfferCreateManyProductInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type ProductIntegrationCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductIntegrationCreateWithoutProductInput, ProductIntegrationUncheckedCreateWithoutProductInput> | ProductIntegrationCreateWithoutProductInput[] | ProductIntegrationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductIntegrationCreateOrConnectWithoutProductInput | ProductIntegrationCreateOrConnectWithoutProductInput[]
    createMany?: ProductIntegrationCreateManyProductInputEnvelope
    connect?: ProductIntegrationWhereUniqueInput | ProductIntegrationWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type CategoriesOnProductsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CategoriesOnProductsCreateWithoutProductInput, CategoriesOnProductsUncheckedCreateWithoutProductInput> | CategoriesOnProductsCreateWithoutProductInput[] | CategoriesOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CategoriesOnProductsCreateOrConnectWithoutProductInput | CategoriesOnProductsCreateOrConnectWithoutProductInput[]
    createMany?: CategoriesOnProductsCreateManyProductInputEnvelope
    connect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
  }

  export type OfferUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OfferCreateWithoutProductInput, OfferUncheckedCreateWithoutProductInput> | OfferCreateWithoutProductInput[] | OfferUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutProductInput | OfferCreateOrConnectWithoutProductInput[]
    createMany?: OfferCreateManyProductInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type ProductIntegrationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductIntegrationCreateWithoutProductInput, ProductIntegrationUncheckedCreateWithoutProductInput> | ProductIntegrationCreateWithoutProductInput[] | ProductIntegrationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductIntegrationCreateOrConnectWithoutProductInput | ProductIntegrationCreateOrConnectWithoutProductInput[]
    createMany?: ProductIntegrationCreateManyProductInputEnvelope
    connect?: ProductIntegrationWhereUniqueInput | ProductIntegrationWhereUniqueInput[]
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type NullableEnumSubscriptionIntervalFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionInterval | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneWithoutCreated_productsNestedInput = {
    create?: XOR<UserCreateWithoutCreated_productsInput, UserUncheckedCreateWithoutCreated_productsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreated_productsInput
    upsert?: UserUpsertWithoutCreated_productsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreated_productsInput, UserUpdateWithoutCreated_productsInput>, UserUncheckedUpdateWithoutCreated_productsInput>
  }

  export type ClinicUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ClinicCreateWithoutProductsInput, ClinicUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutProductsInput
    upsert?: ClinicUpsertWithoutProductsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutProductsInput, ClinicUpdateWithoutProductsInput>, ClinicUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type PurchaseUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutProductInput | PurchaseUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutProductInput | PurchaseUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutProductInput | PurchaseUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type CategoriesOnProductsUpdateManyWithoutProductNestedInput = {
    create?: XOR<CategoriesOnProductsCreateWithoutProductInput, CategoriesOnProductsUncheckedCreateWithoutProductInput> | CategoriesOnProductsCreateWithoutProductInput[] | CategoriesOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CategoriesOnProductsCreateOrConnectWithoutProductInput | CategoriesOnProductsCreateOrConnectWithoutProductInput[]
    upsert?: CategoriesOnProductsUpsertWithWhereUniqueWithoutProductInput | CategoriesOnProductsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CategoriesOnProductsCreateManyProductInputEnvelope
    set?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    disconnect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    delete?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    connect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    update?: CategoriesOnProductsUpdateWithWhereUniqueWithoutProductInput | CategoriesOnProductsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CategoriesOnProductsUpdateManyWithWhereWithoutProductInput | CategoriesOnProductsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CategoriesOnProductsScalarWhereInput | CategoriesOnProductsScalarWhereInput[]
  }

  export type OfferUpdateManyWithoutProductNestedInput = {
    create?: XOR<OfferCreateWithoutProductInput, OfferUncheckedCreateWithoutProductInput> | OfferCreateWithoutProductInput[] | OfferUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutProductInput | OfferCreateOrConnectWithoutProductInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutProductInput | OfferUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OfferCreateManyProductInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutProductInput | OfferUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutProductInput | OfferUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type ProductIntegrationUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductIntegrationCreateWithoutProductInput, ProductIntegrationUncheckedCreateWithoutProductInput> | ProductIntegrationCreateWithoutProductInput[] | ProductIntegrationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductIntegrationCreateOrConnectWithoutProductInput | ProductIntegrationCreateOrConnectWithoutProductInput[]
    upsert?: ProductIntegrationUpsertWithWhereUniqueWithoutProductInput | ProductIntegrationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductIntegrationCreateManyProductInputEnvelope
    set?: ProductIntegrationWhereUniqueInput | ProductIntegrationWhereUniqueInput[]
    disconnect?: ProductIntegrationWhereUniqueInput | ProductIntegrationWhereUniqueInput[]
    delete?: ProductIntegrationWhereUniqueInput | ProductIntegrationWhereUniqueInput[]
    connect?: ProductIntegrationWhereUniqueInput | ProductIntegrationWhereUniqueInput[]
    update?: ProductIntegrationUpdateWithWhereUniqueWithoutProductInput | ProductIntegrationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductIntegrationUpdateManyWithWhereWithoutProductInput | ProductIntegrationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductIntegrationScalarWhereInput | ProductIntegrationScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutProductInput | PurchaseUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutProductInput | PurchaseUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutProductInput | PurchaseUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type CategoriesOnProductsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CategoriesOnProductsCreateWithoutProductInput, CategoriesOnProductsUncheckedCreateWithoutProductInput> | CategoriesOnProductsCreateWithoutProductInput[] | CategoriesOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CategoriesOnProductsCreateOrConnectWithoutProductInput | CategoriesOnProductsCreateOrConnectWithoutProductInput[]
    upsert?: CategoriesOnProductsUpsertWithWhereUniqueWithoutProductInput | CategoriesOnProductsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CategoriesOnProductsCreateManyProductInputEnvelope
    set?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    disconnect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    delete?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    connect?: CategoriesOnProductsWhereUniqueInput | CategoriesOnProductsWhereUniqueInput[]
    update?: CategoriesOnProductsUpdateWithWhereUniqueWithoutProductInput | CategoriesOnProductsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CategoriesOnProductsUpdateManyWithWhereWithoutProductInput | CategoriesOnProductsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CategoriesOnProductsScalarWhereInput | CategoriesOnProductsScalarWhereInput[]
  }

  export type OfferUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OfferCreateWithoutProductInput, OfferUncheckedCreateWithoutProductInput> | OfferCreateWithoutProductInput[] | OfferUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutProductInput | OfferCreateOrConnectWithoutProductInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutProductInput | OfferUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OfferCreateManyProductInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutProductInput | OfferUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutProductInput | OfferUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type ProductIntegrationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductIntegrationCreateWithoutProductInput, ProductIntegrationUncheckedCreateWithoutProductInput> | ProductIntegrationCreateWithoutProductInput[] | ProductIntegrationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductIntegrationCreateOrConnectWithoutProductInput | ProductIntegrationCreateOrConnectWithoutProductInput[]
    upsert?: ProductIntegrationUpsertWithWhereUniqueWithoutProductInput | ProductIntegrationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductIntegrationCreateManyProductInputEnvelope
    set?: ProductIntegrationWhereUniqueInput | ProductIntegrationWhereUniqueInput[]
    disconnect?: ProductIntegrationWhereUniqueInput | ProductIntegrationWhereUniqueInput[]
    delete?: ProductIntegrationWhereUniqueInput | ProductIntegrationWhereUniqueInput[]
    connect?: ProductIntegrationWhereUniqueInput | ProductIntegrationWhereUniqueInput[]
    update?: ProductIntegrationUpdateWithWhereUniqueWithoutProductInput | ProductIntegrationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductIntegrationUpdateManyWithWhereWithoutProductInput | ProductIntegrationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductIntegrationScalarWhereInput | ProductIntegrationScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoriesInput, ProductCategoryUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput
    upsert?: ProductUpsertWithoutCategoriesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCategoriesInput, ProductUpdateWithoutCategoriesInput>, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductCategoryUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoriesInput, ProductCategoryUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoriesInput
    upsert?: ProductCategoryUpsertWithoutCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutCategoriesInput, ProductCategoryUpdateWithoutCategoriesInput>, ProductCategoryUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductCreateNestedOneWithoutOffersInput = {
    create?: XOR<ProductCreateWithoutOffersInput, ProductUncheckedCreateWithoutOffersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOffersInput
    connect?: ProductWhereUniqueInput
  }

  export type OfferPaymentMethodCreateNestedManyWithoutOfferInput = {
    create?: XOR<OfferPaymentMethodCreateWithoutOfferInput, OfferPaymentMethodUncheckedCreateWithoutOfferInput> | OfferPaymentMethodCreateWithoutOfferInput[] | OfferPaymentMethodUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferPaymentMethodCreateOrConnectWithoutOfferInput | OfferPaymentMethodCreateOrConnectWithoutOfferInput[]
    createMany?: OfferPaymentMethodCreateManyOfferInputEnvelope
    connect?: OfferPaymentMethodWhereUniqueInput | OfferPaymentMethodWhereUniqueInput[]
  }

  export type OfferPriceCreateNestedManyWithoutOfferInput = {
    create?: XOR<OfferPriceCreateWithoutOfferInput, OfferPriceUncheckedCreateWithoutOfferInput> | OfferPriceCreateWithoutOfferInput[] | OfferPriceUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferPriceCreateOrConnectWithoutOfferInput | OfferPriceCreateOrConnectWithoutOfferInput[]
    createMany?: OfferPriceCreateManyOfferInputEnvelope
    connect?: OfferPriceWhereUniqueInput | OfferPriceWhereUniqueInput[]
  }

  export type OfferPaymentMethodUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<OfferPaymentMethodCreateWithoutOfferInput, OfferPaymentMethodUncheckedCreateWithoutOfferInput> | OfferPaymentMethodCreateWithoutOfferInput[] | OfferPaymentMethodUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferPaymentMethodCreateOrConnectWithoutOfferInput | OfferPaymentMethodCreateOrConnectWithoutOfferInput[]
    createMany?: OfferPaymentMethodCreateManyOfferInputEnvelope
    connect?: OfferPaymentMethodWhereUniqueInput | OfferPaymentMethodWhereUniqueInput[]
  }

  export type OfferPriceUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<OfferPriceCreateWithoutOfferInput, OfferPriceUncheckedCreateWithoutOfferInput> | OfferPriceCreateWithoutOfferInput[] | OfferPriceUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferPriceCreateOrConnectWithoutOfferInput | OfferPriceCreateOrConnectWithoutOfferInput[]
    createMany?: OfferPriceCreateManyOfferInputEnvelope
    connect?: OfferPriceWhereUniqueInput | OfferPriceWhereUniqueInput[]
  }

  export type EnumCurrencyFieldUpdateOperationsInput = {
    set?: $Enums.Currency
  }

  export type NullableEnumPaymentProviderFieldUpdateOperationsInput = {
    set?: $Enums.PaymentProvider | null
  }

  export type ProductUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<ProductCreateWithoutOffersInput, ProductUncheckedCreateWithoutOffersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOffersInput
    upsert?: ProductUpsertWithoutOffersInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOffersInput, ProductUpdateWithoutOffersInput>, ProductUncheckedUpdateWithoutOffersInput>
  }

  export type OfferPaymentMethodUpdateManyWithoutOfferNestedInput = {
    create?: XOR<OfferPaymentMethodCreateWithoutOfferInput, OfferPaymentMethodUncheckedCreateWithoutOfferInput> | OfferPaymentMethodCreateWithoutOfferInput[] | OfferPaymentMethodUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferPaymentMethodCreateOrConnectWithoutOfferInput | OfferPaymentMethodCreateOrConnectWithoutOfferInput[]
    upsert?: OfferPaymentMethodUpsertWithWhereUniqueWithoutOfferInput | OfferPaymentMethodUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: OfferPaymentMethodCreateManyOfferInputEnvelope
    set?: OfferPaymentMethodWhereUniqueInput | OfferPaymentMethodWhereUniqueInput[]
    disconnect?: OfferPaymentMethodWhereUniqueInput | OfferPaymentMethodWhereUniqueInput[]
    delete?: OfferPaymentMethodWhereUniqueInput | OfferPaymentMethodWhereUniqueInput[]
    connect?: OfferPaymentMethodWhereUniqueInput | OfferPaymentMethodWhereUniqueInput[]
    update?: OfferPaymentMethodUpdateWithWhereUniqueWithoutOfferInput | OfferPaymentMethodUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: OfferPaymentMethodUpdateManyWithWhereWithoutOfferInput | OfferPaymentMethodUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: OfferPaymentMethodScalarWhereInput | OfferPaymentMethodScalarWhereInput[]
  }

  export type OfferPriceUpdateManyWithoutOfferNestedInput = {
    create?: XOR<OfferPriceCreateWithoutOfferInput, OfferPriceUncheckedCreateWithoutOfferInput> | OfferPriceCreateWithoutOfferInput[] | OfferPriceUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferPriceCreateOrConnectWithoutOfferInput | OfferPriceCreateOrConnectWithoutOfferInput[]
    upsert?: OfferPriceUpsertWithWhereUniqueWithoutOfferInput | OfferPriceUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: OfferPriceCreateManyOfferInputEnvelope
    set?: OfferPriceWhereUniqueInput | OfferPriceWhereUniqueInput[]
    disconnect?: OfferPriceWhereUniqueInput | OfferPriceWhereUniqueInput[]
    delete?: OfferPriceWhereUniqueInput | OfferPriceWhereUniqueInput[]
    connect?: OfferPriceWhereUniqueInput | OfferPriceWhereUniqueInput[]
    update?: OfferPriceUpdateWithWhereUniqueWithoutOfferInput | OfferPriceUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: OfferPriceUpdateManyWithWhereWithoutOfferInput | OfferPriceUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: OfferPriceScalarWhereInput | OfferPriceScalarWhereInput[]
  }

  export type OfferPaymentMethodUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<OfferPaymentMethodCreateWithoutOfferInput, OfferPaymentMethodUncheckedCreateWithoutOfferInput> | OfferPaymentMethodCreateWithoutOfferInput[] | OfferPaymentMethodUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferPaymentMethodCreateOrConnectWithoutOfferInput | OfferPaymentMethodCreateOrConnectWithoutOfferInput[]
    upsert?: OfferPaymentMethodUpsertWithWhereUniqueWithoutOfferInput | OfferPaymentMethodUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: OfferPaymentMethodCreateManyOfferInputEnvelope
    set?: OfferPaymentMethodWhereUniqueInput | OfferPaymentMethodWhereUniqueInput[]
    disconnect?: OfferPaymentMethodWhereUniqueInput | OfferPaymentMethodWhereUniqueInput[]
    delete?: OfferPaymentMethodWhereUniqueInput | OfferPaymentMethodWhereUniqueInput[]
    connect?: OfferPaymentMethodWhereUniqueInput | OfferPaymentMethodWhereUniqueInput[]
    update?: OfferPaymentMethodUpdateWithWhereUniqueWithoutOfferInput | OfferPaymentMethodUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: OfferPaymentMethodUpdateManyWithWhereWithoutOfferInput | OfferPaymentMethodUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: OfferPaymentMethodScalarWhereInput | OfferPaymentMethodScalarWhereInput[]
  }

  export type OfferPriceUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<OfferPriceCreateWithoutOfferInput, OfferPriceUncheckedCreateWithoutOfferInput> | OfferPriceCreateWithoutOfferInput[] | OfferPriceUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferPriceCreateOrConnectWithoutOfferInput | OfferPriceCreateOrConnectWithoutOfferInput[]
    upsert?: OfferPriceUpsertWithWhereUniqueWithoutOfferInput | OfferPriceUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: OfferPriceCreateManyOfferInputEnvelope
    set?: OfferPriceWhereUniqueInput | OfferPriceWhereUniqueInput[]
    disconnect?: OfferPriceWhereUniqueInput | OfferPriceWhereUniqueInput[]
    delete?: OfferPriceWhereUniqueInput | OfferPriceWhereUniqueInput[]
    connect?: OfferPriceWhereUniqueInput | OfferPriceWhereUniqueInput[]
    update?: OfferPriceUpdateWithWhereUniqueWithoutOfferInput | OfferPriceUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: OfferPriceUpdateManyWithWhereWithoutOfferInput | OfferPriceUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: OfferPriceScalarWhereInput | OfferPriceScalarWhereInput[]
  }

  export type OfferCreateNestedOneWithoutPricesInput = {
    create?: XOR<OfferCreateWithoutPricesInput, OfferUncheckedCreateWithoutPricesInput>
    connectOrCreate?: OfferCreateOrConnectWithoutPricesInput
    connect?: OfferWhereUniqueInput
  }

  export type OfferUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<OfferCreateWithoutPricesInput, OfferUncheckedCreateWithoutPricesInput>
    connectOrCreate?: OfferCreateOrConnectWithoutPricesInput
    upsert?: OfferUpsertWithoutPricesInput
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutPricesInput, OfferUpdateWithoutPricesInput>, OfferUncheckedUpdateWithoutPricesInput>
  }

  export type OfferCreateNestedOneWithoutPaymentMethodsInput = {
    create?: XOR<OfferCreateWithoutPaymentMethodsInput, OfferUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutPaymentMethodsInput
    connect?: OfferWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OfferUpdateOneRequiredWithoutPaymentMethodsNestedInput = {
    create?: XOR<OfferCreateWithoutPaymentMethodsInput, OfferUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutPaymentMethodsInput
    upsert?: OfferUpsertWithoutPaymentMethodsInput
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutPaymentMethodsInput, OfferUpdateWithoutPaymentMethodsInput>, OfferUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type ProductCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<ProductCreateWithoutIntegrationsInput, ProductUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntegrationsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<ProductCreateWithoutIntegrationsInput, ProductUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntegrationsInput
    upsert?: ProductUpsertWithoutIntegrationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutIntegrationsInput, ProductUpdateWithoutIntegrationsInput>, ProductUncheckedUpdateWithoutIntegrationsInput>
  }

  export type PaymentTransactionCreateNestedOneWithoutCheckoutSessionInput = {
    create?: XOR<PaymentTransactionCreateWithoutCheckoutSessionInput, PaymentTransactionUncheckedCreateWithoutCheckoutSessionInput>
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutCheckoutSessionInput
    connect?: PaymentTransactionWhereUniqueInput
  }

  export type EnumCheckoutSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.CheckoutSessionStatus
  }

  export type NullableEnumCheckoutPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.CheckoutPaymentMethod | null
  }

  export type PaymentTransactionUpdateOneWithoutCheckoutSessionNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutCheckoutSessionInput, PaymentTransactionUncheckedCreateWithoutCheckoutSessionInput>
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutCheckoutSessionInput
    upsert?: PaymentTransactionUpsertWithoutCheckoutSessionInput
    disconnect?: PaymentTransactionWhereInput | boolean
    delete?: PaymentTransactionWhereInput | boolean
    connect?: PaymentTransactionWhereUniqueInput
    update?: XOR<XOR<PaymentTransactionUpdateToOneWithWhereWithoutCheckoutSessionInput, PaymentTransactionUpdateWithoutCheckoutSessionInput>, PaymentTransactionUncheckedUpdateWithoutCheckoutSessionInput>
  }

  export type CheckoutSessionCreateNestedOneWithoutPaymentTransactionInput = {
    create?: XOR<CheckoutSessionCreateWithoutPaymentTransactionInput, CheckoutSessionUncheckedCreateWithoutPaymentTransactionInput>
    connectOrCreate?: CheckoutSessionCreateOrConnectWithoutPaymentTransactionInput
    connect?: CheckoutSessionWhereUniqueInput
  }

  export type CheckoutSessionUncheckedCreateNestedOneWithoutPaymentTransactionInput = {
    create?: XOR<CheckoutSessionCreateWithoutPaymentTransactionInput, CheckoutSessionUncheckedCreateWithoutPaymentTransactionInput>
    connectOrCreate?: CheckoutSessionCreateOrConnectWithoutPaymentTransactionInput
    connect?: CheckoutSessionWhereUniqueInput
  }

  export type NullableEnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus | null
  }

  export type CheckoutSessionUpdateOneWithoutPaymentTransactionNestedInput = {
    create?: XOR<CheckoutSessionCreateWithoutPaymentTransactionInput, CheckoutSessionUncheckedCreateWithoutPaymentTransactionInput>
    connectOrCreate?: CheckoutSessionCreateOrConnectWithoutPaymentTransactionInput
    upsert?: CheckoutSessionUpsertWithoutPaymentTransactionInput
    disconnect?: CheckoutSessionWhereInput | boolean
    delete?: CheckoutSessionWhereInput | boolean
    connect?: CheckoutSessionWhereUniqueInput
    update?: XOR<XOR<CheckoutSessionUpdateToOneWithWhereWithoutPaymentTransactionInput, CheckoutSessionUpdateWithoutPaymentTransactionInput>, CheckoutSessionUncheckedUpdateWithoutPaymentTransactionInput>
  }

  export type CheckoutSessionUncheckedUpdateOneWithoutPaymentTransactionNestedInput = {
    create?: XOR<CheckoutSessionCreateWithoutPaymentTransactionInput, CheckoutSessionUncheckedCreateWithoutPaymentTransactionInput>
    connectOrCreate?: CheckoutSessionCreateOrConnectWithoutPaymentTransactionInput
    upsert?: CheckoutSessionUpsertWithoutPaymentTransactionInput
    disconnect?: CheckoutSessionWhereInput | boolean
    delete?: CheckoutSessionWhereInput | boolean
    connect?: CheckoutSessionWhereUniqueInput
    update?: XOR<XOR<CheckoutSessionUpdateToOneWithWhereWithoutPaymentTransactionInput, CheckoutSessionUpdateWithoutPaymentTransactionInput>, CheckoutSessionUncheckedUpdateWithoutPaymentTransactionInput>
  }

  export type UserCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDoctorPurchasesInput = {
    create?: XOR<UserCreateWithoutDoctorPurchasesInput, UserUncheckedCreateWithoutDoctorPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorPurchasesInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchasesInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    upsert?: UserUpsertWithoutPurchasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchasesInput, UserUpdateWithoutPurchasesInput>, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserUpdateOneRequiredWithoutDoctorPurchasesNestedInput = {
    create?: XOR<UserCreateWithoutDoctorPurchasesInput, UserUncheckedCreateWithoutDoctorPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorPurchasesInput
    upsert?: UserUpsertWithoutDoctorPurchasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorPurchasesInput, UserUpdateWithoutDoctorPurchasesInput>, UserUncheckedUpdateWithoutDoctorPurchasesInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchasesInput
    upsert?: ProductUpsertWithoutPurchasesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchasesInput, ProductUpdateWithoutPurchasesInput>, ProductUncheckedUpdateWithoutPurchasesInput>
  }

  export type CustomerProviderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerProviderCreateWithoutCustomerInput, CustomerProviderUncheckedCreateWithoutCustomerInput> | CustomerProviderCreateWithoutCustomerInput[] | CustomerProviderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProviderCreateOrConnectWithoutCustomerInput | CustomerProviderCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerProviderCreateManyCustomerInputEnvelope
    connect?: CustomerProviderWhereUniqueInput | CustomerProviderWhereUniqueInput[]
  }

  export type CustomerPaymentMethodCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerPaymentMethodCreateWithoutCustomerInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerInput> | CustomerPaymentMethodCreateWithoutCustomerInput[] | CustomerPaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPaymentMethodCreateOrConnectWithoutCustomerInput | CustomerPaymentMethodCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerPaymentMethodCreateManyCustomerInputEnvelope
    connect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
  }

  export type CustomerSubscriptionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerSubscriptionCreateWithoutCustomerInput, CustomerSubscriptionUncheckedCreateWithoutCustomerInput> | CustomerSubscriptionCreateWithoutCustomerInput[] | CustomerSubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerSubscriptionCreateOrConnectWithoutCustomerInput | CustomerSubscriptionCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerSubscriptionCreateManyCustomerInputEnvelope
    connect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
  }

  export type CustomerProviderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerProviderCreateWithoutCustomerInput, CustomerProviderUncheckedCreateWithoutCustomerInput> | CustomerProviderCreateWithoutCustomerInput[] | CustomerProviderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProviderCreateOrConnectWithoutCustomerInput | CustomerProviderCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerProviderCreateManyCustomerInputEnvelope
    connect?: CustomerProviderWhereUniqueInput | CustomerProviderWhereUniqueInput[]
  }

  export type CustomerPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerPaymentMethodCreateWithoutCustomerInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerInput> | CustomerPaymentMethodCreateWithoutCustomerInput[] | CustomerPaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPaymentMethodCreateOrConnectWithoutCustomerInput | CustomerPaymentMethodCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerPaymentMethodCreateManyCustomerInputEnvelope
    connect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
  }

  export type CustomerSubscriptionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerSubscriptionCreateWithoutCustomerInput, CustomerSubscriptionUncheckedCreateWithoutCustomerInput> | CustomerSubscriptionCreateWithoutCustomerInput[] | CustomerSubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerSubscriptionCreateOrConnectWithoutCustomerInput | CustomerSubscriptionCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerSubscriptionCreateManyCustomerInputEnvelope
    connect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
  }

  export type CustomerProviderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerProviderCreateWithoutCustomerInput, CustomerProviderUncheckedCreateWithoutCustomerInput> | CustomerProviderCreateWithoutCustomerInput[] | CustomerProviderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProviderCreateOrConnectWithoutCustomerInput | CustomerProviderCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerProviderUpsertWithWhereUniqueWithoutCustomerInput | CustomerProviderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerProviderCreateManyCustomerInputEnvelope
    set?: CustomerProviderWhereUniqueInput | CustomerProviderWhereUniqueInput[]
    disconnect?: CustomerProviderWhereUniqueInput | CustomerProviderWhereUniqueInput[]
    delete?: CustomerProviderWhereUniqueInput | CustomerProviderWhereUniqueInput[]
    connect?: CustomerProviderWhereUniqueInput | CustomerProviderWhereUniqueInput[]
    update?: CustomerProviderUpdateWithWhereUniqueWithoutCustomerInput | CustomerProviderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerProviderUpdateManyWithWhereWithoutCustomerInput | CustomerProviderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerProviderScalarWhereInput | CustomerProviderScalarWhereInput[]
  }

  export type CustomerPaymentMethodUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerPaymentMethodCreateWithoutCustomerInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerInput> | CustomerPaymentMethodCreateWithoutCustomerInput[] | CustomerPaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPaymentMethodCreateOrConnectWithoutCustomerInput | CustomerPaymentMethodCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerPaymentMethodUpsertWithWhereUniqueWithoutCustomerInput | CustomerPaymentMethodUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerPaymentMethodCreateManyCustomerInputEnvelope
    set?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    disconnect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    delete?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    connect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    update?: CustomerPaymentMethodUpdateWithWhereUniqueWithoutCustomerInput | CustomerPaymentMethodUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerPaymentMethodUpdateManyWithWhereWithoutCustomerInput | CustomerPaymentMethodUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerPaymentMethodScalarWhereInput | CustomerPaymentMethodScalarWhereInput[]
  }

  export type CustomerSubscriptionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerSubscriptionCreateWithoutCustomerInput, CustomerSubscriptionUncheckedCreateWithoutCustomerInput> | CustomerSubscriptionCreateWithoutCustomerInput[] | CustomerSubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerSubscriptionCreateOrConnectWithoutCustomerInput | CustomerSubscriptionCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerSubscriptionUpsertWithWhereUniqueWithoutCustomerInput | CustomerSubscriptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerSubscriptionCreateManyCustomerInputEnvelope
    set?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    disconnect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    delete?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    connect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    update?: CustomerSubscriptionUpdateWithWhereUniqueWithoutCustomerInput | CustomerSubscriptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerSubscriptionUpdateManyWithWhereWithoutCustomerInput | CustomerSubscriptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerSubscriptionScalarWhereInput | CustomerSubscriptionScalarWhereInput[]
  }

  export type CustomerProviderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerProviderCreateWithoutCustomerInput, CustomerProviderUncheckedCreateWithoutCustomerInput> | CustomerProviderCreateWithoutCustomerInput[] | CustomerProviderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProviderCreateOrConnectWithoutCustomerInput | CustomerProviderCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerProviderUpsertWithWhereUniqueWithoutCustomerInput | CustomerProviderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerProviderCreateManyCustomerInputEnvelope
    set?: CustomerProviderWhereUniqueInput | CustomerProviderWhereUniqueInput[]
    disconnect?: CustomerProviderWhereUniqueInput | CustomerProviderWhereUniqueInput[]
    delete?: CustomerProviderWhereUniqueInput | CustomerProviderWhereUniqueInput[]
    connect?: CustomerProviderWhereUniqueInput | CustomerProviderWhereUniqueInput[]
    update?: CustomerProviderUpdateWithWhereUniqueWithoutCustomerInput | CustomerProviderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerProviderUpdateManyWithWhereWithoutCustomerInput | CustomerProviderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerProviderScalarWhereInput | CustomerProviderScalarWhereInput[]
  }

  export type CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerPaymentMethodCreateWithoutCustomerInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerInput> | CustomerPaymentMethodCreateWithoutCustomerInput[] | CustomerPaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerPaymentMethodCreateOrConnectWithoutCustomerInput | CustomerPaymentMethodCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerPaymentMethodUpsertWithWhereUniqueWithoutCustomerInput | CustomerPaymentMethodUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerPaymentMethodCreateManyCustomerInputEnvelope
    set?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    disconnect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    delete?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    connect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    update?: CustomerPaymentMethodUpdateWithWhereUniqueWithoutCustomerInput | CustomerPaymentMethodUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerPaymentMethodUpdateManyWithWhereWithoutCustomerInput | CustomerPaymentMethodUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerPaymentMethodScalarWhereInput | CustomerPaymentMethodScalarWhereInput[]
  }

  export type CustomerSubscriptionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerSubscriptionCreateWithoutCustomerInput, CustomerSubscriptionUncheckedCreateWithoutCustomerInput> | CustomerSubscriptionCreateWithoutCustomerInput[] | CustomerSubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerSubscriptionCreateOrConnectWithoutCustomerInput | CustomerSubscriptionCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerSubscriptionUpsertWithWhereUniqueWithoutCustomerInput | CustomerSubscriptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerSubscriptionCreateManyCustomerInputEnvelope
    set?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    disconnect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    delete?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    connect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    update?: CustomerSubscriptionUpdateWithWhereUniqueWithoutCustomerInput | CustomerSubscriptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerSubscriptionUpdateManyWithWhereWithoutCustomerInput | CustomerSubscriptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerSubscriptionScalarWhereInput | CustomerSubscriptionScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutProvidersInput = {
    create?: XOR<CustomerCreateWithoutProvidersInput, CustomerUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProvidersInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerPaymentMethodCreateNestedManyWithoutCustomerProviderInput = {
    create?: XOR<CustomerPaymentMethodCreateWithoutCustomerProviderInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerProviderInput> | CustomerPaymentMethodCreateWithoutCustomerProviderInput[] | CustomerPaymentMethodUncheckedCreateWithoutCustomerProviderInput[]
    connectOrCreate?: CustomerPaymentMethodCreateOrConnectWithoutCustomerProviderInput | CustomerPaymentMethodCreateOrConnectWithoutCustomerProviderInput[]
    createMany?: CustomerPaymentMethodCreateManyCustomerProviderInputEnvelope
    connect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
  }

  export type CustomerSubscriptionCreateNestedManyWithoutCustomerProviderInput = {
    create?: XOR<CustomerSubscriptionCreateWithoutCustomerProviderInput, CustomerSubscriptionUncheckedCreateWithoutCustomerProviderInput> | CustomerSubscriptionCreateWithoutCustomerProviderInput[] | CustomerSubscriptionUncheckedCreateWithoutCustomerProviderInput[]
    connectOrCreate?: CustomerSubscriptionCreateOrConnectWithoutCustomerProviderInput | CustomerSubscriptionCreateOrConnectWithoutCustomerProviderInput[]
    createMany?: CustomerSubscriptionCreateManyCustomerProviderInputEnvelope
    connect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
  }

  export type CustomerPaymentMethodUncheckedCreateNestedManyWithoutCustomerProviderInput = {
    create?: XOR<CustomerPaymentMethodCreateWithoutCustomerProviderInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerProviderInput> | CustomerPaymentMethodCreateWithoutCustomerProviderInput[] | CustomerPaymentMethodUncheckedCreateWithoutCustomerProviderInput[]
    connectOrCreate?: CustomerPaymentMethodCreateOrConnectWithoutCustomerProviderInput | CustomerPaymentMethodCreateOrConnectWithoutCustomerProviderInput[]
    createMany?: CustomerPaymentMethodCreateManyCustomerProviderInputEnvelope
    connect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
  }

  export type CustomerSubscriptionUncheckedCreateNestedManyWithoutCustomerProviderInput = {
    create?: XOR<CustomerSubscriptionCreateWithoutCustomerProviderInput, CustomerSubscriptionUncheckedCreateWithoutCustomerProviderInput> | CustomerSubscriptionCreateWithoutCustomerProviderInput[] | CustomerSubscriptionUncheckedCreateWithoutCustomerProviderInput[]
    connectOrCreate?: CustomerSubscriptionCreateOrConnectWithoutCustomerProviderInput | CustomerSubscriptionCreateOrConnectWithoutCustomerProviderInput[]
    createMany?: CustomerSubscriptionCreateManyCustomerProviderInputEnvelope
    connect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
  }

  export type CustomerUpdateOneRequiredWithoutProvidersNestedInput = {
    create?: XOR<CustomerCreateWithoutProvidersInput, CustomerUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProvidersInput
    upsert?: CustomerUpsertWithoutProvidersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutProvidersInput, CustomerUpdateWithoutProvidersInput>, CustomerUncheckedUpdateWithoutProvidersInput>
  }

  export type CustomerPaymentMethodUpdateManyWithoutCustomerProviderNestedInput = {
    create?: XOR<CustomerPaymentMethodCreateWithoutCustomerProviderInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerProviderInput> | CustomerPaymentMethodCreateWithoutCustomerProviderInput[] | CustomerPaymentMethodUncheckedCreateWithoutCustomerProviderInput[]
    connectOrCreate?: CustomerPaymentMethodCreateOrConnectWithoutCustomerProviderInput | CustomerPaymentMethodCreateOrConnectWithoutCustomerProviderInput[]
    upsert?: CustomerPaymentMethodUpsertWithWhereUniqueWithoutCustomerProviderInput | CustomerPaymentMethodUpsertWithWhereUniqueWithoutCustomerProviderInput[]
    createMany?: CustomerPaymentMethodCreateManyCustomerProviderInputEnvelope
    set?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    disconnect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    delete?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    connect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    update?: CustomerPaymentMethodUpdateWithWhereUniqueWithoutCustomerProviderInput | CustomerPaymentMethodUpdateWithWhereUniqueWithoutCustomerProviderInput[]
    updateMany?: CustomerPaymentMethodUpdateManyWithWhereWithoutCustomerProviderInput | CustomerPaymentMethodUpdateManyWithWhereWithoutCustomerProviderInput[]
    deleteMany?: CustomerPaymentMethodScalarWhereInput | CustomerPaymentMethodScalarWhereInput[]
  }

  export type CustomerSubscriptionUpdateManyWithoutCustomerProviderNestedInput = {
    create?: XOR<CustomerSubscriptionCreateWithoutCustomerProviderInput, CustomerSubscriptionUncheckedCreateWithoutCustomerProviderInput> | CustomerSubscriptionCreateWithoutCustomerProviderInput[] | CustomerSubscriptionUncheckedCreateWithoutCustomerProviderInput[]
    connectOrCreate?: CustomerSubscriptionCreateOrConnectWithoutCustomerProviderInput | CustomerSubscriptionCreateOrConnectWithoutCustomerProviderInput[]
    upsert?: CustomerSubscriptionUpsertWithWhereUniqueWithoutCustomerProviderInput | CustomerSubscriptionUpsertWithWhereUniqueWithoutCustomerProviderInput[]
    createMany?: CustomerSubscriptionCreateManyCustomerProviderInputEnvelope
    set?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    disconnect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    delete?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    connect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    update?: CustomerSubscriptionUpdateWithWhereUniqueWithoutCustomerProviderInput | CustomerSubscriptionUpdateWithWhereUniqueWithoutCustomerProviderInput[]
    updateMany?: CustomerSubscriptionUpdateManyWithWhereWithoutCustomerProviderInput | CustomerSubscriptionUpdateManyWithWhereWithoutCustomerProviderInput[]
    deleteMany?: CustomerSubscriptionScalarWhereInput | CustomerSubscriptionScalarWhereInput[]
  }

  export type CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerProviderNestedInput = {
    create?: XOR<CustomerPaymentMethodCreateWithoutCustomerProviderInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerProviderInput> | CustomerPaymentMethodCreateWithoutCustomerProviderInput[] | CustomerPaymentMethodUncheckedCreateWithoutCustomerProviderInput[]
    connectOrCreate?: CustomerPaymentMethodCreateOrConnectWithoutCustomerProviderInput | CustomerPaymentMethodCreateOrConnectWithoutCustomerProviderInput[]
    upsert?: CustomerPaymentMethodUpsertWithWhereUniqueWithoutCustomerProviderInput | CustomerPaymentMethodUpsertWithWhereUniqueWithoutCustomerProviderInput[]
    createMany?: CustomerPaymentMethodCreateManyCustomerProviderInputEnvelope
    set?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    disconnect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    delete?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    connect?: CustomerPaymentMethodWhereUniqueInput | CustomerPaymentMethodWhereUniqueInput[]
    update?: CustomerPaymentMethodUpdateWithWhereUniqueWithoutCustomerProviderInput | CustomerPaymentMethodUpdateWithWhereUniqueWithoutCustomerProviderInput[]
    updateMany?: CustomerPaymentMethodUpdateManyWithWhereWithoutCustomerProviderInput | CustomerPaymentMethodUpdateManyWithWhereWithoutCustomerProviderInput[]
    deleteMany?: CustomerPaymentMethodScalarWhereInput | CustomerPaymentMethodScalarWhereInput[]
  }

  export type CustomerSubscriptionUncheckedUpdateManyWithoutCustomerProviderNestedInput = {
    create?: XOR<CustomerSubscriptionCreateWithoutCustomerProviderInput, CustomerSubscriptionUncheckedCreateWithoutCustomerProviderInput> | CustomerSubscriptionCreateWithoutCustomerProviderInput[] | CustomerSubscriptionUncheckedCreateWithoutCustomerProviderInput[]
    connectOrCreate?: CustomerSubscriptionCreateOrConnectWithoutCustomerProviderInput | CustomerSubscriptionCreateOrConnectWithoutCustomerProviderInput[]
    upsert?: CustomerSubscriptionUpsertWithWhereUniqueWithoutCustomerProviderInput | CustomerSubscriptionUpsertWithWhereUniqueWithoutCustomerProviderInput[]
    createMany?: CustomerSubscriptionCreateManyCustomerProviderInputEnvelope
    set?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    disconnect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    delete?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    connect?: CustomerSubscriptionWhereUniqueInput | CustomerSubscriptionWhereUniqueInput[]
    update?: CustomerSubscriptionUpdateWithWhereUniqueWithoutCustomerProviderInput | CustomerSubscriptionUpdateWithWhereUniqueWithoutCustomerProviderInput[]
    updateMany?: CustomerSubscriptionUpdateManyWithWhereWithoutCustomerProviderInput | CustomerSubscriptionUpdateManyWithWhereWithoutCustomerProviderInput[]
    deleteMany?: CustomerSubscriptionScalarWhereInput | CustomerSubscriptionScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutPaymentMethodsInput = {
    create?: XOR<CustomerCreateWithoutPaymentMethodsInput, CustomerUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentMethodsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerProviderCreateNestedOneWithoutPaymentMethodsInput = {
    create?: XOR<CustomerProviderCreateWithoutPaymentMethodsInput, CustomerProviderUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: CustomerProviderCreateOrConnectWithoutPaymentMethodsInput
    connect?: CustomerProviderWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutPaymentMethodsNestedInput = {
    create?: XOR<CustomerCreateWithoutPaymentMethodsInput, CustomerUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentMethodsInput
    upsert?: CustomerUpsertWithoutPaymentMethodsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPaymentMethodsInput, CustomerUpdateWithoutPaymentMethodsInput>, CustomerUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type CustomerProviderUpdateOneWithoutPaymentMethodsNestedInput = {
    create?: XOR<CustomerProviderCreateWithoutPaymentMethodsInput, CustomerProviderUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: CustomerProviderCreateOrConnectWithoutPaymentMethodsInput
    upsert?: CustomerProviderUpsertWithoutPaymentMethodsInput
    disconnect?: CustomerProviderWhereInput | boolean
    delete?: CustomerProviderWhereInput | boolean
    connect?: CustomerProviderWhereUniqueInput
    update?: XOR<XOR<CustomerProviderUpdateToOneWithWhereWithoutPaymentMethodsInput, CustomerProviderUpdateWithoutPaymentMethodsInput>, CustomerProviderUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type CustomerCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerProviderCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<CustomerProviderCreateWithoutSubscriptionsInput, CustomerProviderUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CustomerProviderCreateOrConnectWithoutSubscriptionsInput
    connect?: CustomerProviderWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionsInput
    upsert?: CustomerUpsertWithoutSubscriptionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSubscriptionsInput, CustomerUpdateWithoutSubscriptionsInput>, CustomerUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CustomerProviderUpdateOneWithoutSubscriptionsNestedInput = {
    create?: XOR<CustomerProviderCreateWithoutSubscriptionsInput, CustomerProviderUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CustomerProviderCreateOrConnectWithoutSubscriptionsInput
    upsert?: CustomerProviderUpsertWithoutSubscriptionsInput
    disconnect?: CustomerProviderWhereInput | boolean
    delete?: CustomerProviderWhereInput | boolean
    connect?: CustomerProviderWhereUniqueInput
    update?: XOR<XOR<CustomerProviderUpdateToOneWithWhereWithoutSubscriptionsInput, CustomerProviderUpdateWithoutSubscriptionsInput>, CustomerProviderUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type MessageTemplateCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutMessage_templatesInput = {
    create?: XOR<UserCreateWithoutMessage_templatesInput, UserUncheckedCreateWithoutMessage_templatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_templatesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageSequenceStepCreateNestedManyWithoutTemplateInput = {
    create?: XOR<MessageSequenceStepCreateWithoutTemplateInput, MessageSequenceStepUncheckedCreateWithoutTemplateInput> | MessageSequenceStepCreateWithoutTemplateInput[] | MessageSequenceStepUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: MessageSequenceStepCreateOrConnectWithoutTemplateInput | MessageSequenceStepCreateOrConnectWithoutTemplateInput[]
    createMany?: MessageSequenceStepCreateManyTemplateInputEnvelope
    connect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
  }

  export type MessageSequenceStepUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<MessageSequenceStepCreateWithoutTemplateInput, MessageSequenceStepUncheckedCreateWithoutTemplateInput> | MessageSequenceStepCreateWithoutTemplateInput[] | MessageSequenceStepUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: MessageSequenceStepCreateOrConnectWithoutTemplateInput | MessageSequenceStepCreateOrConnectWithoutTemplateInput[]
    createMany?: MessageSequenceStepCreateManyTemplateInputEnvelope
    connect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
  }

  export type MessageTemplateUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutMessage_templatesNestedInput = {
    create?: XOR<UserCreateWithoutMessage_templatesInput, UserUncheckedCreateWithoutMessage_templatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_templatesInput
    upsert?: UserUpsertWithoutMessage_templatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessage_templatesInput, UserUpdateWithoutMessage_templatesInput>, UserUncheckedUpdateWithoutMessage_templatesInput>
  }

  export type MessageSequenceStepUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<MessageSequenceStepCreateWithoutTemplateInput, MessageSequenceStepUncheckedCreateWithoutTemplateInput> | MessageSequenceStepCreateWithoutTemplateInput[] | MessageSequenceStepUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: MessageSequenceStepCreateOrConnectWithoutTemplateInput | MessageSequenceStepCreateOrConnectWithoutTemplateInput[]
    upsert?: MessageSequenceStepUpsertWithWhereUniqueWithoutTemplateInput | MessageSequenceStepUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: MessageSequenceStepCreateManyTemplateInputEnvelope
    set?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    disconnect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    delete?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    connect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    update?: MessageSequenceStepUpdateWithWhereUniqueWithoutTemplateInput | MessageSequenceStepUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: MessageSequenceStepUpdateManyWithWhereWithoutTemplateInput | MessageSequenceStepUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: MessageSequenceStepScalarWhereInput | MessageSequenceStepScalarWhereInput[]
  }

  export type MessageSequenceStepUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<MessageSequenceStepCreateWithoutTemplateInput, MessageSequenceStepUncheckedCreateWithoutTemplateInput> | MessageSequenceStepCreateWithoutTemplateInput[] | MessageSequenceStepUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: MessageSequenceStepCreateOrConnectWithoutTemplateInput | MessageSequenceStepCreateOrConnectWithoutTemplateInput[]
    upsert?: MessageSequenceStepUpsertWithWhereUniqueWithoutTemplateInput | MessageSequenceStepUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: MessageSequenceStepCreateManyTemplateInputEnvelope
    set?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    disconnect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    delete?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    connect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    update?: MessageSequenceStepUpdateWithWhereUniqueWithoutTemplateInput | MessageSequenceStepUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: MessageSequenceStepUpdateManyWithWhereWithoutTemplateInput | MessageSequenceStepUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: MessageSequenceStepScalarWhereInput | MessageSequenceStepScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMessage_sequencesInput = {
    create?: XOR<UserCreateWithoutMessage_sequencesInput, UserUncheckedCreateWithoutMessage_sequencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_sequencesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageSequenceStepCreateNestedManyWithoutSequenceInput = {
    create?: XOR<MessageSequenceStepCreateWithoutSequenceInput, MessageSequenceStepUncheckedCreateWithoutSequenceInput> | MessageSequenceStepCreateWithoutSequenceInput[] | MessageSequenceStepUncheckedCreateWithoutSequenceInput[]
    connectOrCreate?: MessageSequenceStepCreateOrConnectWithoutSequenceInput | MessageSequenceStepCreateOrConnectWithoutSequenceInput[]
    createMany?: MessageSequenceStepCreateManySequenceInputEnvelope
    connect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
  }

  export type MessageSequenceStepUncheckedCreateNestedManyWithoutSequenceInput = {
    create?: XOR<MessageSequenceStepCreateWithoutSequenceInput, MessageSequenceStepUncheckedCreateWithoutSequenceInput> | MessageSequenceStepCreateWithoutSequenceInput[] | MessageSequenceStepUncheckedCreateWithoutSequenceInput[]
    connectOrCreate?: MessageSequenceStepCreateOrConnectWithoutSequenceInput | MessageSequenceStepCreateOrConnectWithoutSequenceInput[]
    createMany?: MessageSequenceStepCreateManySequenceInputEnvelope
    connect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMessage_sequencesNestedInput = {
    create?: XOR<UserCreateWithoutMessage_sequencesInput, UserUncheckedCreateWithoutMessage_sequencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_sequencesInput
    upsert?: UserUpsertWithoutMessage_sequencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessage_sequencesInput, UserUpdateWithoutMessage_sequencesInput>, UserUncheckedUpdateWithoutMessage_sequencesInput>
  }

  export type MessageSequenceStepUpdateManyWithoutSequenceNestedInput = {
    create?: XOR<MessageSequenceStepCreateWithoutSequenceInput, MessageSequenceStepUncheckedCreateWithoutSequenceInput> | MessageSequenceStepCreateWithoutSequenceInput[] | MessageSequenceStepUncheckedCreateWithoutSequenceInput[]
    connectOrCreate?: MessageSequenceStepCreateOrConnectWithoutSequenceInput | MessageSequenceStepCreateOrConnectWithoutSequenceInput[]
    upsert?: MessageSequenceStepUpsertWithWhereUniqueWithoutSequenceInput | MessageSequenceStepUpsertWithWhereUniqueWithoutSequenceInput[]
    createMany?: MessageSequenceStepCreateManySequenceInputEnvelope
    set?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    disconnect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    delete?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    connect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    update?: MessageSequenceStepUpdateWithWhereUniqueWithoutSequenceInput | MessageSequenceStepUpdateWithWhereUniqueWithoutSequenceInput[]
    updateMany?: MessageSequenceStepUpdateManyWithWhereWithoutSequenceInput | MessageSequenceStepUpdateManyWithWhereWithoutSequenceInput[]
    deleteMany?: MessageSequenceStepScalarWhereInput | MessageSequenceStepScalarWhereInput[]
  }

  export type MessageSequenceStepUncheckedUpdateManyWithoutSequenceNestedInput = {
    create?: XOR<MessageSequenceStepCreateWithoutSequenceInput, MessageSequenceStepUncheckedCreateWithoutSequenceInput> | MessageSequenceStepCreateWithoutSequenceInput[] | MessageSequenceStepUncheckedCreateWithoutSequenceInput[]
    connectOrCreate?: MessageSequenceStepCreateOrConnectWithoutSequenceInput | MessageSequenceStepCreateOrConnectWithoutSequenceInput[]
    upsert?: MessageSequenceStepUpsertWithWhereUniqueWithoutSequenceInput | MessageSequenceStepUpsertWithWhereUniqueWithoutSequenceInput[]
    createMany?: MessageSequenceStepCreateManySequenceInputEnvelope
    set?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    disconnect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    delete?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    connect?: MessageSequenceStepWhereUniqueInput | MessageSequenceStepWhereUniqueInput[]
    update?: MessageSequenceStepUpdateWithWhereUniqueWithoutSequenceInput | MessageSequenceStepUpdateWithWhereUniqueWithoutSequenceInput[]
    updateMany?: MessageSequenceStepUpdateManyWithWhereWithoutSequenceInput | MessageSequenceStepUpdateManyWithWhereWithoutSequenceInput[]
    deleteMany?: MessageSequenceStepScalarWhereInput | MessageSequenceStepScalarWhereInput[]
  }

  export type MessageSequenceCreateNestedOneWithoutStepsInput = {
    create?: XOR<MessageSequenceCreateWithoutStepsInput, MessageSequenceUncheckedCreateWithoutStepsInput>
    connectOrCreate?: MessageSequenceCreateOrConnectWithoutStepsInput
    connect?: MessageSequenceWhereUniqueInput
  }

  export type MessageTemplateCreateNestedOneWithoutStepsInput = {
    create?: XOR<MessageTemplateCreateWithoutStepsInput, MessageTemplateUncheckedCreateWithoutStepsInput>
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutStepsInput
    connect?: MessageTemplateWhereUniqueInput
  }

  export type MessageSequenceUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<MessageSequenceCreateWithoutStepsInput, MessageSequenceUncheckedCreateWithoutStepsInput>
    connectOrCreate?: MessageSequenceCreateOrConnectWithoutStepsInput
    upsert?: MessageSequenceUpsertWithoutStepsInput
    connect?: MessageSequenceWhereUniqueInput
    update?: XOR<XOR<MessageSequenceUpdateToOneWithWhereWithoutStepsInput, MessageSequenceUpdateWithoutStepsInput>, MessageSequenceUncheckedUpdateWithoutStepsInput>
  }

  export type MessageTemplateUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutStepsInput, MessageTemplateUncheckedCreateWithoutStepsInput>
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutStepsInput
    upsert?: MessageTemplateUpsertWithoutStepsInput
    connect?: MessageTemplateWhereUniqueInput
    update?: XOR<XOR<MessageTemplateUpdateToOneWithWhereWithoutStepsInput, MessageTemplateUpdateWithoutStepsInput>, MessageTemplateUncheckedUpdateWithoutStepsInput>
  }

  export type OpenFinanceConsentCreateNestedOneWithoutLinkInput = {
    create?: XOR<OpenFinanceConsentCreateWithoutLinkInput, OpenFinanceConsentUncheckedCreateWithoutLinkInput>
    connectOrCreate?: OpenFinanceConsentCreateOrConnectWithoutLinkInput
    connect?: OpenFinanceConsentWhereUniqueInput
  }

  export type OpenFinanceConsentUncheckedCreateNestedOneWithoutLinkInput = {
    create?: XOR<OpenFinanceConsentCreateWithoutLinkInput, OpenFinanceConsentUncheckedCreateWithoutLinkInput>
    connectOrCreate?: OpenFinanceConsentCreateOrConnectWithoutLinkInput
    connect?: OpenFinanceConsentWhereUniqueInput
  }

  export type OpenFinanceConsentUpdateOneWithoutLinkNestedInput = {
    create?: XOR<OpenFinanceConsentCreateWithoutLinkInput, OpenFinanceConsentUncheckedCreateWithoutLinkInput>
    connectOrCreate?: OpenFinanceConsentCreateOrConnectWithoutLinkInput
    upsert?: OpenFinanceConsentUpsertWithoutLinkInput
    disconnect?: OpenFinanceConsentWhereInput | boolean
    delete?: OpenFinanceConsentWhereInput | boolean
    connect?: OpenFinanceConsentWhereUniqueInput
    update?: XOR<XOR<OpenFinanceConsentUpdateToOneWithWhereWithoutLinkInput, OpenFinanceConsentUpdateWithoutLinkInput>, OpenFinanceConsentUncheckedUpdateWithoutLinkInput>
  }

  export type OpenFinanceConsentUncheckedUpdateOneWithoutLinkNestedInput = {
    create?: XOR<OpenFinanceConsentCreateWithoutLinkInput, OpenFinanceConsentUncheckedCreateWithoutLinkInput>
    connectOrCreate?: OpenFinanceConsentCreateOrConnectWithoutLinkInput
    upsert?: OpenFinanceConsentUpsertWithoutLinkInput
    disconnect?: OpenFinanceConsentWhereInput | boolean
    delete?: OpenFinanceConsentWhereInput | boolean
    connect?: OpenFinanceConsentWhereUniqueInput
    update?: XOR<XOR<OpenFinanceConsentUpdateToOneWithWhereWithoutLinkInput, OpenFinanceConsentUpdateWithoutLinkInput>, OpenFinanceConsentUncheckedUpdateWithoutLinkInput>
  }

  export type OpenFinanceLinkCreateNestedOneWithoutConsentInput = {
    create?: XOR<OpenFinanceLinkCreateWithoutConsentInput, OpenFinanceLinkUncheckedCreateWithoutConsentInput>
    connectOrCreate?: OpenFinanceLinkCreateOrConnectWithoutConsentInput
    connect?: OpenFinanceLinkWhereUniqueInput
  }

  export type OpenFinanceLinkUpdateOneRequiredWithoutConsentNestedInput = {
    create?: XOR<OpenFinanceLinkCreateWithoutConsentInput, OpenFinanceLinkUncheckedCreateWithoutConsentInput>
    connectOrCreate?: OpenFinanceLinkCreateOrConnectWithoutConsentInput
    upsert?: OpenFinanceLinkUpsertWithoutConsentInput
    connect?: OpenFinanceLinkWhereUniqueInput
    update?: XOR<XOR<OpenFinanceLinkUpdateToOneWithWhereWithoutConsentInput, OpenFinanceLinkUpdateWithoutConsentInput>, OpenFinanceLinkUncheckedUpdateWithoutConsentInput>
  }

  export type NullableEnumPaymentStatusOBFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatusOB | null
  }

  export type NullableEnumPaymentTypeOBFieldUpdateOperationsInput = {
    set?: $Enums.PaymentTypeOB | null
  }

  export type NullableEnumConsentStatusOBFieldUpdateOperationsInput = {
    set?: $Enums.ConsentStatusOB | null
  }

  export type NullableEnumEnrollmentStatusOBFieldUpdateOperationsInput = {
    set?: $Enums.EnrollmentStatusOB | null
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType
  }

  export type EnumEventActorFieldUpdateOperationsInput = {
    set?: $Enums.EventActor
  }

  export type WebhookEndpointCreateeventsInput = {
    set: string[]
  }

  export type WebhookEndpointCreatestatusFiltersInput = {
    set: string[]
  }

  export type WebhookEndpointCreateproductFiltersInput = {
    set: string[]
  }

  export type ClinicCreateNestedOneWithoutWebhookEndpointsInput = {
    create?: XOR<ClinicCreateWithoutWebhookEndpointsInput, ClinicUncheckedCreateWithoutWebhookEndpointsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutWebhookEndpointsInput
    connect?: ClinicWhereUniqueInput
  }

  export type OutboundWebhookDeliveryCreateNestedManyWithoutEndpointInput = {
    create?: XOR<OutboundWebhookDeliveryCreateWithoutEndpointInput, OutboundWebhookDeliveryUncheckedCreateWithoutEndpointInput> | OutboundWebhookDeliveryCreateWithoutEndpointInput[] | OutboundWebhookDeliveryUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: OutboundWebhookDeliveryCreateOrConnectWithoutEndpointInput | OutboundWebhookDeliveryCreateOrConnectWithoutEndpointInput[]
    createMany?: OutboundWebhookDeliveryCreateManyEndpointInputEnvelope
    connect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
  }

  export type OutboundWebhookDeliveryUncheckedCreateNestedManyWithoutEndpointInput = {
    create?: XOR<OutboundWebhookDeliveryCreateWithoutEndpointInput, OutboundWebhookDeliveryUncheckedCreateWithoutEndpointInput> | OutboundWebhookDeliveryCreateWithoutEndpointInput[] | OutboundWebhookDeliveryUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: OutboundWebhookDeliveryCreateOrConnectWithoutEndpointInput | OutboundWebhookDeliveryCreateOrConnectWithoutEndpointInput[]
    createMany?: OutboundWebhookDeliveryCreateManyEndpointInputEnvelope
    connect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookEndpointUpdateeventsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WebhookEndpointUpdatestatusFiltersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WebhookEndpointUpdateproductFiltersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClinicUpdateOneRequiredWithoutWebhookEndpointsNestedInput = {
    create?: XOR<ClinicCreateWithoutWebhookEndpointsInput, ClinicUncheckedCreateWithoutWebhookEndpointsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutWebhookEndpointsInput
    upsert?: ClinicUpsertWithoutWebhookEndpointsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutWebhookEndpointsInput, ClinicUpdateWithoutWebhookEndpointsInput>, ClinicUncheckedUpdateWithoutWebhookEndpointsInput>
  }

  export type OutboundWebhookDeliveryUpdateManyWithoutEndpointNestedInput = {
    create?: XOR<OutboundWebhookDeliveryCreateWithoutEndpointInput, OutboundWebhookDeliveryUncheckedCreateWithoutEndpointInput> | OutboundWebhookDeliveryCreateWithoutEndpointInput[] | OutboundWebhookDeliveryUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: OutboundWebhookDeliveryCreateOrConnectWithoutEndpointInput | OutboundWebhookDeliveryCreateOrConnectWithoutEndpointInput[]
    upsert?: OutboundWebhookDeliveryUpsertWithWhereUniqueWithoutEndpointInput | OutboundWebhookDeliveryUpsertWithWhereUniqueWithoutEndpointInput[]
    createMany?: OutboundWebhookDeliveryCreateManyEndpointInputEnvelope
    set?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    disconnect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    delete?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    connect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    update?: OutboundWebhookDeliveryUpdateWithWhereUniqueWithoutEndpointInput | OutboundWebhookDeliveryUpdateWithWhereUniqueWithoutEndpointInput[]
    updateMany?: OutboundWebhookDeliveryUpdateManyWithWhereWithoutEndpointInput | OutboundWebhookDeliveryUpdateManyWithWhereWithoutEndpointInput[]
    deleteMany?: OutboundWebhookDeliveryScalarWhereInput | OutboundWebhookDeliveryScalarWhereInput[]
  }

  export type OutboundWebhookDeliveryUncheckedUpdateManyWithoutEndpointNestedInput = {
    create?: XOR<OutboundWebhookDeliveryCreateWithoutEndpointInput, OutboundWebhookDeliveryUncheckedCreateWithoutEndpointInput> | OutboundWebhookDeliveryCreateWithoutEndpointInput[] | OutboundWebhookDeliveryUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: OutboundWebhookDeliveryCreateOrConnectWithoutEndpointInput | OutboundWebhookDeliveryCreateOrConnectWithoutEndpointInput[]
    upsert?: OutboundWebhookDeliveryUpsertWithWhereUniqueWithoutEndpointInput | OutboundWebhookDeliveryUpsertWithWhereUniqueWithoutEndpointInput[]
    createMany?: OutboundWebhookDeliveryCreateManyEndpointInputEnvelope
    set?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    disconnect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    delete?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    connect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    update?: OutboundWebhookDeliveryUpdateWithWhereUniqueWithoutEndpointInput | OutboundWebhookDeliveryUpdateWithWhereUniqueWithoutEndpointInput[]
    updateMany?: OutboundWebhookDeliveryUpdateManyWithWhereWithoutEndpointInput | OutboundWebhookDeliveryUpdateManyWithWhereWithoutEndpointInput[]
    deleteMany?: OutboundWebhookDeliveryScalarWhereInput | OutboundWebhookDeliveryScalarWhereInput[]
  }

  export type ClinicCreateNestedOneWithoutOutboundEventsInput = {
    create?: XOR<ClinicCreateWithoutOutboundEventsInput, ClinicUncheckedCreateWithoutOutboundEventsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutOutboundEventsInput
    connect?: ClinicWhereUniqueInput
  }

  export type OutboundWebhookDeliveryCreateNestedManyWithoutEventInput = {
    create?: XOR<OutboundWebhookDeliveryCreateWithoutEventInput, OutboundWebhookDeliveryUncheckedCreateWithoutEventInput> | OutboundWebhookDeliveryCreateWithoutEventInput[] | OutboundWebhookDeliveryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: OutboundWebhookDeliveryCreateOrConnectWithoutEventInput | OutboundWebhookDeliveryCreateOrConnectWithoutEventInput[]
    createMany?: OutboundWebhookDeliveryCreateManyEventInputEnvelope
    connect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
  }

  export type OutboundWebhookDeliveryUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<OutboundWebhookDeliveryCreateWithoutEventInput, OutboundWebhookDeliveryUncheckedCreateWithoutEventInput> | OutboundWebhookDeliveryCreateWithoutEventInput[] | OutboundWebhookDeliveryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: OutboundWebhookDeliveryCreateOrConnectWithoutEventInput | OutboundWebhookDeliveryCreateOrConnectWithoutEventInput[]
    createMany?: OutboundWebhookDeliveryCreateManyEventInputEnvelope
    connect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
  }

  export type ClinicUpdateOneRequiredWithoutOutboundEventsNestedInput = {
    create?: XOR<ClinicCreateWithoutOutboundEventsInput, ClinicUncheckedCreateWithoutOutboundEventsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutOutboundEventsInput
    upsert?: ClinicUpsertWithoutOutboundEventsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutOutboundEventsInput, ClinicUpdateWithoutOutboundEventsInput>, ClinicUncheckedUpdateWithoutOutboundEventsInput>
  }

  export type OutboundWebhookDeliveryUpdateManyWithoutEventNestedInput = {
    create?: XOR<OutboundWebhookDeliveryCreateWithoutEventInput, OutboundWebhookDeliveryUncheckedCreateWithoutEventInput> | OutboundWebhookDeliveryCreateWithoutEventInput[] | OutboundWebhookDeliveryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: OutboundWebhookDeliveryCreateOrConnectWithoutEventInput | OutboundWebhookDeliveryCreateOrConnectWithoutEventInput[]
    upsert?: OutboundWebhookDeliveryUpsertWithWhereUniqueWithoutEventInput | OutboundWebhookDeliveryUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: OutboundWebhookDeliveryCreateManyEventInputEnvelope
    set?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    disconnect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    delete?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    connect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    update?: OutboundWebhookDeliveryUpdateWithWhereUniqueWithoutEventInput | OutboundWebhookDeliveryUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: OutboundWebhookDeliveryUpdateManyWithWhereWithoutEventInput | OutboundWebhookDeliveryUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: OutboundWebhookDeliveryScalarWhereInput | OutboundWebhookDeliveryScalarWhereInput[]
  }

  export type OutboundWebhookDeliveryUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<OutboundWebhookDeliveryCreateWithoutEventInput, OutboundWebhookDeliveryUncheckedCreateWithoutEventInput> | OutboundWebhookDeliveryCreateWithoutEventInput[] | OutboundWebhookDeliveryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: OutboundWebhookDeliveryCreateOrConnectWithoutEventInput | OutboundWebhookDeliveryCreateOrConnectWithoutEventInput[]
    upsert?: OutboundWebhookDeliveryUpsertWithWhereUniqueWithoutEventInput | OutboundWebhookDeliveryUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: OutboundWebhookDeliveryCreateManyEventInputEnvelope
    set?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    disconnect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    delete?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    connect?: OutboundWebhookDeliveryWhereUniqueInput | OutboundWebhookDeliveryWhereUniqueInput[]
    update?: OutboundWebhookDeliveryUpdateWithWhereUniqueWithoutEventInput | OutboundWebhookDeliveryUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: OutboundWebhookDeliveryUpdateManyWithWhereWithoutEventInput | OutboundWebhookDeliveryUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: OutboundWebhookDeliveryScalarWhereInput | OutboundWebhookDeliveryScalarWhereInput[]
  }

  export type WebhookEndpointCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<WebhookEndpointCreateWithoutDeliveriesInput, WebhookEndpointUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookEndpointCreateOrConnectWithoutDeliveriesInput
    connect?: WebhookEndpointWhereUniqueInput
  }

  export type OutboundWebhookEventCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<OutboundWebhookEventCreateWithoutDeliveriesInput, OutboundWebhookEventUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: OutboundWebhookEventCreateOrConnectWithoutDeliveriesInput
    connect?: OutboundWebhookEventWhereUniqueInput
  }

  export type WebhookEndpointUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<WebhookEndpointCreateWithoutDeliveriesInput, WebhookEndpointUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookEndpointCreateOrConnectWithoutDeliveriesInput
    upsert?: WebhookEndpointUpsertWithoutDeliveriesInput
    connect?: WebhookEndpointWhereUniqueInput
    update?: XOR<XOR<WebhookEndpointUpdateToOneWithWhereWithoutDeliveriesInput, WebhookEndpointUpdateWithoutDeliveriesInput>, WebhookEndpointUncheckedUpdateWithoutDeliveriesInput>
  }

  export type OutboundWebhookEventUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<OutboundWebhookEventCreateWithoutDeliveriesInput, OutboundWebhookEventUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: OutboundWebhookEventCreateOrConnectWithoutDeliveriesInput
    upsert?: OutboundWebhookEventUpsertWithoutDeliveriesInput
    connect?: OutboundWebhookEventWhereUniqueInput
    update?: XOR<XOR<OutboundWebhookEventUpdateToOneWithWhereWithoutDeliveriesInput, OutboundWebhookEventUpdateWithoutDeliveriesInput>, OutboundWebhookEventUncheckedUpdateWithoutDeliveriesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumClinicThemeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicTheme | EnumClinicThemeFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicTheme[] | ListEnumClinicThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicTheme[] | ListEnumClinicThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicThemeFilter<$PrismaModel> | $Enums.ClinicTheme
  }

  export type NestedEnumClinicThemeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicTheme | EnumClinicThemeFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicTheme[] | ListEnumClinicThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicTheme[] | ListEnumClinicThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicThemeWithAggregatesFilter<$PrismaModel> | $Enums.ClinicTheme
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClinicThemeFilter<$PrismaModel>
    _max?: NestedEnumClinicThemeFilter<$PrismaModel>
  }

  export type NestedEnumClinicRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicRole | EnumClinicRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicRole[] | ListEnumClinicRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicRole[] | ListEnumClinicRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicRoleFilter<$PrismaModel> | $Enums.ClinicRole
  }

  export type NestedEnumClinicRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicRole | EnumClinicRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicRole[] | ListEnumClinicRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicRole[] | ListEnumClinicRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicRoleWithAggregatesFilter<$PrismaModel> | $Enums.ClinicRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClinicRoleFilter<$PrismaModel>
    _max?: NestedEnumClinicRoleFilter<$PrismaModel>
  }

  export type NestedEnumMerchantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantStatus | EnumMerchantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantStatus[] | ListEnumMerchantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantStatus[] | ListEnumMerchantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantStatusFilter<$PrismaModel> | $Enums.MerchantStatus
  }

  export type NestedEnumMerchantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantStatus | EnumMerchantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantStatus[] | ListEnumMerchantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantStatus[] | ListEnumMerchantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantStatusWithAggregatesFilter<$PrismaModel> | $Enums.MerchantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMerchantStatusFilter<$PrismaModel>
    _max?: NestedEnumMerchantStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMerchantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantType | EnumMerchantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantType[] | ListEnumMerchantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantType[] | ListEnumMerchantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantTypeFilter<$PrismaModel> | $Enums.MerchantType
  }

  export type NestedEnumMerchantAppStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantAppStatus | EnumMerchantAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantAppStatus[] | ListEnumMerchantAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantAppStatus[] | ListEnumMerchantAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantAppStatusFilter<$PrismaModel> | $Enums.MerchantAppStatus
  }

  export type NestedEnumMerchantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantType | EnumMerchantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantType[] | ListEnumMerchantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantType[] | ListEnumMerchantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantTypeWithAggregatesFilter<$PrismaModel> | $Enums.MerchantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMerchantTypeFilter<$PrismaModel>
    _max?: NestedEnumMerchantTypeFilter<$PrismaModel>
  }

  export type NestedEnumMerchantAppStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MerchantAppStatus | EnumMerchantAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MerchantAppStatus[] | ListEnumMerchantAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MerchantAppStatus[] | ListEnumMerchantAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMerchantAppStatusWithAggregatesFilter<$PrismaModel> | $Enums.MerchantAppStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMerchantAppStatusFilter<$PrismaModel>
    _max?: NestedEnumMerchantAppStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumPlanTierFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanTier | EnumPlanTierFieldRefInput<$PrismaModel>
    in?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTierFilter<$PrismaModel> | $Enums.PlanTier
  }

  export type NestedEnumPlanTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanTier | EnumPlanTierFieldRefInput<$PrismaModel>
    in?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTierWithAggregatesFilter<$PrismaModel> | $Enums.PlanTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTierFilter<$PrismaModel>
    _max?: NestedEnumPlanTierFilter<$PrismaModel>
  }

  export type NestedEnumAddOnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddOnTypeFilter<$PrismaModel> | $Enums.AddOnType
  }

  export type NestedEnumAddOnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddOnTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddOnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddOnTypeFilter<$PrismaModel>
    _max?: NestedEnumAddOnTypeFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedEnumSubscriptionIntervalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionIntervalNullableFilter<$PrismaModel> | $Enums.SubscriptionInterval | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionIntervalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionIntervalNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionInterval | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionIntervalNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionIntervalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumCurrencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyFilter<$PrismaModel> | $Enums.Currency
  }

  export type NestedEnumPaymentProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentProviderNullableFilter<$PrismaModel> | $Enums.PaymentProvider | null
  }

  export type NestedEnumCurrencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyWithAggregatesFilter<$PrismaModel> | $Enums.Currency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyFilter<$PrismaModel>
    _max?: NestedEnumCurrencyFilter<$PrismaModel>
  }

  export type NestedEnumPaymentProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCheckoutSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckoutSessionStatus | EnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CheckoutSessionStatus[] | ListEnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckoutSessionStatus[] | ListEnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckoutSessionStatusFilter<$PrismaModel> | $Enums.CheckoutSessionStatus
  }

  export type NestedEnumCheckoutPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckoutPaymentMethod | EnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.CheckoutPaymentMethod[] | ListEnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CheckoutPaymentMethod[] | ListEnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCheckoutPaymentMethodNullableFilter<$PrismaModel> | $Enums.CheckoutPaymentMethod | null
  }

  export type NestedEnumCheckoutSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckoutSessionStatus | EnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CheckoutSessionStatus[] | ListEnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckoutSessionStatus[] | ListEnumCheckoutSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckoutSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CheckoutSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCheckoutSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumCheckoutSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumCheckoutPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckoutPaymentMethod | EnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.CheckoutPaymentMethod[] | ListEnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CheckoutPaymentMethod[] | ListEnumCheckoutPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCheckoutPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.CheckoutPaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCheckoutPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumCheckoutPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableFilter<$PrismaModel> | $Enums.PaymentStatus | null
  }

  export type NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedEnumPaymentStatusOBNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusOB | EnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatusOB[] | ListEnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatusOB[] | ListEnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusOBNullableFilter<$PrismaModel> | $Enums.PaymentStatusOB | null
  }

  export type NestedEnumPaymentTypeOBNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentTypeOB | EnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentTypeOB[] | ListEnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentTypeOB[] | ListEnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentTypeOBNullableFilter<$PrismaModel> | $Enums.PaymentTypeOB | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusOBNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusOB | EnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatusOB[] | ListEnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatusOB[] | ListEnumPaymentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusOBNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatusOB | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusOBNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusOBNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeOBNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentTypeOB | EnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentTypeOB[] | ListEnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentTypeOB[] | ListEnumPaymentTypeOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentTypeOBNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentTypeOB | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeOBNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeOBNullableFilter<$PrismaModel>
  }

  export type NestedEnumConsentStatusOBNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatusOB | EnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConsentStatusOB[] | ListEnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConsentStatusOB[] | ListEnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConsentStatusOBNullableFilter<$PrismaModel> | $Enums.ConsentStatusOB | null
  }

  export type NestedEnumConsentStatusOBNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatusOB | EnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConsentStatusOB[] | ListEnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConsentStatusOB[] | ListEnumConsentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConsentStatusOBNullableWithAggregatesFilter<$PrismaModel> | $Enums.ConsentStatusOB | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumConsentStatusOBNullableFilter<$PrismaModel>
    _max?: NestedEnumConsentStatusOBNullableFilter<$PrismaModel>
  }

  export type NestedEnumEnrollmentStatusOBNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatusOB | EnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnrollmentStatusOB[] | ListEnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnrollmentStatusOB[] | ListEnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnrollmentStatusOBNullableFilter<$PrismaModel> | $Enums.EnrollmentStatusOB | null
  }

  export type NestedEnumEnrollmentStatusOBNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatusOB | EnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnrollmentStatusOB[] | ListEnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnrollmentStatusOB[] | ListEnumEnrollmentStatusOBFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnrollmentStatusOBNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnrollmentStatusOB | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnrollmentStatusOBNullableFilter<$PrismaModel>
    _max?: NestedEnumEnrollmentStatusOBNullableFilter<$PrismaModel>
  }

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type NestedEnumEventActorFilter<$PrismaModel = never> = {
    equals?: $Enums.EventActor | EnumEventActorFieldRefInput<$PrismaModel>
    in?: $Enums.EventActor[] | ListEnumEventActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventActor[] | ListEnumEventActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEventActorFilter<$PrismaModel> | $Enums.EventActor
  }

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumEventActorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventActor | EnumEventActorFieldRefInput<$PrismaModel>
    in?: $Enums.EventActor[] | ListEnumEventActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventActor[] | ListEnumEventActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEventActorWithAggregatesFilter<$PrismaModel> | $Enums.EventActor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventActorFilter<$PrismaModel>
    _max?: NestedEnumEventActorFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOther_usersInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutOther_usersInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutOther_usersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOther_usersInput, UserUncheckedCreateWithoutOther_usersInput>
  }

  export type UserCreateWithoutUserInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutUserInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput>
  }

  export type UserCreateManyUserInputEnvelope = {
    data: UserCreateManyUserInput | UserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClinicMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.ClinicRole
    isActive?: boolean
    joinedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutMembersInput
  }

  export type ClinicMemberUncheckedCreateWithoutUserInput = {
    id?: string
    clinicId: string
    role?: $Enums.ClinicRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type ClinicMemberCreateOrConnectWithoutUserInput = {
    where: ClinicMemberWhereUniqueInput
    create: XOR<ClinicMemberCreateWithoutUserInput, ClinicMemberUncheckedCreateWithoutUserInput>
  }

  export type ClinicMemberCreateManyUserInputEnvelope = {
    data: ClinicMemberCreateManyUserInput | ClinicMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClinicCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberCreateNestedManyWithoutClinicInput
    subscriptions?: ClinicSubscriptionCreateNestedManyWithoutClinicInput
    products?: ProductCreateNestedManyWithoutClinicInput
    merchant?: MerchantCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberUncheckedCreateNestedManyWithoutClinicInput
    subscriptions?: ClinicSubscriptionUncheckedCreateNestedManyWithoutClinicInput
    products?: ProductUncheckedCreateNestedManyWithoutClinicInput
    merchant?: MerchantUncheckedCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationUncheckedCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointUncheckedCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutOwnerInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutOwnerInput, ClinicUncheckedCreateWithoutOwnerInput>
  }

  export type ClinicCreateManyOwnerInputEnvelope = {
    data: ClinicCreateManyOwnerInput | ClinicCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutDoctorInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    confirmationUrl?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    clinic?: ClinicCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsCreateNestedManyWithoutProductInput
    offers?: OfferCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutDoctorInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    categoryId?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsUncheckedCreateNestedManyWithoutProductInput
    offers?: OfferUncheckedCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutDoctorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutDoctorInput, ProductUncheckedCreateWithoutDoctorInput>
  }

  export type ProductCreateManyDoctorInputEnvelope = {
    data: ProductCreateManyDoctorInput | ProductCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutDoctorInput = {
    id?: string
    name: string
    slug?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutProductCategoryInput
    categories?: CategoriesOnProductsCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutDoctorInput = {
    id?: string
    name: string
    slug?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
    categories?: CategoriesOnProductsUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutDoctorInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutDoctorInput, ProductCategoryUncheckedCreateWithoutDoctorInput>
  }

  export type ProductCategoryCreateManyDoctorInputEnvelope = {
    data: ProductCategoryCreateManyDoctorInput | ProductCategoryCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type VerificationCodeCreateWithoutUserInput = {
    id?: string
    code: string
    type: string
    created_at?: Date | string
    expires_at: Date | string
    used_at?: Date | string | null
    doctor: UserCreateNestedOneWithoutDoctor_verification_codesInput
  }

  export type VerificationCodeUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    doctor_id: string
    type: string
    created_at?: Date | string
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type VerificationCodeCreateOrConnectWithoutUserInput = {
    where: VerificationCodeWhereUniqueInput
    create: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput>
  }

  export type VerificationCodeCreateManyUserInputEnvelope = {
    data: VerificationCodeCreateManyUserInput | VerificationCodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VerificationCodeCreateWithoutDoctorInput = {
    id?: string
    code: string
    type: string
    created_at?: Date | string
    expires_at: Date | string
    used_at?: Date | string | null
    user: UserCreateNestedOneWithoutUser_verification_codesInput
  }

  export type VerificationCodeUncheckedCreateWithoutDoctorInput = {
    id?: string
    code: string
    user_id: string
    type: string
    created_at?: Date | string
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type VerificationCodeCreateOrConnectWithoutDoctorInput = {
    where: VerificationCodeWhereUniqueInput
    create: XOR<VerificationCodeCreateWithoutDoctorInput, VerificationCodeUncheckedCreateWithoutDoctorInput>
  }

  export type VerificationCodeCreateManyDoctorInputEnvelope = {
    data: VerificationCodeCreateManyDoctorInput | VerificationCodeCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutUserInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: UserCreateNestedOneWithoutDoctorPurchasesInput
    product: ProductCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutUserInput = {
    id?: string
    doctorId: string
    productId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput>
  }

  export type PurchaseCreateManyUserInputEnvelope = {
    data: PurchaseCreateManyUserInput | PurchaseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutDoctorInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPurchasesInput
    product: ProductCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutDoctorInput = {
    id?: string
    userId: string
    productId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutDoctorInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutDoctorInput, PurchaseUncheckedCreateWithoutDoctorInput>
  }

  export type PurchaseCreateManyDoctorInputEnvelope = {
    data: PurchaseCreateManyDoctorInput | PurchaseCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type PointsLedgerCreateWithoutUserInput = {
    id?: string
    sourceType: string
    sourceId: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    createdAt?: Date | string
    patientProfile?: PatientProfileCreateNestedOneWithoutPointsLedgerInput
  }

  export type PointsLedgerUncheckedCreateWithoutUserInput = {
    id?: string
    patientProfileId?: string | null
    sourceType: string
    sourceId: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    createdAt?: Date | string
  }

  export type PointsLedgerCreateOrConnectWithoutUserInput = {
    where: PointsLedgerWhereUniqueInput
    create: XOR<PointsLedgerCreateWithoutUserInput, PointsLedgerUncheckedCreateWithoutUserInput>
  }

  export type PointsLedgerCreateManyUserInputEnvelope = {
    data: PointsLedgerCreateManyUserInput | PointsLedgerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PatientProfileCreateWithoutDoctorInput = {
    id?: string
    name?: string | null
    phone?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPoints?: number
    currentPoints?: number
    patient: UserCreateNestedOneWithoutPatient_profilesInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutPatientProfileInput
  }

  export type PatientProfileUncheckedCreateWithoutDoctorInput = {
    id?: string
    userId: string
    name?: string | null
    phone?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPoints?: number
    currentPoints?: number
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutPatientProfileInput
  }

  export type PatientProfileCreateOrConnectWithoutDoctorInput = {
    where: PatientProfileWhereUniqueInput
    create: XOR<PatientProfileCreateWithoutDoctorInput, PatientProfileUncheckedCreateWithoutDoctorInput>
  }

  export type PatientProfileCreateManyDoctorInputEnvelope = {
    data: PatientProfileCreateManyDoctorInput | PatientProfileCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type PatientProfileCreateWithoutPatientInput = {
    id?: string
    name?: string | null
    phone?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPoints?: number
    currentPoints?: number
    doctor: UserCreateNestedOneWithoutDoctor_profilesInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutPatientProfileInput
  }

  export type PatientProfileUncheckedCreateWithoutPatientInput = {
    id?: string
    doctorId: string
    name?: string | null
    phone?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPoints?: number
    currentPoints?: number
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutPatientProfileInput
  }

  export type PatientProfileCreateOrConnectWithoutPatientInput = {
    where: PatientProfileWhereUniqueInput
    create: XOR<PatientProfileCreateWithoutPatientInput, PatientProfileUncheckedCreateWithoutPatientInput>
  }

  export type PatientProfileCreateManyPatientInputEnvelope = {
    data: PatientProfileCreateManyPatientInput | PatientProfileCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MessageTemplateCreateWithoutDoctorInput = {
    id?: string
    name: string
    channel: string
    subject?: string | null
    html?: string | null
    text?: string | null
    mjml?: string | null
    renderStrategy?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    provider?: string | null
    waTemplateName?: string | null
    waLanguage?: string | null
    waCategory?: string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: string | null
    waProviderId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateCreatetagsInput | string[]
    smsMaxSegments?: number | null
    steps?: MessageSequenceStepCreateNestedManyWithoutTemplateInput
  }

  export type MessageTemplateUncheckedCreateWithoutDoctorInput = {
    id?: string
    name: string
    channel: string
    subject?: string | null
    html?: string | null
    text?: string | null
    mjml?: string | null
    renderStrategy?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    provider?: string | null
    waTemplateName?: string | null
    waLanguage?: string | null
    waCategory?: string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: string | null
    waProviderId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateCreatetagsInput | string[]
    smsMaxSegments?: number | null
    steps?: MessageSequenceStepUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type MessageTemplateCreateOrConnectWithoutDoctorInput = {
    where: MessageTemplateWhereUniqueInput
    create: XOR<MessageTemplateCreateWithoutDoctorInput, MessageTemplateUncheckedCreateWithoutDoctorInput>
  }

  export type MessageTemplateCreateManyDoctorInputEnvelope = {
    data: MessageTemplateCreateManyDoctorInput | MessageTemplateCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type MessageSequenceCreateWithoutDoctorInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: MessageSequenceStepCreateNestedManyWithoutSequenceInput
  }

  export type MessageSequenceUncheckedCreateWithoutDoctorInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: MessageSequenceStepUncheckedCreateNestedManyWithoutSequenceInput
  }

  export type MessageSequenceCreateOrConnectWithoutDoctorInput = {
    where: MessageSequenceWhereUniqueInput
    create: XOR<MessageSequenceCreateWithoutDoctorInput, MessageSequenceUncheckedCreateWithoutDoctorInput>
  }

  export type MessageSequenceCreateManyDoctorInputEnvelope = {
    data: MessageSequenceCreateManyDoctorInput | MessageSequenceCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserUpsertWithoutOther_usersInput = {
    update: XOR<UserUpdateWithoutOther_usersInput, UserUncheckedUpdateWithoutOther_usersInput>
    create: XOR<UserCreateWithoutOther_usersInput, UserUncheckedCreateWithoutOther_usersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOther_usersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOther_usersInput, UserUncheckedUpdateWithoutOther_usersInput>
  }

  export type UserUpdateWithoutOther_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutOther_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutUserInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutUserInput, UserUncheckedUpdateWithoutUserInput>
    create: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput>
  }

  export type UserUpdateWithWhereUniqueWithoutUserInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutUserInput, UserUncheckedUpdateWithoutUserInput>
  }

  export type UserUpdateManyWithWhereWithoutUserInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    public_cover_image_url?: StringNullableFilter<"User"> | string | null
    doctor_slug?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    is_active?: BoolFilter<"User"> | boolean
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    email_verified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    reset_token?: StringNullableFilter<"User"> | string | null
    reset_token_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    verification_code?: StringNullableFilter<"User"> | string | null
    verification_code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    doctor_id?: StringNullableFilter<"User"> | string | null
    referral_code?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    birth_date?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    emergency_contact?: StringNullableFilter<"User"> | string | null
    emergency_phone?: StringNullableFilter<"User"> | string | null
    medical_history?: StringNullableFilter<"User"> | string | null
    allergies?: StringNullableFilter<"User"> | string | null
    medications?: StringNullableFilter<"User"> | string | null
    notes?: StringNullableFilter<"User"> | string | null
    google_review_link?: StringNullableFilter<"User"> | string | null
    stripe_connect_id?: StringNullableFilter<"User"> | string | null
    accessGranted?: BoolFilter<"User"> | boolean
  }

  export type ClinicMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ClinicMemberWhereUniqueInput
    update: XOR<ClinicMemberUpdateWithoutUserInput, ClinicMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ClinicMemberCreateWithoutUserInput, ClinicMemberUncheckedCreateWithoutUserInput>
  }

  export type ClinicMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ClinicMemberWhereUniqueInput
    data: XOR<ClinicMemberUpdateWithoutUserInput, ClinicMemberUncheckedUpdateWithoutUserInput>
  }

  export type ClinicMemberUpdateManyWithWhereWithoutUserInput = {
    where: ClinicMemberScalarWhereInput
    data: XOR<ClinicMemberUpdateManyMutationInput, ClinicMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ClinicMemberScalarWhereInput = {
    AND?: ClinicMemberScalarWhereInput | ClinicMemberScalarWhereInput[]
    OR?: ClinicMemberScalarWhereInput[]
    NOT?: ClinicMemberScalarWhereInput | ClinicMemberScalarWhereInput[]
    id?: StringFilter<"ClinicMember"> | string
    clinicId?: StringFilter<"ClinicMember"> | string
    userId?: StringFilter<"ClinicMember"> | string
    role?: EnumClinicRoleFilter<"ClinicMember"> | $Enums.ClinicRole
    isActive?: BoolFilter<"ClinicMember"> | boolean
    joinedAt?: DateTimeFilter<"ClinicMember"> | Date | string
  }

  export type ClinicUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ClinicWhereUniqueInput
    update: XOR<ClinicUpdateWithoutOwnerInput, ClinicUncheckedUpdateWithoutOwnerInput>
    create: XOR<ClinicCreateWithoutOwnerInput, ClinicUncheckedCreateWithoutOwnerInput>
  }

  export type ClinicUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ClinicWhereUniqueInput
    data: XOR<ClinicUpdateWithoutOwnerInput, ClinicUncheckedUpdateWithoutOwnerInput>
  }

  export type ClinicUpdateManyWithWhereWithoutOwnerInput = {
    where: ClinicScalarWhereInput
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ClinicScalarWhereInput = {
    AND?: ClinicScalarWhereInput | ClinicScalarWhereInput[]
    OR?: ClinicScalarWhereInput[]
    NOT?: ClinicScalarWhereInput | ClinicScalarWhereInput[]
    id?: StringFilter<"Clinic"> | string
    name?: StringFilter<"Clinic"> | string
    description?: StringNullableFilter<"Clinic"> | string | null
    ownerId?: StringFilter<"Clinic"> | string
    isActive?: BoolFilter<"Clinic"> | boolean
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
    email?: StringNullableFilter<"Clinic"> | string | null
    phone?: StringNullableFilter<"Clinic"> | string | null
    address?: StringNullableFilter<"Clinic"> | string | null
    city?: StringNullableFilter<"Clinic"> | string | null
    state?: StringNullableFilter<"Clinic"> | string | null
    zipCode?: StringNullableFilter<"Clinic"> | string | null
    country?: StringNullableFilter<"Clinic"> | string | null
    website?: StringNullableFilter<"Clinic"> | string | null
    logo?: StringNullableFilter<"Clinic"> | string | null
    slug?: StringNullableFilter<"Clinic"> | string | null
    subdomain?: StringNullableFilter<"Clinic"> | string | null
    monthlyRevenueRange?: StringNullableFilter<"Clinic"> | string | null
    currentGateway?: StringNullableFilter<"Clinic"> | string | null
    theme?: EnumClinicThemeFilter<"Clinic"> | $Enums.ClinicTheme
    buttonColor?: StringNullableFilter<"Clinic"> | string | null
    buttonTextColor?: StringNullableFilter<"Clinic"> | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutDoctorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutDoctorInput, ProductUncheckedUpdateWithoutDoctorInput>
    create: XOR<ProductCreateWithoutDoctorInput, ProductUncheckedCreateWithoutDoctorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutDoctorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutDoctorInput, ProductUncheckedUpdateWithoutDoctorInput>
  }

  export type ProductUpdateManyWithWhereWithoutDoctorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutDoctorInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    subtitle?: StringNullableFilter<"Product"> | string | null
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    priority?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    doctorId?: StringNullableFilter<"Product"> | string | null
    clinicId?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    confirmationUrl?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    interval?: EnumSubscriptionIntervalNullableFilter<"Product"> | $Enums.SubscriptionInterval | null
    intervalCount?: IntNullableFilter<"Product"> | number | null
    trialDays?: IntNullableFilter<"Product"> | number | null
    providerPlanId?: StringNullableFilter<"Product"> | string | null
    providerPlanData?: JsonNullableFilter<"Product">
    autoRenew?: BoolNullableFilter<"Product"> | boolean | null
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutDoctorInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutDoctorInput, ProductCategoryUncheckedUpdateWithoutDoctorInput>
    create: XOR<ProductCategoryCreateWithoutDoctorInput, ProductCategoryUncheckedCreateWithoutDoctorInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutDoctorInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutDoctorInput, ProductCategoryUncheckedUpdateWithoutDoctorInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutDoctorInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutDoctorInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    slug?: StringNullableFilter<"ProductCategory"> | string | null
    doctorId?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
  }

  export type VerificationCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: VerificationCodeWhereUniqueInput
    update: XOR<VerificationCodeUpdateWithoutUserInput, VerificationCodeUncheckedUpdateWithoutUserInput>
    create: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput>
  }

  export type VerificationCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: VerificationCodeWhereUniqueInput
    data: XOR<VerificationCodeUpdateWithoutUserInput, VerificationCodeUncheckedUpdateWithoutUserInput>
  }

  export type VerificationCodeUpdateManyWithWhereWithoutUserInput = {
    where: VerificationCodeScalarWhereInput
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyWithoutUserInput>
  }

  export type VerificationCodeScalarWhereInput = {
    AND?: VerificationCodeScalarWhereInput | VerificationCodeScalarWhereInput[]
    OR?: VerificationCodeScalarWhereInput[]
    NOT?: VerificationCodeScalarWhereInput | VerificationCodeScalarWhereInput[]
    id?: StringFilter<"VerificationCode"> | string
    code?: StringFilter<"VerificationCode"> | string
    user_id?: StringFilter<"VerificationCode"> | string
    doctor_id?: StringFilter<"VerificationCode"> | string
    type?: StringFilter<"VerificationCode"> | string
    created_at?: DateTimeFilter<"VerificationCode"> | Date | string
    expires_at?: DateTimeFilter<"VerificationCode"> | Date | string
    used_at?: DateTimeNullableFilter<"VerificationCode"> | Date | string | null
  }

  export type VerificationCodeUpsertWithWhereUniqueWithoutDoctorInput = {
    where: VerificationCodeWhereUniqueInput
    update: XOR<VerificationCodeUpdateWithoutDoctorInput, VerificationCodeUncheckedUpdateWithoutDoctorInput>
    create: XOR<VerificationCodeCreateWithoutDoctorInput, VerificationCodeUncheckedCreateWithoutDoctorInput>
  }

  export type VerificationCodeUpdateWithWhereUniqueWithoutDoctorInput = {
    where: VerificationCodeWhereUniqueInput
    data: XOR<VerificationCodeUpdateWithoutDoctorInput, VerificationCodeUncheckedUpdateWithoutDoctorInput>
  }

  export type VerificationCodeUpdateManyWithWhereWithoutDoctorInput = {
    where: VerificationCodeScalarWhereInput
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyWithoutDoctorInput>
  }

  export type PurchaseUpsertWithWhereUniqueWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutUserInput, PurchaseUncheckedUpdateWithoutUserInput>
    create: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutUserInput, PurchaseUncheckedUpdateWithoutUserInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutUserInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutUserInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    userId?: StringFilter<"Purchase"> | string
    doctorId?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    quantity?: IntFilter<"Purchase"> | number
    unitPrice?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Purchase"> | string
    externalIdempotencyKey?: StringNullableFilter<"Purchase"> | string | null
    notes?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutDoctorInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutDoctorInput, PurchaseUncheckedUpdateWithoutDoctorInput>
    create: XOR<PurchaseCreateWithoutDoctorInput, PurchaseUncheckedCreateWithoutDoctorInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutDoctorInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutDoctorInput, PurchaseUncheckedUpdateWithoutDoctorInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutDoctorInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutDoctorInput>
  }

  export type PointsLedgerUpsertWithWhereUniqueWithoutUserInput = {
    where: PointsLedgerWhereUniqueInput
    update: XOR<PointsLedgerUpdateWithoutUserInput, PointsLedgerUncheckedUpdateWithoutUserInput>
    create: XOR<PointsLedgerCreateWithoutUserInput, PointsLedgerUncheckedCreateWithoutUserInput>
  }

  export type PointsLedgerUpdateWithWhereUniqueWithoutUserInput = {
    where: PointsLedgerWhereUniqueInput
    data: XOR<PointsLedgerUpdateWithoutUserInput, PointsLedgerUncheckedUpdateWithoutUserInput>
  }

  export type PointsLedgerUpdateManyWithWhereWithoutUserInput = {
    where: PointsLedgerScalarWhereInput
    data: XOR<PointsLedgerUpdateManyMutationInput, PointsLedgerUncheckedUpdateManyWithoutUserInput>
  }

  export type PointsLedgerScalarWhereInput = {
    AND?: PointsLedgerScalarWhereInput | PointsLedgerScalarWhereInput[]
    OR?: PointsLedgerScalarWhereInput[]
    NOT?: PointsLedgerScalarWhereInput | PointsLedgerScalarWhereInput[]
    id?: StringFilter<"PointsLedger"> | string
    userId?: StringFilter<"PointsLedger"> | string
    patientProfileId?: StringNullableFilter<"PointsLedger"> | string | null
    sourceType?: StringFilter<"PointsLedger"> | string
    sourceId?: StringFilter<"PointsLedger"> | string
    amount?: DecimalFilter<"PointsLedger"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"PointsLedger"> | string | null
    createdAt?: DateTimeFilter<"PointsLedger"> | Date | string
  }

  export type PatientProfileUpsertWithWhereUniqueWithoutDoctorInput = {
    where: PatientProfileWhereUniqueInput
    update: XOR<PatientProfileUpdateWithoutDoctorInput, PatientProfileUncheckedUpdateWithoutDoctorInput>
    create: XOR<PatientProfileCreateWithoutDoctorInput, PatientProfileUncheckedCreateWithoutDoctorInput>
  }

  export type PatientProfileUpdateWithWhereUniqueWithoutDoctorInput = {
    where: PatientProfileWhereUniqueInput
    data: XOR<PatientProfileUpdateWithoutDoctorInput, PatientProfileUncheckedUpdateWithoutDoctorInput>
  }

  export type PatientProfileUpdateManyWithWhereWithoutDoctorInput = {
    where: PatientProfileScalarWhereInput
    data: XOR<PatientProfileUpdateManyMutationInput, PatientProfileUncheckedUpdateManyWithoutDoctorInput>
  }

  export type PatientProfileScalarWhereInput = {
    AND?: PatientProfileScalarWhereInput | PatientProfileScalarWhereInput[]
    OR?: PatientProfileScalarWhereInput[]
    NOT?: PatientProfileScalarWhereInput | PatientProfileScalarWhereInput[]
    id?: StringFilter<"PatientProfile"> | string
    doctorId?: StringFilter<"PatientProfile"> | string
    userId?: StringFilter<"PatientProfile"> | string
    name?: StringNullableFilter<"PatientProfile"> | string | null
    phone?: StringNullableFilter<"PatientProfile"> | string | null
    address?: StringNullableFilter<"PatientProfile"> | string | null
    emergency_contact?: StringNullableFilter<"PatientProfile"> | string | null
    emergency_phone?: StringNullableFilter<"PatientProfile"> | string | null
    medical_history?: StringNullableFilter<"PatientProfile"> | string | null
    allergies?: StringNullableFilter<"PatientProfile"> | string | null
    medications?: StringNullableFilter<"PatientProfile"> | string | null
    notes?: StringNullableFilter<"PatientProfile"> | string | null
    isActive?: BoolFilter<"PatientProfile"> | boolean
    createdAt?: DateTimeFilter<"PatientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PatientProfile"> | Date | string
    totalPoints?: IntFilter<"PatientProfile"> | number
    currentPoints?: IntFilter<"PatientProfile"> | number
  }

  export type PatientProfileUpsertWithWhereUniqueWithoutPatientInput = {
    where: PatientProfileWhereUniqueInput
    update: XOR<PatientProfileUpdateWithoutPatientInput, PatientProfileUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientProfileCreateWithoutPatientInput, PatientProfileUncheckedCreateWithoutPatientInput>
  }

  export type PatientProfileUpdateWithWhereUniqueWithoutPatientInput = {
    where: PatientProfileWhereUniqueInput
    data: XOR<PatientProfileUpdateWithoutPatientInput, PatientProfileUncheckedUpdateWithoutPatientInput>
  }

  export type PatientProfileUpdateManyWithWhereWithoutPatientInput = {
    where: PatientProfileScalarWhereInput
    data: XOR<PatientProfileUpdateManyMutationInput, PatientProfileUncheckedUpdateManyWithoutPatientInput>
  }

  export type MessageTemplateUpsertWithWhereUniqueWithoutDoctorInput = {
    where: MessageTemplateWhereUniqueInput
    update: XOR<MessageTemplateUpdateWithoutDoctorInput, MessageTemplateUncheckedUpdateWithoutDoctorInput>
    create: XOR<MessageTemplateCreateWithoutDoctorInput, MessageTemplateUncheckedCreateWithoutDoctorInput>
  }

  export type MessageTemplateUpdateWithWhereUniqueWithoutDoctorInput = {
    where: MessageTemplateWhereUniqueInput
    data: XOR<MessageTemplateUpdateWithoutDoctorInput, MessageTemplateUncheckedUpdateWithoutDoctorInput>
  }

  export type MessageTemplateUpdateManyWithWhereWithoutDoctorInput = {
    where: MessageTemplateScalarWhereInput
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyWithoutDoctorInput>
  }

  export type MessageTemplateScalarWhereInput = {
    AND?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
    OR?: MessageTemplateScalarWhereInput[]
    NOT?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
    id?: StringFilter<"MessageTemplate"> | string
    doctorId?: StringFilter<"MessageTemplate"> | string
    name?: StringFilter<"MessageTemplate"> | string
    channel?: StringFilter<"MessageTemplate"> | string
    subject?: StringNullableFilter<"MessageTemplate"> | string | null
    html?: StringNullableFilter<"MessageTemplate"> | string | null
    text?: StringNullableFilter<"MessageTemplate"> | string | null
    mjml?: StringNullableFilter<"MessageTemplate"> | string | null
    renderStrategy?: StringNullableFilter<"MessageTemplate"> | string | null
    fromName?: StringNullableFilter<"MessageTemplate"> | string | null
    fromEmail?: StringNullableFilter<"MessageTemplate"> | string | null
    replyTo?: StringNullableFilter<"MessageTemplate"> | string | null
    provider?: StringNullableFilter<"MessageTemplate"> | string | null
    waTemplateName?: StringNullableFilter<"MessageTemplate"> | string | null
    waLanguage?: StringNullableFilter<"MessageTemplate"> | string | null
    waCategory?: StringNullableFilter<"MessageTemplate"> | string | null
    waComponents?: JsonNullableFilter<"MessageTemplate">
    waStatus?: StringNullableFilter<"MessageTemplate"> | string | null
    waProviderId?: StringNullableFilter<"MessageTemplate"> | string | null
    isActive?: BoolFilter<"MessageTemplate"> | boolean
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    variablesSchema?: JsonNullableFilter<"MessageTemplate">
    sampleVariables?: JsonNullableFilter<"MessageTemplate">
    tags?: StringNullableListFilter<"MessageTemplate">
    smsMaxSegments?: IntNullableFilter<"MessageTemplate"> | number | null
  }

  export type MessageSequenceUpsertWithWhereUniqueWithoutDoctorInput = {
    where: MessageSequenceWhereUniqueInput
    update: XOR<MessageSequenceUpdateWithoutDoctorInput, MessageSequenceUncheckedUpdateWithoutDoctorInput>
    create: XOR<MessageSequenceCreateWithoutDoctorInput, MessageSequenceUncheckedCreateWithoutDoctorInput>
  }

  export type MessageSequenceUpdateWithWhereUniqueWithoutDoctorInput = {
    where: MessageSequenceWhereUniqueInput
    data: XOR<MessageSequenceUpdateWithoutDoctorInput, MessageSequenceUncheckedUpdateWithoutDoctorInput>
  }

  export type MessageSequenceUpdateManyWithWhereWithoutDoctorInput = {
    where: MessageSequenceScalarWhereInput
    data: XOR<MessageSequenceUpdateManyMutationInput, MessageSequenceUncheckedUpdateManyWithoutDoctorInput>
  }

  export type MessageSequenceScalarWhereInput = {
    AND?: MessageSequenceScalarWhereInput | MessageSequenceScalarWhereInput[]
    OR?: MessageSequenceScalarWhereInput[]
    NOT?: MessageSequenceScalarWhereInput | MessageSequenceScalarWhereInput[]
    id?: StringFilter<"MessageSequence"> | string
    doctorId?: StringFilter<"MessageSequence"> | string
    name?: StringFilter<"MessageSequence"> | string
    description?: StringNullableFilter<"MessageSequence"> | string | null
    isActive?: BoolFilter<"MessageSequence"> | boolean
    createdAt?: DateTimeFilter<"MessageSequence"> | Date | string
    updatedAt?: DateTimeFilter<"MessageSequence"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type UserCreateWithoutUser_verification_codesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutUser_verification_codesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutUser_verification_codesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_verification_codesInput, UserUncheckedCreateWithoutUser_verification_codesInput>
  }

  export type UserCreateWithoutDoctor_verification_codesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutDoctor_verification_codesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutDoctor_verification_codesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctor_verification_codesInput, UserUncheckedCreateWithoutDoctor_verification_codesInput>
  }

  export type UserUpsertWithoutUser_verification_codesInput = {
    update: XOR<UserUpdateWithoutUser_verification_codesInput, UserUncheckedUpdateWithoutUser_verification_codesInput>
    create: XOR<UserCreateWithoutUser_verification_codesInput, UserUncheckedCreateWithoutUser_verification_codesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_verification_codesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_verification_codesInput, UserUncheckedUpdateWithoutUser_verification_codesInput>
  }

  export type UserUpdateWithoutUser_verification_codesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_verification_codesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type UserUpsertWithoutDoctor_verification_codesInput = {
    update: XOR<UserUpdateWithoutDoctor_verification_codesInput, UserUncheckedUpdateWithoutDoctor_verification_codesInput>
    create: XOR<UserCreateWithoutDoctor_verification_codesInput, UserUncheckedCreateWithoutDoctor_verification_codesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctor_verification_codesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctor_verification_codesInput, UserUncheckedUpdateWithoutDoctor_verification_codesInput>
  }

  export type UserUpdateWithoutDoctor_verification_codesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctor_verification_codesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type UserCreateWithoutDoctor_profilesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutDoctor_profilesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutDoctor_profilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctor_profilesInput, UserUncheckedCreateWithoutDoctor_profilesInput>
  }

  export type UserCreateWithoutPatient_profilesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutPatient_profilesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutPatient_profilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatient_profilesInput, UserUncheckedCreateWithoutPatient_profilesInput>
  }

  export type PointsLedgerCreateWithoutPatientProfileInput = {
    id?: string
    sourceType: string
    sourceId: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPointsLedgerInput
  }

  export type PointsLedgerUncheckedCreateWithoutPatientProfileInput = {
    id?: string
    userId: string
    sourceType: string
    sourceId: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    createdAt?: Date | string
  }

  export type PointsLedgerCreateOrConnectWithoutPatientProfileInput = {
    where: PointsLedgerWhereUniqueInput
    create: XOR<PointsLedgerCreateWithoutPatientProfileInput, PointsLedgerUncheckedCreateWithoutPatientProfileInput>
  }

  export type PointsLedgerCreateManyPatientProfileInputEnvelope = {
    data: PointsLedgerCreateManyPatientProfileInput | PointsLedgerCreateManyPatientProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDoctor_profilesInput = {
    update: XOR<UserUpdateWithoutDoctor_profilesInput, UserUncheckedUpdateWithoutDoctor_profilesInput>
    create: XOR<UserCreateWithoutDoctor_profilesInput, UserUncheckedCreateWithoutDoctor_profilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctor_profilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctor_profilesInput, UserUncheckedUpdateWithoutDoctor_profilesInput>
  }

  export type UserUpdateWithoutDoctor_profilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctor_profilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type UserUpsertWithoutPatient_profilesInput = {
    update: XOR<UserUpdateWithoutPatient_profilesInput, UserUncheckedUpdateWithoutPatient_profilesInput>
    create: XOR<UserCreateWithoutPatient_profilesInput, UserUncheckedCreateWithoutPatient_profilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPatient_profilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPatient_profilesInput, UserUncheckedUpdateWithoutPatient_profilesInput>
  }

  export type UserUpdateWithoutPatient_profilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutPatient_profilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PointsLedgerUpsertWithWhereUniqueWithoutPatientProfileInput = {
    where: PointsLedgerWhereUniqueInput
    update: XOR<PointsLedgerUpdateWithoutPatientProfileInput, PointsLedgerUncheckedUpdateWithoutPatientProfileInput>
    create: XOR<PointsLedgerCreateWithoutPatientProfileInput, PointsLedgerUncheckedCreateWithoutPatientProfileInput>
  }

  export type PointsLedgerUpdateWithWhereUniqueWithoutPatientProfileInput = {
    where: PointsLedgerWhereUniqueInput
    data: XOR<PointsLedgerUpdateWithoutPatientProfileInput, PointsLedgerUncheckedUpdateWithoutPatientProfileInput>
  }

  export type PointsLedgerUpdateManyWithWhereWithoutPatientProfileInput = {
    where: PointsLedgerScalarWhereInput
    data: XOR<PointsLedgerUpdateManyMutationInput, PointsLedgerUncheckedUpdateManyWithoutPatientProfileInput>
  }

  export type UserCreateWithoutPointsLedgerInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutPointsLedgerInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutPointsLedgerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPointsLedgerInput, UserUncheckedCreateWithoutPointsLedgerInput>
  }

  export type PatientProfileCreateWithoutPointsLedgerInput = {
    id?: string
    name?: string | null
    phone?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPoints?: number
    currentPoints?: number
    doctor: UserCreateNestedOneWithoutDoctor_profilesInput
    patient: UserCreateNestedOneWithoutPatient_profilesInput
  }

  export type PatientProfileUncheckedCreateWithoutPointsLedgerInput = {
    id?: string
    doctorId: string
    userId: string
    name?: string | null
    phone?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPoints?: number
    currentPoints?: number
  }

  export type PatientProfileCreateOrConnectWithoutPointsLedgerInput = {
    where: PatientProfileWhereUniqueInput
    create: XOR<PatientProfileCreateWithoutPointsLedgerInput, PatientProfileUncheckedCreateWithoutPointsLedgerInput>
  }

  export type UserUpsertWithoutPointsLedgerInput = {
    update: XOR<UserUpdateWithoutPointsLedgerInput, UserUncheckedUpdateWithoutPointsLedgerInput>
    create: XOR<UserCreateWithoutPointsLedgerInput, UserUncheckedCreateWithoutPointsLedgerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPointsLedgerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPointsLedgerInput, UserUncheckedUpdateWithoutPointsLedgerInput>
  }

  export type UserUpdateWithoutPointsLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutPointsLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PatientProfileUpsertWithoutPointsLedgerInput = {
    update: XOR<PatientProfileUpdateWithoutPointsLedgerInput, PatientProfileUncheckedUpdateWithoutPointsLedgerInput>
    create: XOR<PatientProfileCreateWithoutPointsLedgerInput, PatientProfileUncheckedCreateWithoutPointsLedgerInput>
    where?: PatientProfileWhereInput
  }

  export type PatientProfileUpdateToOneWithWhereWithoutPointsLedgerInput = {
    where?: PatientProfileWhereInput
    data: XOR<PatientProfileUpdateWithoutPointsLedgerInput, PatientProfileUncheckedUpdateWithoutPointsLedgerInput>
  }

  export type PatientProfileUpdateWithoutPointsLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
    doctor?: UserUpdateOneRequiredWithoutDoctor_profilesNestedInput
    patient?: UserUpdateOneRequiredWithoutPatient_profilesNestedInput
  }

  export type PatientProfileUncheckedUpdateWithoutPointsLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
  }

  export type ClinicMemberCreateWithoutClinicInput = {
    id?: string
    role?: $Enums.ClinicRole
    isActive?: boolean
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutClinic_membershipsInput
  }

  export type ClinicMemberUncheckedCreateWithoutClinicInput = {
    id?: string
    userId: string
    role?: $Enums.ClinicRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type ClinicMemberCreateOrConnectWithoutClinicInput = {
    where: ClinicMemberWhereUniqueInput
    create: XOR<ClinicMemberCreateWithoutClinicInput, ClinicMemberUncheckedCreateWithoutClinicInput>
  }

  export type ClinicMemberCreateManyClinicInputEnvelope = {
    data: ClinicMemberCreateManyClinicInput | ClinicMemberCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOwned_clinicsInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutOwned_clinicsInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutOwned_clinicsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwned_clinicsInput, UserUncheckedCreateWithoutOwned_clinicsInput>
  }

  export type ClinicSubscriptionCreateWithoutClinicInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    trialEndsAt: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    canceledAt?: Date | string | null
    cancelReason?: string | null
    currentDoctorsCount?: number
    currentPatientsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: ClinicPlanCreateNestedOneWithoutSubscriptionsInput
    addOns?: ClinicAddOnSubscriptionCreateNestedManyWithoutSubscriptionInput
  }

  export type ClinicSubscriptionUncheckedCreateWithoutClinicInput = {
    id?: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    trialEndsAt: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    canceledAt?: Date | string | null
    cancelReason?: string | null
    currentDoctorsCount?: number
    currentPatientsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addOns?: ClinicAddOnSubscriptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type ClinicSubscriptionCreateOrConnectWithoutClinicInput = {
    where: ClinicSubscriptionWhereUniqueInput
    create: XOR<ClinicSubscriptionCreateWithoutClinicInput, ClinicSubscriptionUncheckedCreateWithoutClinicInput>
  }

  export type ClinicSubscriptionCreateManyClinicInputEnvelope = {
    data: ClinicSubscriptionCreateManyClinicInput | ClinicSubscriptionCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutClinicInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    confirmationUrl?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    doctor?: UserCreateNestedOneWithoutCreated_productsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsCreateNestedManyWithoutProductInput
    offers?: OfferCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutClinicInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    categoryId?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsUncheckedCreateNestedManyWithoutProductInput
    offers?: OfferUncheckedCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutClinicInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutClinicInput, ProductUncheckedCreateWithoutClinicInput>
  }

  export type ProductCreateManyClinicInputEnvelope = {
    data: ProductCreateManyClinicInput | ProductCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type MerchantCreateWithoutClinicInput = {
    id?: string
    status?: $Enums.MerchantStatus
    recipientId?: string | null
    externalAccountId?: string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: number
    platformFeeBps?: number
    transactionFeeCents?: number | null
    transactionFeeType?: string | null
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    integrations?: MerchantIntegrationCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutClinicInput = {
    id?: string
    status?: $Enums.MerchantStatus
    recipientId?: string | null
    externalAccountId?: string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: number
    platformFeeBps?: number
    transactionFeeCents?: number | null
    transactionFeeType?: string | null
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    integrations?: MerchantIntegrationUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutClinicInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutClinicInput, MerchantUncheckedCreateWithoutClinicInput>
  }

  export type MerchantApplicationCreateWithoutClinicInput = {
    id?: string
    type?: $Enums.MerchantType
    businessName?: string | null
    fullName?: string | null
    documentNumber?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: string | null
    status?: $Enums.MerchantAppStatus
    reviewNotes?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: MerchantDocumentCreateNestedManyWithoutApplicationInput
  }

  export type MerchantApplicationUncheckedCreateWithoutClinicInput = {
    id?: string
    type?: $Enums.MerchantType
    businessName?: string | null
    fullName?: string | null
    documentNumber?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: string | null
    status?: $Enums.MerchantAppStatus
    reviewNotes?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: MerchantDocumentUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type MerchantApplicationCreateOrConnectWithoutClinicInput = {
    where: MerchantApplicationWhereUniqueInput
    create: XOR<MerchantApplicationCreateWithoutClinicInput, MerchantApplicationUncheckedCreateWithoutClinicInput>
  }

  export type WebhookEndpointCreateWithoutClinicInput = {
    id?: string
    name: string
    url: string
    secret: string
    events?: WebhookEndpointCreateeventsInput | string[]
    enabled?: boolean
    maxConcurrentDeliveries?: number
    categoryFilter?: string
    statusFilters?: WebhookEndpointCreatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointCreateproductFiltersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: OutboundWebhookDeliveryCreateNestedManyWithoutEndpointInput
  }

  export type WebhookEndpointUncheckedCreateWithoutClinicInput = {
    id?: string
    name: string
    url: string
    secret: string
    events?: WebhookEndpointCreateeventsInput | string[]
    enabled?: boolean
    maxConcurrentDeliveries?: number
    categoryFilter?: string
    statusFilters?: WebhookEndpointCreatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointCreateproductFiltersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: OutboundWebhookDeliveryUncheckedCreateNestedManyWithoutEndpointInput
  }

  export type WebhookEndpointCreateOrConnectWithoutClinicInput = {
    where: WebhookEndpointWhereUniqueInput
    create: XOR<WebhookEndpointCreateWithoutClinicInput, WebhookEndpointUncheckedCreateWithoutClinicInput>
  }

  export type WebhookEndpointCreateManyClinicInputEnvelope = {
    data: WebhookEndpointCreateManyClinicInput | WebhookEndpointCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type OutboundWebhookEventCreateWithoutClinicInput = {
    id?: string
    type: string
    resource: string
    resourceId: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    deliveries?: OutboundWebhookDeliveryCreateNestedManyWithoutEventInput
  }

  export type OutboundWebhookEventUncheckedCreateWithoutClinicInput = {
    id?: string
    type: string
    resource: string
    resourceId: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    deliveries?: OutboundWebhookDeliveryUncheckedCreateNestedManyWithoutEventInput
  }

  export type OutboundWebhookEventCreateOrConnectWithoutClinicInput = {
    where: OutboundWebhookEventWhereUniqueInput
    create: XOR<OutboundWebhookEventCreateWithoutClinicInput, OutboundWebhookEventUncheckedCreateWithoutClinicInput>
  }

  export type OutboundWebhookEventCreateManyClinicInputEnvelope = {
    data: OutboundWebhookEventCreateManyClinicInput | OutboundWebhookEventCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type ClinicMemberUpsertWithWhereUniqueWithoutClinicInput = {
    where: ClinicMemberWhereUniqueInput
    update: XOR<ClinicMemberUpdateWithoutClinicInput, ClinicMemberUncheckedUpdateWithoutClinicInput>
    create: XOR<ClinicMemberCreateWithoutClinicInput, ClinicMemberUncheckedCreateWithoutClinicInput>
  }

  export type ClinicMemberUpdateWithWhereUniqueWithoutClinicInput = {
    where: ClinicMemberWhereUniqueInput
    data: XOR<ClinicMemberUpdateWithoutClinicInput, ClinicMemberUncheckedUpdateWithoutClinicInput>
  }

  export type ClinicMemberUpdateManyWithWhereWithoutClinicInput = {
    where: ClinicMemberScalarWhereInput
    data: XOR<ClinicMemberUpdateManyMutationInput, ClinicMemberUncheckedUpdateManyWithoutClinicInput>
  }

  export type UserUpsertWithoutOwned_clinicsInput = {
    update: XOR<UserUpdateWithoutOwned_clinicsInput, UserUncheckedUpdateWithoutOwned_clinicsInput>
    create: XOR<UserCreateWithoutOwned_clinicsInput, UserUncheckedCreateWithoutOwned_clinicsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwned_clinicsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwned_clinicsInput, UserUncheckedUpdateWithoutOwned_clinicsInput>
  }

  export type UserUpdateWithoutOwned_clinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutOwned_clinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type ClinicSubscriptionUpsertWithWhereUniqueWithoutClinicInput = {
    where: ClinicSubscriptionWhereUniqueInput
    update: XOR<ClinicSubscriptionUpdateWithoutClinicInput, ClinicSubscriptionUncheckedUpdateWithoutClinicInput>
    create: XOR<ClinicSubscriptionCreateWithoutClinicInput, ClinicSubscriptionUncheckedCreateWithoutClinicInput>
  }

  export type ClinicSubscriptionUpdateWithWhereUniqueWithoutClinicInput = {
    where: ClinicSubscriptionWhereUniqueInput
    data: XOR<ClinicSubscriptionUpdateWithoutClinicInput, ClinicSubscriptionUncheckedUpdateWithoutClinicInput>
  }

  export type ClinicSubscriptionUpdateManyWithWhereWithoutClinicInput = {
    where: ClinicSubscriptionScalarWhereInput
    data: XOR<ClinicSubscriptionUpdateManyMutationInput, ClinicSubscriptionUncheckedUpdateManyWithoutClinicInput>
  }

  export type ClinicSubscriptionScalarWhereInput = {
    AND?: ClinicSubscriptionScalarWhereInput | ClinicSubscriptionScalarWhereInput[]
    OR?: ClinicSubscriptionScalarWhereInput[]
    NOT?: ClinicSubscriptionScalarWhereInput | ClinicSubscriptionScalarWhereInput[]
    id?: StringFilter<"ClinicSubscription"> | string
    clinicId?: StringFilter<"ClinicSubscription"> | string
    planId?: StringFilter<"ClinicSubscription"> | string
    status?: EnumSubscriptionStatusFilter<"ClinicSubscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"ClinicSubscription"> | Date | string
    trialEndsAt?: DateTimeFilter<"ClinicSubscription"> | Date | string
    currentPeriodStart?: DateTimeFilter<"ClinicSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"ClinicSubscription"> | Date | string
    stripeCustomerId?: StringNullableFilter<"ClinicSubscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"ClinicSubscription"> | string | null
    canceledAt?: DateTimeNullableFilter<"ClinicSubscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"ClinicSubscription"> | string | null
    currentDoctorsCount?: IntFilter<"ClinicSubscription"> | number
    currentPatientsCount?: IntFilter<"ClinicSubscription"> | number
    createdAt?: DateTimeFilter<"ClinicSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicSubscription"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutClinicInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutClinicInput, ProductUncheckedUpdateWithoutClinicInput>
    create: XOR<ProductCreateWithoutClinicInput, ProductUncheckedCreateWithoutClinicInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutClinicInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutClinicInput, ProductUncheckedUpdateWithoutClinicInput>
  }

  export type ProductUpdateManyWithWhereWithoutClinicInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutClinicInput>
  }

  export type MerchantUpsertWithoutClinicInput = {
    update: XOR<MerchantUpdateWithoutClinicInput, MerchantUncheckedUpdateWithoutClinicInput>
    create: XOR<MerchantCreateWithoutClinicInput, MerchantUncheckedCreateWithoutClinicInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutClinicInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutClinicInput, MerchantUncheckedUpdateWithoutClinicInput>
  }

  export type MerchantUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMerchantStatusFieldUpdateOperationsInput | $Enums.MerchantStatus
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    externalAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: IntFieldUpdateOperationsInput | number
    platformFeeBps?: IntFieldUpdateOperationsInput | number
    transactionFeeCents?: NullableIntFieldUpdateOperationsInput | number | null
    transactionFeeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrations?: MerchantIntegrationUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMerchantStatusFieldUpdateOperationsInput | $Enums.MerchantStatus
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    externalAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: IntFieldUpdateOperationsInput | number
    platformFeeBps?: IntFieldUpdateOperationsInput | number
    transactionFeeCents?: NullableIntFieldUpdateOperationsInput | number | null
    transactionFeeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrations?: MerchantIntegrationUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantApplicationUpsertWithoutClinicInput = {
    update: XOR<MerchantApplicationUpdateWithoutClinicInput, MerchantApplicationUncheckedUpdateWithoutClinicInput>
    create: XOR<MerchantApplicationCreateWithoutClinicInput, MerchantApplicationUncheckedCreateWithoutClinicInput>
    where?: MerchantApplicationWhereInput
  }

  export type MerchantApplicationUpdateToOneWithWhereWithoutClinicInput = {
    where?: MerchantApplicationWhereInput
    data: XOR<MerchantApplicationUpdateWithoutClinicInput, MerchantApplicationUncheckedUpdateWithoutClinicInput>
  }

  export type MerchantApplicationUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMerchantTypeFieldUpdateOperationsInput | $Enums.MerchantType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMerchantAppStatusFieldUpdateOperationsInput | $Enums.MerchantAppStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: MerchantDocumentUpdateManyWithoutApplicationNestedInput
  }

  export type MerchantApplicationUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMerchantTypeFieldUpdateOperationsInput | $Enums.MerchantType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMerchantAppStatusFieldUpdateOperationsInput | $Enums.MerchantAppStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: MerchantDocumentUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type WebhookEndpointUpsertWithWhereUniqueWithoutClinicInput = {
    where: WebhookEndpointWhereUniqueInput
    update: XOR<WebhookEndpointUpdateWithoutClinicInput, WebhookEndpointUncheckedUpdateWithoutClinicInput>
    create: XOR<WebhookEndpointCreateWithoutClinicInput, WebhookEndpointUncheckedCreateWithoutClinicInput>
  }

  export type WebhookEndpointUpdateWithWhereUniqueWithoutClinicInput = {
    where: WebhookEndpointWhereUniqueInput
    data: XOR<WebhookEndpointUpdateWithoutClinicInput, WebhookEndpointUncheckedUpdateWithoutClinicInput>
  }

  export type WebhookEndpointUpdateManyWithWhereWithoutClinicInput = {
    where: WebhookEndpointScalarWhereInput
    data: XOR<WebhookEndpointUpdateManyMutationInput, WebhookEndpointUncheckedUpdateManyWithoutClinicInput>
  }

  export type WebhookEndpointScalarWhereInput = {
    AND?: WebhookEndpointScalarWhereInput | WebhookEndpointScalarWhereInput[]
    OR?: WebhookEndpointScalarWhereInput[]
    NOT?: WebhookEndpointScalarWhereInput | WebhookEndpointScalarWhereInput[]
    id?: StringFilter<"WebhookEndpoint"> | string
    clinicId?: StringFilter<"WebhookEndpoint"> | string
    name?: StringFilter<"WebhookEndpoint"> | string
    url?: StringFilter<"WebhookEndpoint"> | string
    secret?: StringFilter<"WebhookEndpoint"> | string
    events?: StringNullableListFilter<"WebhookEndpoint">
    enabled?: BoolFilter<"WebhookEndpoint"> | boolean
    maxConcurrentDeliveries?: IntFilter<"WebhookEndpoint"> | number
    categoryFilter?: StringFilter<"WebhookEndpoint"> | string
    statusFilters?: StringNullableListFilter<"WebhookEndpoint">
    productFilters?: StringNullableListFilter<"WebhookEndpoint">
    createdAt?: DateTimeFilter<"WebhookEndpoint"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookEndpoint"> | Date | string
  }

  export type OutboundWebhookEventUpsertWithWhereUniqueWithoutClinicInput = {
    where: OutboundWebhookEventWhereUniqueInput
    update: XOR<OutboundWebhookEventUpdateWithoutClinicInput, OutboundWebhookEventUncheckedUpdateWithoutClinicInput>
    create: XOR<OutboundWebhookEventCreateWithoutClinicInput, OutboundWebhookEventUncheckedCreateWithoutClinicInput>
  }

  export type OutboundWebhookEventUpdateWithWhereUniqueWithoutClinicInput = {
    where: OutboundWebhookEventWhereUniqueInput
    data: XOR<OutboundWebhookEventUpdateWithoutClinicInput, OutboundWebhookEventUncheckedUpdateWithoutClinicInput>
  }

  export type OutboundWebhookEventUpdateManyWithWhereWithoutClinicInput = {
    where: OutboundWebhookEventScalarWhereInput
    data: XOR<OutboundWebhookEventUpdateManyMutationInput, OutboundWebhookEventUncheckedUpdateManyWithoutClinicInput>
  }

  export type OutboundWebhookEventScalarWhereInput = {
    AND?: OutboundWebhookEventScalarWhereInput | OutboundWebhookEventScalarWhereInput[]
    OR?: OutboundWebhookEventScalarWhereInput[]
    NOT?: OutboundWebhookEventScalarWhereInput | OutboundWebhookEventScalarWhereInput[]
    id?: StringFilter<"OutboundWebhookEvent"> | string
    clinicId?: StringFilter<"OutboundWebhookEvent"> | string
    type?: StringFilter<"OutboundWebhookEvent"> | string
    resource?: StringFilter<"OutboundWebhookEvent"> | string
    resourceId?: StringFilter<"OutboundWebhookEvent"> | string
    payload?: JsonFilter<"OutboundWebhookEvent">
    createdAt?: DateTimeFilter<"OutboundWebhookEvent"> | Date | string
  }

  export type ClinicCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    owner: UserCreateNestedOneWithoutOwned_clinicsInput
    subscriptions?: ClinicSubscriptionCreateNestedManyWithoutClinicInput
    products?: ProductCreateNestedManyWithoutClinicInput
    merchant?: MerchantCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    subscriptions?: ClinicSubscriptionUncheckedCreateNestedManyWithoutClinicInput
    products?: ProductUncheckedCreateNestedManyWithoutClinicInput
    merchant?: MerchantUncheckedCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationUncheckedCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointUncheckedCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutMembersInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutMembersInput, ClinicUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutClinic_membershipsInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutClinic_membershipsInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutClinic_membershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClinic_membershipsInput, UserUncheckedCreateWithoutClinic_membershipsInput>
  }

  export type ClinicUpsertWithoutMembersInput = {
    update: XOR<ClinicUpdateWithoutMembersInput, ClinicUncheckedUpdateWithoutMembersInput>
    create: XOR<ClinicCreateWithoutMembersInput, ClinicUncheckedCreateWithoutMembersInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutMembersInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutMembersInput, ClinicUncheckedUpdateWithoutMembersInput>
  }

  export type ClinicUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwned_clinicsNestedInput
    subscriptions?: ClinicSubscriptionUpdateManyWithoutClinicNestedInput
    products?: ProductUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptions?: ClinicSubscriptionUncheckedUpdateManyWithoutClinicNestedInput
    products?: ProductUncheckedUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUncheckedUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUncheckedUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUncheckedUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type UserUpsertWithoutClinic_membershipsInput = {
    update: XOR<UserUpdateWithoutClinic_membershipsInput, UserUncheckedUpdateWithoutClinic_membershipsInput>
    create: XOR<UserCreateWithoutClinic_membershipsInput, UserUncheckedCreateWithoutClinic_membershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClinic_membershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClinic_membershipsInput, UserUncheckedUpdateWithoutClinic_membershipsInput>
  }

  export type UserUpdateWithoutClinic_membershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutClinic_membershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type ClinicCreateWithoutMerchantInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberCreateNestedManyWithoutClinicInput
    owner: UserCreateNestedOneWithoutOwned_clinicsInput
    subscriptions?: ClinicSubscriptionCreateNestedManyWithoutClinicInput
    products?: ProductCreateNestedManyWithoutClinicInput
    merchantApplication?: MerchantApplicationCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutMerchantInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberUncheckedCreateNestedManyWithoutClinicInput
    subscriptions?: ClinicSubscriptionUncheckedCreateNestedManyWithoutClinicInput
    products?: ProductUncheckedCreateNestedManyWithoutClinicInput
    merchantApplication?: MerchantApplicationUncheckedCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointUncheckedCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutMerchantInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutMerchantInput, ClinicUncheckedCreateWithoutMerchantInput>
  }

  export type MerchantIntegrationCreateWithoutMerchantInput = {
    id?: string
    provider: $Enums.PaymentProvider
    credentials: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPrimary?: boolean
    connectedAt?: Date | string
    lastUsedAt?: Date | string | null
    lastError?: string | null
    lastErrorAt?: Date | string | null
  }

  export type MerchantIntegrationUncheckedCreateWithoutMerchantInput = {
    id?: string
    provider: $Enums.PaymentProvider
    credentials: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPrimary?: boolean
    connectedAt?: Date | string
    lastUsedAt?: Date | string | null
    lastError?: string | null
    lastErrorAt?: Date | string | null
  }

  export type MerchantIntegrationCreateOrConnectWithoutMerchantInput = {
    where: MerchantIntegrationWhereUniqueInput
    create: XOR<MerchantIntegrationCreateWithoutMerchantInput, MerchantIntegrationUncheckedCreateWithoutMerchantInput>
  }

  export type MerchantIntegrationCreateManyMerchantInputEnvelope = {
    data: MerchantIntegrationCreateManyMerchantInput | MerchantIntegrationCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutMerchantInput = {
    update: XOR<ClinicUpdateWithoutMerchantInput, ClinicUncheckedUpdateWithoutMerchantInput>
    create: XOR<ClinicCreateWithoutMerchantInput, ClinicUncheckedCreateWithoutMerchantInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutMerchantInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutMerchantInput, ClinicUncheckedUpdateWithoutMerchantInput>
  }

  export type ClinicUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUpdateManyWithoutClinicNestedInput
    owner?: UserUpdateOneRequiredWithoutOwned_clinicsNestedInput
    subscriptions?: ClinicSubscriptionUpdateManyWithoutClinicNestedInput
    products?: ProductUpdateManyWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUncheckedUpdateManyWithoutClinicNestedInput
    subscriptions?: ClinicSubscriptionUncheckedUpdateManyWithoutClinicNestedInput
    products?: ProductUncheckedUpdateManyWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUncheckedUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUncheckedUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type MerchantIntegrationUpsertWithWhereUniqueWithoutMerchantInput = {
    where: MerchantIntegrationWhereUniqueInput
    update: XOR<MerchantIntegrationUpdateWithoutMerchantInput, MerchantIntegrationUncheckedUpdateWithoutMerchantInput>
    create: XOR<MerchantIntegrationCreateWithoutMerchantInput, MerchantIntegrationUncheckedCreateWithoutMerchantInput>
  }

  export type MerchantIntegrationUpdateWithWhereUniqueWithoutMerchantInput = {
    where: MerchantIntegrationWhereUniqueInput
    data: XOR<MerchantIntegrationUpdateWithoutMerchantInput, MerchantIntegrationUncheckedUpdateWithoutMerchantInput>
  }

  export type MerchantIntegrationUpdateManyWithWhereWithoutMerchantInput = {
    where: MerchantIntegrationScalarWhereInput
    data: XOR<MerchantIntegrationUpdateManyMutationInput, MerchantIntegrationUncheckedUpdateManyWithoutMerchantInput>
  }

  export type MerchantIntegrationScalarWhereInput = {
    AND?: MerchantIntegrationScalarWhereInput | MerchantIntegrationScalarWhereInput[]
    OR?: MerchantIntegrationScalarWhereInput[]
    NOT?: MerchantIntegrationScalarWhereInput | MerchantIntegrationScalarWhereInput[]
    id?: StringFilter<"MerchantIntegration"> | string
    merchantId?: StringFilter<"MerchantIntegration"> | string
    provider?: EnumPaymentProviderFilter<"MerchantIntegration"> | $Enums.PaymentProvider
    credentials?: JsonFilter<"MerchantIntegration">
    config?: JsonNullableFilter<"MerchantIntegration">
    isActive?: BoolFilter<"MerchantIntegration"> | boolean
    isPrimary?: BoolFilter<"MerchantIntegration"> | boolean
    connectedAt?: DateTimeFilter<"MerchantIntegration"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"MerchantIntegration"> | Date | string | null
    lastError?: StringNullableFilter<"MerchantIntegration"> | string | null
    lastErrorAt?: DateTimeNullableFilter<"MerchantIntegration"> | Date | string | null
  }

  export type ClinicCreateWithoutMerchantApplicationInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberCreateNestedManyWithoutClinicInput
    owner: UserCreateNestedOneWithoutOwned_clinicsInput
    subscriptions?: ClinicSubscriptionCreateNestedManyWithoutClinicInput
    products?: ProductCreateNestedManyWithoutClinicInput
    merchant?: MerchantCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutMerchantApplicationInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberUncheckedCreateNestedManyWithoutClinicInput
    subscriptions?: ClinicSubscriptionUncheckedCreateNestedManyWithoutClinicInput
    products?: ProductUncheckedCreateNestedManyWithoutClinicInput
    merchant?: MerchantUncheckedCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointUncheckedCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutMerchantApplicationInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutMerchantApplicationInput, ClinicUncheckedCreateWithoutMerchantApplicationInput>
  }

  export type MerchantDocumentCreateWithoutApplicationInput = {
    id?: string
    type: $Enums.DocumentType
    fileUrl: string
    status?: $Enums.DocumentStatus
    notes?: string | null
    uploadedAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type MerchantDocumentUncheckedCreateWithoutApplicationInput = {
    id?: string
    type: $Enums.DocumentType
    fileUrl: string
    status?: $Enums.DocumentStatus
    notes?: string | null
    uploadedAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type MerchantDocumentCreateOrConnectWithoutApplicationInput = {
    where: MerchantDocumentWhereUniqueInput
    create: XOR<MerchantDocumentCreateWithoutApplicationInput, MerchantDocumentUncheckedCreateWithoutApplicationInput>
  }

  export type MerchantDocumentCreateManyApplicationInputEnvelope = {
    data: MerchantDocumentCreateManyApplicationInput | MerchantDocumentCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutMerchantApplicationInput = {
    update: XOR<ClinicUpdateWithoutMerchantApplicationInput, ClinicUncheckedUpdateWithoutMerchantApplicationInput>
    create: XOR<ClinicCreateWithoutMerchantApplicationInput, ClinicUncheckedCreateWithoutMerchantApplicationInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutMerchantApplicationInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutMerchantApplicationInput, ClinicUncheckedUpdateWithoutMerchantApplicationInput>
  }

  export type ClinicUpdateWithoutMerchantApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUpdateManyWithoutClinicNestedInput
    owner?: UserUpdateOneRequiredWithoutOwned_clinicsNestedInput
    subscriptions?: ClinicSubscriptionUpdateManyWithoutClinicNestedInput
    products?: ProductUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutMerchantApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUncheckedUpdateManyWithoutClinicNestedInput
    subscriptions?: ClinicSubscriptionUncheckedUpdateManyWithoutClinicNestedInput
    products?: ProductUncheckedUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUncheckedUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUncheckedUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type MerchantDocumentUpsertWithWhereUniqueWithoutApplicationInput = {
    where: MerchantDocumentWhereUniqueInput
    update: XOR<MerchantDocumentUpdateWithoutApplicationInput, MerchantDocumentUncheckedUpdateWithoutApplicationInput>
    create: XOR<MerchantDocumentCreateWithoutApplicationInput, MerchantDocumentUncheckedCreateWithoutApplicationInput>
  }

  export type MerchantDocumentUpdateWithWhereUniqueWithoutApplicationInput = {
    where: MerchantDocumentWhereUniqueInput
    data: XOR<MerchantDocumentUpdateWithoutApplicationInput, MerchantDocumentUncheckedUpdateWithoutApplicationInput>
  }

  export type MerchantDocumentUpdateManyWithWhereWithoutApplicationInput = {
    where: MerchantDocumentScalarWhereInput
    data: XOR<MerchantDocumentUpdateManyMutationInput, MerchantDocumentUncheckedUpdateManyWithoutApplicationInput>
  }

  export type MerchantDocumentScalarWhereInput = {
    AND?: MerchantDocumentScalarWhereInput | MerchantDocumentScalarWhereInput[]
    OR?: MerchantDocumentScalarWhereInput[]
    NOT?: MerchantDocumentScalarWhereInput | MerchantDocumentScalarWhereInput[]
    id?: StringFilter<"MerchantDocument"> | string
    applicationId?: StringFilter<"MerchantDocument"> | string
    type?: EnumDocumentTypeFilter<"MerchantDocument"> | $Enums.DocumentType
    fileUrl?: StringFilter<"MerchantDocument"> | string
    status?: EnumDocumentStatusFilter<"MerchantDocument"> | $Enums.DocumentStatus
    notes?: StringNullableFilter<"MerchantDocument"> | string | null
    uploadedAt?: DateTimeFilter<"MerchantDocument"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"MerchantDocument"> | Date | string | null
  }

  export type MerchantApplicationCreateWithoutDocumentsInput = {
    id?: string
    type?: $Enums.MerchantType
    businessName?: string | null
    fullName?: string | null
    documentNumber?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: string | null
    status?: $Enums.MerchantAppStatus
    reviewNotes?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutMerchantApplicationInput
  }

  export type MerchantApplicationUncheckedCreateWithoutDocumentsInput = {
    id?: string
    clinicId: string
    type?: $Enums.MerchantType
    businessName?: string | null
    fullName?: string | null
    documentNumber?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: string | null
    status?: $Enums.MerchantAppStatus
    reviewNotes?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MerchantApplicationCreateOrConnectWithoutDocumentsInput = {
    where: MerchantApplicationWhereUniqueInput
    create: XOR<MerchantApplicationCreateWithoutDocumentsInput, MerchantApplicationUncheckedCreateWithoutDocumentsInput>
  }

  export type MerchantApplicationUpsertWithoutDocumentsInput = {
    update: XOR<MerchantApplicationUpdateWithoutDocumentsInput, MerchantApplicationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<MerchantApplicationCreateWithoutDocumentsInput, MerchantApplicationUncheckedCreateWithoutDocumentsInput>
    where?: MerchantApplicationWhereInput
  }

  export type MerchantApplicationUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: MerchantApplicationWhereInput
    data: XOR<MerchantApplicationUpdateWithoutDocumentsInput, MerchantApplicationUncheckedUpdateWithoutDocumentsInput>
  }

  export type MerchantApplicationUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMerchantTypeFieldUpdateOperationsInput | $Enums.MerchantType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMerchantAppStatusFieldUpdateOperationsInput | $Enums.MerchantAppStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutMerchantApplicationNestedInput
  }

  export type MerchantApplicationUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    type?: EnumMerchantTypeFieldUpdateOperationsInput | $Enums.MerchantType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMerchantAppStatusFieldUpdateOperationsInput | $Enums.MerchantAppStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantCreateWithoutIntegrationsInput = {
    id?: string
    status?: $Enums.MerchantStatus
    recipientId?: string | null
    externalAccountId?: string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: number
    platformFeeBps?: number
    transactionFeeCents?: number | null
    transactionFeeType?: string | null
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    clinicId: string
    status?: $Enums.MerchantStatus
    recipientId?: string | null
    externalAccountId?: string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: number
    platformFeeBps?: number
    transactionFeeCents?: number | null
    transactionFeeType?: string | null
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MerchantCreateOrConnectWithoutIntegrationsInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutIntegrationsInput, MerchantUncheckedCreateWithoutIntegrationsInput>
  }

  export type MerchantUpsertWithoutIntegrationsInput = {
    update: XOR<MerchantUpdateWithoutIntegrationsInput, MerchantUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<MerchantCreateWithoutIntegrationsInput, MerchantUncheckedCreateWithoutIntegrationsInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutIntegrationsInput, MerchantUncheckedUpdateWithoutIntegrationsInput>
  }

  export type MerchantUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMerchantStatusFieldUpdateOperationsInput | $Enums.MerchantStatus
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    externalAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: IntFieldUpdateOperationsInput | number
    platformFeeBps?: IntFieldUpdateOperationsInput | number
    transactionFeeCents?: NullableIntFieldUpdateOperationsInput | number | null
    transactionFeeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    status?: EnumMerchantStatusFieldUpdateOperationsInput | $Enums.MerchantStatus
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    externalAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingState?: NullableJsonNullValueInput | InputJsonValue
    splitPercent?: IntFieldUpdateOperationsInput | number
    platformFeeBps?: IntFieldUpdateOperationsInput | number
    transactionFeeCents?: NullableIntFieldUpdateOperationsInput | number | null
    transactionFeeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicSubscriptionCreateWithoutPlanInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    trialEndsAt: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    canceledAt?: Date | string | null
    cancelReason?: string | null
    currentDoctorsCount?: number
    currentPatientsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutSubscriptionsInput
    addOns?: ClinicAddOnSubscriptionCreateNestedManyWithoutSubscriptionInput
  }

  export type ClinicSubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    clinicId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    trialEndsAt: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    canceledAt?: Date | string | null
    cancelReason?: string | null
    currentDoctorsCount?: number
    currentPatientsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addOns?: ClinicAddOnSubscriptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type ClinicSubscriptionCreateOrConnectWithoutPlanInput = {
    where: ClinicSubscriptionWhereUniqueInput
    create: XOR<ClinicSubscriptionCreateWithoutPlanInput, ClinicSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type ClinicSubscriptionCreateManyPlanInputEnvelope = {
    data: ClinicSubscriptionCreateManyPlanInput | ClinicSubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type ClinicSubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: ClinicSubscriptionWhereUniqueInput
    update: XOR<ClinicSubscriptionUpdateWithoutPlanInput, ClinicSubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<ClinicSubscriptionCreateWithoutPlanInput, ClinicSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type ClinicSubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: ClinicSubscriptionWhereUniqueInput
    data: XOR<ClinicSubscriptionUpdateWithoutPlanInput, ClinicSubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type ClinicSubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: ClinicSubscriptionScalarWhereInput
    data: XOR<ClinicSubscriptionUpdateManyMutationInput, ClinicSubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type ClinicAddOnSubscriptionCreateWithoutAddOnInput = {
    id?: string
    quantity: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: ClinicSubscriptionCreateNestedOneWithoutAddOnsInput
  }

  export type ClinicAddOnSubscriptionUncheckedCreateWithoutAddOnInput = {
    id?: string
    subscriptionId: string
    quantity: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicAddOnSubscriptionCreateOrConnectWithoutAddOnInput = {
    where: ClinicAddOnSubscriptionWhereUniqueInput
    create: XOR<ClinicAddOnSubscriptionCreateWithoutAddOnInput, ClinicAddOnSubscriptionUncheckedCreateWithoutAddOnInput>
  }

  export type ClinicAddOnSubscriptionCreateManyAddOnInputEnvelope = {
    data: ClinicAddOnSubscriptionCreateManyAddOnInput | ClinicAddOnSubscriptionCreateManyAddOnInput[]
    skipDuplicates?: boolean
  }

  export type ClinicAddOnSubscriptionUpsertWithWhereUniqueWithoutAddOnInput = {
    where: ClinicAddOnSubscriptionWhereUniqueInput
    update: XOR<ClinicAddOnSubscriptionUpdateWithoutAddOnInput, ClinicAddOnSubscriptionUncheckedUpdateWithoutAddOnInput>
    create: XOR<ClinicAddOnSubscriptionCreateWithoutAddOnInput, ClinicAddOnSubscriptionUncheckedCreateWithoutAddOnInput>
  }

  export type ClinicAddOnSubscriptionUpdateWithWhereUniqueWithoutAddOnInput = {
    where: ClinicAddOnSubscriptionWhereUniqueInput
    data: XOR<ClinicAddOnSubscriptionUpdateWithoutAddOnInput, ClinicAddOnSubscriptionUncheckedUpdateWithoutAddOnInput>
  }

  export type ClinicAddOnSubscriptionUpdateManyWithWhereWithoutAddOnInput = {
    where: ClinicAddOnSubscriptionScalarWhereInput
    data: XOR<ClinicAddOnSubscriptionUpdateManyMutationInput, ClinicAddOnSubscriptionUncheckedUpdateManyWithoutAddOnInput>
  }

  export type ClinicAddOnSubscriptionScalarWhereInput = {
    AND?: ClinicAddOnSubscriptionScalarWhereInput | ClinicAddOnSubscriptionScalarWhereInput[]
    OR?: ClinicAddOnSubscriptionScalarWhereInput[]
    NOT?: ClinicAddOnSubscriptionScalarWhereInput | ClinicAddOnSubscriptionScalarWhereInput[]
    id?: StringFilter<"ClinicAddOnSubscription"> | string
    subscriptionId?: StringFilter<"ClinicAddOnSubscription"> | string
    addOnId?: StringFilter<"ClinicAddOnSubscription"> | string
    quantity?: IntFilter<"ClinicAddOnSubscription"> | number
    startDate?: DateTimeFilter<"ClinicAddOnSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"ClinicAddOnSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"ClinicAddOnSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicAddOnSubscription"> | Date | string
  }

  export type ClinicCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberCreateNestedManyWithoutClinicInput
    owner: UserCreateNestedOneWithoutOwned_clinicsInput
    products?: ProductCreateNestedManyWithoutClinicInput
    merchant?: MerchantCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberUncheckedCreateNestedManyWithoutClinicInput
    products?: ProductUncheckedCreateNestedManyWithoutClinicInput
    merchant?: MerchantUncheckedCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationUncheckedCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointUncheckedCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutSubscriptionsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutSubscriptionsInput, ClinicUncheckedCreateWithoutSubscriptionsInput>
  }

  export type ClinicPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    tier: $Enums.PlanTier
    description?: string | null
    monthlyPrice: Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: number
    features?: JsonNullValueInput | InputJsonValue
    trialDays?: number
    requireCard?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    tier: $Enums.PlanTier
    description?: string | null
    monthlyPrice: Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: number
    features?: JsonNullValueInput | InputJsonValue
    trialDays?: number
    requireCard?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: ClinicPlanWhereUniqueInput
    create: XOR<ClinicPlanCreateWithoutSubscriptionsInput, ClinicPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type ClinicAddOnSubscriptionCreateWithoutSubscriptionInput = {
    id?: string
    quantity: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addOn: ClinicAddOnCreateNestedOneWithoutSubscriptionsInput
  }

  export type ClinicAddOnSubscriptionUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    addOnId: string
    quantity: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicAddOnSubscriptionCreateOrConnectWithoutSubscriptionInput = {
    where: ClinicAddOnSubscriptionWhereUniqueInput
    create: XOR<ClinicAddOnSubscriptionCreateWithoutSubscriptionInput, ClinicAddOnSubscriptionUncheckedCreateWithoutSubscriptionInput>
  }

  export type ClinicAddOnSubscriptionCreateManySubscriptionInputEnvelope = {
    data: ClinicAddOnSubscriptionCreateManySubscriptionInput | ClinicAddOnSubscriptionCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutSubscriptionsInput = {
    update: XOR<ClinicUpdateWithoutSubscriptionsInput, ClinicUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<ClinicCreateWithoutSubscriptionsInput, ClinicUncheckedCreateWithoutSubscriptionsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutSubscriptionsInput, ClinicUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ClinicUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUpdateManyWithoutClinicNestedInput
    owner?: UserUpdateOneRequiredWithoutOwned_clinicsNestedInput
    products?: ProductUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUncheckedUpdateManyWithoutClinicNestedInput
    products?: ProductUncheckedUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUncheckedUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUncheckedUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUncheckedUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClinicPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<ClinicPlanUpdateWithoutSubscriptionsInput, ClinicPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<ClinicPlanCreateWithoutSubscriptionsInput, ClinicPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: ClinicPlanWhereInput
  }

  export type ClinicPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: ClinicPlanWhereInput
    data: XOR<ClinicPlanUpdateWithoutSubscriptionsInput, ClinicPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ClinicPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    requireCard?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyTxLimit?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    requireCard?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: ClinicAddOnSubscriptionWhereUniqueInput
    update: XOR<ClinicAddOnSubscriptionUpdateWithoutSubscriptionInput, ClinicAddOnSubscriptionUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<ClinicAddOnSubscriptionCreateWithoutSubscriptionInput, ClinicAddOnSubscriptionUncheckedCreateWithoutSubscriptionInput>
  }

  export type ClinicAddOnSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: ClinicAddOnSubscriptionWhereUniqueInput
    data: XOR<ClinicAddOnSubscriptionUpdateWithoutSubscriptionInput, ClinicAddOnSubscriptionUncheckedUpdateWithoutSubscriptionInput>
  }

  export type ClinicAddOnSubscriptionUpdateManyWithWhereWithoutSubscriptionInput = {
    where: ClinicAddOnSubscriptionScalarWhereInput
    data: XOR<ClinicAddOnSubscriptionUpdateManyMutationInput, ClinicAddOnSubscriptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type ClinicSubscriptionCreateWithoutAddOnsInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    trialEndsAt: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    canceledAt?: Date | string | null
    cancelReason?: string | null
    currentDoctorsCount?: number
    currentPatientsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutSubscriptionsInput
    plan: ClinicPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type ClinicSubscriptionUncheckedCreateWithoutAddOnsInput = {
    id?: string
    clinicId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    trialEndsAt: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    canceledAt?: Date | string | null
    cancelReason?: string | null
    currentDoctorsCount?: number
    currentPatientsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicSubscriptionCreateOrConnectWithoutAddOnsInput = {
    where: ClinicSubscriptionWhereUniqueInput
    create: XOR<ClinicSubscriptionCreateWithoutAddOnsInput, ClinicSubscriptionUncheckedCreateWithoutAddOnsInput>
  }

  export type ClinicAddOnCreateWithoutSubscriptionsInput = {
    id?: string
    type: $Enums.AddOnType
    name: string
    description?: string | null
    monthlyPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicAddOnUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    type: $Enums.AddOnType
    name: string
    description?: string | null
    monthlyPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicAddOnCreateOrConnectWithoutSubscriptionsInput = {
    where: ClinicAddOnWhereUniqueInput
    create: XOR<ClinicAddOnCreateWithoutSubscriptionsInput, ClinicAddOnUncheckedCreateWithoutSubscriptionsInput>
  }

  export type ClinicSubscriptionUpsertWithoutAddOnsInput = {
    update: XOR<ClinicSubscriptionUpdateWithoutAddOnsInput, ClinicSubscriptionUncheckedUpdateWithoutAddOnsInput>
    create: XOR<ClinicSubscriptionCreateWithoutAddOnsInput, ClinicSubscriptionUncheckedCreateWithoutAddOnsInput>
    where?: ClinicSubscriptionWhereInput
  }

  export type ClinicSubscriptionUpdateToOneWithWhereWithoutAddOnsInput = {
    where?: ClinicSubscriptionWhereInput
    data: XOR<ClinicSubscriptionUpdateWithoutAddOnsInput, ClinicSubscriptionUncheckedUpdateWithoutAddOnsInput>
  }

  export type ClinicSubscriptionUpdateWithoutAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: ClinicPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type ClinicSubscriptionUncheckedUpdateWithoutAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnUpsertWithoutSubscriptionsInput = {
    update: XOR<ClinicAddOnUpdateWithoutSubscriptionsInput, ClinicAddOnUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<ClinicAddOnCreateWithoutSubscriptionsInput, ClinicAddOnUncheckedCreateWithoutSubscriptionsInput>
    where?: ClinicAddOnWhereInput
  }

  export type ClinicAddOnUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: ClinicAddOnWhereInput
    data: XOR<ClinicAddOnUpdateWithoutSubscriptionsInput, ClinicAddOnUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ClinicAddOnUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCreated_categoriesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutCreated_categoriesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutCreated_categoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreated_categoriesInput, UserUncheckedCreateWithoutCreated_categoriesInput>
  }

  export type ProductCreateWithoutProductCategoryInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    confirmationUrl?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    doctor?: UserCreateNestedOneWithoutCreated_productsInput
    clinic?: ClinicCreateNestedOneWithoutProductsInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsCreateNestedManyWithoutProductInput
    offers?: OfferCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductCategoryInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
    clinicId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsUncheckedCreateNestedManyWithoutProductInput
    offers?: OfferUncheckedCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductCreateManyProductCategoryInputEnvelope = {
    data: ProductCreateManyProductCategoryInput | ProductCreateManyProductCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoriesOnProductsCreateWithoutCategoryInput = {
    assignedAt?: Date | string
    product: ProductCreateNestedOneWithoutCategoriesInput
  }

  export type CategoriesOnProductsUncheckedCreateWithoutCategoryInput = {
    productId: string
    assignedAt?: Date | string
  }

  export type CategoriesOnProductsCreateOrConnectWithoutCategoryInput = {
    where: CategoriesOnProductsWhereUniqueInput
    create: XOR<CategoriesOnProductsCreateWithoutCategoryInput, CategoriesOnProductsUncheckedCreateWithoutCategoryInput>
  }

  export type CategoriesOnProductsCreateManyCategoryInputEnvelope = {
    data: CategoriesOnProductsCreateManyCategoryInput | CategoriesOnProductsCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreated_categoriesInput = {
    update: XOR<UserUpdateWithoutCreated_categoriesInput, UserUncheckedUpdateWithoutCreated_categoriesInput>
    create: XOR<UserCreateWithoutCreated_categoriesInput, UserUncheckedCreateWithoutCreated_categoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreated_categoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreated_categoriesInput, UserUncheckedUpdateWithoutCreated_categoriesInput>
  }

  export type UserUpdateWithoutCreated_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreated_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductCategoryInput>
  }

  export type CategoriesOnProductsUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CategoriesOnProductsWhereUniqueInput
    update: XOR<CategoriesOnProductsUpdateWithoutCategoryInput, CategoriesOnProductsUncheckedUpdateWithoutCategoryInput>
    create: XOR<CategoriesOnProductsCreateWithoutCategoryInput, CategoriesOnProductsUncheckedCreateWithoutCategoryInput>
  }

  export type CategoriesOnProductsUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CategoriesOnProductsWhereUniqueInput
    data: XOR<CategoriesOnProductsUpdateWithoutCategoryInput, CategoriesOnProductsUncheckedUpdateWithoutCategoryInput>
  }

  export type CategoriesOnProductsUpdateManyWithWhereWithoutCategoryInput = {
    where: CategoriesOnProductsScalarWhereInput
    data: XOR<CategoriesOnProductsUpdateManyMutationInput, CategoriesOnProductsUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoriesOnProductsScalarWhereInput = {
    AND?: CategoriesOnProductsScalarWhereInput | CategoriesOnProductsScalarWhereInput[]
    OR?: CategoriesOnProductsScalarWhereInput[]
    NOT?: CategoriesOnProductsScalarWhereInput | CategoriesOnProductsScalarWhereInput[]
    productId?: StringFilter<"CategoriesOnProducts"> | string
    categoryId?: StringFilter<"CategoriesOnProducts"> | string
    assignedAt?: DateTimeFilter<"CategoriesOnProducts"> | Date | string
  }

  export type UserCreateWithoutCreated_productsInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutCreated_productsInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutCreated_productsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreated_productsInput, UserUncheckedCreateWithoutCreated_productsInput>
  }

  export type ClinicCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberCreateNestedManyWithoutClinicInput
    owner: UserCreateNestedOneWithoutOwned_clinicsInput
    subscriptions?: ClinicSubscriptionCreateNestedManyWithoutClinicInput
    merchant?: MerchantCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberUncheckedCreateNestedManyWithoutClinicInput
    subscriptions?: ClinicSubscriptionUncheckedCreateNestedManyWithoutClinicInput
    merchant?: MerchantUncheckedCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationUncheckedCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointUncheckedCreateNestedManyWithoutClinicInput
    outboundEvents?: OutboundWebhookEventUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutProductsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutProductsInput, ClinicUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    slug?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor?: UserCreateNestedOneWithoutCreated_categoriesInput
    categories?: CategoriesOnProductsCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug?: string | null
    doctorId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoriesOnProductsUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type PurchaseCreateWithoutProductInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPurchasesInput
    doctor: UserCreateNestedOneWithoutDoctorPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    doctorId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput>
  }

  export type PurchaseCreateManyProductInputEnvelope = {
    data: PurchaseCreateManyProductInput | PurchaseCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoriesOnProductsCreateWithoutProductInput = {
    assignedAt?: Date | string
    category: ProductCategoryCreateNestedOneWithoutCategoriesInput
  }

  export type CategoriesOnProductsUncheckedCreateWithoutProductInput = {
    categoryId: string
    assignedAt?: Date | string
  }

  export type CategoriesOnProductsCreateOrConnectWithoutProductInput = {
    where: CategoriesOnProductsWhereUniqueInput
    create: XOR<CategoriesOnProductsCreateWithoutProductInput, CategoriesOnProductsUncheckedCreateWithoutProductInput>
  }

  export type CategoriesOnProductsCreateManyProductInputEnvelope = {
    data: CategoriesOnProductsCreateManyProductInput | CategoriesOnProductsCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OfferCreateWithoutProductInput = {
    id?: string
    name: string
    description?: string | null
    currency?: $Enums.Currency
    priceCents: number
    preferredProvider?: $Enums.PaymentProvider | null
    maxInstallments?: number | null
    installmentMinCents?: number | null
    active?: boolean
    isSubscription?: boolean
    intervalCount?: number | null
    intervalUnit?: $Enums.SubscriptionInterval | null
    trialDays?: number | null
    checkoutUrl?: string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: OfferPaymentMethodCreateNestedManyWithoutOfferInput
    prices?: OfferPriceCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    description?: string | null
    currency?: $Enums.Currency
    priceCents: number
    preferredProvider?: $Enums.PaymentProvider | null
    maxInstallments?: number | null
    installmentMinCents?: number | null
    active?: boolean
    isSubscription?: boolean
    intervalCount?: number | null
    intervalUnit?: $Enums.SubscriptionInterval | null
    trialDays?: number | null
    checkoutUrl?: string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: OfferPaymentMethodUncheckedCreateNestedManyWithoutOfferInput
    prices?: OfferPriceUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutProductInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutProductInput, OfferUncheckedCreateWithoutProductInput>
  }

  export type OfferCreateManyProductInputEnvelope = {
    data: OfferCreateManyProductInput | OfferCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductIntegrationCreateWithoutProductInput = {
    id?: string
    provider: $Enums.PaymentProvider
    externalProductId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductIntegrationUncheckedCreateWithoutProductInput = {
    id?: string
    provider: $Enums.PaymentProvider
    externalProductId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductIntegrationCreateOrConnectWithoutProductInput = {
    where: ProductIntegrationWhereUniqueInput
    create: XOR<ProductIntegrationCreateWithoutProductInput, ProductIntegrationUncheckedCreateWithoutProductInput>
  }

  export type ProductIntegrationCreateManyProductInputEnvelope = {
    data: ProductIntegrationCreateManyProductInput | ProductIntegrationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreated_productsInput = {
    update: XOR<UserUpdateWithoutCreated_productsInput, UserUncheckedUpdateWithoutCreated_productsInput>
    create: XOR<UserCreateWithoutCreated_productsInput, UserUncheckedCreateWithoutCreated_productsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreated_productsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreated_productsInput, UserUncheckedUpdateWithoutCreated_productsInput>
  }

  export type UserUpdateWithoutCreated_productsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreated_productsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type ClinicUpsertWithoutProductsInput = {
    update: XOR<ClinicUpdateWithoutProductsInput, ClinicUncheckedUpdateWithoutProductsInput>
    create: XOR<ClinicCreateWithoutProductsInput, ClinicUncheckedCreateWithoutProductsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutProductsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutProductsInput, ClinicUncheckedUpdateWithoutProductsInput>
  }

  export type ClinicUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUpdateManyWithoutClinicNestedInput
    owner?: UserUpdateOneRequiredWithoutOwned_clinicsNestedInput
    subscriptions?: ClinicSubscriptionUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUncheckedUpdateManyWithoutClinicNestedInput
    subscriptions?: ClinicSubscriptionUncheckedUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUncheckedUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUncheckedUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUncheckedUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneWithoutCreated_categoriesNestedInput
    categories?: CategoriesOnProductsUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoriesOnProductsUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type PurchaseUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutProductInput, PurchaseUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutProductInput, PurchaseUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutProductInput>
  }

  export type CategoriesOnProductsUpsertWithWhereUniqueWithoutProductInput = {
    where: CategoriesOnProductsWhereUniqueInput
    update: XOR<CategoriesOnProductsUpdateWithoutProductInput, CategoriesOnProductsUncheckedUpdateWithoutProductInput>
    create: XOR<CategoriesOnProductsCreateWithoutProductInput, CategoriesOnProductsUncheckedCreateWithoutProductInput>
  }

  export type CategoriesOnProductsUpdateWithWhereUniqueWithoutProductInput = {
    where: CategoriesOnProductsWhereUniqueInput
    data: XOR<CategoriesOnProductsUpdateWithoutProductInput, CategoriesOnProductsUncheckedUpdateWithoutProductInput>
  }

  export type CategoriesOnProductsUpdateManyWithWhereWithoutProductInput = {
    where: CategoriesOnProductsScalarWhereInput
    data: XOR<CategoriesOnProductsUpdateManyMutationInput, CategoriesOnProductsUncheckedUpdateManyWithoutProductInput>
  }

  export type OfferUpsertWithWhereUniqueWithoutProductInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutProductInput, OfferUncheckedUpdateWithoutProductInput>
    create: XOR<OfferCreateWithoutProductInput, OfferUncheckedCreateWithoutProductInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutProductInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutProductInput, OfferUncheckedUpdateWithoutProductInput>
  }

  export type OfferUpdateManyWithWhereWithoutProductInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutProductInput>
  }

  export type OfferScalarWhereInput = {
    AND?: OfferScalarWhereInput | OfferScalarWhereInput[]
    OR?: OfferScalarWhereInput[]
    NOT?: OfferScalarWhereInput | OfferScalarWhereInput[]
    id?: StringFilter<"Offer"> | string
    productId?: StringFilter<"Offer"> | string
    name?: StringFilter<"Offer"> | string
    description?: StringNullableFilter<"Offer"> | string | null
    currency?: EnumCurrencyFilter<"Offer"> | $Enums.Currency
    priceCents?: IntFilter<"Offer"> | number
    preferredProvider?: EnumPaymentProviderNullableFilter<"Offer"> | $Enums.PaymentProvider | null
    maxInstallments?: IntNullableFilter<"Offer"> | number | null
    installmentMinCents?: IntNullableFilter<"Offer"> | number | null
    active?: BoolFilter<"Offer"> | boolean
    isSubscription?: BoolFilter<"Offer"> | boolean
    intervalCount?: IntNullableFilter<"Offer"> | number | null
    intervalUnit?: EnumSubscriptionIntervalNullableFilter<"Offer"> | $Enums.SubscriptionInterval | null
    trialDays?: IntNullableFilter<"Offer"> | number | null
    checkoutUrl?: StringNullableFilter<"Offer"> | string | null
    providerConfig?: JsonNullableFilter<"Offer">
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
  }

  export type ProductIntegrationUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductIntegrationWhereUniqueInput
    update: XOR<ProductIntegrationUpdateWithoutProductInput, ProductIntegrationUncheckedUpdateWithoutProductInput>
    create: XOR<ProductIntegrationCreateWithoutProductInput, ProductIntegrationUncheckedCreateWithoutProductInput>
  }

  export type ProductIntegrationUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductIntegrationWhereUniqueInput
    data: XOR<ProductIntegrationUpdateWithoutProductInput, ProductIntegrationUncheckedUpdateWithoutProductInput>
  }

  export type ProductIntegrationUpdateManyWithWhereWithoutProductInput = {
    where: ProductIntegrationScalarWhereInput
    data: XOR<ProductIntegrationUpdateManyMutationInput, ProductIntegrationUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductIntegrationScalarWhereInput = {
    AND?: ProductIntegrationScalarWhereInput | ProductIntegrationScalarWhereInput[]
    OR?: ProductIntegrationScalarWhereInput[]
    NOT?: ProductIntegrationScalarWhereInput | ProductIntegrationScalarWhereInput[]
    id?: StringFilter<"ProductIntegration"> | string
    productId?: StringFilter<"ProductIntegration"> | string
    provider?: EnumPaymentProviderFilter<"ProductIntegration"> | $Enums.PaymentProvider
    externalProductId?: StringFilter<"ProductIntegration"> | string
    metadata?: JsonNullableFilter<"ProductIntegration">
    createdAt?: DateTimeFilter<"ProductIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"ProductIntegration"> | Date | string
  }

  export type ProductCreateWithoutCategoriesInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    confirmationUrl?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    doctor?: UserCreateNestedOneWithoutCreated_productsInput
    clinic?: ClinicCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    offers?: OfferCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
    clinicId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    categoryId?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
    offers?: OfferUncheckedCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductCategoryCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor?: UserCreateNestedOneWithoutCreated_categoriesInput
    products?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug?: string | null
    doctorId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutCategoriesInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutCategoriesInput, ProductCategoryUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpsertWithoutCategoriesInput = {
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doctor?: UserUpdateOneWithoutCreated_productsNestedInput
    clinic?: ClinicUpdateOneWithoutProductsNestedInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    offers?: OfferUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
    offers?: OfferUncheckedUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCategoryUpsertWithoutCategoriesInput = {
    update: XOR<ProductCategoryUpdateWithoutCategoriesInput, ProductCategoryUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCategoryCreateWithoutCategoriesInput, ProductCategoryUncheckedCreateWithoutCategoriesInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutCategoriesInput, ProductCategoryUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductCategoryUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneWithoutCreated_categoriesNestedInput
    products?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCreateWithoutOffersInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    confirmationUrl?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    doctor?: UserCreateNestedOneWithoutCreated_productsInput
    clinic?: ClinicCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOffersInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
    clinicId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    categoryId?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsUncheckedCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOffersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOffersInput, ProductUncheckedCreateWithoutOffersInput>
  }

  export type OfferPaymentMethodCreateWithoutOfferInput = {
    id?: string
    method: $Enums.PaymentMethod
    active?: boolean
    feePercent?: number | null
  }

  export type OfferPaymentMethodUncheckedCreateWithoutOfferInput = {
    id?: string
    method: $Enums.PaymentMethod
    active?: boolean
    feePercent?: number | null
  }

  export type OfferPaymentMethodCreateOrConnectWithoutOfferInput = {
    where: OfferPaymentMethodWhereUniqueInput
    create: XOR<OfferPaymentMethodCreateWithoutOfferInput, OfferPaymentMethodUncheckedCreateWithoutOfferInput>
  }

  export type OfferPaymentMethodCreateManyOfferInputEnvelope = {
    data: OfferPaymentMethodCreateManyOfferInput | OfferPaymentMethodCreateManyOfferInput[]
    skipDuplicates?: boolean
  }

  export type OfferPriceCreateWithoutOfferInput = {
    id?: string
    country: string
    currency: $Enums.Currency
    provider: $Enums.PaymentProvider
    amountCents?: number
    externalPriceId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferPriceUncheckedCreateWithoutOfferInput = {
    id?: string
    country: string
    currency: $Enums.Currency
    provider: $Enums.PaymentProvider
    amountCents?: number
    externalPriceId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferPriceCreateOrConnectWithoutOfferInput = {
    where: OfferPriceWhereUniqueInput
    create: XOR<OfferPriceCreateWithoutOfferInput, OfferPriceUncheckedCreateWithoutOfferInput>
  }

  export type OfferPriceCreateManyOfferInputEnvelope = {
    data: OfferPriceCreateManyOfferInput | OfferPriceCreateManyOfferInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutOffersInput = {
    update: XOR<ProductUpdateWithoutOffersInput, ProductUncheckedUpdateWithoutOffersInput>
    create: XOR<ProductCreateWithoutOffersInput, ProductUncheckedCreateWithoutOffersInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOffersInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOffersInput, ProductUncheckedUpdateWithoutOffersInput>
  }

  export type ProductUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doctor?: UserUpdateOneWithoutCreated_productsNestedInput
    clinic?: ClinicUpdateOneWithoutProductsNestedInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUncheckedUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OfferPaymentMethodUpsertWithWhereUniqueWithoutOfferInput = {
    where: OfferPaymentMethodWhereUniqueInput
    update: XOR<OfferPaymentMethodUpdateWithoutOfferInput, OfferPaymentMethodUncheckedUpdateWithoutOfferInput>
    create: XOR<OfferPaymentMethodCreateWithoutOfferInput, OfferPaymentMethodUncheckedCreateWithoutOfferInput>
  }

  export type OfferPaymentMethodUpdateWithWhereUniqueWithoutOfferInput = {
    where: OfferPaymentMethodWhereUniqueInput
    data: XOR<OfferPaymentMethodUpdateWithoutOfferInput, OfferPaymentMethodUncheckedUpdateWithoutOfferInput>
  }

  export type OfferPaymentMethodUpdateManyWithWhereWithoutOfferInput = {
    where: OfferPaymentMethodScalarWhereInput
    data: XOR<OfferPaymentMethodUpdateManyMutationInput, OfferPaymentMethodUncheckedUpdateManyWithoutOfferInput>
  }

  export type OfferPaymentMethodScalarWhereInput = {
    AND?: OfferPaymentMethodScalarWhereInput | OfferPaymentMethodScalarWhereInput[]
    OR?: OfferPaymentMethodScalarWhereInput[]
    NOT?: OfferPaymentMethodScalarWhereInput | OfferPaymentMethodScalarWhereInput[]
    id?: StringFilter<"OfferPaymentMethod"> | string
    offerId?: StringFilter<"OfferPaymentMethod"> | string
    method?: EnumPaymentMethodFilter<"OfferPaymentMethod"> | $Enums.PaymentMethod
    active?: BoolFilter<"OfferPaymentMethod"> | boolean
    feePercent?: FloatNullableFilter<"OfferPaymentMethod"> | number | null
  }

  export type OfferPriceUpsertWithWhereUniqueWithoutOfferInput = {
    where: OfferPriceWhereUniqueInput
    update: XOR<OfferPriceUpdateWithoutOfferInput, OfferPriceUncheckedUpdateWithoutOfferInput>
    create: XOR<OfferPriceCreateWithoutOfferInput, OfferPriceUncheckedCreateWithoutOfferInput>
  }

  export type OfferPriceUpdateWithWhereUniqueWithoutOfferInput = {
    where: OfferPriceWhereUniqueInput
    data: XOR<OfferPriceUpdateWithoutOfferInput, OfferPriceUncheckedUpdateWithoutOfferInput>
  }

  export type OfferPriceUpdateManyWithWhereWithoutOfferInput = {
    where: OfferPriceScalarWhereInput
    data: XOR<OfferPriceUpdateManyMutationInput, OfferPriceUncheckedUpdateManyWithoutOfferInput>
  }

  export type OfferPriceScalarWhereInput = {
    AND?: OfferPriceScalarWhereInput | OfferPriceScalarWhereInput[]
    OR?: OfferPriceScalarWhereInput[]
    NOT?: OfferPriceScalarWhereInput | OfferPriceScalarWhereInput[]
    id?: StringFilter<"OfferPrice"> | string
    offerId?: StringFilter<"OfferPrice"> | string
    country?: StringFilter<"OfferPrice"> | string
    currency?: EnumCurrencyFilter<"OfferPrice"> | $Enums.Currency
    provider?: EnumPaymentProviderFilter<"OfferPrice"> | $Enums.PaymentProvider
    amountCents?: IntFilter<"OfferPrice"> | number
    externalPriceId?: StringNullableFilter<"OfferPrice"> | string | null
    active?: BoolFilter<"OfferPrice"> | boolean
    createdAt?: DateTimeFilter<"OfferPrice"> | Date | string
    updatedAt?: DateTimeFilter<"OfferPrice"> | Date | string
  }

  export type OfferCreateWithoutPricesInput = {
    id?: string
    name: string
    description?: string | null
    currency?: $Enums.Currency
    priceCents: number
    preferredProvider?: $Enums.PaymentProvider | null
    maxInstallments?: number | null
    installmentMinCents?: number | null
    active?: boolean
    isSubscription?: boolean
    intervalCount?: number | null
    intervalUnit?: $Enums.SubscriptionInterval | null
    trialDays?: number | null
    checkoutUrl?: string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutOffersInput
    paymentMethods?: OfferPaymentMethodCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutPricesInput = {
    id?: string
    productId: string
    name: string
    description?: string | null
    currency?: $Enums.Currency
    priceCents: number
    preferredProvider?: $Enums.PaymentProvider | null
    maxInstallments?: number | null
    installmentMinCents?: number | null
    active?: boolean
    isSubscription?: boolean
    intervalCount?: number | null
    intervalUnit?: $Enums.SubscriptionInterval | null
    trialDays?: number | null
    checkoutUrl?: string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: OfferPaymentMethodUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutPricesInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutPricesInput, OfferUncheckedCreateWithoutPricesInput>
  }

  export type OfferUpsertWithoutPricesInput = {
    update: XOR<OfferUpdateWithoutPricesInput, OfferUncheckedUpdateWithoutPricesInput>
    create: XOR<OfferCreateWithoutPricesInput, OfferUncheckedCreateWithoutPricesInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutPricesInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutPricesInput, OfferUncheckedUpdateWithoutPricesInput>
  }

  export type OfferUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    priceCents?: IntFieldUpdateOperationsInput | number
    preferredProvider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    maxInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    installmentMinCents?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    intervalUnit?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    checkoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOffersNestedInput
    paymentMethods?: OfferPaymentMethodUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    priceCents?: IntFieldUpdateOperationsInput | number
    preferredProvider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    maxInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    installmentMinCents?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    intervalUnit?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    checkoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: OfferPaymentMethodUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferCreateWithoutPaymentMethodsInput = {
    id?: string
    name: string
    description?: string | null
    currency?: $Enums.Currency
    priceCents: number
    preferredProvider?: $Enums.PaymentProvider | null
    maxInstallments?: number | null
    installmentMinCents?: number | null
    active?: boolean
    isSubscription?: boolean
    intervalCount?: number | null
    intervalUnit?: $Enums.SubscriptionInterval | null
    trialDays?: number | null
    checkoutUrl?: string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutOffersInput
    prices?: OfferPriceCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutPaymentMethodsInput = {
    id?: string
    productId: string
    name: string
    description?: string | null
    currency?: $Enums.Currency
    priceCents: number
    preferredProvider?: $Enums.PaymentProvider | null
    maxInstallments?: number | null
    installmentMinCents?: number | null
    active?: boolean
    isSubscription?: boolean
    intervalCount?: number | null
    intervalUnit?: $Enums.SubscriptionInterval | null
    trialDays?: number | null
    checkoutUrl?: string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: OfferPriceUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutPaymentMethodsInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutPaymentMethodsInput, OfferUncheckedCreateWithoutPaymentMethodsInput>
  }

  export type OfferUpsertWithoutPaymentMethodsInput = {
    update: XOR<OfferUpdateWithoutPaymentMethodsInput, OfferUncheckedUpdateWithoutPaymentMethodsInput>
    create: XOR<OfferCreateWithoutPaymentMethodsInput, OfferUncheckedCreateWithoutPaymentMethodsInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutPaymentMethodsInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutPaymentMethodsInput, OfferUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type OfferUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    priceCents?: IntFieldUpdateOperationsInput | number
    preferredProvider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    maxInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    installmentMinCents?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    intervalUnit?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    checkoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOffersNestedInput
    prices?: OfferPriceUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    priceCents?: IntFieldUpdateOperationsInput | number
    preferredProvider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    maxInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    installmentMinCents?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    intervalUnit?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    checkoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: OfferPriceUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type ProductCreateWithoutIntegrationsInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    confirmationUrl?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    doctor?: UserCreateNestedOneWithoutCreated_productsInput
    clinic?: ClinicCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsCreateNestedManyWithoutProductInput
    offers?: OfferCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutIntegrationsInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
    clinicId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    categoryId?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
    categories?: CategoriesOnProductsUncheckedCreateNestedManyWithoutProductInput
    offers?: OfferUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutIntegrationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutIntegrationsInput, ProductUncheckedCreateWithoutIntegrationsInput>
  }

  export type ProductUpsertWithoutIntegrationsInput = {
    update: XOR<ProductUpdateWithoutIntegrationsInput, ProductUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<ProductCreateWithoutIntegrationsInput, ProductUncheckedCreateWithoutIntegrationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutIntegrationsInput, ProductUncheckedUpdateWithoutIntegrationsInput>
  }

  export type ProductUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doctor?: UserUpdateOneWithoutCreated_productsNestedInput
    clinic?: ClinicUpdateOneWithoutProductsNestedInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUpdateManyWithoutProductNestedInput
    offers?: OfferUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUncheckedUpdateManyWithoutProductNestedInput
    offers?: OfferUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PaymentTransactionCreateWithoutCheckoutSessionInput = {
    id: string
    provider: string
    providerOrderId?: string | null
    providerChargeId?: string | null
    doctorId?: string | null
    patientProfileId?: string | null
    clinicId?: string | null
    merchantId?: string | null
    productId?: string | null
    amountCents?: number
    currency?: string
    installments?: number | null
    paymentMethodType?: string | null
    status?: string
    status_v2?: $Enums.PaymentStatus | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    capturedAt?: Date | string | null
    refundStatus?: string | null
    refundedAt?: Date | string | null
    routedProvider?: string | null
    customerId?: string | null
    customerProviderId?: string | null
    customerPaymentMethodId?: string | null
    customerSubscriptionId?: string | null
    billingPeriodStart?: Date | string | null
    billingPeriodEnd?: Date | string | null
    provider_v2?: $Enums.PaymentProvider | null
  }

  export type PaymentTransactionUncheckedCreateWithoutCheckoutSessionInput = {
    id: string
    provider: string
    providerOrderId?: string | null
    providerChargeId?: string | null
    doctorId?: string | null
    patientProfileId?: string | null
    clinicId?: string | null
    merchantId?: string | null
    productId?: string | null
    amountCents?: number
    currency?: string
    installments?: number | null
    paymentMethodType?: string | null
    status?: string
    status_v2?: $Enums.PaymentStatus | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    capturedAt?: Date | string | null
    refundStatus?: string | null
    refundedAt?: Date | string | null
    routedProvider?: string | null
    customerId?: string | null
    customerProviderId?: string | null
    customerPaymentMethodId?: string | null
    customerSubscriptionId?: string | null
    billingPeriodStart?: Date | string | null
    billingPeriodEnd?: Date | string | null
    provider_v2?: $Enums.PaymentProvider | null
  }

  export type PaymentTransactionCreateOrConnectWithoutCheckoutSessionInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutCheckoutSessionInput, PaymentTransactionUncheckedCreateWithoutCheckoutSessionInput>
  }

  export type PaymentTransactionUpsertWithoutCheckoutSessionInput = {
    update: XOR<PaymentTransactionUpdateWithoutCheckoutSessionInput, PaymentTransactionUncheckedUpdateWithoutCheckoutSessionInput>
    create: XOR<PaymentTransactionCreateWithoutCheckoutSessionInput, PaymentTransactionUncheckedCreateWithoutCheckoutSessionInput>
    where?: PaymentTransactionWhereInput
  }

  export type PaymentTransactionUpdateToOneWithWhereWithoutCheckoutSessionInput = {
    where?: PaymentTransactionWhereInput
    data: XOR<PaymentTransactionUpdateWithoutCheckoutSessionInput, PaymentTransactionUncheckedUpdateWithoutCheckoutSessionInput>
  }

  export type PaymentTransactionUpdateWithoutCheckoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    providerChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    patientProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    installments?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethodType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    status_v2?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routedProvider?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    customerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_v2?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
  }

  export type PaymentTransactionUncheckedUpdateWithoutCheckoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    providerChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    patientProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    installments?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethodType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    status_v2?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routedProvider?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    customerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_v2?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
  }

  export type CheckoutSessionCreateWithoutPaymentTransactionInput = {
    id?: string
    resumeToken: string
    clinicId?: string | null
    productId?: string | null
    offerId?: string | null
    slug?: string | null
    provider?: $Enums.PaymentProvider | null
    country?: string | null
    locale?: string | null
    status?: $Enums.CheckoutSessionStatus
    paymentMethod?: $Enums.CheckoutPaymentMethod | null
    orderId?: string | null
    pixOrderId?: string | null
    pixExpiresAt?: Date | string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmTerm?: string | null
    utmContent?: string | null
    referrer?: string | null
    ip?: string | null
    userAgent?: string | null
    selectedInstallments?: number | null
    selectedBank?: string | null
    paymentMethodsAllowed?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastHeartbeatAt?: Date | string | null
    lastStep?: string | null
    reminders?: NullableJsonNullValueInput | InputJsonValue
    reminderExpiringSentAt?: Date | string | null
    reminderExpiredSentAt?: Date | string | null
    conversionLikelihood?: number | null
    origin?: string | null
    createdBy?: string | null
  }

  export type CheckoutSessionUncheckedCreateWithoutPaymentTransactionInput = {
    id?: string
    resumeToken: string
    clinicId?: string | null
    productId?: string | null
    offerId?: string | null
    slug?: string | null
    provider?: $Enums.PaymentProvider | null
    country?: string | null
    locale?: string | null
    status?: $Enums.CheckoutSessionStatus
    paymentMethod?: $Enums.CheckoutPaymentMethod | null
    orderId?: string | null
    pixOrderId?: string | null
    pixExpiresAt?: Date | string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmTerm?: string | null
    utmContent?: string | null
    referrer?: string | null
    ip?: string | null
    userAgent?: string | null
    selectedInstallments?: number | null
    selectedBank?: string | null
    paymentMethodsAllowed?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastHeartbeatAt?: Date | string | null
    lastStep?: string | null
    reminders?: NullableJsonNullValueInput | InputJsonValue
    reminderExpiringSentAt?: Date | string | null
    reminderExpiredSentAt?: Date | string | null
    conversionLikelihood?: number | null
    origin?: string | null
    createdBy?: string | null
  }

  export type CheckoutSessionCreateOrConnectWithoutPaymentTransactionInput = {
    where: CheckoutSessionWhereUniqueInput
    create: XOR<CheckoutSessionCreateWithoutPaymentTransactionInput, CheckoutSessionUncheckedCreateWithoutPaymentTransactionInput>
  }

  export type CheckoutSessionUpsertWithoutPaymentTransactionInput = {
    update: XOR<CheckoutSessionUpdateWithoutPaymentTransactionInput, CheckoutSessionUncheckedUpdateWithoutPaymentTransactionInput>
    create: XOR<CheckoutSessionCreateWithoutPaymentTransactionInput, CheckoutSessionUncheckedCreateWithoutPaymentTransactionInput>
    where?: CheckoutSessionWhereInput
  }

  export type CheckoutSessionUpdateToOneWithWhereWithoutPaymentTransactionInput = {
    where?: CheckoutSessionWhereInput
    data: XOR<CheckoutSessionUpdateWithoutPaymentTransactionInput, CheckoutSessionUncheckedUpdateWithoutPaymentTransactionInput>
  }

  export type CheckoutSessionUpdateWithoutPaymentTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeToken?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckoutSessionStatusFieldUpdateOperationsInput | $Enums.CheckoutSessionStatus
    paymentMethod?: NullableEnumCheckoutPaymentMethodFieldUpdateOperationsInput | $Enums.CheckoutPaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmTerm?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    selectedInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    selectedBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethodsAllowed?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStep?: NullableStringFieldUpdateOperationsInput | string | null
    reminders?: NullableJsonNullValueInput | InputJsonValue
    reminderExpiringSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderExpiredSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionLikelihood?: NullableFloatFieldUpdateOperationsInput | number | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckoutSessionUncheckedUpdateWithoutPaymentTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeToken?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckoutSessionStatusFieldUpdateOperationsInput | $Enums.CheckoutSessionStatus
    paymentMethod?: NullableEnumCheckoutPaymentMethodFieldUpdateOperationsInput | $Enums.CheckoutPaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmTerm?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    selectedInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    selectedBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethodsAllowed?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStep?: NullableStringFieldUpdateOperationsInput | string | null
    reminders?: NullableJsonNullValueInput | InputJsonValue
    reminderExpiringSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderExpiredSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionLikelihood?: NullableFloatFieldUpdateOperationsInput | number | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutPurchasesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutPurchasesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutPurchasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
  }

  export type UserCreateWithoutDoctorPurchasesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutDoctorPurchasesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutDoctorPurchasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorPurchasesInput, UserUncheckedCreateWithoutDoctorPurchasesInput>
  }

  export type ProductCreateWithoutPurchasesInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    confirmationUrl?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    doctor?: UserCreateNestedOneWithoutCreated_productsInput
    clinic?: ClinicCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    categories?: CategoriesOnProductsCreateNestedManyWithoutProductInput
    offers?: OfferCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchasesInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
    clinicId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    categoryId?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
    categories?: CategoriesOnProductsUncheckedCreateNestedManyWithoutProductInput
    offers?: OfferUncheckedCreateNestedManyWithoutProductInput
    integrations?: ProductIntegrationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchasesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
  }

  export type UserUpsertWithoutPurchasesInput = {
    update: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type UserUpsertWithoutDoctorPurchasesInput = {
    update: XOR<UserUpdateWithoutDoctorPurchasesInput, UserUncheckedUpdateWithoutDoctorPurchasesInput>
    create: XOR<UserCreateWithoutDoctorPurchasesInput, UserUncheckedCreateWithoutDoctorPurchasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorPurchasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorPurchasesInput, UserUncheckedUpdateWithoutDoctorPurchasesInput>
  }

  export type UserUpdateWithoutDoctorPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type ProductUpsertWithoutPurchasesInput = {
    update: XOR<ProductUpdateWithoutPurchasesInput, ProductUncheckedUpdateWithoutPurchasesInput>
    create: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchasesInput, ProductUncheckedUpdateWithoutPurchasesInput>
  }

  export type ProductUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doctor?: UserUpdateOneWithoutCreated_productsNestedInput
    clinic?: ClinicUpdateOneWithoutProductsNestedInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsNestedInput
    categories?: CategoriesOnProductsUpdateManyWithoutProductNestedInput
    offers?: OfferUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categories?: CategoriesOnProductsUncheckedUpdateManyWithoutProductNestedInput
    offers?: OfferUncheckedUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CustomerProviderCreateWithoutCustomerInput = {
    id?: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerCustomerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: CustomerPaymentMethodCreateNestedManyWithoutCustomerProviderInput
    subscriptions?: CustomerSubscriptionCreateNestedManyWithoutCustomerProviderInput
  }

  export type CustomerProviderUncheckedCreateWithoutCustomerInput = {
    id?: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerCustomerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: CustomerPaymentMethodUncheckedCreateNestedManyWithoutCustomerProviderInput
    subscriptions?: CustomerSubscriptionUncheckedCreateNestedManyWithoutCustomerProviderInput
  }

  export type CustomerProviderCreateOrConnectWithoutCustomerInput = {
    where: CustomerProviderWhereUniqueInput
    create: XOR<CustomerProviderCreateWithoutCustomerInput, CustomerProviderUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerProviderCreateManyCustomerInputEnvelope = {
    data: CustomerProviderCreateManyCustomerInput | CustomerProviderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerPaymentMethodCreateWithoutCustomerInput = {
    id?: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerPaymentMethodId?: string | null
    brand?: string | null
    last4?: string | null
    expMonth?: number | null
    expYear?: number | null
    isDefault?: boolean
    status?: string | null
    fingerprint?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customerProvider?: CustomerProviderCreateNestedOneWithoutPaymentMethodsInput
  }

  export type CustomerPaymentMethodUncheckedCreateWithoutCustomerInput = {
    id?: string
    customerProviderId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerPaymentMethodId?: string | null
    brand?: string | null
    last4?: string | null
    expMonth?: number | null
    expYear?: number | null
    isDefault?: boolean
    status?: string | null
    fingerprint?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentMethodCreateOrConnectWithoutCustomerInput = {
    where: CustomerPaymentMethodWhereUniqueInput
    create: XOR<CustomerPaymentMethodCreateWithoutCustomerInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerPaymentMethodCreateManyCustomerInputEnvelope = {
    data: CustomerPaymentMethodCreateManyCustomerInput | CustomerPaymentMethodCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerSubscriptionCreateWithoutCustomerInput = {
    id?: string
    merchantId: string
    productId: string
    offerId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    isNative?: boolean
    providerSubscriptionId?: string | null
    vaultPaymentMethodId?: string | null
    status?: $Enums.SubscriptionStatus
    startAt?: Date | string
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    priceCents: number
    currency: $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customerProvider?: CustomerProviderCreateNestedOneWithoutSubscriptionsInput
  }

  export type CustomerSubscriptionUncheckedCreateWithoutCustomerInput = {
    id?: string
    merchantId: string
    productId: string
    offerId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    isNative?: boolean
    customerProviderId?: string | null
    providerSubscriptionId?: string | null
    vaultPaymentMethodId?: string | null
    status?: $Enums.SubscriptionStatus
    startAt?: Date | string
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    priceCents: number
    currency: $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSubscriptionCreateOrConnectWithoutCustomerInput = {
    where: CustomerSubscriptionWhereUniqueInput
    create: XOR<CustomerSubscriptionCreateWithoutCustomerInput, CustomerSubscriptionUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerSubscriptionCreateManyCustomerInputEnvelope = {
    data: CustomerSubscriptionCreateManyCustomerInput | CustomerSubscriptionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerProviderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerProviderWhereUniqueInput
    update: XOR<CustomerProviderUpdateWithoutCustomerInput, CustomerProviderUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerProviderCreateWithoutCustomerInput, CustomerProviderUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerProviderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerProviderWhereUniqueInput
    data: XOR<CustomerProviderUpdateWithoutCustomerInput, CustomerProviderUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerProviderUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerProviderScalarWhereInput
    data: XOR<CustomerProviderUpdateManyMutationInput, CustomerProviderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerProviderScalarWhereInput = {
    AND?: CustomerProviderScalarWhereInput | CustomerProviderScalarWhereInput[]
    OR?: CustomerProviderScalarWhereInput[]
    NOT?: CustomerProviderScalarWhereInput | CustomerProviderScalarWhereInput[]
    id?: StringFilter<"CustomerProvider"> | string
    customerId?: StringFilter<"CustomerProvider"> | string
    provider?: EnumPaymentProviderFilter<"CustomerProvider"> | $Enums.PaymentProvider
    accountId?: StringNullableFilter<"CustomerProvider"> | string | null
    providerCustomerId?: StringNullableFilter<"CustomerProvider"> | string | null
    metadata?: JsonNullableFilter<"CustomerProvider">
    createdAt?: DateTimeFilter<"CustomerProvider"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerProvider"> | Date | string
  }

  export type CustomerPaymentMethodUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerPaymentMethodWhereUniqueInput
    update: XOR<CustomerPaymentMethodUpdateWithoutCustomerInput, CustomerPaymentMethodUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerPaymentMethodCreateWithoutCustomerInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerPaymentMethodUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerPaymentMethodWhereUniqueInput
    data: XOR<CustomerPaymentMethodUpdateWithoutCustomerInput, CustomerPaymentMethodUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerPaymentMethodUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerPaymentMethodScalarWhereInput
    data: XOR<CustomerPaymentMethodUpdateManyMutationInput, CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerPaymentMethodScalarWhereInput = {
    AND?: CustomerPaymentMethodScalarWhereInput | CustomerPaymentMethodScalarWhereInput[]
    OR?: CustomerPaymentMethodScalarWhereInput[]
    NOT?: CustomerPaymentMethodScalarWhereInput | CustomerPaymentMethodScalarWhereInput[]
    id?: StringFilter<"CustomerPaymentMethod"> | string
    customerId?: StringFilter<"CustomerPaymentMethod"> | string
    customerProviderId?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    provider?: EnumPaymentProviderFilter<"CustomerPaymentMethod"> | $Enums.PaymentProvider
    accountId?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    providerPaymentMethodId?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    brand?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    last4?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    expMonth?: IntNullableFilter<"CustomerPaymentMethod"> | number | null
    expYear?: IntNullableFilter<"CustomerPaymentMethod"> | number | null
    isDefault?: BoolFilter<"CustomerPaymentMethod"> | boolean
    status?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    fingerprint?: StringNullableFilter<"CustomerPaymentMethod"> | string | null
    metadata?: JsonNullableFilter<"CustomerPaymentMethod">
    createdAt?: DateTimeFilter<"CustomerPaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPaymentMethod"> | Date | string
  }

  export type CustomerSubscriptionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerSubscriptionWhereUniqueInput
    update: XOR<CustomerSubscriptionUpdateWithoutCustomerInput, CustomerSubscriptionUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerSubscriptionCreateWithoutCustomerInput, CustomerSubscriptionUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerSubscriptionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerSubscriptionWhereUniqueInput
    data: XOR<CustomerSubscriptionUpdateWithoutCustomerInput, CustomerSubscriptionUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerSubscriptionUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerSubscriptionScalarWhereInput
    data: XOR<CustomerSubscriptionUpdateManyMutationInput, CustomerSubscriptionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerSubscriptionScalarWhereInput = {
    AND?: CustomerSubscriptionScalarWhereInput | CustomerSubscriptionScalarWhereInput[]
    OR?: CustomerSubscriptionScalarWhereInput[]
    NOT?: CustomerSubscriptionScalarWhereInput | CustomerSubscriptionScalarWhereInput[]
    id?: StringFilter<"CustomerSubscription"> | string
    customerId?: StringFilter<"CustomerSubscription"> | string
    merchantId?: StringFilter<"CustomerSubscription"> | string
    productId?: StringFilter<"CustomerSubscription"> | string
    offerId?: StringNullableFilter<"CustomerSubscription"> | string | null
    provider?: EnumPaymentProviderFilter<"CustomerSubscription"> | $Enums.PaymentProvider
    accountId?: StringNullableFilter<"CustomerSubscription"> | string | null
    isNative?: BoolFilter<"CustomerSubscription"> | boolean
    customerProviderId?: StringNullableFilter<"CustomerSubscription"> | string | null
    providerSubscriptionId?: StringNullableFilter<"CustomerSubscription"> | string | null
    vaultPaymentMethodId?: StringNullableFilter<"CustomerSubscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"CustomerSubscription"> | $Enums.SubscriptionStatus
    startAt?: DateTimeFilter<"CustomerSubscription"> | Date | string
    trialEndsAt?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    cancelAt?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"CustomerSubscription"> | Date | string | null
    priceCents?: IntFilter<"CustomerSubscription"> | number
    currency?: EnumCurrencyFilter<"CustomerSubscription"> | $Enums.Currency
    metadata?: JsonNullableFilter<"CustomerSubscription">
    createdAt?: DateTimeFilter<"CustomerSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerSubscription"> | Date | string
  }

  export type CustomerCreateWithoutProvidersInput = {
    id?: string
    merchantId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: CustomerPaymentMethodCreateNestedManyWithoutCustomerInput
    subscriptions?: CustomerSubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutProvidersInput = {
    id?: string
    merchantId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: CustomerPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: CustomerSubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutProvidersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutProvidersInput, CustomerUncheckedCreateWithoutProvidersInput>
  }

  export type CustomerPaymentMethodCreateWithoutCustomerProviderInput = {
    id?: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerPaymentMethodId?: string | null
    brand?: string | null
    last4?: string | null
    expMonth?: number | null
    expYear?: number | null
    isDefault?: boolean
    status?: string | null
    fingerprint?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutPaymentMethodsInput
  }

  export type CustomerPaymentMethodUncheckedCreateWithoutCustomerProviderInput = {
    id?: string
    customerId: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerPaymentMethodId?: string | null
    brand?: string | null
    last4?: string | null
    expMonth?: number | null
    expYear?: number | null
    isDefault?: boolean
    status?: string | null
    fingerprint?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentMethodCreateOrConnectWithoutCustomerProviderInput = {
    where: CustomerPaymentMethodWhereUniqueInput
    create: XOR<CustomerPaymentMethodCreateWithoutCustomerProviderInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerProviderInput>
  }

  export type CustomerPaymentMethodCreateManyCustomerProviderInputEnvelope = {
    data: CustomerPaymentMethodCreateManyCustomerProviderInput | CustomerPaymentMethodCreateManyCustomerProviderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerSubscriptionCreateWithoutCustomerProviderInput = {
    id?: string
    merchantId: string
    productId: string
    offerId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    isNative?: boolean
    providerSubscriptionId?: string | null
    vaultPaymentMethodId?: string | null
    status?: $Enums.SubscriptionStatus
    startAt?: Date | string
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    priceCents: number
    currency: $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
  }

  export type CustomerSubscriptionUncheckedCreateWithoutCustomerProviderInput = {
    id?: string
    customerId: string
    merchantId: string
    productId: string
    offerId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    isNative?: boolean
    providerSubscriptionId?: string | null
    vaultPaymentMethodId?: string | null
    status?: $Enums.SubscriptionStatus
    startAt?: Date | string
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    priceCents: number
    currency: $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSubscriptionCreateOrConnectWithoutCustomerProviderInput = {
    where: CustomerSubscriptionWhereUniqueInput
    create: XOR<CustomerSubscriptionCreateWithoutCustomerProviderInput, CustomerSubscriptionUncheckedCreateWithoutCustomerProviderInput>
  }

  export type CustomerSubscriptionCreateManyCustomerProviderInputEnvelope = {
    data: CustomerSubscriptionCreateManyCustomerProviderInput | CustomerSubscriptionCreateManyCustomerProviderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutProvidersInput = {
    update: XOR<CustomerUpdateWithoutProvidersInput, CustomerUncheckedUpdateWithoutProvidersInput>
    create: XOR<CustomerCreateWithoutProvidersInput, CustomerUncheckedCreateWithoutProvidersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutProvidersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutProvidersInput, CustomerUncheckedUpdateWithoutProvidersInput>
  }

  export type CustomerUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: CustomerPaymentMethodUpdateManyWithoutCustomerNestedInput
    subscriptions?: CustomerSubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: CustomerSubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerPaymentMethodUpsertWithWhereUniqueWithoutCustomerProviderInput = {
    where: CustomerPaymentMethodWhereUniqueInput
    update: XOR<CustomerPaymentMethodUpdateWithoutCustomerProviderInput, CustomerPaymentMethodUncheckedUpdateWithoutCustomerProviderInput>
    create: XOR<CustomerPaymentMethodCreateWithoutCustomerProviderInput, CustomerPaymentMethodUncheckedCreateWithoutCustomerProviderInput>
  }

  export type CustomerPaymentMethodUpdateWithWhereUniqueWithoutCustomerProviderInput = {
    where: CustomerPaymentMethodWhereUniqueInput
    data: XOR<CustomerPaymentMethodUpdateWithoutCustomerProviderInput, CustomerPaymentMethodUncheckedUpdateWithoutCustomerProviderInput>
  }

  export type CustomerPaymentMethodUpdateManyWithWhereWithoutCustomerProviderInput = {
    where: CustomerPaymentMethodScalarWhereInput
    data: XOR<CustomerPaymentMethodUpdateManyMutationInput, CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerProviderInput>
  }

  export type CustomerSubscriptionUpsertWithWhereUniqueWithoutCustomerProviderInput = {
    where: CustomerSubscriptionWhereUniqueInput
    update: XOR<CustomerSubscriptionUpdateWithoutCustomerProviderInput, CustomerSubscriptionUncheckedUpdateWithoutCustomerProviderInput>
    create: XOR<CustomerSubscriptionCreateWithoutCustomerProviderInput, CustomerSubscriptionUncheckedCreateWithoutCustomerProviderInput>
  }

  export type CustomerSubscriptionUpdateWithWhereUniqueWithoutCustomerProviderInput = {
    where: CustomerSubscriptionWhereUniqueInput
    data: XOR<CustomerSubscriptionUpdateWithoutCustomerProviderInput, CustomerSubscriptionUncheckedUpdateWithoutCustomerProviderInput>
  }

  export type CustomerSubscriptionUpdateManyWithWhereWithoutCustomerProviderInput = {
    where: CustomerSubscriptionScalarWhereInput
    data: XOR<CustomerSubscriptionUpdateManyMutationInput, CustomerSubscriptionUncheckedUpdateManyWithoutCustomerProviderInput>
  }

  export type CustomerCreateWithoutPaymentMethodsInput = {
    id?: string
    merchantId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    providers?: CustomerProviderCreateNestedManyWithoutCustomerInput
    subscriptions?: CustomerSubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPaymentMethodsInput = {
    id?: string
    merchantId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    providers?: CustomerProviderUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: CustomerSubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPaymentMethodsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPaymentMethodsInput, CustomerUncheckedCreateWithoutPaymentMethodsInput>
  }

  export type CustomerProviderCreateWithoutPaymentMethodsInput = {
    id?: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerCustomerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutProvidersInput
    subscriptions?: CustomerSubscriptionCreateNestedManyWithoutCustomerProviderInput
  }

  export type CustomerProviderUncheckedCreateWithoutPaymentMethodsInput = {
    id?: string
    customerId: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerCustomerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: CustomerSubscriptionUncheckedCreateNestedManyWithoutCustomerProviderInput
  }

  export type CustomerProviderCreateOrConnectWithoutPaymentMethodsInput = {
    where: CustomerProviderWhereUniqueInput
    create: XOR<CustomerProviderCreateWithoutPaymentMethodsInput, CustomerProviderUncheckedCreateWithoutPaymentMethodsInput>
  }

  export type CustomerUpsertWithoutPaymentMethodsInput = {
    update: XOR<CustomerUpdateWithoutPaymentMethodsInput, CustomerUncheckedUpdateWithoutPaymentMethodsInput>
    create: XOR<CustomerCreateWithoutPaymentMethodsInput, CustomerUncheckedCreateWithoutPaymentMethodsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPaymentMethodsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPaymentMethodsInput, CustomerUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type CustomerUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: CustomerProviderUpdateManyWithoutCustomerNestedInput
    subscriptions?: CustomerSubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: CustomerProviderUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: CustomerSubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerProviderUpsertWithoutPaymentMethodsInput = {
    update: XOR<CustomerProviderUpdateWithoutPaymentMethodsInput, CustomerProviderUncheckedUpdateWithoutPaymentMethodsInput>
    create: XOR<CustomerProviderCreateWithoutPaymentMethodsInput, CustomerProviderUncheckedCreateWithoutPaymentMethodsInput>
    where?: CustomerProviderWhereInput
  }

  export type CustomerProviderUpdateToOneWithWhereWithoutPaymentMethodsInput = {
    where?: CustomerProviderWhereInput
    data: XOR<CustomerProviderUpdateWithoutPaymentMethodsInput, CustomerProviderUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type CustomerProviderUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutProvidersNestedInput
    subscriptions?: CustomerSubscriptionUpdateManyWithoutCustomerProviderNestedInput
  }

  export type CustomerProviderUncheckedUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: CustomerSubscriptionUncheckedUpdateManyWithoutCustomerProviderNestedInput
  }

  export type CustomerCreateWithoutSubscriptionsInput = {
    id?: string
    merchantId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    providers?: CustomerProviderCreateNestedManyWithoutCustomerInput
    paymentMethods?: CustomerPaymentMethodCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    merchantId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    document?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    providers?: CustomerProviderUncheckedCreateNestedManyWithoutCustomerInput
    paymentMethods?: CustomerPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSubscriptionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
  }

  export type CustomerProviderCreateWithoutSubscriptionsInput = {
    id?: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerCustomerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutProvidersInput
    paymentMethods?: CustomerPaymentMethodCreateNestedManyWithoutCustomerProviderInput
  }

  export type CustomerProviderUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    customerId: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerCustomerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: CustomerPaymentMethodUncheckedCreateNestedManyWithoutCustomerProviderInput
  }

  export type CustomerProviderCreateOrConnectWithoutSubscriptionsInput = {
    where: CustomerProviderWhereUniqueInput
    create: XOR<CustomerProviderCreateWithoutSubscriptionsInput, CustomerProviderUncheckedCreateWithoutSubscriptionsInput>
  }

  export type CustomerUpsertWithoutSubscriptionsInput = {
    update: XOR<CustomerUpdateWithoutSubscriptionsInput, CustomerUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSubscriptionsInput, CustomerUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CustomerUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: CustomerProviderUpdateManyWithoutCustomerNestedInput
    paymentMethods?: CustomerPaymentMethodUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: CustomerProviderUncheckedUpdateManyWithoutCustomerNestedInput
    paymentMethods?: CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerProviderUpsertWithoutSubscriptionsInput = {
    update: XOR<CustomerProviderUpdateWithoutSubscriptionsInput, CustomerProviderUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<CustomerProviderCreateWithoutSubscriptionsInput, CustomerProviderUncheckedCreateWithoutSubscriptionsInput>
    where?: CustomerProviderWhereInput
  }

  export type CustomerProviderUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: CustomerProviderWhereInput
    data: XOR<CustomerProviderUpdateWithoutSubscriptionsInput, CustomerProviderUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CustomerProviderUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutProvidersNestedInput
    paymentMethods?: CustomerPaymentMethodUpdateManyWithoutCustomerProviderNestedInput
  }

  export type CustomerProviderUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerProviderNestedInput
  }

  export type UserCreateWithoutMessage_templatesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_sequences?: MessageSequenceCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutMessage_templatesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_sequences?: MessageSequenceUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutMessage_templatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessage_templatesInput, UserUncheckedCreateWithoutMessage_templatesInput>
  }

  export type MessageSequenceStepCreateWithoutTemplateInput = {
    id?: string
    orderIndex?: number
    delayAmount?: number
    delayUnit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sequence: MessageSequenceCreateNestedOneWithoutStepsInput
  }

  export type MessageSequenceStepUncheckedCreateWithoutTemplateInput = {
    id?: string
    sequenceId: string
    orderIndex?: number
    delayAmount?: number
    delayUnit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageSequenceStepCreateOrConnectWithoutTemplateInput = {
    where: MessageSequenceStepWhereUniqueInput
    create: XOR<MessageSequenceStepCreateWithoutTemplateInput, MessageSequenceStepUncheckedCreateWithoutTemplateInput>
  }

  export type MessageSequenceStepCreateManyTemplateInputEnvelope = {
    data: MessageSequenceStepCreateManyTemplateInput | MessageSequenceStepCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMessage_templatesInput = {
    update: XOR<UserUpdateWithoutMessage_templatesInput, UserUncheckedUpdateWithoutMessage_templatesInput>
    create: XOR<UserCreateWithoutMessage_templatesInput, UserUncheckedCreateWithoutMessage_templatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessage_templatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessage_templatesInput, UserUncheckedUpdateWithoutMessage_templatesInput>
  }

  export type UserUpdateWithoutMessage_templatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutMessage_templatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type MessageSequenceStepUpsertWithWhereUniqueWithoutTemplateInput = {
    where: MessageSequenceStepWhereUniqueInput
    update: XOR<MessageSequenceStepUpdateWithoutTemplateInput, MessageSequenceStepUncheckedUpdateWithoutTemplateInput>
    create: XOR<MessageSequenceStepCreateWithoutTemplateInput, MessageSequenceStepUncheckedCreateWithoutTemplateInput>
  }

  export type MessageSequenceStepUpdateWithWhereUniqueWithoutTemplateInput = {
    where: MessageSequenceStepWhereUniqueInput
    data: XOR<MessageSequenceStepUpdateWithoutTemplateInput, MessageSequenceStepUncheckedUpdateWithoutTemplateInput>
  }

  export type MessageSequenceStepUpdateManyWithWhereWithoutTemplateInput = {
    where: MessageSequenceStepScalarWhereInput
    data: XOR<MessageSequenceStepUpdateManyMutationInput, MessageSequenceStepUncheckedUpdateManyWithoutTemplateInput>
  }

  export type MessageSequenceStepScalarWhereInput = {
    AND?: MessageSequenceStepScalarWhereInput | MessageSequenceStepScalarWhereInput[]
    OR?: MessageSequenceStepScalarWhereInput[]
    NOT?: MessageSequenceStepScalarWhereInput | MessageSequenceStepScalarWhereInput[]
    id?: StringFilter<"MessageSequenceStep"> | string
    sequenceId?: StringFilter<"MessageSequenceStep"> | string
    orderIndex?: IntFilter<"MessageSequenceStep"> | number
    delayAmount?: IntFilter<"MessageSequenceStep"> | number
    delayUnit?: StringFilter<"MessageSequenceStep"> | string
    templateId?: StringFilter<"MessageSequenceStep"> | string
    createdAt?: DateTimeFilter<"MessageSequenceStep"> | Date | string
    updatedAt?: DateTimeFilter<"MessageSequenceStep"> | Date | string
  }

  export type UserCreateWithoutMessage_sequencesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_usersInput
    other_users?: UserCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicCreateNestedManyWithoutOwnerInput
    created_products?: ProductCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateCreateNestedManyWithoutDoctorInput
  }

  export type UserUncheckedCreateWithoutMessage_sequencesInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    doctor_id?: string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    other_users?: UserUncheckedCreateNestedManyWithoutUserInput
    clinic_memberships?: ClinicMemberUncheckedCreateNestedManyWithoutUserInput
    owned_clinics?: ClinicUncheckedCreateNestedManyWithoutOwnerInput
    created_products?: ProductUncheckedCreateNestedManyWithoutDoctorInput
    created_categories?: ProductCategoryUncheckedCreateNestedManyWithoutDoctorInput
    user_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    doctor_verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutDoctorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    doctorPurchases?: PurchaseUncheckedCreateNestedManyWithoutDoctorInput
    pointsLedger?: PointsLedgerUncheckedCreateNestedManyWithoutUserInput
    doctor_profiles?: PatientProfileUncheckedCreateNestedManyWithoutDoctorInput
    patient_profiles?: PatientProfileUncheckedCreateNestedManyWithoutPatientInput
    message_templates?: MessageTemplateUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutMessage_sequencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessage_sequencesInput, UserUncheckedCreateWithoutMessage_sequencesInput>
  }

  export type MessageSequenceStepCreateWithoutSequenceInput = {
    id?: string
    orderIndex?: number
    delayAmount?: number
    delayUnit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    template: MessageTemplateCreateNestedOneWithoutStepsInput
  }

  export type MessageSequenceStepUncheckedCreateWithoutSequenceInput = {
    id?: string
    orderIndex?: number
    delayAmount?: number
    delayUnit?: string
    templateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageSequenceStepCreateOrConnectWithoutSequenceInput = {
    where: MessageSequenceStepWhereUniqueInput
    create: XOR<MessageSequenceStepCreateWithoutSequenceInput, MessageSequenceStepUncheckedCreateWithoutSequenceInput>
  }

  export type MessageSequenceStepCreateManySequenceInputEnvelope = {
    data: MessageSequenceStepCreateManySequenceInput | MessageSequenceStepCreateManySequenceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMessage_sequencesInput = {
    update: XOR<UserUpdateWithoutMessage_sequencesInput, UserUncheckedUpdateWithoutMessage_sequencesInput>
    create: XOR<UserCreateWithoutMessage_sequencesInput, UserUncheckedCreateWithoutMessage_sequencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessage_sequencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessage_sequencesInput, UserUncheckedUpdateWithoutMessage_sequencesInput>
  }

  export type UserUpdateWithoutMessage_sequencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_usersNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutMessage_sequencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type MessageSequenceStepUpsertWithWhereUniqueWithoutSequenceInput = {
    where: MessageSequenceStepWhereUniqueInput
    update: XOR<MessageSequenceStepUpdateWithoutSequenceInput, MessageSequenceStepUncheckedUpdateWithoutSequenceInput>
    create: XOR<MessageSequenceStepCreateWithoutSequenceInput, MessageSequenceStepUncheckedCreateWithoutSequenceInput>
  }

  export type MessageSequenceStepUpdateWithWhereUniqueWithoutSequenceInput = {
    where: MessageSequenceStepWhereUniqueInput
    data: XOR<MessageSequenceStepUpdateWithoutSequenceInput, MessageSequenceStepUncheckedUpdateWithoutSequenceInput>
  }

  export type MessageSequenceStepUpdateManyWithWhereWithoutSequenceInput = {
    where: MessageSequenceStepScalarWhereInput
    data: XOR<MessageSequenceStepUpdateManyMutationInput, MessageSequenceStepUncheckedUpdateManyWithoutSequenceInput>
  }

  export type MessageSequenceCreateWithoutStepsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: UserCreateNestedOneWithoutMessage_sequencesInput
  }

  export type MessageSequenceUncheckedCreateWithoutStepsInput = {
    id?: string
    doctorId: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageSequenceCreateOrConnectWithoutStepsInput = {
    where: MessageSequenceWhereUniqueInput
    create: XOR<MessageSequenceCreateWithoutStepsInput, MessageSequenceUncheckedCreateWithoutStepsInput>
  }

  export type MessageTemplateCreateWithoutStepsInput = {
    id?: string
    name: string
    channel: string
    subject?: string | null
    html?: string | null
    text?: string | null
    mjml?: string | null
    renderStrategy?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    provider?: string | null
    waTemplateName?: string | null
    waLanguage?: string | null
    waCategory?: string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: string | null
    waProviderId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateCreatetagsInput | string[]
    smsMaxSegments?: number | null
    doctor: UserCreateNestedOneWithoutMessage_templatesInput
  }

  export type MessageTemplateUncheckedCreateWithoutStepsInput = {
    id?: string
    doctorId: string
    name: string
    channel: string
    subject?: string | null
    html?: string | null
    text?: string | null
    mjml?: string | null
    renderStrategy?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    provider?: string | null
    waTemplateName?: string | null
    waLanguage?: string | null
    waCategory?: string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: string | null
    waProviderId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateCreatetagsInput | string[]
    smsMaxSegments?: number | null
  }

  export type MessageTemplateCreateOrConnectWithoutStepsInput = {
    where: MessageTemplateWhereUniqueInput
    create: XOR<MessageTemplateCreateWithoutStepsInput, MessageTemplateUncheckedCreateWithoutStepsInput>
  }

  export type MessageSequenceUpsertWithoutStepsInput = {
    update: XOR<MessageSequenceUpdateWithoutStepsInput, MessageSequenceUncheckedUpdateWithoutStepsInput>
    create: XOR<MessageSequenceCreateWithoutStepsInput, MessageSequenceUncheckedCreateWithoutStepsInput>
    where?: MessageSequenceWhereInput
  }

  export type MessageSequenceUpdateToOneWithWhereWithoutStepsInput = {
    where?: MessageSequenceWhereInput
    data: XOR<MessageSequenceUpdateWithoutStepsInput, MessageSequenceUncheckedUpdateWithoutStepsInput>
  }

  export type MessageSequenceUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutMessage_sequencesNestedInput
  }

  export type MessageSequenceUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUpsertWithoutStepsInput = {
    update: XOR<MessageTemplateUpdateWithoutStepsInput, MessageTemplateUncheckedUpdateWithoutStepsInput>
    create: XOR<MessageTemplateCreateWithoutStepsInput, MessageTemplateUncheckedCreateWithoutStepsInput>
    where?: MessageTemplateWhereInput
  }

  export type MessageTemplateUpdateToOneWithWhereWithoutStepsInput = {
    where?: MessageTemplateWhereInput
    data: XOR<MessageTemplateUpdateWithoutStepsInput, MessageTemplateUncheckedUpdateWithoutStepsInput>
  }

  export type MessageTemplateUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mjml?: NullableStringFieldUpdateOperationsInput | string | null
    renderStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    waTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    waLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    waCategory?: NullableStringFieldUpdateOperationsInput | string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: NullableStringFieldUpdateOperationsInput | string | null
    waProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateUpdatetagsInput | string[]
    smsMaxSegments?: NullableIntFieldUpdateOperationsInput | number | null
    doctor?: UserUpdateOneRequiredWithoutMessage_templatesNestedInput
  }

  export type MessageTemplateUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mjml?: NullableStringFieldUpdateOperationsInput | string | null
    renderStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    waTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    waLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    waCategory?: NullableStringFieldUpdateOperationsInput | string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: NullableStringFieldUpdateOperationsInput | string | null
    waProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateUpdatetagsInput | string[]
    smsMaxSegments?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OpenFinanceConsentCreateWithoutLinkInput = {
    id?: string
    consentId: string
    contractId: string
    status?: string
    amountCents: number
    periodicity: string
    nextExecutionAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpenFinanceConsentUncheckedCreateWithoutLinkInput = {
    id?: string
    consentId: string
    contractId: string
    status?: string
    amountCents: number
    periodicity: string
    nextExecutionAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpenFinanceConsentCreateOrConnectWithoutLinkInput = {
    where: OpenFinanceConsentWhereUniqueInput
    create: XOR<OpenFinanceConsentCreateWithoutLinkInput, OpenFinanceConsentUncheckedCreateWithoutLinkInput>
  }

  export type OpenFinanceConsentUpsertWithoutLinkInput = {
    update: XOR<OpenFinanceConsentUpdateWithoutLinkInput, OpenFinanceConsentUncheckedUpdateWithoutLinkInput>
    create: XOR<OpenFinanceConsentCreateWithoutLinkInput, OpenFinanceConsentUncheckedCreateWithoutLinkInput>
    where?: OpenFinanceConsentWhereInput
  }

  export type OpenFinanceConsentUpdateToOneWithWhereWithoutLinkInput = {
    where?: OpenFinanceConsentWhereInput
    data: XOR<OpenFinanceConsentUpdateWithoutLinkInput, OpenFinanceConsentUncheckedUpdateWithoutLinkInput>
  }

  export type OpenFinanceConsentUpdateWithoutLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    periodicity?: StringFieldUpdateOperationsInput | string
    nextExecutionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenFinanceConsentUncheckedUpdateWithoutLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    periodicity?: StringFieldUpdateOperationsInput | string
    nextExecutionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenFinanceLinkCreateWithoutConsentInput = {
    id?: string
    userId: string
    clinicId?: string | null
    organisationId: string
    authorisationServerId: string
    enrollmentId: string
    status?: string
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpenFinanceLinkUncheckedCreateWithoutConsentInput = {
    id?: string
    userId: string
    clinicId?: string | null
    organisationId: string
    authorisationServerId: string
    enrollmentId: string
    status?: string
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpenFinanceLinkCreateOrConnectWithoutConsentInput = {
    where: OpenFinanceLinkWhereUniqueInput
    create: XOR<OpenFinanceLinkCreateWithoutConsentInput, OpenFinanceLinkUncheckedCreateWithoutConsentInput>
  }

  export type OpenFinanceLinkUpsertWithoutConsentInput = {
    update: XOR<OpenFinanceLinkUpdateWithoutConsentInput, OpenFinanceLinkUncheckedUpdateWithoutConsentInput>
    create: XOR<OpenFinanceLinkCreateWithoutConsentInput, OpenFinanceLinkUncheckedCreateWithoutConsentInput>
    where?: OpenFinanceLinkWhereInput
  }

  export type OpenFinanceLinkUpdateToOneWithWhereWithoutConsentInput = {
    where?: OpenFinanceLinkWhereInput
    data: XOR<OpenFinanceLinkUpdateWithoutConsentInput, OpenFinanceLinkUncheckedUpdateWithoutConsentInput>
  }

  export type OpenFinanceLinkUpdateWithoutConsentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: StringFieldUpdateOperationsInput | string
    authorisationServerId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenFinanceLinkUncheckedUpdateWithoutConsentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: StringFieldUpdateOperationsInput | string
    authorisationServerId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deviceBinding?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicCreateWithoutWebhookEndpointsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberCreateNestedManyWithoutClinicInput
    owner: UserCreateNestedOneWithoutOwned_clinicsInput
    subscriptions?: ClinicSubscriptionCreateNestedManyWithoutClinicInput
    products?: ProductCreateNestedManyWithoutClinicInput
    merchant?: MerchantCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationCreateNestedOneWithoutClinicInput
    outboundEvents?: OutboundWebhookEventCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutWebhookEndpointsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberUncheckedCreateNestedManyWithoutClinicInput
    subscriptions?: ClinicSubscriptionUncheckedCreateNestedManyWithoutClinicInput
    products?: ProductUncheckedCreateNestedManyWithoutClinicInput
    merchant?: MerchantUncheckedCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationUncheckedCreateNestedOneWithoutClinicInput
    outboundEvents?: OutboundWebhookEventUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutWebhookEndpointsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutWebhookEndpointsInput, ClinicUncheckedCreateWithoutWebhookEndpointsInput>
  }

  export type OutboundWebhookDeliveryCreateWithoutEndpointInput = {
    id?: string
    status?: string
    attempts?: number
    lastCode?: number | null
    lastError?: string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: OutboundWebhookEventCreateNestedOneWithoutDeliveriesInput
  }

  export type OutboundWebhookDeliveryUncheckedCreateWithoutEndpointInput = {
    id?: string
    eventId: string
    status?: string
    attempts?: number
    lastCode?: number | null
    lastError?: string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundWebhookDeliveryCreateOrConnectWithoutEndpointInput = {
    where: OutboundWebhookDeliveryWhereUniqueInput
    create: XOR<OutboundWebhookDeliveryCreateWithoutEndpointInput, OutboundWebhookDeliveryUncheckedCreateWithoutEndpointInput>
  }

  export type OutboundWebhookDeliveryCreateManyEndpointInputEnvelope = {
    data: OutboundWebhookDeliveryCreateManyEndpointInput | OutboundWebhookDeliveryCreateManyEndpointInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutWebhookEndpointsInput = {
    update: XOR<ClinicUpdateWithoutWebhookEndpointsInput, ClinicUncheckedUpdateWithoutWebhookEndpointsInput>
    create: XOR<ClinicCreateWithoutWebhookEndpointsInput, ClinicUncheckedCreateWithoutWebhookEndpointsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutWebhookEndpointsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutWebhookEndpointsInput, ClinicUncheckedUpdateWithoutWebhookEndpointsInput>
  }

  export type ClinicUpdateWithoutWebhookEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUpdateManyWithoutClinicNestedInput
    owner?: UserUpdateOneRequiredWithoutOwned_clinicsNestedInput
    subscriptions?: ClinicSubscriptionUpdateManyWithoutClinicNestedInput
    products?: ProductUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUpdateOneWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutWebhookEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUncheckedUpdateManyWithoutClinicNestedInput
    subscriptions?: ClinicSubscriptionUncheckedUpdateManyWithoutClinicNestedInput
    products?: ProductUncheckedUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUncheckedUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUncheckedUpdateOneWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type OutboundWebhookDeliveryUpsertWithWhereUniqueWithoutEndpointInput = {
    where: OutboundWebhookDeliveryWhereUniqueInput
    update: XOR<OutboundWebhookDeliveryUpdateWithoutEndpointInput, OutboundWebhookDeliveryUncheckedUpdateWithoutEndpointInput>
    create: XOR<OutboundWebhookDeliveryCreateWithoutEndpointInput, OutboundWebhookDeliveryUncheckedCreateWithoutEndpointInput>
  }

  export type OutboundWebhookDeliveryUpdateWithWhereUniqueWithoutEndpointInput = {
    where: OutboundWebhookDeliveryWhereUniqueInput
    data: XOR<OutboundWebhookDeliveryUpdateWithoutEndpointInput, OutboundWebhookDeliveryUncheckedUpdateWithoutEndpointInput>
  }

  export type OutboundWebhookDeliveryUpdateManyWithWhereWithoutEndpointInput = {
    where: OutboundWebhookDeliveryScalarWhereInput
    data: XOR<OutboundWebhookDeliveryUpdateManyMutationInput, OutboundWebhookDeliveryUncheckedUpdateManyWithoutEndpointInput>
  }

  export type OutboundWebhookDeliveryScalarWhereInput = {
    AND?: OutboundWebhookDeliveryScalarWhereInput | OutboundWebhookDeliveryScalarWhereInput[]
    OR?: OutboundWebhookDeliveryScalarWhereInput[]
    NOT?: OutboundWebhookDeliveryScalarWhereInput | OutboundWebhookDeliveryScalarWhereInput[]
    id?: StringFilter<"OutboundWebhookDelivery"> | string
    endpointId?: StringFilter<"OutboundWebhookDelivery"> | string
    eventId?: StringFilter<"OutboundWebhookDelivery"> | string
    status?: StringFilter<"OutboundWebhookDelivery"> | string
    attempts?: IntFilter<"OutboundWebhookDelivery"> | number
    lastCode?: IntNullableFilter<"OutboundWebhookDelivery"> | number | null
    lastError?: StringNullableFilter<"OutboundWebhookDelivery"> | string | null
    nextAttemptAt?: DateTimeNullableFilter<"OutboundWebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"OutboundWebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"OutboundWebhookDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"OutboundWebhookDelivery"> | Date | string
  }

  export type ClinicCreateWithoutOutboundEventsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberCreateNestedManyWithoutClinicInput
    owner: UserCreateNestedOneWithoutOwned_clinicsInput
    subscriptions?: ClinicSubscriptionCreateNestedManyWithoutClinicInput
    products?: ProductCreateNestedManyWithoutClinicInput
    merchant?: MerchantCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutOutboundEventsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
    members?: ClinicMemberUncheckedCreateNestedManyWithoutClinicInput
    subscriptions?: ClinicSubscriptionUncheckedCreateNestedManyWithoutClinicInput
    products?: ProductUncheckedCreateNestedManyWithoutClinicInput
    merchant?: MerchantUncheckedCreateNestedOneWithoutClinicInput
    merchantApplication?: MerchantApplicationUncheckedCreateNestedOneWithoutClinicInput
    webhookEndpoints?: WebhookEndpointUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutOutboundEventsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutOutboundEventsInput, ClinicUncheckedCreateWithoutOutboundEventsInput>
  }

  export type OutboundWebhookDeliveryCreateWithoutEventInput = {
    id?: string
    status?: string
    attempts?: number
    lastCode?: number | null
    lastError?: string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    endpoint: WebhookEndpointCreateNestedOneWithoutDeliveriesInput
  }

  export type OutboundWebhookDeliveryUncheckedCreateWithoutEventInput = {
    id?: string
    endpointId: string
    status?: string
    attempts?: number
    lastCode?: number | null
    lastError?: string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundWebhookDeliveryCreateOrConnectWithoutEventInput = {
    where: OutboundWebhookDeliveryWhereUniqueInput
    create: XOR<OutboundWebhookDeliveryCreateWithoutEventInput, OutboundWebhookDeliveryUncheckedCreateWithoutEventInput>
  }

  export type OutboundWebhookDeliveryCreateManyEventInputEnvelope = {
    data: OutboundWebhookDeliveryCreateManyEventInput | OutboundWebhookDeliveryCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutOutboundEventsInput = {
    update: XOR<ClinicUpdateWithoutOutboundEventsInput, ClinicUncheckedUpdateWithoutOutboundEventsInput>
    create: XOR<ClinicCreateWithoutOutboundEventsInput, ClinicUncheckedCreateWithoutOutboundEventsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutOutboundEventsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutOutboundEventsInput, ClinicUncheckedUpdateWithoutOutboundEventsInput>
  }

  export type ClinicUpdateWithoutOutboundEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUpdateManyWithoutClinicNestedInput
    owner?: UserUpdateOneRequiredWithoutOwned_clinicsNestedInput
    subscriptions?: ClinicSubscriptionUpdateManyWithoutClinicNestedInput
    products?: ProductUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutOutboundEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUncheckedUpdateManyWithoutClinicNestedInput
    subscriptions?: ClinicSubscriptionUncheckedUpdateManyWithoutClinicNestedInput
    products?: ProductUncheckedUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUncheckedUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUncheckedUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type OutboundWebhookDeliveryUpsertWithWhereUniqueWithoutEventInput = {
    where: OutboundWebhookDeliveryWhereUniqueInput
    update: XOR<OutboundWebhookDeliveryUpdateWithoutEventInput, OutboundWebhookDeliveryUncheckedUpdateWithoutEventInput>
    create: XOR<OutboundWebhookDeliveryCreateWithoutEventInput, OutboundWebhookDeliveryUncheckedCreateWithoutEventInput>
  }

  export type OutboundWebhookDeliveryUpdateWithWhereUniqueWithoutEventInput = {
    where: OutboundWebhookDeliveryWhereUniqueInput
    data: XOR<OutboundWebhookDeliveryUpdateWithoutEventInput, OutboundWebhookDeliveryUncheckedUpdateWithoutEventInput>
  }

  export type OutboundWebhookDeliveryUpdateManyWithWhereWithoutEventInput = {
    where: OutboundWebhookDeliveryScalarWhereInput
    data: XOR<OutboundWebhookDeliveryUpdateManyMutationInput, OutboundWebhookDeliveryUncheckedUpdateManyWithoutEventInput>
  }

  export type WebhookEndpointCreateWithoutDeliveriesInput = {
    id?: string
    name: string
    url: string
    secret: string
    events?: WebhookEndpointCreateeventsInput | string[]
    enabled?: boolean
    maxConcurrentDeliveries?: number
    categoryFilter?: string
    statusFilters?: WebhookEndpointCreatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointCreateproductFiltersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutWebhookEndpointsInput
  }

  export type WebhookEndpointUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    clinicId: string
    name: string
    url: string
    secret: string
    events?: WebhookEndpointCreateeventsInput | string[]
    enabled?: boolean
    maxConcurrentDeliveries?: number
    categoryFilter?: string
    statusFilters?: WebhookEndpointCreatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointCreateproductFiltersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookEndpointCreateOrConnectWithoutDeliveriesInput = {
    where: WebhookEndpointWhereUniqueInput
    create: XOR<WebhookEndpointCreateWithoutDeliveriesInput, WebhookEndpointUncheckedCreateWithoutDeliveriesInput>
  }

  export type OutboundWebhookEventCreateWithoutDeliveriesInput = {
    id?: string
    type: string
    resource: string
    resourceId: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutOutboundEventsInput
  }

  export type OutboundWebhookEventUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    clinicId: string
    type: string
    resource: string
    resourceId: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OutboundWebhookEventCreateOrConnectWithoutDeliveriesInput = {
    where: OutboundWebhookEventWhereUniqueInput
    create: XOR<OutboundWebhookEventCreateWithoutDeliveriesInput, OutboundWebhookEventUncheckedCreateWithoutDeliveriesInput>
  }

  export type WebhookEndpointUpsertWithoutDeliveriesInput = {
    update: XOR<WebhookEndpointUpdateWithoutDeliveriesInput, WebhookEndpointUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<WebhookEndpointCreateWithoutDeliveriesInput, WebhookEndpointUncheckedCreateWithoutDeliveriesInput>
    where?: WebhookEndpointWhereInput
  }

  export type WebhookEndpointUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: WebhookEndpointWhereInput
    data: XOR<WebhookEndpointUpdateWithoutDeliveriesInput, WebhookEndpointUncheckedUpdateWithoutDeliveriesInput>
  }

  export type WebhookEndpointUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookEndpointUpdateeventsInput | string[]
    enabled?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentDeliveries?: IntFieldUpdateOperationsInput | number
    categoryFilter?: StringFieldUpdateOperationsInput | string
    statusFilters?: WebhookEndpointUpdatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointUpdateproductFiltersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutWebhookEndpointsNestedInput
  }

  export type WebhookEndpointUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookEndpointUpdateeventsInput | string[]
    enabled?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentDeliveries?: IntFieldUpdateOperationsInput | number
    categoryFilter?: StringFieldUpdateOperationsInput | string
    statusFilters?: WebhookEndpointUpdatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointUpdateproductFiltersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundWebhookEventUpsertWithoutDeliveriesInput = {
    update: XOR<OutboundWebhookEventUpdateWithoutDeliveriesInput, OutboundWebhookEventUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<OutboundWebhookEventCreateWithoutDeliveriesInput, OutboundWebhookEventUncheckedCreateWithoutDeliveriesInput>
    where?: OutboundWebhookEventWhereInput
  }

  export type OutboundWebhookEventUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: OutboundWebhookEventWhereInput
    data: XOR<OutboundWebhookEventUpdateWithoutDeliveriesInput, OutboundWebhookEventUncheckedUpdateWithoutDeliveriesInput>
  }

  export type OutboundWebhookEventUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutOutboundEventsNestedInput
  }

  export type OutboundWebhookEventUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserCreateManyUserInput = {
    id: string
    email: string
    name?: string | null
    image?: string | null
    public_cover_image_url?: string | null
    doctor_slug?: string | null
    role?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_verified?: Date | string | null
    password?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    verification_code?: string | null
    verification_code_expiry?: Date | string | null
    referral_code?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    google_review_link?: string | null
    stripe_connect_id?: string | null
    accessGranted?: boolean
  }

  export type ClinicMemberCreateManyUserInput = {
    id?: string
    clinicId: string
    role?: $Enums.ClinicRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type ClinicCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    website?: string | null
    logo?: string | null
    slug?: string | null
    subdomain?: string | null
    monthlyRevenueRange?: string | null
    currentGateway?: string | null
    theme?: $Enums.ClinicTheme
    buttonColor?: string | null
    buttonTextColor?: string | null
  }

  export type ProductCreateManyDoctorInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    categoryId?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
  }

  export type ProductCategoryCreateManyDoctorInput = {
    id?: string
    name: string
    slug?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationCodeCreateManyUserInput = {
    id?: string
    code: string
    doctor_id: string
    type: string
    created_at?: Date | string
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type VerificationCodeCreateManyDoctorInput = {
    id?: string
    code: string
    user_id: string
    type: string
    created_at?: Date | string
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type PurchaseCreateManyUserInput = {
    id?: string
    doctorId: string
    productId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyDoctorInput = {
    id?: string
    userId: string
    productId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointsLedgerCreateManyUserInput = {
    id?: string
    patientProfileId?: string | null
    sourceType: string
    sourceId: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    createdAt?: Date | string
  }

  export type PatientProfileCreateManyDoctorInput = {
    id?: string
    userId: string
    name?: string | null
    phone?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPoints?: number
    currentPoints?: number
  }

  export type PatientProfileCreateManyPatientInput = {
    id?: string
    doctorId: string
    name?: string | null
    phone?: string | null
    address?: string | null
    emergency_contact?: string | null
    emergency_phone?: string | null
    medical_history?: string | null
    allergies?: string | null
    medications?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPoints?: number
    currentPoints?: number
  }

  export type MessageTemplateCreateManyDoctorInput = {
    id?: string
    name: string
    channel: string
    subject?: string | null
    html?: string | null
    text?: string | null
    mjml?: string | null
    renderStrategy?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    provider?: string | null
    waTemplateName?: string | null
    waLanguage?: string | null
    waCategory?: string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: string | null
    waProviderId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateCreatetagsInput | string[]
    smsMaxSegments?: number | null
  }

  export type MessageSequenceCreateManyDoctorInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    other_users?: UserUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    other_users?: UserUncheckedUpdateManyWithoutUserNestedInput
    clinic_memberships?: ClinicMemberUncheckedUpdateManyWithoutUserNestedInput
    owned_clinics?: ClinicUncheckedUpdateManyWithoutOwnerNestedInput
    created_products?: ProductUncheckedUpdateManyWithoutDoctorNestedInput
    created_categories?: ProductCategoryUncheckedUpdateManyWithoutDoctorNestedInput
    user_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    doctor_verification_codes?: VerificationCodeUncheckedUpdateManyWithoutDoctorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    doctorPurchases?: PurchaseUncheckedUpdateManyWithoutDoctorNestedInput
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutUserNestedInput
    doctor_profiles?: PatientProfileUncheckedUpdateManyWithoutDoctorNestedInput
    patient_profiles?: PatientProfileUncheckedUpdateManyWithoutPatientNestedInput
    message_templates?: MessageTemplateUncheckedUpdateManyWithoutDoctorNestedInput
    message_sequences?: MessageSequenceUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    public_cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_slug?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    verification_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    google_review_link?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_id?: NullableStringFieldUpdateOperationsInput | string | null
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClinicMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumClinicRoleFieldUpdateOperationsInput | $Enums.ClinicRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ClinicMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    role?: EnumClinicRoleFieldUpdateOperationsInput | $Enums.ClinicRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    role?: EnumClinicRoleFieldUpdateOperationsInput | $Enums.ClinicRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUpdateManyWithoutClinicNestedInput
    subscriptions?: ClinicSubscriptionUpdateManyWithoutClinicNestedInput
    products?: ProductUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ClinicMemberUncheckedUpdateManyWithoutClinicNestedInput
    subscriptions?: ClinicSubscriptionUncheckedUpdateManyWithoutClinicNestedInput
    products?: ProductUncheckedUpdateManyWithoutClinicNestedInput
    merchant?: MerchantUncheckedUpdateOneWithoutClinicNestedInput
    merchantApplication?: MerchantApplicationUncheckedUpdateOneWithoutClinicNestedInput
    webhookEndpoints?: WebhookEndpointUncheckedUpdateManyWithoutClinicNestedInput
    outboundEvents?: OutboundWebhookEventUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRevenueRange?: NullableStringFieldUpdateOperationsInput | string | null
    currentGateway?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: EnumClinicThemeFieldUpdateOperationsInput | $Enums.ClinicTheme
    buttonColor?: NullableStringFieldUpdateOperationsInput | string | null
    buttonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clinic?: ClinicUpdateOneWithoutProductsNestedInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUpdateManyWithoutProductNestedInput
    offers?: OfferUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUncheckedUpdateManyWithoutProductNestedInput
    offers?: OfferUncheckedUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ProductCategoryUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutProductCategoryNestedInput
    categories?: CategoriesOnProductsUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
    categories?: CategoriesOnProductsUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: UserUpdateOneRequiredWithoutDoctor_verification_codesNestedInput
  }

  export type VerificationCodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCodeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCodeUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUser_verification_codesNestedInput
  }

  export type VerificationCodeUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCodeUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PurchaseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutDoctorPurchasesNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientProfile?: PatientProfileUpdateOneWithoutPointsLedgerNestedInput
  }

  export type PointsLedgerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientProfileUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
    patient?: UserUpdateOneRequiredWithoutPatient_profilesNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutPatientProfileNestedInput
  }

  export type PatientProfileUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutPatientProfileNestedInput
  }

  export type PatientProfileUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
  }

  export type PatientProfileUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
    doctor?: UserUpdateOneRequiredWithoutDoctor_profilesNestedInput
    pointsLedger?: PointsLedgerUpdateManyWithoutPatientProfileNestedInput
  }

  export type PatientProfileUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsLedger?: PointsLedgerUncheckedUpdateManyWithoutPatientProfileNestedInput
  }

  export type PatientProfileUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentPoints?: IntFieldUpdateOperationsInput | number
  }

  export type MessageTemplateUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mjml?: NullableStringFieldUpdateOperationsInput | string | null
    renderStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    waTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    waLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    waCategory?: NullableStringFieldUpdateOperationsInput | string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: NullableStringFieldUpdateOperationsInput | string | null
    waProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateUpdatetagsInput | string[]
    smsMaxSegments?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: MessageSequenceStepUpdateManyWithoutTemplateNestedInput
  }

  export type MessageTemplateUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mjml?: NullableStringFieldUpdateOperationsInput | string | null
    renderStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    waTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    waLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    waCategory?: NullableStringFieldUpdateOperationsInput | string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: NullableStringFieldUpdateOperationsInput | string | null
    waProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateUpdatetagsInput | string[]
    smsMaxSegments?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: MessageSequenceStepUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type MessageTemplateUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mjml?: NullableStringFieldUpdateOperationsInput | string | null
    renderStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    waTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    waLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    waCategory?: NullableStringFieldUpdateOperationsInput | string | null
    waComponents?: NullableJsonNullValueInput | InputJsonValue
    waStatus?: NullableStringFieldUpdateOperationsInput | string | null
    waProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variablesSchema?: NullableJsonNullValueInput | InputJsonValue
    sampleVariables?: NullableJsonNullValueInput | InputJsonValue
    tags?: MessageTemplateUpdatetagsInput | string[]
    smsMaxSegments?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MessageSequenceUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: MessageSequenceStepUpdateManyWithoutSequenceNestedInput
  }

  export type MessageSequenceUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: MessageSequenceStepUncheckedUpdateManyWithoutSequenceNestedInput
  }

  export type MessageSequenceUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerCreateManyPatientProfileInput = {
    id?: string
    userId: string
    sourceType: string
    sourceId: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    createdAt?: Date | string
  }

  export type PointsLedgerUpdateWithoutPatientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPointsLedgerNestedInput
  }

  export type PointsLedgerUncheckedUpdateWithoutPatientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerUncheckedUpdateManyWithoutPatientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicMemberCreateManyClinicInput = {
    id?: string
    userId: string
    role?: $Enums.ClinicRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type ClinicSubscriptionCreateManyClinicInput = {
    id?: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    trialEndsAt: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    canceledAt?: Date | string | null
    cancelReason?: string | null
    currentDoctorsCount?: number
    currentPatientsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyClinicInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    categoryId?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
  }

  export type WebhookEndpointCreateManyClinicInput = {
    id?: string
    name: string
    url: string
    secret: string
    events?: WebhookEndpointCreateeventsInput | string[]
    enabled?: boolean
    maxConcurrentDeliveries?: number
    categoryFilter?: string
    statusFilters?: WebhookEndpointCreatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointCreateproductFiltersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundWebhookEventCreateManyClinicInput = {
    id?: string
    type: string
    resource: string
    resourceId: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ClinicMemberUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumClinicRoleFieldUpdateOperationsInput | $Enums.ClinicRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClinic_membershipsNestedInput
  }

  export type ClinicMemberUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumClinicRoleFieldUpdateOperationsInput | $Enums.ClinicRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicMemberUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumClinicRoleFieldUpdateOperationsInput | $Enums.ClinicRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicSubscriptionUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: ClinicPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    addOns?: ClinicAddOnSubscriptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type ClinicSubscriptionUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOns?: ClinicAddOnSubscriptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type ClinicSubscriptionUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doctor?: UserUpdateOneWithoutCreated_productsNestedInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUpdateManyWithoutProductNestedInput
    offers?: OfferUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUncheckedUpdateManyWithoutProductNestedInput
    offers?: OfferUncheckedUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type WebhookEndpointUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookEndpointUpdateeventsInput | string[]
    enabled?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentDeliveries?: IntFieldUpdateOperationsInput | number
    categoryFilter?: StringFieldUpdateOperationsInput | string
    statusFilters?: WebhookEndpointUpdatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointUpdateproductFiltersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: OutboundWebhookDeliveryUpdateManyWithoutEndpointNestedInput
  }

  export type WebhookEndpointUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookEndpointUpdateeventsInput | string[]
    enabled?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentDeliveries?: IntFieldUpdateOperationsInput | number
    categoryFilter?: StringFieldUpdateOperationsInput | string
    statusFilters?: WebhookEndpointUpdatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointUpdateproductFiltersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: OutboundWebhookDeliveryUncheckedUpdateManyWithoutEndpointNestedInput
  }

  export type WebhookEndpointUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookEndpointUpdateeventsInput | string[]
    enabled?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentDeliveries?: IntFieldUpdateOperationsInput | number
    categoryFilter?: StringFieldUpdateOperationsInput | string
    statusFilters?: WebhookEndpointUpdatestatusFiltersInput | string[]
    productFilters?: WebhookEndpointUpdateproductFiltersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundWebhookEventUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: OutboundWebhookDeliveryUpdateManyWithoutEventNestedInput
  }

  export type OutboundWebhookEventUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: OutboundWebhookDeliveryUncheckedUpdateManyWithoutEventNestedInput
  }

  export type OutboundWebhookEventUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantIntegrationCreateManyMerchantInput = {
    id?: string
    provider: $Enums.PaymentProvider
    credentials: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPrimary?: boolean
    connectedAt?: Date | string
    lastUsedAt?: Date | string | null
    lastError?: string | null
    lastErrorAt?: Date | string | null
  }

  export type MerchantIntegrationUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    credentials?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastErrorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantIntegrationUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    credentials?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastErrorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantIntegrationUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    credentials?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastErrorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantDocumentCreateManyApplicationInput = {
    id?: string
    type: $Enums.DocumentType
    fileUrl: string
    status?: $Enums.DocumentStatus
    notes?: string | null
    uploadedAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type MerchantDocumentUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantDocumentUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantDocumentUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicSubscriptionCreateManyPlanInput = {
    id?: string
    clinicId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    trialEndsAt: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    canceledAt?: Date | string | null
    cancelReason?: string | null
    currentDoctorsCount?: number
    currentPatientsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicSubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutSubscriptionsNestedInput
    addOns?: ClinicAddOnSubscriptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type ClinicSubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOns?: ClinicAddOnSubscriptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type ClinicSubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    currentDoctorsCount?: IntFieldUpdateOperationsInput | number
    currentPatientsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnSubscriptionCreateManyAddOnInput = {
    id?: string
    subscriptionId: string
    quantity: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicAddOnSubscriptionUpdateWithoutAddOnInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: ClinicSubscriptionUpdateOneRequiredWithoutAddOnsNestedInput
  }

  export type ClinicAddOnSubscriptionUncheckedUpdateWithoutAddOnInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnSubscriptionUncheckedUpdateManyWithoutAddOnInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnSubscriptionCreateManySubscriptionInput = {
    id?: string
    addOnId: string
    quantity: number
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicAddOnSubscriptionUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOn?: ClinicAddOnUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type ClinicAddOnSubscriptionUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicAddOnSubscriptionUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyProductCategoryInput = {
    id: string
    name: string
    subtitle?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    creditsPerUnit?: Decimal | DecimalJsLike | number | string
    category: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorId?: string | null
    clinicId?: string | null
    imageUrl?: string | null
    confirmationUrl?: string | null
    type?: $Enums.ProductType
    interval?: $Enums.SubscriptionInterval | null
    intervalCount?: number | null
    trialDays?: number | null
    providerPlanId?: string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: boolean | null
  }

  export type CategoriesOnProductsCreateManyCategoryInput = {
    productId: string
    assignedAt?: Date | string
  }

  export type ProductUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doctor?: UserUpdateOneWithoutCreated_productsNestedInput
    clinic?: ClinicUpdateOneWithoutProductsNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUpdateManyWithoutProductNestedInput
    offers?: OfferUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
    categories?: CategoriesOnProductsUncheckedUpdateManyWithoutProductNestedInput
    offers?: OfferUncheckedUpdateManyWithoutProductNestedInput
    integrations?: ProductIntegrationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    interval?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    providerPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPlanData?: NullableJsonNullValueInput | InputJsonValue
    autoRenew?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CategoriesOnProductsUpdateWithoutCategoryInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CategoriesOnProductsUncheckedUpdateWithoutCategoryInput = {
    productId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriesOnProductsUncheckedUpdateManyWithoutCategoryInput = {
    productId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManyProductInput = {
    id?: string
    userId: string
    doctorId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pointsAwarded?: Decimal | DecimalJsLike | number | string
    status?: string
    externalIdempotencyKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoriesOnProductsCreateManyProductInput = {
    categoryId: string
    assignedAt?: Date | string
  }

  export type OfferCreateManyProductInput = {
    id?: string
    name: string
    description?: string | null
    currency?: $Enums.Currency
    priceCents: number
    preferredProvider?: $Enums.PaymentProvider | null
    maxInstallments?: number | null
    installmentMinCents?: number | null
    active?: boolean
    isSubscription?: boolean
    intervalCount?: number | null
    intervalUnit?: $Enums.SubscriptionInterval | null
    trialDays?: number | null
    checkoutUrl?: string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductIntegrationCreateManyProductInput = {
    id?: string
    provider: $Enums.PaymentProvider
    externalProductId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAwarded?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalIdempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriesOnProductsUpdateWithoutProductInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ProductCategoryUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CategoriesOnProductsUncheckedUpdateWithoutProductInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriesOnProductsUncheckedUpdateManyWithoutProductInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    priceCents?: IntFieldUpdateOperationsInput | number
    preferredProvider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    maxInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    installmentMinCents?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    intervalUnit?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    checkoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: OfferPaymentMethodUpdateManyWithoutOfferNestedInput
    prices?: OfferPriceUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    priceCents?: IntFieldUpdateOperationsInput | number
    preferredProvider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    maxInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    installmentMinCents?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    intervalUnit?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    checkoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: OfferPaymentMethodUncheckedUpdateManyWithoutOfferNestedInput
    prices?: OfferPriceUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    priceCents?: IntFieldUpdateOperationsInput | number
    preferredProvider?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    maxInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    installmentMinCents?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    intervalUnit?: NullableEnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    checkoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductIntegrationUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    externalProductId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductIntegrationUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    externalProductId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductIntegrationUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    externalProductId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferPaymentMethodCreateManyOfferInput = {
    id?: string
    method: $Enums.PaymentMethod
    active?: boolean
    feePercent?: number | null
  }

  export type OfferPriceCreateManyOfferInput = {
    id?: string
    country: string
    currency: $Enums.Currency
    provider: $Enums.PaymentProvider
    amountCents?: number
    externalPriceId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferPaymentMethodUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    active?: BoolFieldUpdateOperationsInput | boolean
    feePercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OfferPaymentMethodUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    active?: BoolFieldUpdateOperationsInput | boolean
    feePercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OfferPaymentMethodUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    active?: BoolFieldUpdateOperationsInput | boolean
    feePercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OfferPriceUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amountCents?: IntFieldUpdateOperationsInput | number
    externalPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferPriceUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amountCents?: IntFieldUpdateOperationsInput | number
    externalPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferPriceUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amountCents?: IntFieldUpdateOperationsInput | number
    externalPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProviderCreateManyCustomerInput = {
    id?: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerCustomerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentMethodCreateManyCustomerInput = {
    id?: string
    customerProviderId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerPaymentMethodId?: string | null
    brand?: string | null
    last4?: string | null
    expMonth?: number | null
    expYear?: number | null
    isDefault?: boolean
    status?: string | null
    fingerprint?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSubscriptionCreateManyCustomerInput = {
    id?: string
    merchantId: string
    productId: string
    offerId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    isNative?: boolean
    customerProviderId?: string | null
    providerSubscriptionId?: string | null
    vaultPaymentMethodId?: string | null
    status?: $Enums.SubscriptionStatus
    startAt?: Date | string
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    priceCents: number
    currency: $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProviderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: CustomerPaymentMethodUpdateManyWithoutCustomerProviderNestedInput
    subscriptions?: CustomerSubscriptionUpdateManyWithoutCustomerProviderNestedInput
  }

  export type CustomerProviderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerProviderNestedInput
    subscriptions?: CustomerSubscriptionUncheckedUpdateManyWithoutCustomerProviderNestedInput
  }

  export type CustomerProviderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentMethodUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerProvider?: CustomerProviderUpdateOneWithoutPaymentMethodsNestedInput
  }

  export type CustomerPaymentMethodUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSubscriptionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    isNative?: BoolFieldUpdateOperationsInput | boolean
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerProvider?: CustomerProviderUpdateOneWithoutSubscriptionsNestedInput
  }

  export type CustomerSubscriptionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    isNative?: BoolFieldUpdateOperationsInput | boolean
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSubscriptionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    isNative?: BoolFieldUpdateOperationsInput | boolean
    customerProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentMethodCreateManyCustomerProviderInput = {
    id?: string
    customerId: string
    provider: $Enums.PaymentProvider
    accountId?: string | null
    providerPaymentMethodId?: string | null
    brand?: string | null
    last4?: string | null
    expMonth?: number | null
    expYear?: number | null
    isDefault?: boolean
    status?: string | null
    fingerprint?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSubscriptionCreateManyCustomerProviderInput = {
    id?: string
    customerId: string
    merchantId: string
    productId: string
    offerId?: string | null
    provider: $Enums.PaymentProvider
    accountId?: string | null
    isNative?: boolean
    providerSubscriptionId?: string | null
    vaultPaymentMethodId?: string | null
    status?: $Enums.SubscriptionStatus
    startAt?: Date | string
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    priceCents: number
    currency: $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentMethodUpdateWithoutCustomerProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutPaymentMethodsNestedInput
  }

  export type CustomerPaymentMethodUncheckedUpdateWithoutCustomerProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentMethodUncheckedUpdateManyWithoutCustomerProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSubscriptionUpdateWithoutCustomerProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    isNative?: BoolFieldUpdateOperationsInput | boolean
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type CustomerSubscriptionUncheckedUpdateWithoutCustomerProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    isNative?: BoolFieldUpdateOperationsInput | boolean
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSubscriptionUncheckedUpdateManyWithoutCustomerProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    isNative?: BoolFieldUpdateOperationsInput | boolean
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageSequenceStepCreateManyTemplateInput = {
    id?: string
    sequenceId: string
    orderIndex?: number
    delayAmount?: number
    delayUnit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageSequenceStepUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    delayAmount?: IntFieldUpdateOperationsInput | number
    delayUnit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequence?: MessageSequenceUpdateOneRequiredWithoutStepsNestedInput
  }

  export type MessageSequenceStepUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceId?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    delayAmount?: IntFieldUpdateOperationsInput | number
    delayUnit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageSequenceStepUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceId?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    delayAmount?: IntFieldUpdateOperationsInput | number
    delayUnit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageSequenceStepCreateManySequenceInput = {
    id?: string
    orderIndex?: number
    delayAmount?: number
    delayUnit?: string
    templateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageSequenceStepUpdateWithoutSequenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    delayAmount?: IntFieldUpdateOperationsInput | number
    delayUnit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: MessageTemplateUpdateOneRequiredWithoutStepsNestedInput
  }

  export type MessageSequenceStepUncheckedUpdateWithoutSequenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    delayAmount?: IntFieldUpdateOperationsInput | number
    delayUnit?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageSequenceStepUncheckedUpdateManyWithoutSequenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    delayAmount?: IntFieldUpdateOperationsInput | number
    delayUnit?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundWebhookDeliveryCreateManyEndpointInput = {
    id?: string
    eventId: string
    status?: string
    attempts?: number
    lastCode?: number | null
    lastError?: string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundWebhookDeliveryUpdateWithoutEndpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastCode?: NullableIntFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: OutboundWebhookEventUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type OutboundWebhookDeliveryUncheckedUpdateWithoutEndpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastCode?: NullableIntFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundWebhookDeliveryUncheckedUpdateManyWithoutEndpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastCode?: NullableIntFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundWebhookDeliveryCreateManyEventInput = {
    id?: string
    endpointId: string
    status?: string
    attempts?: number
    lastCode?: number | null
    lastError?: string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundWebhookDeliveryUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastCode?: NullableIntFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endpoint?: WebhookEndpointUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type OutboundWebhookDeliveryUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpointId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastCode?: NullableIntFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundWebhookDeliveryUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpointId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastCode?: NullableIntFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}