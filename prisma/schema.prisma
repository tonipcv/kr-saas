generator client {
  provider = "prisma-client-js"
}

/// Normalized per-country pricing per offer and provider
model OfferPrice {
  id            String           @id @default(cuid())
  offerId       String           @map("offer_id")
  country       String           @db.VarChar(2)
  currency      Currency
  provider      PaymentProvider
  amountCents   Int              @default(0) @map("amount_cents")
  externalPriceId String?        @map("external_price_id")
  active        Boolean          @default(true)
  createdAt     DateTime         @default(now()) @map("created_at")
  updatedAt     DateTime         @updatedAt @map("updated_at")

  offer         Offer            @relation(fields: [offerId], references: [id], onDelete: Cascade)

  @@unique([offerId, country, currency, provider])
  @@index([offerId])
  @@index([country, currency])
  @@map("offer_prices")
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model ProductCategory {
  id        String   @id @default(cuid())
  name      String
  slug      String?  @unique
  doctorId  String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  doctor     User?                  @relation("DoctorCategories", fields: [doctorId], references: [id])
  // Legacy 1:N relation (via products.categoryId)
  products   products[]
  // New N:N relation through pivot table
  categories CategoriesOnProducts[]

  @@unique([doctorId, name])
  @@map("product_categories")
}

model products {
  id              String                 @id
  name            String
  subtitle        String?
  description     String?
  price           Decimal                @db.Decimal(10, 2)
  creditsPerUnit  Decimal                @default(0) @db.Decimal(10, 2)
  category        String
  isActive        Boolean                @default(true)
  priority        Int                    @default(0)
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @default(now())
  doctorId        String?
  clinicId        String?                @map("clinic_id")
  imageUrl        String?
  confirmationUrl String?
  categoryId      String?
  // Selling type and subscription fields
  type            ProductType            @default(PRODUCT)
  interval        SubscriptionInterval?
  intervalCount   Int?                   @default(1) @map("intervalcount")
  trialDays       Int?                   @map("trialdays")
  providerPlanId   String?               @map("providerplanid")
  providerPlanData Json?                 @map("providerplandata")
  autoRenew       Boolean?               @default(true) @map("autorenew")
  doctor          User?                  @relation("DoctorProducts", fields: [doctorId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  clinic          Clinic?                @relation(fields: [clinicId], references: [id])
  productCategory ProductCategory?       @relation(fields: [categoryId], references: [id])
  purchases       Purchase[]
  // New N:N relation through pivot table
  categories      CategoriesOnProducts[]
  // Back-relation for coupons
  coupons         Coupon[]               @relation("ProductCoupons")
  // New: Offers associated with this product (how it's sold)
  offers          Offer[]
  // New: Provider integrations per product (Stripe, KRXPAY, etc)
  integrations    ProductIntegration[]

  @@index([doctorId])
  @@index([categoryId])
  @@index([clinicId])
  @@index([type])
}

// Pivot table for many-to-many between products and ProductCategory
model CategoriesOnProducts {
  productId  String   @map("product_id")
  categoryId String   @map("category_id")
  assignedAt DateTime @default(now()) @map("assigned_at")

  product  products        @relation(fields: [productId], references: [id], onDelete: Cascade)
  category ProductCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([productId, categoryId])
  @@map("categories_on_products")
}

// protocol_products removed due to Protocol removal

// SystemMetrics removed

model Clinic {
  id              String      @id @default(cuid())
  name            String
  description     String?
  ownerId         String
  isActive        Boolean     @default(true)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @default(now()) @updatedAt
  email           String?
  phone           String?
  address         String?
  city            String?
  state           String?
  zipCode         String?
  country         String?
  website         String?
  logo            String?
  slug            String?     @unique @db.VarChar(255)
  subdomain       String?     @unique @db.VarChar(255)
  // Business metadata
  monthlyRevenueRange String?  @map("monthly_revenue_range")
  currentGateway       String?  @map("current_gateway")
  // Branding / Theming
  theme           ClinicTheme @default(LIGHT)
  buttonColor     String?
  buttonTextColor String?

  // Relações
  members ClinicMember[]
  owner   User           @relation("ClinicOwner", fields: [ownerId], references: [id])

  // Nova estrutura de subscrição
  subscriptions   ClinicSubscription[]
  products        products[]
  referralLeads   ReferralLead[]
  couponTemplates CouponTemplate[]
  referralRewards ReferralReward[]
  merchant        Merchant?
  merchantApplication MerchantApplication?

  @@index([ownerId])
  @@index([slug])
  @@map("clinics")
}

model Merchant {
  id                String         @id @default(cuid())
  clinicId          String         @unique @map("clinic_id")
  status            MerchantStatus @default(PENDING)
  recipientId       String?        @map("recipient_id")
  externalAccountId String?        @map("external_account_id")
  onboardingState   Json?          @map("onboarding_state")
  splitPercent      Int            @default(100) @map("split_percent")
  platformFeeBps    Int            @default(0) @map("platform_fee_bps")
  transactionFeeCents Int?         @default(0) @map("transaction_fee_cents")
  transactionFeeType  String?      @default("flat") @map("transaction_fee_type")
  lastSyncAt        DateTime?      @map("last_sync_at")
  createdAt         DateTime       @default(now()) @map("created_at")
  updatedAt         DateTime       @default(now()) @updatedAt @map("updated_at")
  clinic            Clinic         @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  // Back-relations
  integrations     MerchantIntegration[]

  @@map("merchants")
}

/// Application for merchant onboarding per clinic, with data and documents
model MerchantApplication {
  id             String             @id @default(cuid())
  clinicId       String             @unique @map("clinic_id")
  type           MerchantType       @default(INDIVIDUAL)
  businessName   String?
  fullName       String?
  documentNumber String?
  email          String?
  phone          String?
  address        Json?
  bankAccount    Json?
  recipientId    String?            @map("recipient_id")
  status         MerchantAppStatus  @default(DRAFT)
  reviewNotes    String?
  reviewedBy     String?
  reviewedAt     DateTime?
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  clinic    Clinic             @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  documents MerchantDocument[]

  @@map("merchant_applications")
}

/// Documents uploaded for merchant application (e.g., ID, address proof)
model MerchantDocument {
  id            String            @id @default(cuid())
  applicationId String            @map("application_id")
  type          DocumentType
  fileUrl       String            @map("file_url")
  status        DocumentStatus    @default(PENDING)
  notes         String?
  uploadedAt    DateTime          @default(now()) @map("uploaded_at")
  reviewedAt    DateTime?         @map("reviewed_at")

  application MerchantApplication @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  @@index([applicationId])
  @@map("merchant_documents")
}

enum ClinicRole {
  OWNER // Dono do negócio
  MANAGER // Gerente com acesso administrativo
  PROVIDER // Profissional que presta serviço (médico, dentista, cabeleireiro, etc)
  STAFF // Equipe de apoio (recepcionista, assistente, etc)
}

enum ClinicTheme {
  LIGHT
  DARK
}

enum MerchantStatus {
  PENDING
  ACTIVE
  REJECTED
  DISABLED
}

enum MerchantType {
  INDIVIDUAL
  COMPANY
}

enum MerchantAppStatus {
  DRAFT
  PENDING_DOCUMENTS
  UNDER_REVIEW
  APPROVED
  REJECTED
}

enum DocumentType {
  ID_FRONT
  ID_BACK
  SELFIE
  CNPJ_CARD
  ADDRESS_PROOF
  CONTRACT_SOCIAL
  BANK_STATEMENT
  OTHER
}

enum DocumentStatus {
  PENDING
  APPROVED
  REJECTED
}

model ClinicMember {
  id       String     @id @default(cuid())
  clinicId String
  userId   String
  role     ClinicRole @default(STAFF)
  isActive Boolean    @default(true)
  joinedAt DateTime   @default(now())
  clinic   Clinic     @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  user     User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([clinicId, userId])
  @@index([role])
  @@map("clinic_members")
}

model ReferralLead {
  id                                   String           @id(map: "ReferralLead_pkey") @default(cuid())
  name                                 String
  email                                String
  phone                                String?
  message                              String?
  status                               String           @default("NEW")
  source                               String?
  referrerId                           String?
  doctorId                             String?
  clinicId                             String?          @map("clinic_id")
  convertedUserId                      String?
  convertedAt                          DateTime?
  creditValue                          Decimal          @default(0) @db.Decimal(10, 2)
  creditAwarded                        Boolean          @default(false)
  creditAwardedAt                      DateTime?
  notes                                String?
  followUpDate                         DateTime?
  lastContactDate                      DateTime?
  priority                             String           @default("MEDIUM")
  tags                                 String[]
  customFields                         Json?
  createdAt                            DateTime         @default(now())
  updatedAt                            DateTime         @default(now()) @updatedAt
  referralCode                         String?
  referral_credits                     ReferralCredit[]
  convertedUser                        User?            @relation("ConvertedFromLead", fields: [convertedUserId], references: [id], map: "ReferralLead_convertedUserId_fkey")
  doctor                               User?            @relation("DoctorLeads", fields: [doctorId], references: [id], map: "ReferralLead_doctorId_fkey")
  clinic                               Clinic?          @relation(fields: [clinicId], references: [id])
  User_referral_leads_referrerIdToUser User?            @relation("referral_leads_referrerIdToUser", fields: [referrerId], references: [id], map: "ReferralLead_referrerId_fkey")

  @@unique([email, doctorId], map: "ReferralLead_email_doctorId_key")
  @@index([clinicId])
  @@index([doctorId])
  @@index([referrerId])
  @@index([status])
  @@index([doctorId], map: "ReferralLead_doctorId_idx")
  @@index([referrerId], map: "ReferralLead_referrerId_idx")
  @@index([status], map: "ReferralLead_status_idx")
  @@map("referral_leads")
}

model ReferralCredit {
  id              String        @id(map: "ReferralCredit_pkey") @default(cuid())
  userId          String
  amount          Decimal       @db.Decimal(10, 2)
  type            String        @default("REFERRAL")
  description     String?
  referralLeadId  String?
  expiresAt       DateTime?
  isUsed          Boolean       @default(false)
  usedAt          DateTime?
  usedForRewardId String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @default(now()) @updatedAt
  referral_leads  ReferralLead? @relation(fields: [referralLeadId], references: [id], map: "ReferralCredit_referralLeadId_fkey")
  user            User          @relation("UserCredits", fields: [userId], references: [id], onDelete: Cascade, map: "ReferralCredit_userId_fkey")

  @@index([isUsed], map: "ReferralCredit_isUsed_idx")
  @@index([userId], map: "ReferralCredit_userId_idx")
  @@map("referral_credits")
}

model ReferralReward {
  id                 String               @id(map: "ReferralReward_pkey") @default(cuid())
  title              String
  description        String?
  type               String               @default("DISCOUNT")
  value              Decimal              @db.Decimal(10, 2)
  costInCredits      Decimal              @db.Decimal(10, 2)
  isActive           Boolean              @default(true)
  validUntil         DateTime?
  maxRedemptions     Int?
  currentRedemptions Int                  @default(0)
  doctorId           String
  clinicId           String?              @map("clinic_id")
  createdAt          DateTime             @default(now()) @map("created_at")
  updatedAt          DateTime             @default(now()) @updatedAt @map("updated_at")
  imageUrl           String?              @map("image_url")
  doctor             User                 @relation("DoctorRewards", fields: [doctorId], references: [id], onDelete: Cascade, map: "ReferralReward_doctorId_fkey")
  clinic             Clinic?              @relation(fields: [clinicId], references: [id])
  redemptions        RewardRedemption[]
  codes              ReferralRewardCode[]

  @@index([doctorId])
  @@index([clinicId])
  @@map("referral_rewards")
}

model RewardRedemption {
  id          String               @id(map: "RewardRedemption_pkey") @default(cuid())
  userId      String
  rewardId    String
  creditsUsed Decimal              @db.Decimal(10, 2)
  status      String               @default("PENDING")
  redeemedAt  DateTime             @default(now())
  fulfilledAt DateTime?
  notes       String?
  // Código único atribuído quando aprovado
  uniqueCode  String?
  reward      ReferralReward       @relation(fields: [rewardId], references: [id], onDelete: Cascade, map: "RewardRedemption_rewardId_fkey")
  user        User                 @relation("UserRedemptions", fields: [userId], references: [id], onDelete: Cascade, map: "RewardRedemption_userId_fkey")
  codes       ReferralRewardCode[]

  @@index([userId], map: "RewardRedemption_userId_idx")
  @@map("reward_redemptions")
}

/// Pool de códigos únicos por recompensa
model ReferralRewardCode {
  id           String   @id @default(cuid())
  rewardId     String
  code         String   @unique
  status       String   @default("UNUSED") // UNUSED | USED
  redemptionId String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt

  reward     ReferralReward    @relation(fields: [rewardId], references: [id], onDelete: Cascade)
  redemption RewardRedemption? @relation(fields: [redemptionId], references: [id])

  @@index([rewardId, status])
  @@map("referral_reward_codes")
}

model ReferralFormSettings {
  id                 String   @id(map: "ReferralFormSettings_pkey") @default(cuid())
  doctorId           String   @unique(map: "ReferralFormSettings_doctorId_key")
  title              String   @default("Indique um amigo")
  description        String?
  title_page         String?  @default("Agende sua consulta")
  thankYouMessage    String?
  customFields       Json?
  isActive           Boolean  @default(true)
  allowAnonymous     Boolean  @default(false)
  requirePhone       Boolean  @default(false)
  requireMessage     Boolean  @default(false)
  autoAssignToDoctor Boolean  @default(true)
  emailNotifications Boolean  @default(true)
  smsNotifications   Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @default(now()) @updatedAt
  doctor             User     @relation("DoctorFormSettings", fields: [doctorId], references: [id], onDelete: Cascade, map: "ReferralFormSettings_doctorId_fkey")

  @@map("referral_form_settings")
}

// ConsultationForm removed

// ConsultationSubmission removed

model leads {
  id         String   @id
  name       String
  email      String
  phone      String?
  message    String?
  status     String   @default("NEW")
  source     String?
  referrerId String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now())
  User       User?    @relation(fields: [referrerId], references: [id])
}

model referrals {
  id                             String    @id @default(cuid())
  patientId                      String
  doctorId                       String
  status                         String    @default("PENDING")
  notes                          String?
  createdAt                      DateTime  @default(now())
  updatedAt                      DateTime  @default(now()) @updatedAt
  referral_type                  String?   @default("PROTOCOL") @db.VarChar(20)
  priority                       String?   @default("MEDIUM") @db.VarChar(10)
  valid_until                    DateTime? @db.Timestamp(6)
  accepted_at                    DateTime? @db.Timestamp(6)
  completed_at                   DateTime? @db.Timestamp(6)
  User_referrals_doctorIdToUser  User      @relation("referrals_doctorIdToUser", fields: [doctorId], references: [id])
  User_referrals_patientIdToUser User      @relation("referrals_patientIdToUser", fields: [patientId], references: [id])

  @@index([referral_type], map: "idx_referrals_referral_type")
  @@index([status], map: "idx_referrals_status")
  @@map("referrals")
}

// ClinicReferral removed

// DoctorPatientRelationship removed

model User {
  id                       String    @id
  email                    String    @unique
  name                     String?
  image                    String?
  public_cover_image_url   String?
  public_page_template     String? @ignore
  doctor_slug              String?   @unique
  role                     String    @default("PATIENT")
  is_active                Boolean   @default(true)
  created_at               DateTime  @default(now())
  updated_at               DateTime  @default(now()) @updatedAt
  email_verified           DateTime?
  password                 String?
  reset_token              String?
  reset_token_expiry       DateTime?
  verification_code        String?
  verification_code_expiry DateTime?
  doctor_id                String?
  referral_code            String?   @unique
  phone                    String?
  birth_date               DateTime? @db.Date
  gender                   String?
  address                  String?
  emergency_contact        String?
  emergency_phone          String?
  medical_history          String?
  allergies                String?
  medications              String?
  notes                    String?
  google_review_link       String?
  stripe_connect_id        String?
  accessGranted            Boolean   @default(false) @map("access_granted")
  accounts                 Account[]

  sessions Session[]

  User               User?          @relation("UserToUser", fields: [doctor_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  other_users        User[]         @relation("UserToUser")
  clinic_memberships ClinicMember[]

  owned_clinics Clinic[] @relation("ClinicOwner")

  leads              leads[]
  created_products   products[]        @relation("DoctorProducts")
  created_categories ProductCategory[] @relation("DoctorCategories")

  credits             ReferralCredit[]      @relation("UserCredits")
  form_settings       ReferralFormSettings? @relation("DoctorFormSettings")
  converted_from_lead ReferralLead[]        @relation("ConvertedFromLead")
  leads_received      ReferralLead[]        @relation("DoctorLeads")
  referral_leads      ReferralLead[]        @relation("referral_leads_referrerIdToUser")
  offered_rewards     ReferralReward[]      @relation("DoctorRewards")
  referrals_doctor    referrals[]           @relation("referrals_doctorIdToUser")
  referrals_patient   referrals[]           @relation("referrals_patientIdToUser")
  redemptions         RewardRedemption[]    @relation("UserRedemptions")

  user_verification_codes      VerificationCode[] @relation("UserVerificationCodes")
  doctor_verification_codes    VerificationCode[] @relation("DoctorVerificationCodes")
  purchases                    Purchase[]         @relation("UserPurchases")
  doctorPurchases              Purchase[]         @relation("DoctorPurchases")
  pointsLedger                 PointsLedger[]     @relation("UserPointsLedger")
  coupon_templates             CouponTemplate[]   @relation("DoctorCouponTemplates")
  coupons_as_doctor            Coupon[]           @relation("CouponDoctor")
  coupons_as_patient           Coupon[]           @relation("CouponPatient")
  coupons_as_referrer          Coupon[]           @relation("CouponReferrer")
  coupon_redemptions_as_doctor CouponRedemption[] @relation("CouponRedemptionDoctor")
  coupon_redemptions_redeemed  CouponRedemption[] @relation("CouponRedeemer")
  // Back-relations for tenant-specific patient profiles
  doctor_profiles              PatientProfile[]   @relation("ProfileDoctor")
  patient_profiles             PatientProfile[]   @relation("ProfilePatient")
  // Messaging templates and sequences
  message_templates            MessageTemplate[]  @relation("DoctorMessageTemplates")
  message_sequences            MessageSequence[]  @relation("DoctorMessageSequences")
}

// PublicPageTemplate removed (User field now String)

model PatientProfile {
  id                String   @id @default(cuid())
  doctorId          String   @map("doctor_id")
  userId            String   @map("user_id")
  // Tenant-scoped profile fields (copied from User for per-doctor variance)
  name              String?
  phone             String?
  address           String?
  emergency_contact String?
  emergency_phone   String?
  medical_history   String?
  allergies         String?
  medications       String?
  notes             String?
  isActive          Boolean  @default(true) @map("is_active")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  // Membership snapshots per clinic (doctor)
  totalPoints   Int @default(0) @map("total_points")
  currentPoints Int @default(0) @map("current_points")

  // Relations
  doctor       User           @relation("ProfileDoctor", fields: [doctorId], references: [id], onDelete: Cascade)
  patient      User           @relation("ProfilePatient", fields: [userId], references: [id], onDelete: Cascade)
  // Back-relation for points ledger entries scoped to this profile
  pointsLedger PointsLedger[]

  @@unique([doctorId, userId])
  @@index([doctorId])
  @@index([userId])
  @@map("patient_profiles")
}

// MembershipLevelTemplate removed

// MembershipLevel removed

// patient_document_metadata and patient_documents removed

model ClinicPlan {
  id           String   @id @default(cuid())
  name         String
  tier         PlanTier
  description  String?
  monthlyPrice Decimal  @map("monthly_price") @db.Decimal(10, 2)

  // Limites base incluídos
  baseDoctors  Int @map("base_doctors")
  basePatients Int @map("base_patients")

  // Features incluídas no plano
  features Json @default("{}")

  // Trial
  trialDays   Int     @default(30) @map("trial_days")
  requireCard Boolean @default(false) @map("require_card")

  // Controle
  isActive Boolean @default(true) @map("is_active")
  isPublic Boolean @default(true) @map("is_public")

  // Relações
  subscriptions ClinicSubscription[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([tier])
  @@index([isActive])
  @@map("clinic_plans")
}

model ClinicAddOn {
  id           String    @id @default(cuid())
  type         AddOnType
  name         String
  description  String?
  monthlyPrice Decimal   @map("monthly_price") @db.Decimal(10, 2)

  // Quantidade que o add-on oferece
  quantity Int

  isActive Boolean @default(true)

  // Relações
  subscriptions ClinicAddOnSubscription[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([isActive])
  @@map("clinic_add_ons")
}

model ClinicSubscription {
  id       String             @id @default(cuid()) @map("id")
  clinicId String             @map("clinic_id")
  planId   String             @map("plan_id")
  status   SubscriptionStatus @default(TRIAL) @map("status")

  // Datas importantes
  startDate          DateTime @default(now()) @map("start_date")
  trialEndsAt        DateTime @map("trial_ends_at")
  currentPeriodStart DateTime @default(now()) @map("current_period_start")
  currentPeriodEnd   DateTime @map("current_period_end")

  // Controle de pagamento
  stripeCustomerId     String? @map("stripe_customer_id")
  stripeSubscriptionId String? @map("stripe_subscription_id")

  // Cancelamento
  canceledAt   DateTime? @map("canceled_at")
  cancelReason String?   @map("cancel_reason")

  // Uso atual
  currentDoctorsCount  Int @default(0) @map("current_doctors_count")
  currentPatientsCount Int @default(0) @map("current_patients_count")

  // Relações
  clinic Clinic                    @relation(fields: [clinicId], references: [id])
  plan   ClinicPlan                @relation(fields: [planId], references: [id])
  addOns ClinicAddOnSubscription[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([clinicId])
  @@index([status])
  @@map("clinic_subscriptions")
}

model ClinicAddOnSubscription {
  id             String    @id @default(cuid())
  subscriptionId String
  addOnId        String
  quantity       Int
  startDate      DateTime  @default(now())
  endDate        DateTime?

  // Relações
  subscription ClinicSubscription @relation(fields: [subscriptionId], references: [id])
  addOn        ClinicAddOn        @relation(fields: [addOnId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([subscriptionId])
  @@index([addOnId])
  @@map("clinic_add_on_subscriptions")
}

// SubscriptionMigrationLog removed

// GoogleCalendarCredentials removed

// Appointment removed

// DoctorService removed
enum SubscriptionStatus {
  TRIAL
  ACTIVE
  PAST_DUE
  CANCELED
  EXPIRED

  @@map("subscription_status")
}

enum PlanTier {
  STARTER
  GROWTH
  ENTERPRISE
}

enum AddOnType {
  EXTRA_DOCTOR
  EXTRA_PATIENTS
  ADVANCED_REPORTS
  CUSTOM_BRANDING
  WHITE_LABEL
  API_ACCESS
}

// Product selling modes
enum ProductType {
  PRODUCT
  SUBSCRIPTION
}

// Subscription recurrence options
enum SubscriptionInterval {
  DAY
  WEEK
  MONTH
  YEAR
}

// Sales/checkout currencies
enum Currency {
  BRL
  USD
  EUR
  MXN
}

// Supported payment methods per offer
enum PaymentMethod {
  CARD
  PIX
  BOLETO
  PAYPAL
  OPEN_FINANCE
  OPEN_FINANCE_AUTOMATIC
}

model Offer {
  id                   String         @id @default(cuid())
  productId            String         @map("productid")
  name                 String
  description          String?
  currency             Currency       @default(BRL)
  priceCents           Int            @map("pricecents")
  // Preferred provider override for routing hierarchy (optional)
  preferredProvider    PaymentProvider? @map("preferred_provider")
  maxInstallments      Int?           @default(1) @map("maxinstallments")
  installmentMinCents  Int?           @map("installmentmincents")
  active               Boolean        @default(true)
  isSubscription       Boolean        @default(false) @map("issubscription")
  intervalCount        Int?           @map("intervalcount")
  intervalUnit         SubscriptionInterval? @map("intervalunit")
  trialDays            Int?           @map("trialdays")
  checkoutUrl          String?        @map("checkouturl")
  providerConfig       Json?          @map("provider_config")

  createdAt            DateTime       @default(now()) @map("createdat")
  updatedAt            DateTime       @updatedAt @map("updatedat")

  // Relations
  product              products       @relation(fields: [productId], references: [id], onDelete: Cascade)
  paymentMethods       OfferPaymentMethod[]
  prices               OfferPrice[]

  @@index([productId])
  @@index([isSubscription])
  @@map("offers")
}

/// Merchant-scoped routing rule to select provider by location/method with optional product/offer scope
model PaymentRoutingRule {
  id          String           @id @default(cuid())
  merchantId  String           @map("merchant_id")
  productId   String?          @map("product_id")
  offerId     String?          @map("offer_id")
  country     String?          @db.VarChar(2)
  method      PaymentMethod?
  provider    PaymentProvider
  priority    Int              @default(100)
  isActive    Boolean          @default(true) @map("is_active")
  createdAt   DateTime         @default(now()) @map("created_at")
  updatedAt   DateTime         @updatedAt @map("updated_at")

  @@index([merchantId, isActive, priority])
  @@index([merchantId, country, method])
  @@index([productId])
  @@index([offerId])
  @@map("payment_routing_rules")
}

model OfferPaymentMethod {
  id          String         @id @default(cuid())
  offerId     String         @map("offerid")
  method      PaymentMethod
  active      Boolean        @default(true)
  feePercent  Float?         @map("feepercent")

  offer       Offer          @relation(fields: [offerId], references: [id])

  @@unique([offerId, method])
  @@map("offer_payment_methods")
}

/// Gateway integrations per product (e.g., Stripe Product, KRXPay Item)
model ProductIntegration {
  id                String           @id @default(cuid())
  productId         String           @map("product_id")
  provider          PaymentProvider
  externalProductId String           @map("external_product_id")
  metadata          Json?
  createdAt         DateTime         @default(now()) @map("created_at")
  updatedAt         DateTime         @updatedAt @map("updated_at")

  product           products         @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId, provider])
  @@index([provider])
  @@map("product_integrations")
}

model PaymentTransaction {
  id                 String   @id
  provider           String
  providerOrderId    String?  @map("provider_order_id")
  providerChargeId   String?  @map("provider_charge_id")
  doctorId           String?  @map("doctor_id")
  patientProfileId   String?  @map("patient_profile_id")
  clinicId           String?  @map("clinic_id")
  merchantId         String?  @map("merchant_id")
  productId          String?  @map("product_id")
  amountCents        Int      @default(0) @map("amount_cents")
  currency           String   @default("BRL")
  installments       Int?
  paymentMethodType  String?  @map("payment_method_type")
  status             String   @default("processing")
  // Progressive migration to unified enum-based status machine
  status_v2          PaymentStatus?
  rawPayload         Json?    @map("raw_payload")
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")

  // Audit fields (optional)
  paidAt             DateTime? @map("paid_at")
  capturedAt         DateTime? @map("captured_at")
  refundStatus       String?   @map("refund_status")
  refundedAt         DateTime? @map("refunded_at")
  routedProvider     String?   @map("routed_provider")

  // Optional back-relation to CheckoutSession
  checkoutSession    CheckoutSession? @relation("SessionPayment")

  // New unified provider enum (progressive migration)
  provider_v2        PaymentProvider?

  @@index([doctorId])
  @@index([productId])
  @@index([createdAt])
  @@index([providerOrderId])
  @@index([provider, providerChargeId])
  @@index([updatedAt])
  @@index([merchantId])
  @@index([status])
  @@index([paidAt])
  @@index([routedProvider])
  @@map("payment_transactions")
}

 

// Removed enums: AppointmentStatus, ServiceAvailability, FeeType, FeeVisibility

model VerificationCode {
  id         String    @id @default(cuid())
  code       String
  user_id    String
  doctor_id  String
  type       String
  created_at DateTime  @default(now())
  expires_at DateTime
  used_at    DateTime?

  user   User @relation("UserVerificationCodes", fields: [user_id], references: [id], onDelete: Cascade)
  doctor User @relation("DoctorVerificationCodes", fields: [doctor_id], references: [id], onDelete: Cascade)
}

model Purchase {
  id                     String   @id @default(cuid())
  userId                 String
  doctorId               String
  productId              String
  quantity               Int      @default(1)
  unitPrice              Decimal  @db.Decimal(10, 2)
  totalPrice             Decimal  @db.Decimal(10, 2)
  pointsAwarded          Decimal  @default(0) @db.Decimal(10, 2)
  status                 String   @default("COMPLETED")
  externalIdempotencyKey String?
  notes                  String?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @default(now()) @updatedAt

  user    User     @relation("UserPurchases", fields: [userId], references: [id], onDelete: Cascade)
  doctor  User     @relation("DoctorPurchases", fields: [doctorId], references: [id], onDelete: Cascade)
  product products @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([doctorId])
  @@index([productId])
  @@index([status])
  @@index([createdAt])
  @@map("purchases")
}

model PointsLedger {
  id               String   @id @default(cuid())
  userId           String
  patientProfileId String?  @map("patient_profile_id")
  sourceType       String
  sourceId         String
  amount           Decimal  @db.Decimal(10, 2)
  description      String?
  createdAt        DateTime @default(now())

  user           User            @relation("UserPointsLedger", fields: [userId], references: [id], onDelete: Cascade)
  patientProfile PatientProfile? @relation(fields: [patientProfileId], references: [id])

  @@index([userId])
  @@index([patientProfileId])
  @@index([sourceType])
  @@index([sourceId])
  @@index([createdAt])
  @@map("points_ledger")
}

/// Checkout session lifecycle for abandoned cart and recovery
enum CheckoutSessionStatus {
  started
  pix_generated
  paid
  abandoned
  canceled
}

/// Specific payment methods used in checkout sessions (distinct from Offer PaymentMethod)
enum CheckoutPaymentMethod {
  pix
  card
  pix_ob
  unknown
}

model CheckoutSession {
  id                     String                  @id @default(cuid())
  resumeToken            String                  @unique @map("resume_token")

  // Business context
  clinicId               String?                 @map("clinic_id")
  productId              String?                 @map("product_id")
  offerId                String?                 @map("offer_id")
  slug                   String?
  // Provider and localization (multi-gateway)
  provider               PaymentProvider?
  country                String?                 @db.VarChar(2)
  locale                 String?                 @db.VarChar(10)

  // State
  status                 CheckoutSessionStatus   @default(started)
  paymentMethod          CheckoutPaymentMethod?  @default(unknown) @map("payment_method")
  orderId                String?                 @map("order_id")
  pixOrderId             String?                 @map("pix_order_id")
  pixExpiresAt           DateTime?               @map("pix_expires_at")
  paymentTransactionId   String?                 @unique @map("payment_transaction_id")
  paymentTransaction     PaymentTransaction?     @relation("SessionPayment", fields: [paymentTransactionId], references: [id])

  // Contact
  email                  String?
  phone                  String?
  document               String?

  // Attribution
  utmSource              String?                 @map("utm_source")
  utmMedium              String?                 @map("utm_medium")
  utmCampaign            String?                 @map("utm_campaign")
  utmTerm                String?                 @map("utm_term")
  utmContent             String?                 @map("utm_content")
  referrer               String?
  ip                     String?
  userAgent              String?                 @map("user_agent")

  // Selection snapshot
  selectedInstallments   Int?                    @map("selected_installments")
  selectedBank           String?                 @map("selected_bank")
  paymentMethodsAllowed  Json?                   @map("payment_methods_allowed")
  metadata               Json?

  // Timestamps and activity
  startedAt              DateTime                @default(now()) @map("started_at")
  createdAt              DateTime                @default(now()) @map("created_at")
  updatedAt              DateTime                @updatedAt @map("updated_at")
  lastHeartbeatAt        DateTime?               @map("last_heartbeat_at")
  lastStep               String?                 @map("last_step")

  // Reminders and scoring
  reminders              Json?
  reminderExpiringSentAt DateTime?               @map("reminder_expiring_sent_at")
  reminderExpiredSentAt  DateTime?               @map("reminder_expired_sent_at")
  conversionLikelihood   Float?                  @map("conversion_likelihood")

  // Source/audit
  origin                 String?
  createdBy              String?                 @map("created_by")

  @@index([status, clinicId, updatedAt])
  @@index([status, pixExpiresAt])
  @@index([orderId])
  @@index([pixOrderId])
  @@map("checkout_sessions")
}

model Coupon {
  id             String    @id @default(cuid())
  code           String
  doctorId       String    @map("doctor_id")
  campaignId     String?   @map("campaign_id")
  patientId      String?   @map("patient_id")
  referrerId     String?   @map("referrer_id")
  productId      String?   @map("product_id")
  templateId     String?   @map("template_id")
  objective      String?
  objectiveMeta  Json?     @map("objective_meta")
  displayTitle   String?   @map("display_title")
  displayMessage String?   @map("display_message")
  status         String    @default("ISSUED")
  expiresAt      DateTime? @map("expires_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @default(now()) @updatedAt @map("updated_at")

  // Relations
  doctor      User               @relation("CouponDoctor", fields: [doctorId], references: [id], onDelete: Cascade)
  patient     User?              @relation("CouponPatient", fields: [patientId], references: [id], onDelete: SetNull)
  referrer    User?              @relation("CouponReferrer", fields: [referrerId], references: [id], onDelete: SetNull)
  product     products?          @relation("ProductCoupons", fields: [productId], references: [id], onDelete: SetNull)
  template    CouponTemplate?    @relation(fields: [templateId], references: [id], onDelete: SetNull)
  redemptions CouponRedemption[]

  @@unique([doctorId, patientId, objective])
  @@index([doctorId])
  @@index([campaignId])
  @@index([patientId])
  @@index([referrerId])
  @@index([productId])
  @@index([templateId])
  @@index([status])
  @@index([createdAt])
  @@map("coupons")
}

model CouponTemplate {
  id             String   @id @default(cuid())
  doctorId       String   @map("doctor_id")
  clinicId       String?  @map("clinic_id")
  name           String
  slug           String
  displayTitle   String?  @map("display_title")
  displayMessage String?  @map("display_message")
  config         Json?    @default("{}")
  isActive       Boolean  @default(true) @map("is_active")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @default(now()) @updatedAt @map("updated_at")

  // Relations
  doctor  User     @relation("DoctorCouponTemplates", fields: [doctorId], references: [id], onDelete: Cascade)
  clinic  Clinic?  @relation(fields: [clinicId], references: [id])
  coupons Coupon[]

  @@unique([doctorId, slug])
  @@index([doctorId])
  @@index([clinicId])
  @@index([slug])
  @@map("coupon_templates")
}

model CouponRedemption {
  id           String   @id @default(cuid())
  couponId     String   @map("coupon_id")
  doctorId     String   @map("doctor_id")
  redeemedById String?  @map("redeemed_by_id")
  redeemedAt   DateTime @default(now()) @map("redeemed_at")
  notes        String?

  // Relations
  coupon     Coupon @relation(fields: [couponId], references: [id], onDelete: Cascade)
  doctor     User   @relation("CouponRedemptionDoctor", fields: [doctorId], references: [id], onDelete: Cascade)
  redeemedBy User?  @relation("CouponRedeemer", fields: [redeemedById], references: [id], onDelete: SetNull)

  @@index([couponId])
  @@index([doctorId])
  @@index([redeemedAt])
  @@map("coupon_redemptions")
}

/// Unified events store for analytics and auditing
model Event {
  id         String     @id @default(cuid())
  eventId    String?    @unique @map("event_id")
  eventType  EventType  @map("event_type")
  customerId String?    @map("customer_id")
  clinicId   String     @map("clinic_id")
  actor      EventActor
  timestamp  DateTime   @default(now())
  metadata   Json       @default("{}")
  createdAt  DateTime   @default(now()) @map("created_at")

  @@index([clinicId, timestamp], map: "idx_events_clinic_ts")
  @@index([eventType, timestamp], map: "idx_events_type_ts")
  @@index([customerId, timestamp], map: "idx_events_customer_ts")
  @@map("events")
}

/// Canonical list of event types
enum EventType {
  // Cliente (Ciclo de Vida)
  customer_created
  customer_updated
  customer_visit
  lead_created
  lead_converted
  review_submitted
  feedback_negative

  // Transação / Pagamento
  purchase_made
  purchase_refund
  payment_processed
  subscription_billed
  subscription_canceled
  chargeback_reported

  // Loyalty / Rewards
  reward_created
  reward_offered
  reward_viewed
  reward_claimed
  reward_redeemed
  reward_expired
  points_earned
  points_spent

  // Comunicação / Engajamento
  campaign_sent
  campaign_opened
  campaign_clicked
  campaign_replied
  conversation_started
  conversation_closed

  // Membership
  membership_started
  membership_renewed
  membership_canceled
  membership_upgraded

  // IA (Feedback Loop)
  prediction_made
  action_taken
  outcome_recorded

  // Sistema / Infra
  user_logged_in
  config_changed
  integration_added
}

/// Actor who originated the event
enum EventActor {
  customer
  clinic
  system
  ai

  @@map("event_actor_enum")
}

/// Campaign broadcast jobs (mapped to existing SQL table "campaign_jobs")
model CampaignJob {
  id         String   @id
  doctorId   String   @map("doctor_id")
  campaignId String   @map("campaign_id")
  channel    String // 'whatsapp' | 'sms' | 'email'
  trigger    String?
  scheduleAt DateTime @map("schedule_at") @db.Timestamptz(6)
  createdAt  DateTime @default(now()) @map("created_at")
  status     String // 'scheduled' | 'running' | 'done' | 'failed' | 'cancelled'
  lastError  String?  @map("last_error")

  @@index([doctorId])
  @@index([scheduleAt])
  @@index([status])
  @@map("campaign_jobs")
}



/// Reusable per-channel message template owned by a doctor
model MessageTemplate {
  id              String   @id @default(cuid())
  doctorId        String
  name            String
  channel         String   @db.VarChar(20)
  // Email fields (for channel = email)
  subject         String?
  html            String?
  text            String?
  // Optional MJML source; if set with renderStrategy = mjml, compile to HTML on send
  mjml            String?
  renderStrategy  String?  @default("raw_html") @db.VarChar(20)
  // Optional sender overrides (if not provided, use doctor's defaults)
  fromName        String?
  fromEmail       String?
  replyTo         String?
  // WhatsApp template (for channel = whatsapp)
  provider        String? // e.g., 'meta'
  waTemplateName  String?
  waLanguage      String?  @default("pt_BR")
  waCategory      String? // MARKETING | UTILITY | AUTHENTICATION (livre)
  waComponents    Json?
  waStatus        String? // APPROVED | REJECTED | PENDING
  waProviderId    String?
  // Common metadata
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now()) @updatedAt
  // Variables & validation
  variablesSchema Json? // JSON Schema to validate variables passed to this template
  sampleVariables Json? // Example variables for preview
  // Organization
  tags            String[] @default([])
  // SMS helpers
  smsMaxSegments  Int?

  doctor User                  @relation("DoctorMessageTemplates", fields: [doctorId], references: [id], onDelete: Cascade)
  steps  MessageSequenceStep[]

  @@unique([doctorId, name])
  // Avoid duplicate WA templates per doctor/language
  @@unique([doctorId, channel, waTemplateName, waLanguage])
  @@index([doctorId])
  @@map("message_templates")
}

/// A sequence (flow) of messages composed of multiple steps with delays
model MessageSequence {
  id          String   @id @default(cuid())
  doctorId    String
  name        String
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  doctor User                  @relation("DoctorMessageSequences", fields: [doctorId], references: [id], onDelete: Cascade)
  steps  MessageSequenceStep[]

  @@unique([doctorId, name])
  @@index([doctorId])
  @@map("message_sequences")
}

/// An individual scheduled message within a sequence
model MessageSequenceStep {
  id          String @id @default(cuid())
  sequenceId  String
  orderIndex  Int    @default(0)
  // Delay relative to previous step or sequence start
  delayAmount Int    @default(0)
  delayUnit   String @default("hours") @db.VarChar(16)

  // Template to send for this step
  templateId String

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  sequence MessageSequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)
  template MessageTemplate @relation(fields: [templateId], references: [id], onDelete: Restrict)

  @@unique([sequenceId, orderIndex])
  @@index([sequenceId])
  @@index([templateId])
  @@map("message_sequence_steps")
}


/// Open Finance enrollment link (vínculo) for Pix Automático
model OpenFinanceLink {
  id                    String   @id @default(cuid())
  userId                String   @map("user_id")
  clinicId              String?  @map("clinic_id")
  organisationId        String   @map("organisation_id")
  authorisationServerId String   @map("authorisation_server_id")
  enrollmentId          String   @map("enrollment_id")
  status                String   @default("PENDING") // PENDING | AUTHORISED | REVOKED
  deviceBinding         Json?    @map("device_binding")
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  // Back-relations
  consent OpenFinanceConsent?

  @@index([userId])
  @@index([clinicId])
  @@index([status])
  @@map("open_finance_links")
}

/// Open Finance recurring consent/contract for Pix Automático
model OpenFinanceConsent {
  id              String   @id @default(cuid())
  linkId          String   @unique
  consentId       String
  contractId      String
  status          String   @default("ACTIVE")
  amountCents     Int
  periodicity     String   // WEEKLY | MONTHLY | ...
  nextExecutionAt DateTime?
  metadata        Json?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  link OpenFinanceLink @relation(fields: [linkId], references: [id])

  @@index([status])
  @@index([nextExecutionAt])
  @@map("open_finance_consents")
}

/// Webhook delivery log (existing table created via SQL migrations)
model WebhookEvent {
  id                String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  provider          String
  hook_id           String   @map("hook_id")
  type              String
  resource_order_id String?  @map("resource_order_id")
  resource_charge_id String? @map("resource_charge_id")
  status            String?
  received_at       DateTime @default(now()) @map("received_at")
  processed_at      DateTime? @map("processed_at")
  attempts          Int?
  raw               Json

  // Idempotency and retry strategy (extended)
  provider_event_id String?   @map("provider_event_id")
  processed         Boolean   @default(false) @map("processed")
  processing_error  String?   @map("processing_error")
  retry_count       Int       @default(0) @map("retry_count")
  max_retries       Int       @default(3) @map("max_retries")
  next_retry_at     DateTime? @map("next_retry_at")
  last_retry_at     DateTime? @map("last_retry_at")
  error_type        String?   @map("error_type")
  is_retryable      Boolean   @default(true) @map("is_retryable")
  moved_dead_letter Boolean   @default(false) @map("moved_dead_letter")
  dead_letter_reason String?  @map("dead_letter_reason")

  @@unique([provider, hook_id], map: "webhook_events_provider_hook_id_key")
  @@index([type], map: "idx_webhook_events_type")
  @@index([resource_order_id], map: "idx_webhook_events_order")
  @@index([resource_charge_id], map: "idx_webhook_events_charge")
  @@index([received_at], map: "idx_webhook_events_received")
  @@unique([provider, provider_event_id], map: "webhook_events_provider_event_unique")
  @@index([provider, type, processed], map: "idx_webhook_events_processing")
  @@index([processed, received_at], map: "idx_webhook_events_unprocessed")
  @@map("webhook_events")
}

// ===== Open Finance Enums =====
enum PaymentTypeOB {
  SINGLE
  RECURRING
}

enum PaymentStatusOB {
  PENDING
  PROCESSING
  COMPLETED
  REJECTED
  CANCELLED
  EXPIRED
  ACCP
  PAGO
  RJCT
  CANC
}

enum EnrollmentStatusOB {
  PENDING
  AUTHORISED
  REJECTED
  REVOKED
  EXPIRED
}

enum ConsentStatusOB {
  AWAITING_AUTHORISATION
  AUTHORISED
  REJECTED
  CONSUMED
  EXPIRED
}

/// OAuth state storage for PKCE/OpenID flows
model OAuthState {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  state        String   @unique
  nonce        String?
  codeVerifier String?  @map("code_verifier")
  tenantId     String?  @map("tenant_id")
  createdAt    DateTime @default(now()) @map("created_at")
  usedAt       DateTime? @map("used_at")

  @@map("oauth_states")
}

/// OAuth tokens (access/refresh) per tenant/provider
model OAuthToken {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId     String?  @map("tenant_id")
  provider     String   @default("mockbank")
  accessToken  String   @map("access_token")
  refreshToken String?  @map("refresh_token")
  scope        String?
  expiresAt    DateTime? @map("expires_at")
  createdAt    DateTime @default(now()) @map("created_at")

  @@map("oauth_tokens")
}

/// Stored payment consents from Open Finance provider
model PaymentConsent {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId   String?  @map("tenant_id")
  consentId  String   @unique @map("consent_id")
  status     String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  @@map("payment_consents")
}

/// Executed payments via Open Finance
model OpenBankingPayment {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  providerPaymentId String?  @map("provider_payment_id")
  consentId        String?
  amountCents      Int?
  currency         String?
  status           PaymentStatusOB?
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @default(now()) @updatedAt @map("updated_at")

  // Additive fields for full audit and payer/creditor references
  enrollmentId             String?   @map("enrollment_id")
  transactionIdentification String?  @map("transaction_identification")
  payerId                  String?   @map("payer_id")
  payerDocument            String?   @map("payer_document")
  payerEmail               String?   @map("payer_email")
  payerName                String?   @map("payer_name")
  creditorName             String?   @map("creditor_name")
  creditorCpfCnpj          String?   @map("creditor_cpf_cnpj")
  clinicId                 String?   @map("clinic_id")
  productId                String?   @map("product_id")
  purchaseId               String?   @map("purchase_id")
  type                     PaymentTypeOB?   @map("type")
  executedAt               DateTime? @map("executed_at")
  settledAt                DateTime? @map("settled_at")
  recurrenceType           String?   @map("recurrence_type")
  subscriptionId           String?   @map("subscription_id")
  executionOrder           Int?      @map("execution_order")
  providerResponse         Json?     @map("provider_response_json")
  fidoAssertion            Json?     @map("fido_assertion_json")
  riskSignals              Json?     @map("risk_signals_json")

  // Redirect-based flow fields
  paymentLinkId            String?   @unique @map("payment_link_id")
  userId                   String?   @map("user_id")
  orderRef                 String?   @map("order_ref")
  redirectUri              String?   @map("redirect_uri")
  transactionId            String?   @map("transaction_id")
  expiresAt                DateTime? @map("expires_at")
  metadata                 Json?     @map("metadata")

  @@map("openbanking_payments")
  @@index([enrollmentId])
  @@index([payerId])
  @@index([clinicId])
  @@index([status])
  @@index([executedAt])
  @@index([providerPaymentId])
  @@index([type])
  @@index([createdAt])
}

/// Metadata linked to an OAuth state (bank selection)
model OAuthStateMeta {
  state                  String   @id
  organisationId         String?  @map("organisation_id")
  authorisationServerId  String?  @map("authorisation_server_id")
  createdAt              DateTime @default(now()) @map("created_at")

  // Checkout context for persistence after validate
  productId              String?  @map("product_id")
  amountCents            Int?     @map("amount_cents")
  currency               String?  @map("currency")
  orderRef               String?  @map("order_ref")

  @@map("oauth_state_meta")
}

/// Persist last successful Open Finance enrollment context per user/session
model EnrollmentContext {
  id                     String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId                 String   @map("user_id")
  sessionId              String?  @map("session_id")
  enrollmentId           String   @map("enrollment_id")
  organisationId         String   @map("organisation_id")
  authorisationServerId  String   @map("authorisation_server_id")
  fallbackUsed           Boolean  @default(false) @map("fallback_used")
  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @default(now()) @updatedAt @map("updated_at")
  status                 EnrollmentStatusOB?  @map("status")
  deviceRegistered       Boolean  @default(false) @map("device_registered")
  expiresAt              DateTime? @map("expires_at")

  // Additive buyer/device/audit fields
  clinicId               String?  @map("clinic_id")
  payerEmail             String?  @map("payer_email")
  payerDocument          String?  @map("payer_document")
  payerName              String?  @map("payer_name")
  recurringEnabled       Boolean? @map("recurring_enabled")
  deviceBinding          Json?    @map("device_binding_json")
  providerResponse       Json?    @map("provider_response_json")

  @@unique([userId, organisationId])
  @@index([userId, createdAt])
  @@index([sessionId, createdAt])
  @@map("enrollment_contexts")
  @@index([enrollmentId])
  @@index([clinicId])
  @@index([status])
  @@index([deviceRegistered])
  @@index([recurringEnabled])
}

/// Consents created for Open Finance payments (JSR)
model OpenBankingConsent {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  enrollmentId     String?  @map("enrollment_id")
  consentId        String   @unique @map("consent_id")
  amountCents      Int?     @map("amount_cents")
  currency         String?  @map("currency")
  creditorName     String?  @map("creditor_name")
  creditorCpfCnpj  String?  @map("creditor_cpf_cnpj")
  productId        String?  @map("product_id")
  clinicId         String?  @map("clinic_id")
  status           ConsentStatusOB?  @map("status")
  providerResponse Json?    @map("provider_response_json")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @default(now()) @updatedAt @map("updated_at")

  @@index([consentId])
  @@index([enrollmentId])
  @@map("openbanking_consents")
  @@index([status])
  @@index([productId])
}

/// Buyer profile for checkouts (non-clinical)
model PaymentCustomer {
  id         String   @id @default(cuid())
  userId     String?
  clinicId   String?
  email      String?
  document   String?  @map("document")
  fullName   String?
  phones     String?  @map("phones_json")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  @@index([userId])
  @@index([clinicId])
  @@index([document])
  @@map("payment_customers")
}

// ===== Payments: Provider enum and integrations =====

enum PaymentProvider {
  KRXPAY
  STRIPE
  ADYEN
  APPMAX
  PAYPAL
  MERCADOPAGO
  PAGARME
  OPENFINANCE
}

model MerchantIntegration {
  id           String          @id @default(cuid())
  merchantId   String          @map("merchant_id")
  provider     PaymentProvider
  credentials  Json
  config       Json?
  isActive     Boolean         @default(true) @map("is_active")
  isPrimary    Boolean         @default(false) @map("is_primary")
  connectedAt  DateTime        @default(now()) @map("connected_at")
  lastUsedAt   DateTime?       @map("last_used_at")
  lastError    String?         @map("last_error")
  lastErrorAt  DateTime?       @map("last_error_at")

  merchant     Merchant        @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@unique([merchantId, provider])
  @@index([merchantId, isActive])
  @@index([provider, isActive])
  @@map("merchant_integrations")
}

// Unified payment status machine (progressive adoption via PaymentTransaction.status_v2)
enum PaymentStatus {
  PENDING
  PROCESSING
  REQUIRES_ACTION
  SUCCEEDED
  FAILED
  CANCELED
  EXPIRED
  REFUNDING
  REFUNDED
  PARTIALLY_REFUNDED
  CHARGEBACK
  DISPUTED
}
