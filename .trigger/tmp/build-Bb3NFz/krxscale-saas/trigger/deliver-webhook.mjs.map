{
  "version": 3,
  "sources": ["../../../../../trigger/deliver-webhook.ts", "../../../../../src/lib/webhooks/signature.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk/v3\";\nimport { prisma } from \"@/lib/prisma\";\nimport { signPayload } from \"@/lib/webhooks/signature\";\n\n/**\n * Trigger.dev task para entregar webhooks outbound\n * \n * Substitui o worker manual (outbound-worker.ts) com:\n * - Retry automÃ¡tico nativo do Trigger.dev\n * - Dashboard com logs/mÃ©tricas\n * - Escalabilidade automÃ¡tica\n * \n * MantÃ©m 100% compatÃ­vel com:\n * - Tabelas existentes (outbound_webhook_deliveries, etc)\n * - Payload format (specVersion 1.0)\n * - Assinatura HMAC SHA-256\n * - ValidaÃ§Ãµes (HTTPS, tamanho)\n */\nexport const deliverWebhook = task({\n  id: \"deliver-webhook\",\n  \n  // Retry policy: replica o backoff manual original\n  // [0s, 1min, 5min, 15min, 1h, 6h, 24h, 48h, 72h, 96h]\n  retry: {\n    maxAttempts: 10,\n    factor: 1.8,\n    minTimeoutInMs: 60000,      // 1 minuto\n    maxTimeoutInMs: 86400000,   // 24 horas\n    randomize: true,            // Jitter para evitar thundering herd\n  },\n  \n  // Timeout por tentativa (15s como no worker manual)\n  // Nota: Trigger.dev nÃ£o tem timeout de execuÃ§Ã£o, mas o fetch tem\n  \n  run: async (payload: { deliveryId: string }, { ctx }) => {\n    const { deliveryId } = payload;\n    const attemptNumber = ctx.attempt.number;\n\n    console.log(`[Webhook Delivery] Processing ${deliveryId} (attempt ${attemptNumber}/10)`);\n\n    // 1. Buscar delivery com endpoint e event\n    const delivery = await prisma.outboundWebhookDelivery.findUnique({\n      where: { id: deliveryId },\n      include: {\n        endpoint: true,\n        event: true,\n      },\n    });\n\n    if (!delivery) {\n      console.error(`[Webhook Delivery] Delivery ${deliveryId} not found`);\n      throw new Error(`Delivery ${deliveryId} not found`);\n    }\n\n    // Se jÃ¡ foi entregue, skip (idempotÃªncia)\n    if (delivery.status === 'DELIVERED') {\n      console.log(`[Webhook Delivery] ${deliveryId} already delivered, skipping`);\n      return {\n        status: 'already_delivered',\n        deliveryId,\n        attempt: attemptNumber,\n      };\n    }\n\n    // 2. Validar HTTPS (seguranÃ§a obrigatÃ³ria)\n    if (!delivery.endpoint.url.startsWith('https://')) {\n      console.error(`[Webhook Delivery] ${deliveryId} endpoint must use HTTPS: ${delivery.endpoint.url}`);\n      \n      await prisma.outboundWebhookDelivery.update({\n        where: { id: deliveryId },\n        data: {\n          status: 'FAILED',\n          lastError: 'Endpoint URL must use HTTPS for security',\n          attempts: (delivery.attempts || 0) + 1,\n          nextAttemptAt: null,\n        },\n      });\n      \n      throw new Error('HTTPS required');\n    }\n\n    // 3. Montar payload (formato v1.0 - mantÃ©m compatibilidade)\n    const webhookPayload = {\n      specVersion: '1.0',\n      id: delivery.event.id,\n      type: delivery.event.type,\n      createdAt: delivery.event.createdAt.toISOString(),\n      attempt: attemptNumber,\n      idempotencyKey: delivery.event.id,\n      clinicId: delivery.event.clinicId,\n      resource: delivery.event.resource,\n      data: delivery.event.payload,\n    };\n\n    const body = JSON.stringify(webhookPayload);\n\n    // 4. Validar tamanho do payload (max 1MB)\n    const sizeBytes = Buffer.byteLength(body, 'utf8');\n    const MAX_SIZE = 1024 * 1024; // 1MB\n\n    if (sizeBytes > MAX_SIZE) {\n      console.error(`[Webhook Delivery] ${deliveryId} payload too large: ${sizeBytes} bytes (max: ${MAX_SIZE})`);\n      \n      await prisma.outboundWebhookDelivery.update({\n        where: { id: deliveryId },\n        data: {\n          status: 'FAILED',\n          lastError: `Payload too large: ${sizeBytes} bytes (max: 1MB)`,\n          attempts: (delivery.attempts || 0) + 1,\n          nextAttemptAt: null,\n        },\n      });\n      \n      throw new Error('Payload too large');\n    }\n\n    // 5. Assinar payload com HMAC SHA-256\n    const timestamp = Math.floor(Date.now() / 1000);\n    const signature = signPayload(delivery.endpoint.secret, body, timestamp);\n\n    // 6. Enviar webhook com timeout de 15s\n    const startTime = Date.now();\n    \n    try {\n      const response = await fetch(delivery.endpoint.url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Webhook-Id': delivery.event.id,\n          'X-Webhook-Event': delivery.event.type,\n          'X-Webhook-Signature': signature,\n          'X-Webhook-Timestamp': timestamp.toString(),\n          'X-Webhook-Spec-Version': '1.0',\n          'User-Agent': 'KrxScale-Webhooks/1.0 (Trigger.dev)',\n        },\n        body,\n        signal: AbortSignal.timeout(15000), // 15s timeout\n      });\n\n      const latency = Date.now() - startTime;\n      const responseText = await response.text().catch(() => '');\n\n      // 7. Processar resposta\n      if (response.ok) {\n        // âœ… Sucesso - marcar como DELIVERED\n        await prisma.outboundWebhookDelivery.update({\n          where: { id: deliveryId },\n          data: {\n            status: 'DELIVERED',\n            deliveredAt: new Date(),\n            attempts: (delivery.attempts || 0) + 1,\n            lastCode: response.status,\n            lastError: null,\n            nextAttemptAt: null,\n          },\n        });\n\n        console.log(`[Webhook Delivery] âœ… ${deliveryId} delivered successfully in ${latency}ms (HTTP ${response.status})`);\n\n        return {\n          status: 'delivered',\n          deliveryId,\n          statusCode: response.status,\n          latency,\n          attempt: attemptNumber,\n        };\n      } else {\n        // âŒ Falha HTTP - Trigger.dev vai fazer retry automaticamente\n        const error = `HTTP ${response.status}: ${responseText.slice(0, 500)}`;\n        \n        console.error(`[Webhook Delivery] âŒ ${deliveryId} failed: ${error}`);\n        \n        // Atualizar delivery com erro (mantÃ©m PENDING para retry)\n        await prisma.outboundWebhookDelivery.update({\n          where: { id: deliveryId },\n          data: {\n            status: 'PENDING',\n            attempts: (delivery.attempts || 0) + 1,\n            lastCode: response.status,\n            lastError: error,\n            // nextAttemptAt Ã© gerenciado pelo Trigger.dev\n          },\n        });\n\n        // LanÃ§ar erro para Trigger.dev fazer retry\n        throw new Error(error);\n      }\n    } catch (err: any) {\n      const latency = Date.now() - startTime;\n      const errorMessage = err?.message || String(err);\n      \n      console.error(`[Webhook Delivery] âŒ ${deliveryId} exception after ${latency}ms:`, errorMessage);\n      \n      // Atualizar delivery com erro\n      await prisma.outboundWebhookDelivery.update({\n        where: { id: deliveryId },\n        data: {\n          status: 'PENDING',\n          attempts: (delivery.attempts || 0) + 1,\n          lastCode: null,\n          lastError: errorMessage.slice(0, 1000), // Limitar tamanho\n        },\n      });\n\n      // Se atingiu max attempts, marcar como FAILED permanente\n      if (attemptNumber >= 10) {\n        await prisma.outboundWebhookDelivery.update({\n          where: { id: deliveryId },\n          data: {\n            status: 'FAILED',\n            nextAttemptAt: null,\n          },\n        });\n        \n        console.error(`[Webhook Delivery] ðŸ’€ ${deliveryId} permanently failed after ${attemptNumber} attempts`);\n      }\n\n      // Re-lanÃ§ar para Trigger.dev fazer retry\n      throw err;\n    }\n  },\n});\n", "import crypto from 'crypto'\n\nexport function signPayload(secret: string, body: string, timestamp: number): string {\n  const base = `t=${timestamp}.${body}`\n  const hmac = crypto.createHmac('sha256', secret).update(base).digest('hex')\n  return `t=${timestamp},v1=${hmac}`\n}\n\nexport function verifySignature(secret: string, body: string, signature: string, toleranceSeconds = 300): boolean {\n  try {\n    const [tPart, v1Part] = signature.split(',')\n    const timestamp = parseInt(tPart.split('=')[1], 10)\n    const received = (v1Part.split('=')[1] || '').trim()\n    if (!Number.isFinite(timestamp)) return false\n    const now = Math.floor(Date.now() / 1000)\n    if (Math.abs(now - timestamp) > toleranceSeconds) return false\n    const base = `t=${timestamp}.${body}`\n    const computed = crypto.createHmac('sha256', secret).update(base).digest('hex')\n    return crypto.timingSafeEqual(Buffer.from(computed), Buffer.from(received))\n  } catch {\n    return false\n  }\n}\n\nexport function generateSecret(): string {\n  return `whsec_${crypto.randomBytes(32).toString('hex')}`\n}\n"],
  "mappings": "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",
  "names": []
}
