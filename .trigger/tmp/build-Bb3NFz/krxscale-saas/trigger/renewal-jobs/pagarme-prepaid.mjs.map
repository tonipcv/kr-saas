{
  "version": 3,
  "sources": ["../../../../../../trigger/renewal-jobs/pagarme-prepaid.ts", "../../../../../../src/lib/payments/pagarme/sdk.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk/v3\";\nimport { prisma } from \"@/lib/prisma\";\nimport { pagarmeCreateOrder, pagarmeGetOrder } from \"@/lib/payments/pagarme/sdk\";\n\nexport const pagarmePrepaidRenewal = task({\n  id: \"pagarme-prepaid-renewal\",\n  retry: { maxAttempts: 5, minTimeoutInMs: 2000, maxTimeoutInMs: 60000, factor: 2 },\n  queue: { concurrencyLimit: 10 },\n  run: async (payload: { subscriptionId: string }) => {\n    const { subscriptionId } = payload;\n    console.log(`ðŸ”„ Processing Pagar.me prepaid renewal for subscription: ${subscriptionId}`);\n\n    if (process.env.TRIGGER_ENABLE_PAGARME_PREPAID !== \"true\") {\n      console.log(\"âš ï¸  Feature disabled: TRIGGER_ENABLE_PAGARME_PREPAID\");\n      return { skipped: true, reason: \"feature_disabled\" };\n    }\n\n    // Fetch subscription with fallback to default payment method\n    const subscription = await prisma.customerSubscription.findUnique({\n      where: { id: subscriptionId },\n      include: {\n        customer: {\n          include: {\n            paymentMethods: {\n              where: { provider: \"PAGARME\" as any },\n              orderBy: { isDefault: \"desc\" },\n              take: 1,\n            },\n          },\n        },\n      },\n    });\n\n    if (!subscription) throw new Error(`Subscription ${subscriptionId} not found`);\n    if (!subscription.currentPeriodEnd) return { skipped: true, reason: \"missing_current_period\" };\n\n    // Only process due subscriptions\n    if (subscription.currentPeriodEnd > new Date()) {\n      return { skipped: true, reason: \"not_due\" };\n    }\n\n    if (!subscription.isNative) {\n      // Determine payment method\n      const paymentMethod = subscription.vaultPaymentMethodId\n        ? await prisma.customerPaymentMethod.findUnique({ where: { id: subscription.vaultPaymentMethodId } })\n        : subscription.customer.paymentMethods?.[0];\n\n      if (!paymentMethod) {\n        await prisma.customerSubscription.update({\n          where: { id: subscriptionId },\n          data: {\n            status: \"PAST_DUE\",\n            metadata: {\n              ...(subscription.metadata as any),\n              lastRenewalError: \"no_payment_method\",\n              lastRenewalAttempt: new Date().toISOString(),\n            },\n          },\n        });\n        throw new Error(\"No payment method found\");\n      }\n\n      // Compute next period\n      const meta = (subscription.metadata as any) || {};\n      const intervalUnit: string = meta.intervalUnit || \"MONTH\";\n      const intervalCount: number = Number(meta.intervalCount || 1);\n      const nextPeriodStart: Date = subscription.currentPeriodEnd;\n      const nextPeriodEnd: Date = calculateNextPeriod(nextPeriodStart, intervalUnit, intervalCount);\n\n      // Create order in Pagar.me\n      const pagarmeCustomerId: string | undefined = meta.pagarmeCustomerId;\n      const pagarmeCardId: string | undefined = paymentMethod.providerPaymentMethodId || meta.pagarmeCardId;\n      if (!pagarmeCardId) throw new Error(\"Missing Pagar.me card_id (providerPaymentMethodId or metadata.pagarmeCardId)\");\n\n      // Build customer payload with required identity fields (Pagarme v5 validates even with card_id)\n      const customerDoc = String(subscription.customer?.document || \"\").replace(/\\D+/g, \"\");\n      const customerType = customerDoc && customerDoc.length > 11 ? \"company\" : (customerDoc ? \"individual\" : undefined);\n      const phoneRaw = String(subscription.customer?.telephone || \"\");\n      const phoneDigits = phoneRaw.replace(/\\D+/g, \"\");\n      const mobile_phone = phoneDigits.length >= 10 ? {\n        country_code: phoneDigits.length >= 12 ? phoneDigits.slice(0, 2) : \"55\",\n        area_code: phoneDigits.length >= 12 ? phoneDigits.slice(2, 4) : phoneDigits.slice(0, 2),\n        number: phoneDigits.length >= 12 ? phoneDigits.slice(4) : phoneDigits.slice(2),\n      } : undefined;\n\n      const customerPayload: any = {\n        ...(pagarmeCustomerId ? { id: pagarmeCustomerId } : {}),\n        name: subscription.customer?.name || \"Cliente\",\n        email: subscription.customer?.email || undefined,\n        document: customerDoc || undefined,\n        type: customerType,\n        phones: mobile_phone ? { mobile_phone } : undefined,\n      };\n\n      const order = await pagarmeCreateOrder({\n        customer: customerPayload,\n        items: [\n          {\n            amount: subscription.priceCents,\n            description: `RenovaÃ§Ã£o ${subscription.productId || \"subscription\"}`,\n            quantity: 1,\n            code: subscription.productId || \"subscription\",\n          },\n        ],\n        payments: [\n          {\n            payment_method: \"credit_card\",\n            credit_card: { card_id: pagarmeCardId, installments: 1, capture: true },\n          },\n        ],\n        currency: \"BRL\",\n        metadata: {\n          type: \"subscription_renewal\",\n          subscriptionId: subscription.id,\n          billingCycle: \"renewal\",\n          periodStart: nextPeriodStart.toISOString(),\n          periodEnd: nextPeriodEnd.toISOString(),\n        },\n      });\n\n      // Optional: if not paid, inspect order/transaction to aid diagnostics\n      try {\n        if (order?.status !== \"paid\") {\n          const inspected = await pagarmeGetOrder(order.id).catch(() => order);\n          const ch = Array.isArray(inspected?.charges) ? inspected.charges[0] : null;\n          const tx = ch?.last_transaction || (Array.isArray(inspected?.payments) ? inspected.payments?.[0]?.last_transaction : null) || null;\n          const summary = tx ? {\n            tx_status: tx?.status,\n            acquirer_message: tx?.acquirer_message,\n            acquirer_return_code: tx?.acquirer_return_code,\n            code: tx?.code,\n            message: tx?.message,\n          } : { no_transaction: true };\n          console.log(\"[pagarme-prepaid][order inspection]\", {\n            order_id: order?.id,\n            order_status: order?.status,\n            charge_status: ch?.status,\n            last_transaction: summary,\n          });\n        }\n      } catch {}\n\n      const txId = `tx_pagarme_${order.id}`;\n\n      // Upsert payment transaction\n      const transaction = await prisma.paymentTransaction.upsert({\n        where: { id: txId },\n        create: {\n          id: txId,\n          provider: \"pagarme\",\n          provider_v2: \"PAGARME\" as any,\n          providerOrderId: order.id,\n          merchantId: subscription.merchantId,\n          customerId: subscription.customerId,\n          customerSubscriptionId: subscription.id,\n          productId: subscription.productId,\n          amountCents: subscription.priceCents,\n          currency: String(subscription.currency).toLowerCase(),\n          status: order.status || \"processing\",\n          status_v2: mapPagarmeStatus(order.status),\n          paymentMethodType: \"subscription_renewal\",\n          billingPeriodStart: nextPeriodStart,\n          billingPeriodEnd: nextPeriodEnd,\n          rawPayload: order as any,\n        },\n        update: {\n          status: order.status || \"processing\",\n          status_v2: mapPagarmeStatus(order.status),\n          rawPayload: order as any,\n        },\n      });\n\n      // If paid immediately, activate subscription\n      if (order.status === \"paid\") {\n        await prisma.$transaction([\n          prisma.customerSubscription.update({\n            where: { id: subscriptionId },\n            data: {\n              status: \"ACTIVE\",\n              currentPeriodStart: nextPeriodStart,\n              currentPeriodEnd: nextPeriodEnd,\n            },\n          }),\n          prisma.paymentTransaction.update({\n            where: { id: txId },\n            data: {\n              status: \"paid\",\n              status_v2: \"SUCCEEDED\" as any,\n              paidAt: new Date(),\n              capturedAt: new Date(),\n            },\n          }),\n          prisma.event.create({\n            data: {\n              eventType: \"subscription_billed\" as any,\n              clinicId: subscription.merchantId,\n              customerId: subscription.customerId,\n              actor: \"system\" as any,\n              metadata: {\n                subscriptionId: subscription.id,\n                transactionId: transaction.id,\n                amount: subscription.priceCents,\n                provider: \"PAGARME\",\n                type: \"prepaid_renewal\",\n              },\n            },\n          }),\n        ]);\n      }\n\n      console.log(`âœ… Renewal processed (Pagar.me prepaid)`, {\n        subscriptionId: subscription.id,\n        transactionId: txId,\n        paid: order.status === \"paid\",\n      });\n\n      return { success: true, transactionId: txId, paid: order.status === \"paid\" };\n    }\n\n    return { skipped: true, reason: \"native_subscription\" };\n  },\n});\n\nfunction calculateNextPeriod(current: Date, unit: string, count: number): Date {\n  const next = new Date(current);\n  switch (unit) {\n    case \"DAY\":\n      next.setDate(next.getDate() + count);\n      break;\n    case \"WEEK\":\n      next.setDate(next.getDate() + count * 7);\n      break;\n    case \"MONTH\":\n      next.setMonth(next.getMonth() + count);\n      break;\n    case \"YEAR\":\n      next.setFullYear(next.getFullYear() + count);\n      break;\n  }\n  return next;\n}\n\nfunction mapPagarmeStatus(status?: string): any {\n  const map: Record<string, any> = {\n    paid: \"SUCCEEDED\",\n    pending: \"PROCESSING\",\n    processing: \"PROCESSING\",\n    canceled: \"CANCELED\",\n    failed: \"FAILED\",\n    refunded: \"REFUNDED\",\n  };\n  return status ? map[status] || \"PROCESSING\" : \"PROCESSING\";\n}\n", "import crypto from 'crypto';\n\nconst PAGARME_API_KEY = process.env.PAGARME_API_KEY || '';\nconst PAGARME_BASE_URL = process.env.PAGARME_BASE_URL || 'https://api.pagar.me/1';\nconst PAGARME_WEBHOOK_SECRET = process.env.PAGARME_WEBHOOK_SECRET || '';\nconst IS_V5 = PAGARME_BASE_URL.includes('/core/v5');\nconst AUTH_SCHEME = (process.env.PAGARME_AUTH_SCHEME || 'basic').toLowerCase(); // 'basic' | 'bearer'\nconst PAGARME_ACCOUNT_ID = process.env.PAGARME_ACCOUNT_ID || '';\nexport function isV5() { return IS_V5; }\n\nexport async function pagarmeListSubscriptions(params: Record<string, any> = {}) {\n  const qs = new URLSearchParams();\n  for (const [k, v] of Object.entries(params)) {\n    if (v == null) continue;\n    qs.append(k, String(v));\n  }\n  const url = `${PAGARME_BASE_URL}/subscriptions${qs.toString() ? `?${qs.toString()}` : ''}`;\n  const res = await fetch(url, {\n    method: 'GET',\n    headers: authHeaders(),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    const err: any = new Error(`[Pagarme ${res.status}] ${msg}`);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\nexport async function pagarmeGetSubscription(subscriptionId: string) {\n  const res = await fetch(`${PAGARME_BASE_URL}/subscriptions/${encodeURIComponent(subscriptionId)}`, {\n    method: 'GET',\n    headers: authHeaders(),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    const err: any = new Error(`[Pagarme ${res.status}] ${msg}`);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\n// ===== Subscriptions (v5) =====\nexport async function pagarmeCreatePlan(payload: Record<string, any>) {\n  // Typical payload:\n  // {\n  //   name: 'Plano X',\n  //   amount: 1000, // cents\n  //   interval: 'month',\n  //   interval_count: 1,\n  //   trial_period_days: 0\n  // }\n  const res = await fetch(`${PAGARME_BASE_URL}/plans`, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify(payload),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    const err: any = new Error(`[Pagarme ${res.status}] ${msg}`);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\nexport async function pagarmeCreateSubscription(payload: Record<string, any>) {\n  // Typical payload:\n  // {\n  //   plan_id: 'pln_xxx',\n  //   customer: {...}, // or customer_id\n  //   payment_method: 'credit_card',\n  //   card_id: 'card_xxx' | card: {...},\n  //   metadata: { productId, clinicId, buyerEmail }\n  // }\n  const res = await fetch(`${PAGARME_BASE_URL}/subscriptions`, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify(payload),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    const err: any = new Error(`[Pagarme ${res.status}] ${msg}`);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\n// ===== v5 Customers & Cards helpers =====\n\nexport async function pagarmeCreateCustomer(payload: Record<string, any>) {\n  const res = await fetch(`${PAGARME_BASE_URL}/customers`, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify(payload),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    const err: any = new Error(`[Pagarme ${res.status}] ${msg}`);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\nexport async function pagarmeCreateCustomerCard(customerId: string, payload: Record<string, any>) {\n  const res = await fetch(`${PAGARME_BASE_URL}/customers/${encodeURIComponent(customerId)}/cards`, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify(payload),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    const err: any = new Error(`[Pagarme ${res.status}] ${msg}`);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\nexport async function pagarmeGetOrder(orderId: string) {\n  const res = await fetch(`${PAGARME_BASE_URL}/orders/${encodeURIComponent(orderId)}`, {\n    method: 'GET',\n    headers: authHeaders(),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    const err: any = new Error(`[Pagarme ${res.status}] ${msg}`);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\nexport async function pagarmeGetCharge(chargeId: string) {\n  const res = await fetch(`${PAGARME_BASE_URL}/charges/${encodeURIComponent(chargeId)}`, {\n    method: 'GET',\n    headers: authHeaders(),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    const err: any = new Error(`[Pagarme ${res.status}] ${msg}`);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\nfunction authHeaders() {\n  if (AUTH_SCHEME === 'bearer') {\n    const h: Record<string, string> = {\n      Authorization: `Bearer ${PAGARME_API_KEY}`,\n      'Content-Type': 'application/json',\n    };\n    if (PAGARME_ACCOUNT_ID) h['X-PagarMe-Account-Id'] = PAGARME_ACCOUNT_ID;\n    return h;\n  }\n  // Default: Basic (api_key as username, empty password)\n  const token = Buffer.from(`${PAGARME_API_KEY}:`).toString('base64');\n  const h: Record<string, string> = {\n    Authorization: `Basic ${token}`,\n    'Content-Type': 'application/json',\n  };\n  if (PAGARME_ACCOUNT_ID) h['X-PagarMe-Account-Id'] = PAGARME_ACCOUNT_ID;\n  return h;\n}\n\nexport async function pagarmeCreateBankAccount(payload: Record<string, any>) {\n  const res = await fetch(`${PAGARME_BASE_URL}/bank_accounts`, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify(payload),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) throw new Error(data?.errors?.[0]?.message || data?.error || text || `Pagar.me error ${res.status}`);\n  return data;\n}\n\nexport async function pagarmeCreateRecipient(payload: Record<string, any>) {\n  // v5 and v1 both use /recipients, but body shape differs; caller is responsible for shaping payload\n  const res = await fetch(`${PAGARME_BASE_URL}/recipients`, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify(payload),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    const err: any = new Error(`[Pagarme ${res.status}] ${msg}`);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\nexport async function pagarmeUpdateRecipient(recipientId: string, payload: Record<string, any>) {\n  const url = `${PAGARME_BASE_URL}/recipients/${encodeURIComponent(recipientId)}`;\n  // Primary attempt: PATCH on v5, PUT on v1\n  let method = IS_V5 ? 'PATCH' : 'PUT';\n  let res = await fetch(url, {\n    method,\n    headers: authHeaders(),\n    body: JSON.stringify(payload),\n    cache: 'no-store',\n  });\n  let text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n\n  // If v5 rejects PATCH (405/404), fallback to PUT\n  if (!res.ok && IS_V5 && (res.status === 405 || res.status === 404)) {\n    method = 'PUT';\n    res = await fetch(url, {\n      method,\n      headers: authHeaders(),\n      body: JSON.stringify(payload),\n      cache: 'no-store',\n    });\n    text = await res.text();\n    data = {};\n    try { data = JSON.parse(text); } catch {}\n  }\n\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    const err: any = new Error(`[Pagarme ${res.status}] ${msg}`);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\nexport async function pagarmeGetRecipient(recipientId: string) {\n  const res = await fetch(`${PAGARME_BASE_URL}/recipients/${encodeURIComponent(recipientId)}`, {\n    method: 'GET',\n    headers: authHeaders(),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    throw new Error(`[Pagarme ${res.status}] ${msg}`);\n  }\n  return data;\n}\n\nexport function verifyPagarmeWebhookSignature(rawBody: string, signatureHeader: string | undefined): boolean {\n  if (!PAGARME_WEBHOOK_SECRET) return false;\n  if (!signatureHeader) return false;\n  // Some Pagar.me versions use HMAC-SHA1 or SHA256. We'll assume SHA256 for modern setups.\n  const computed = crypto.createHmac('sha256', PAGARME_WEBHOOK_SECRET).update(rawBody, 'utf8').digest('hex');\n  // Signature header may be like: sha256=xxx\n  const received = signatureHeader.split('=')[1] || signatureHeader;\n  const a = Buffer.from(computed);\n  const b = Buffer.from(received);\n  if (a.length !== b.length) return false;\n  return crypto.timingSafeEqual(a, b);\n}\n\nexport type MerchantStatus = 'PENDING' | 'ACTIVE' | 'REJECTED' | 'DISABLED';\n\nexport type MerchantIntegrationStatus = {\n  connected: boolean;\n  status: MerchantStatus;\n  recipientId: string | null;\n  splitPercent: number;\n  platformFeeBps: number;\n  lastSyncAt: string | null;\n};\n\nexport async function pagarmeCreateOrder(payload: Record<string, any>) {\n  const res = await fetch(`${PAGARME_BASE_URL}/orders`, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify(payload),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme error ${res.status}`;\n    const err: any = new Error(`[Pagarme ${res.status}] ${msg}`);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\nexport async function pagarmeCancelCharge(chargeId: string) {\n  // Core v5 cancel/refund: DELETE /charges/{charge_id}\n  const url = `${PAGARME_BASE_URL}/charges/${encodeURIComponent(chargeId)}`;\n  const res = await fetch(url, {\n    method: 'DELETE',\n    headers: authHeaders(),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    try { console.error('[pagarme][cancel] error', { status: res.status, data }); } catch {}\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme cancel error ${res.status}`;\n    const err: any = new Error(msg);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\nexport async function pagarmeRefundCharge(chargeId: string, amountCents?: number) {\n  // Core v5 refunds: POST /charges/{charge_id}/refunds\n  const url = `${PAGARME_BASE_URL}/charges/${encodeURIComponent(chargeId)}/refunds`;\n  const body: any = {};\n  if (Number.isFinite(Number(amountCents)) && Number(amountCents) > 0) body.amount = Math.floor(Number(amountCents));\n  const res = await fetch(url, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify(body),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    try { console.error('[pagarme][refund] error', { status: res.status, data }); } catch {}\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme refund error ${res.status}`;\n    const err: any = new Error(msg);\n    err.status = res.status;\n    err.responseText = text;\n    err.responseJson = data;\n    throw err;\n  }\n  return data;\n}\n\nexport async function pagarmeUpdateCharge(chargeId: string, payload: Record<string, any>) {\n  // Core v5: PATCH /charges/{charge_id} to update split, metadata, etc.\n  const url = `${PAGARME_BASE_URL}/charges/${encodeURIComponent(chargeId)}`;\n  const res = await fetch(url, {\n    method: 'PATCH',\n    headers: authHeaders(),\n    body: JSON.stringify(payload),\n    cache: 'no-store',\n  });\n  const text = await res.text();\n  let data: any = {};\n  try { data = JSON.parse(text); } catch {}\n  if (!res.ok) {\n    try { console.error('[pagarme][update_charge] error', { status: res.status, data }); } catch {}\n    const msgFromArray = Array.isArray(data?.errors)\n      ? data.errors.map((e: any) => e?.message || e?.code || JSON.stringify(e)).join(' | ')\n      : undefined;\n    const msg = msgFromArray || data?.message || data?.error || text || `Pagarme update charge error ${res.status}`;\n    throw new Error(msg);\n  }\n  return data;\n}\n"],
  "mappings": "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",
  "names": ["h"]
}
