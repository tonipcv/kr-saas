import {
  __commonJS,
  __esm,
  __export,
  __name,
  __require,
  __toCommonJS,
  __toESM,
  init_esm
} from "./chunk-UMSOOAUP.mjs";

// node_modules/zod/v3/helpers/util.cjs
var require_util = __commonJS({
  "node_modules/zod/v3/helpers/util.cjs"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
    var util2;
    (function(util3) {
      util3.assertEqual = (_2) => {
      };
      function assertIs(_arg) {
      }
      __name(assertIs, "assertIs");
      util3.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      __name(assertNever, "assertNever");
      util3.assertNever = assertNever;
      util3.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util3.getValidEnumValues = (obj) => {
        const validKeys = util3.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util3.objectValues(filtered);
      };
      util3.objectValues = (obj) => {
        return util3.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util3.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      __name(joinValues, "joinValues");
      util3.joinValues = joinValues;
      util3.jsonStringifyReplacer = (_2, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util2 || (exports.util = util2 = {}));
    var objectUtil2;
    (function(objectUtil3) {
      objectUtil3.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil2 || (exports.objectUtil = objectUtil2 = {}));
    exports.ZodParsedType = util2.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    var getParsedType2 = /* @__PURE__ */ __name((data) => {
      const t2 = typeof data;
      switch (t2) {
        case "undefined":
          return exports.ZodParsedType.undefined;
        case "string":
          return exports.ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
          return exports.ZodParsedType.boolean;
        case "function":
          return exports.ZodParsedType.function;
        case "bigint":
          return exports.ZodParsedType.bigint;
        case "symbol":
          return exports.ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return exports.ZodParsedType.array;
          }
          if (data === null) {
            return exports.ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return exports.ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return exports.ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return exports.ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return exports.ZodParsedType.date;
          }
          return exports.ZodParsedType.object;
        default:
          return exports.ZodParsedType.unknown;
      }
    }, "getParsedType");
    exports.getParsedType = getParsedType2;
  }
});

// node_modules/zod/v3/ZodError.cjs
var require_ZodError = __commonJS({
  "node_modules/zod/v3/ZodError.cjs"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;
    var util_js_1 = require_util();
    exports.ZodIssueCode = util_js_1.util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    var quotelessJson2 = /* @__PURE__ */ __name((obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    }, "quotelessJson");
    exports.quotelessJson = quotelessJson2;
    var ZodError2 = class _ZodError extends Error {
      static {
        __name(this, "ZodError");
      }
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = /* @__PURE__ */ __name((error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i2 = 0;
              while (i2 < issue.path.length) {
                const el = issue.path[i2];
                const terminal = i2 === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i2++;
              }
            }
          }
        }, "processError");
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util_js_1.util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    exports.ZodError = ZodError2;
    ZodError2.create = (issues) => {
      const error = new ZodError2(issues);
      return error;
    };
  }
});

// node_modules/zod/v3/locales/en.cjs
var require_en = __commonJS({
  "node_modules/zod/v3/locales/en.cjs"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    var ZodError_js_1 = require_ZodError();
    var util_js_1 = require_util();
    var errorMap2 = /* @__PURE__ */ __name((issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodError_js_1.ZodIssueCode.invalid_type:
          if (issue.received === util_js_1.ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodError_js_1.ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_js_1.util.jsonStringifyReplacer)}`;
          break;
        case ZodError_js_1.ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util_js_1.util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util_js_1.util.joinValues(issue.options)}`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util_js_1.util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util_js_1.util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodError_js_1.ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "bigint")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_js_1.ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_js_1.ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodError_js_1.ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodError_js_1.ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util_js_1.util.assertNever(issue);
      }
      return { message };
    }, "errorMap");
    exports.default = errorMap2;
  }
});

// node_modules/zod/v3/errors.cjs
var require_errors = __commonJS({
  "node_modules/zod/v3/errors.cjs"(exports) {
    "use strict";
    init_esm();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultErrorMap = void 0;
    exports.setErrorMap = setErrorMap2;
    exports.getErrorMap = getErrorMap2;
    var en_js_1 = __importDefault(require_en());
    exports.defaultErrorMap = en_js_1.default;
    var overrideErrorMap2 = en_js_1.default;
    function setErrorMap2(map) {
      overrideErrorMap2 = map;
    }
    __name(setErrorMap2, "setErrorMap");
    function getErrorMap2() {
      return overrideErrorMap2;
    }
    __name(getErrorMap2, "getErrorMap");
  }
});

// node_modules/zod/v3/helpers/parseUtil.cjs
var require_parseUtil = __commonJS({
  "node_modules/zod/v3/helpers/parseUtil.cjs"(exports) {
    "use strict";
    init_esm();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.EMPTY_PATH = exports.makeIssue = void 0;
    exports.addIssueToContext = addIssueToContext2;
    var errors_js_1 = require_errors();
    var en_js_1 = __importDefault(require_en());
    var makeIssue2 = /* @__PURE__ */ __name((params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    }, "makeIssue");
    exports.makeIssue = makeIssue2;
    exports.EMPTY_PATH = [];
    function addIssueToContext2(ctx, issueData) {
      const overrideMap = (0, errors_js_1.getErrorMap)();
      const issue = (0, exports.makeIssue)({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          // contextual error map is first priority
          ctx.schemaErrorMap,
          // then schema-bound map if available
          overrideMap,
          // then global override map
          overrideMap === en_js_1.default ? void 0 : en_js_1.default
          // then global default map
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    __name(addIssueToContext2, "addIssueToContext");
    var ParseStatus2 = class _ParseStatus {
      static {
        __name(this, "ParseStatus");
      }
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return exports.INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return exports.INVALID;
          if (value.status === "aborted")
            return exports.INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    exports.ParseStatus = ParseStatus2;
    exports.INVALID = Object.freeze({
      status: "aborted"
    });
    var DIRTY2 = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
    exports.DIRTY = DIRTY2;
    var OK2 = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
    exports.OK = OK2;
    var isAborted2 = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
    exports.isAborted = isAborted2;
    var isDirty2 = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
    exports.isDirty = isDirty2;
    var isValid2 = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
    exports.isValid = isValid2;
    var isAsync2 = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");
    exports.isAsync = isAsync2;
  }
});

// node_modules/zod/v3/helpers/typeAliases.cjs
var require_typeAliases = __commonJS({
  "node_modules/zod/v3/helpers/typeAliases.cjs"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/zod/v3/helpers/errorUtil.cjs
var require_errorUtil = __commonJS({
  "node_modules/zod/v3/helpers/errorUtil.cjs"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorUtil = void 0;
    var errorUtil2;
    (function(errorUtil3) {
      errorUtil3.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil3.toString = (message) => typeof message === "string" ? message : message?.message;
    })(errorUtil2 || (exports.errorUtil = errorUtil2 = {}));
  }
});

// node_modules/zod/v3/types.cjs
var require_types = __commonJS({
  "node_modules/zod/v3/types.cjs"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.discriminatedUnion = exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;
    exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = void 0;
    exports.datetimeRegex = datetimeRegex2;
    exports.custom = custom2;
    var ZodError_js_1 = require_ZodError();
    var errors_js_1 = require_errors();
    var errorUtil_js_1 = require_errorUtil();
    var parseUtil_js_1 = require_parseUtil();
    var util_js_1 = require_util();
    var ParseInputLazyPath2 = class {
      static {
        __name(this, "ParseInputLazyPath");
      }
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    var handleResult2 = /* @__PURE__ */ __name((ctx, result) => {
      if ((0, parseUtil_js_1.isValid)(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError_js_1.ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    }, "handleResult");
    function processCreateParams2(params) {
      if (!params)
        return {};
      const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
      if (errorMap2 && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap2)
        return { errorMap: errorMap2, description };
      const customMap = /* @__PURE__ */ __name((iss, ctx) => {
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
          return { message: message ?? ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
          return { message: message ?? required_error ?? ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        return { message: message ?? invalid_type_error ?? ctx.defaultError };
      }, "customMap");
      return { errorMap: customMap, description };
    }
    __name(processCreateParams2, "processCreateParams");
    var ZodType2 = class {
      static {
        __name(this, "ZodType");
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return (0, util_js_1.getParsedType)(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_js_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new parseUtil_js_1.ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_js_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_js_1.isAsync)(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        const ctx = {
          common: {
            issues: [],
            async: params?.async ?? false,
            contextualErrorMap: params?.errorMap
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_js_1.getParsedType)(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult2(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_js_1.getParsedType)(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return (0, parseUtil_js_1.isValid)(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_js_1.isValid)(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params?.errorMap,
            async: true
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_js_1.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_js_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult2(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = /* @__PURE__ */ __name((val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        }, "getIssueProperties");
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
            code: ZodError_js_1.ZodIssueCode.custom,
            ...getIssueProperties(val)
          }), "setError");
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects2({
          schema: this,
          typeName: ZodFirstPartyTypeKind2.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
        };
      }
      optional() {
        return ZodOptional2.create(this, this._def);
      }
      nullable() {
        return ZodNullable2.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray2.create(this);
      }
      promise() {
        return ZodPromise2.create(this, this._def);
      }
      or(option) {
        return ZodUnion2.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection2.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects2({
          ...processCreateParams2(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind2.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault2({
          ...processCreateParams2(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind2.ZodDefault
        });
      }
      brand() {
        return new ZodBranded2({
          typeName: ZodFirstPartyTypeKind2.ZodBranded,
          type: this,
          ...processCreateParams2(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch2({
          ...processCreateParams2(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind2.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline2.create(this, target);
      }
      readonly() {
        return ZodReadonly2.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    exports.ZodType = ZodType2;
    exports.Schema = ZodType2;
    exports.ZodSchema = ZodType2;
    var cuidRegex2 = /^c[^\s-]{8,}$/i;
    var cuid2Regex2 = /^[0-9a-z]+$/;
    var ulidRegex2 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    var uuidRegex2 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    var nanoidRegex2 = /^[a-z0-9_-]{21}$/i;
    var jwtRegex2 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    var durationRegex2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    var emailRegex2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    var _emojiRegex2 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    var emojiRegex2;
    var ipv4Regex2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    var ipv4CidrRegex2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    var ipv6Regex2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    var ipv6CidrRegex2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    var base64Regex2 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    var base64urlRegex2 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    var dateRegexSource2 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    var dateRegex2 = new RegExp(`^${dateRegexSource2}$`);
    function timeRegexSource2(args) {
      let secondsRegexSource = `[0-5]\\d`;
      if (args.precision) {
        secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
      } else if (args.precision == null) {
        secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
      }
      const secondsQuantifier = args.precision ? "+" : "?";
      return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
    }
    __name(timeRegexSource2, "timeRegexSource");
    function timeRegex2(args) {
      return new RegExp(`^${timeRegexSource2(args)}$`);
    }
    __name(timeRegex2, "timeRegex");
    function datetimeRegex2(args) {
      let regex = `${dateRegexSource2}T${timeRegexSource2(args)}`;
      const opts = [];
      opts.push(args.local ? `Z?` : `Z`);
      if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
      regex = `${regex}(${opts.join("|")})`;
      return new RegExp(`^${regex}$`);
    }
    __name(datetimeRegex2, "datetimeRegex");
    function isValidIP2(ip, version) {
      if ((version === "v4" || !version) && ipv4Regex2.test(ip)) {
        return true;
      }
      if ((version === "v6" || !version) && ipv6Regex2.test(ip)) {
        return true;
      }
      return false;
    }
    __name(isValidIP2, "isValidIP");
    function isValidJWT2(jwt, alg) {
      if (!jwtRegex2.test(jwt))
        return false;
      try {
        const [header] = jwt.split(".");
        if (!header)
          return false;
        const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null)
          return false;
        if ("typ" in decoded && decoded?.typ !== "JWT")
          return false;
        if (!decoded.alg)
          return false;
        if (alg && decoded.alg !== alg)
          return false;
        return true;
      } catch {
        return false;
      }
    }
    __name(isValidJWT2, "isValidJWT");
    function isValidCidr2(ip, version) {
      if ((version === "v4" || !version) && ipv4CidrRegex2.test(ip)) {
        return true;
      }
      if ((version === "v6" || !version) && ipv6CidrRegex2.test(ip)) {
        return true;
      }
      return false;
    }
    __name(isValidCidr2, "isValidCidr");
    var ZodString2 = class _ZodString extends ZodType2 {
      static {
        __name(this, "ZodString");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.string,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const status = new parseUtil_js_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                (0, parseUtil_js_1.addIssueToContext)(ctx, {
                  code: ZodError_js_1.ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                (0, parseUtil_js_1.addIssueToContext)(ctx, {
                  code: ZodError_js_1.ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "email",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex2) {
              emojiRegex2 = new RegExp(_emojiRegex2, "u");
            }
            if (!emojiRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "emoji",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "uuid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "nanoid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "cuid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "cuid2",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "ulid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "url",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "regex",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex2(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex2;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex2(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "duration",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP2(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "ip",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "jwt") {
            if (!isValidJWT2(input.data, check.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "jwt",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cidr") {
            if (!isValidCidr2(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "cidr",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "base64",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64url") {
            if (!base64urlRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "base64url",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodError_js_1.ZodIssueCode.invalid_string,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil_js_1.errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_js_1.errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil_js_1.errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil_js_1.errorUtil.errToObj(options?.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil_js_1.errorUtil.errToObj(options?.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil_js_1.errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil_js_1.errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports.ZodString = ZodString2;
    ZodString2.create = (params) => {
      return new ZodString2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams2(params)
      });
    };
    function floatSafeRemainder2(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / 10 ** decCount;
    }
    __name(floatSafeRemainder2, "floatSafeRemainder");
    var ZodNumber2 = class _ZodNumber extends ZodType2 {
      static {
        __name(this, "ZodNumber");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.number,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_js_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util_js_1.util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder2(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_js_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil_js_1.errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_js_1.util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    exports.ZodNumber = ZodNumber2;
    ZodNumber2.create = (params) => {
      return new ZodNumber2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams2(params)
      });
    };
    var ZodBigInt2 = class _ZodBigInt extends ZodType2 {
      static {
        __name(this, "ZodBigInt");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new parseUtil_js_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_js_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports.ZodBigInt = ZodBigInt2;
    ZodBigInt2.create = (params) => {
      return new ZodBigInt2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams2(params)
      });
    };
    var ZodBoolean2 = class extends ZodType2 {
      static {
        __name(this, "ZodBoolean");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports.ZodBoolean = ZodBoolean2;
    ZodBoolean2.create = (params) => {
      return new ZodBoolean2({
        typeName: ZodFirstPartyTypeKind2.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams2(params)
      });
    };
    var ZodDate2 = class _ZodDate extends ZodType2 {
      static {
        __name(this, "ZodDate");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.date,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_date
          });
          return parseUtil_js_1.INVALID;
        }
        const status = new parseUtil_js_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    exports.ZodDate = ZodDate2;
    ZodDate2.create = (params) => {
      return new ZodDate2({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind2.ZodDate,
        ...processCreateParams2(params)
      });
    };
    var ZodSymbol2 = class extends ZodType2 {
      static {
        __name(this, "ZodSymbol");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports.ZodSymbol = ZodSymbol2;
    ZodSymbol2.create = (params) => {
      return new ZodSymbol2({
        typeName: ZodFirstPartyTypeKind2.ZodSymbol,
        ...processCreateParams2(params)
      });
    };
    var ZodUndefined2 = class extends ZodType2 {
      static {
        __name(this, "ZodUndefined");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports.ZodUndefined = ZodUndefined2;
    ZodUndefined2.create = (params) => {
      return new ZodUndefined2({
        typeName: ZodFirstPartyTypeKind2.ZodUndefined,
        ...processCreateParams2(params)
      });
    };
    var ZodNull2 = class extends ZodType2 {
      static {
        __name(this, "ZodNull");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.null,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports.ZodNull = ZodNull2;
    ZodNull2.create = (params) => {
      return new ZodNull2({
        typeName: ZodFirstPartyTypeKind2.ZodNull,
        ...processCreateParams2(params)
      });
    };
    var ZodAny2 = class extends ZodType2 {
      static {
        __name(this, "ZodAny");
      }
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports.ZodAny = ZodAny2;
    ZodAny2.create = (params) => {
      return new ZodAny2({
        typeName: ZodFirstPartyTypeKind2.ZodAny,
        ...processCreateParams2(params)
      });
    };
    var ZodUnknown2 = class extends ZodType2 {
      static {
        __name(this, "ZodUnknown");
      }
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports.ZodUnknown = ZodUnknown2;
    ZodUnknown2.create = (params) => {
      return new ZodUnknown2({
        typeName: ZodFirstPartyTypeKind2.ZodUnknown,
        ...processCreateParams2(params)
      });
    };
    var ZodNever2 = class extends ZodType2 {
      static {
        __name(this, "ZodNever");
      }
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.never,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
    };
    exports.ZodNever = ZodNever2;
    ZodNever2.create = (params) => {
      return new ZodNever2({
        typeName: ZodFirstPartyTypeKind2.ZodNever,
        ...processCreateParams2(params)
      });
    };
    var ZodVoid2 = class extends ZodType2 {
      static {
        __name(this, "ZodVoid");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.void,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports.ZodVoid = ZodVoid2;
    ZodVoid2.create = (params) => {
      return new ZodVoid2({
        typeName: ZodFirstPartyTypeKind2.ZodVoid,
        ...processCreateParams2(params)
      });
    };
    var ZodArray2 = class _ZodArray extends ZodType2 {
      static {
        __name(this, "ZodArray");
      }
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: tooBig ? ZodError_js_1.ZodIssueCode.too_big : ZodError_js_1.ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i2) => {
            return def.type._parseAsync(new ParseInputLazyPath2(ctx, item, ctx.path, i2));
          })).then((result2) => {
            return parseUtil_js_1.ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i2) => {
          return def.type._parseSync(new ParseInputLazyPath2(ctx, item, ctx.path, i2));
        });
        return parseUtil_js_1.ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports.ZodArray = ZodArray2;
    ZodArray2.create = (schema, params) => {
      return new ZodArray2({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind2.ZodArray,
        ...processCreateParams2(params)
      });
    };
    function deepPartialify2(schema) {
      if (schema instanceof ZodObject2) {
        const newShape = {};
        for (const key in schema.shape) {
          const fieldSchema = schema.shape[key];
          newShape[key] = ZodOptional2.create(deepPartialify2(fieldSchema));
        }
        return new ZodObject2({
          ...schema._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      } else if (schema instanceof ZodArray2) {
        return new ZodArray2({
          ...schema._def,
          type: deepPartialify2(schema.element)
        });
      } else if (schema instanceof ZodOptional2) {
        return ZodOptional2.create(deepPartialify2(schema.unwrap()));
      } else if (schema instanceof ZodNullable2) {
        return ZodNullable2.create(deepPartialify2(schema.unwrap()));
      } else if (schema instanceof ZodTuple2) {
        return ZodTuple2.create(schema.items.map((item) => deepPartialify2(item)));
      } else {
        return schema;
      }
    }
    __name(deepPartialify2, "deepPartialify");
    var ZodObject2 = class _ZodObject extends ZodType2 {
      static {
        __name(this, "ZodObject");
      }
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util_js_1.util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.object,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath2(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever2) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath2(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return parseUtil_js_1.ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil_js_1.errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: /* @__PURE__ */ __name((issue, ctx) => {
              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: errorUtil_js_1.errorUtil.errToObj(message).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }, "errorMap")
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...augmentation
          }), "shape")
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }), "shape"),
          typeName: ZodFirstPartyTypeKind2.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util_js_1.util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util_js_1.util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify2(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util_js_1.util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util_js_1.util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional2) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      keyof() {
        return createZodEnum2(util_js_1.util.objectKeys(this.shape));
      }
    };
    exports.ZodObject = ZodObject2;
    ZodObject2.create = (shape, params) => {
      return new ZodObject2({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strip",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams2(params)
      });
    };
    ZodObject2.strictCreate = (shape, params) => {
      return new ZodObject2({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strict",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams2(params)
      });
    };
    ZodObject2.lazycreate = (shape, params) => {
      return new ZodObject2({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams2(params)
      });
    };
    var ZodUnion2 = class extends ZodType2 {
      static {
        __name(this, "ZodUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError_js_1.ZodError(result.ctx.common.issues));
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_js_1.INVALID;
        }
        __name(handleResults, "handleResults");
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError_js_1.ZodError(issues2));
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_js_1.INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    exports.ZodUnion = ZodUnion2;
    ZodUnion2.create = (types, params) => {
      return new ZodUnion2({
        options: types,
        typeName: ZodFirstPartyTypeKind2.ZodUnion,
        ...processCreateParams2(params)
      });
    };
    var getDiscriminator2 = /* @__PURE__ */ __name((type) => {
      if (type instanceof ZodLazy2) {
        return getDiscriminator2(type.schema);
      } else if (type instanceof ZodEffects2) {
        return getDiscriminator2(type.innerType());
      } else if (type instanceof ZodLiteral2) {
        return [type.value];
      } else if (type instanceof ZodEnum2) {
        return type.options;
      } else if (type instanceof ZodNativeEnum2) {
        return util_js_1.util.objectValues(type.enum);
      } else if (type instanceof ZodDefault2) {
        return getDiscriminator2(type._def.innerType);
      } else if (type instanceof ZodUndefined2) {
        return [void 0];
      } else if (type instanceof ZodNull2) {
        return [null];
      } else if (type instanceof ZodOptional2) {
        return [void 0, ...getDiscriminator2(type.unwrap())];
      } else if (type instanceof ZodNullable2) {
        return [null, ...getDiscriminator2(type.unwrap())];
      } else if (type instanceof ZodBranded2) {
        return getDiscriminator2(type.unwrap());
      } else if (type instanceof ZodReadonly2) {
        return getDiscriminator2(type.unwrap());
      } else if (type instanceof ZodCatch2) {
        return getDiscriminator2(type._def.innerType);
      } else {
        return [];
      }
    }, "getDiscriminator");
    var ZodDiscriminatedUnion2 = class _ZodDiscriminatedUnion extends ZodType2 {
      static {
        __name(this, "ZodDiscriminatedUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return parseUtil_js_1.INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator2(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams2(params)
        });
      }
    };
    exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion2;
    function mergeValues2(a2, b2) {
      const aType = (0, util_js_1.getParsedType)(a2);
      const bType = (0, util_js_1.getParsedType)(b2);
      if (a2 === b2) {
        return { valid: true, data: a2 };
      } else if (aType === util_js_1.ZodParsedType.object && bType === util_js_1.ZodParsedType.object) {
        const bKeys = util_js_1.util.objectKeys(b2);
        const sharedKeys = util_js_1.util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a2, ...b2 };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues2(a2[key], b2[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === util_js_1.ZodParsedType.array && bType === util_js_1.ZodParsedType.array) {
        if (a2.length !== b2.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a2.length; index++) {
          const itemA = a2[index];
          const itemB = b2[index];
          const sharedValue = mergeValues2(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === util_js_1.ZodParsedType.date && bType === util_js_1.ZodParsedType.date && +a2 === +b2) {
        return { valid: true, data: a2 };
      } else {
        return { valid: false };
      }
    }
    __name(mergeValues2, "mergeValues");
    var ZodIntersection2 = class extends ZodType2 {
      static {
        __name(this, "ZodIntersection");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
          if ((0, parseUtil_js_1.isAborted)(parsedLeft) || (0, parseUtil_js_1.isAborted)(parsedRight)) {
            return parseUtil_js_1.INVALID;
          }
          const merged = mergeValues2(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_intersection_types
            });
            return parseUtil_js_1.INVALID;
          }
          if ((0, parseUtil_js_1.isDirty)(parsedLeft) || (0, parseUtil_js_1.isDirty)(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        }, "handleParsed");
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    exports.ZodIntersection = ZodIntersection2;
    ZodIntersection2.create = (left, right, params) => {
      return new ZodIntersection2({
        left,
        right,
        typeName: ZodFirstPartyTypeKind2.ZodIntersection,
        ...processCreateParams2(params)
      });
    };
    var ZodTuple2 = class _ZodTuple extends ZodType2 {
      static {
        __name(this, "ZodTuple");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return parseUtil_js_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath2(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return parseUtil_js_1.ParseStatus.mergeArray(status, results);
          });
        } else {
          return parseUtil_js_1.ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    exports.ZodTuple = ZodTuple2;
    ZodTuple2.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple2({
        items: schemas,
        typeName: ZodFirstPartyTypeKind2.ZodTuple,
        rest: null,
        ...processCreateParams2(params)
      });
    };
    var ZodRecord2 = class _ZodRecord extends ZodType2 {
      static {
        __name(this, "ZodRecord");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath2(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return parseUtil_js_1.ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType2) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind2.ZodRecord,
            ...processCreateParams2(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString2.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind2.ZodRecord,
          ...processCreateParams2(second)
        });
      }
    };
    exports.ZodRecord = ZodRecord2;
    var ZodMap2 = class extends ZodType2 {
      static {
        __name(this, "ZodMap");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.map) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.map,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath2(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return parseUtil_js_1.INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_js_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    exports.ZodMap = ZodMap2;
    ZodMap2.create = (keyType, valueType, params) => {
      return new ZodMap2({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind2.ZodMap,
        ...processCreateParams2(params)
      });
    };
    var ZodSet2 = class _ZodSet extends ZodType2 {
      static {
        __name(this, "ZodSet");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.set) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.set,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        __name(finalizeSet, "finalizeSet");
        const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath2(ctx, item, ctx.path, i2)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports.ZodSet = ZodSet2;
    ZodSet2.create = (valueType, params) => {
      return new ZodSet2({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind2.ZodSet,
        ...processCreateParams2(params)
      });
    };
    var ZodFunction2 = class _ZodFunction extends ZodType2 {
      static {
        __name(this, "ZodFunction");
      }
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.function) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.function,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        function makeArgsIssue(args, error) {
          return (0, parseUtil_js_1.makeIssue)({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),
            issueData: {
              code: ZodError_js_1.ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        __name(makeArgsIssue, "makeArgsIssue");
        function makeReturnsIssue(returns, error) {
          return (0, parseUtil_js_1.makeIssue)({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),
            issueData: {
              code: ZodError_js_1.ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        __name(makeReturnsIssue, "makeReturnsIssue");
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise2) {
          const me = this;
          return (0, parseUtil_js_1.OK)(async function(...args) {
            const error = new ZodError_js_1.ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return (0, parseUtil_js_1.OK)(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError_js_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError_js_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple2.create(items).rest(ZodUnknown2.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
          returns: returns || ZodUnknown2.create(),
          typeName: ZodFirstPartyTypeKind2.ZodFunction,
          ...processCreateParams2(params)
        });
      }
    };
    exports.ZodFunction = ZodFunction2;
    var ZodLazy2 = class extends ZodType2 {
      static {
        __name(this, "ZodLazy");
      }
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    exports.ZodLazy = ZodLazy2;
    ZodLazy2.create = (getter, params) => {
      return new ZodLazy2({
        getter,
        typeName: ZodFirstPartyTypeKind2.ZodLazy,
        ...processCreateParams2(params)
      });
    };
    var ZodLiteral2 = class extends ZodType2 {
      static {
        __name(this, "ZodLiteral");
      }
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_js_1.ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return parseUtil_js_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    exports.ZodLiteral = ZodLiteral2;
    ZodLiteral2.create = (value, params) => {
      return new ZodLiteral2({
        value,
        typeName: ZodFirstPartyTypeKind2.ZodLiteral,
        ...processCreateParams2(params)
      });
    };
    function createZodEnum2(values, params) {
      return new ZodEnum2({
        values,
        typeName: ZodFirstPartyTypeKind2.ZodEnum,
        ...processCreateParams2(params)
      });
    }
    __name(createZodEnum2, "createZodEnum");
    var ZodEnum2 = class _ZodEnum extends ZodType2 {
      static {
        __name(this, "ZodEnum");
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            expected: util_js_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_js_1.ZodIssueCode.invalid_type
          });
          return parseUtil_js_1.INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    exports.ZodEnum = ZodEnum2;
    ZodEnum2.create = createZodEnum2;
    var ZodNativeEnum2 = class extends ZodType2 {
      static {
        __name(this, "ZodNativeEnum");
      }
      _parse(input) {
        const nativeEnumValues = util_js_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.string && ctx.parsedType !== util_js_1.ZodParsedType.number) {
          const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            expected: util_js_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_js_1.ZodIssueCode.invalid_type
          });
          return parseUtil_js_1.INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util_js_1.util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    exports.ZodNativeEnum = ZodNativeEnum2;
    ZodNativeEnum2.create = (values, params) => {
      return new ZodNativeEnum2({
        values,
        typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
        ...processCreateParams2(params)
      });
    };
    var ZodPromise2 = class extends ZodType2 {
      static {
        __name(this, "ZodPromise");
      }
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.promise && ctx.common.async === false) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.promise,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const promisified = ctx.parsedType === util_js_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_js_1.OK)(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    exports.ZodPromise = ZodPromise2;
    ZodPromise2.create = (schema, params) => {
      return new ZodPromise2({
        type: schema,
        typeName: ZodFirstPartyTypeKind2.ZodPromise,
        ...processCreateParams2(params)
      });
    };
    var ZodEffects2 = class extends ZodType2 {
      static {
        __name(this, "ZodEffects");
      }
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: /* @__PURE__ */ __name((arg) => {
            (0, parseUtil_js_1.addIssueToContext)(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          }, "addIssue"),
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return parseUtil_js_1.INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return parseUtil_js_1.INVALID;
              if (result.status === "dirty")
                return (0, parseUtil_js_1.DIRTY)(result.value);
              if (status.value === "dirty")
                return (0, parseUtil_js_1.DIRTY)(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return parseUtil_js_1.INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (result.status === "dirty")
              return (0, parseUtil_js_1.DIRTY)(result.value);
            if (status.value === "dirty")
              return (0, parseUtil_js_1.DIRTY)(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = /* @__PURE__ */ __name((acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          }, "executeRefinement");
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return parseUtil_js_1.INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!(0, parseUtil_js_1.isValid)(base))
              return parseUtil_js_1.INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!(0, parseUtil_js_1.isValid)(base))
                return parseUtil_js_1.INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util_js_1.util.assertNever(effect);
      }
    };
    exports.ZodEffects = ZodEffects2;
    exports.ZodTransformer = ZodEffects2;
    ZodEffects2.create = (schema, effect, params) => {
      return new ZodEffects2({
        schema,
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        effect,
        ...processCreateParams2(params)
      });
    };
    ZodEffects2.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects2({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        ...processCreateParams2(params)
      });
    };
    var ZodOptional2 = class extends ZodType2 {
      static {
        __name(this, "ZodOptional");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_js_1.ZodParsedType.undefined) {
          return (0, parseUtil_js_1.OK)(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodOptional = ZodOptional2;
    ZodOptional2.create = (type, params) => {
      return new ZodOptional2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodOptional,
        ...processCreateParams2(params)
      });
    };
    var ZodNullable2 = class extends ZodType2 {
      static {
        __name(this, "ZodNullable");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_js_1.ZodParsedType.null) {
          return (0, parseUtil_js_1.OK)(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodNullable = ZodNullable2;
    ZodNullable2.create = (type, params) => {
      return new ZodNullable2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodNullable,
        ...processCreateParams2(params)
      });
    };
    var ZodDefault2 = class extends ZodType2 {
      static {
        __name(this, "ZodDefault");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_js_1.ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    exports.ZodDefault = ZodDefault2;
    ZodDefault2.create = (type, params) => {
      return new ZodDefault2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams2(params)
      });
    };
    var ZodCatch2 = class extends ZodType2 {
      static {
        __name(this, "ZodCatch");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if ((0, parseUtil_js_1.isAsync)(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError_js_1.ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError_js_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    exports.ZodCatch = ZodCatch2;
    ZodCatch2.create = (type, params) => {
      return new ZodCatch2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams2(params)
      });
    };
    var ZodNaN2 = class extends ZodType2 {
      static {
        __name(this, "ZodNaN");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.nan,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    exports.ZodNaN = ZodNaN2;
    ZodNaN2.create = (params) => {
      return new ZodNaN2({
        typeName: ZodFirstPartyTypeKind2.ZodNaN,
        ...processCreateParams2(params)
      });
    };
    exports.BRAND = Symbol("zod_brand");
    var ZodBranded2 = class extends ZodType2 {
      static {
        __name(this, "ZodBranded");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    exports.ZodBranded = ZodBranded2;
    var ZodPipeline2 = class _ZodPipeline extends ZodType2 {
      static {
        __name(this, "ZodPipeline");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = /* @__PURE__ */ __name(async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return (0, parseUtil_js_1.DIRTY)(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }, "handleAsync");
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_js_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a2, b2) {
        return new _ZodPipeline({
          in: a2,
          out: b2,
          typeName: ZodFirstPartyTypeKind2.ZodPipeline
        });
      }
    };
    exports.ZodPipeline = ZodPipeline2;
    var ZodReadonly2 = class extends ZodType2 {
      static {
        __name(this, "ZodReadonly");
      }
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = /* @__PURE__ */ __name((data) => {
          if ((0, parseUtil_js_1.isValid)(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        }, "freeze");
        return (0, parseUtil_js_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodReadonly = ZodReadonly2;
    ZodReadonly2.create = (type, params) => {
      return new ZodReadonly2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodReadonly,
        ...processCreateParams2(params)
      });
    };
    function cleanParams2(params, data) {
      const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
      const p22 = typeof p2 === "string" ? { message: p2 } : p2;
      return p22;
    }
    __name(cleanParams2, "cleanParams");
    function custom2(check, _params = {}, fatal) {
      if (check)
        return ZodAny2.create().superRefine((data, ctx) => {
          const r2 = check(data);
          if (r2 instanceof Promise) {
            return r2.then((r3) => {
              if (!r3) {
                const params = cleanParams2(_params, data);
                const _fatal = params.fatal ?? fatal ?? true;
                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
              }
            });
          }
          if (!r2) {
            const params = cleanParams2(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
          return;
        });
      return ZodAny2.create();
    }
    __name(custom2, "custom");
    exports.late = {
      object: ZodObject2.lazycreate
    };
    var ZodFirstPartyTypeKind2;
    (function(ZodFirstPartyTypeKind3) {
      ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind2 || (exports.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind2 = {}));
    var instanceOfType2 = /* @__PURE__ */ __name((cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom2((data) => data instanceof cls, params), "instanceOfType");
    exports.instanceof = instanceOfType2;
    var stringType2 = ZodString2.create;
    exports.string = stringType2;
    var numberType2 = ZodNumber2.create;
    exports.number = numberType2;
    var nanType2 = ZodNaN2.create;
    exports.nan = nanType2;
    var bigIntType2 = ZodBigInt2.create;
    exports.bigint = bigIntType2;
    var booleanType2 = ZodBoolean2.create;
    exports.boolean = booleanType2;
    var dateType2 = ZodDate2.create;
    exports.date = dateType2;
    var symbolType2 = ZodSymbol2.create;
    exports.symbol = symbolType2;
    var undefinedType2 = ZodUndefined2.create;
    exports.undefined = undefinedType2;
    var nullType2 = ZodNull2.create;
    exports.null = nullType2;
    var anyType2 = ZodAny2.create;
    exports.any = anyType2;
    var unknownType2 = ZodUnknown2.create;
    exports.unknown = unknownType2;
    var neverType2 = ZodNever2.create;
    exports.never = neverType2;
    var voidType2 = ZodVoid2.create;
    exports.void = voidType2;
    var arrayType2 = ZodArray2.create;
    exports.array = arrayType2;
    var objectType2 = ZodObject2.create;
    exports.object = objectType2;
    var strictObjectType2 = ZodObject2.strictCreate;
    exports.strictObject = strictObjectType2;
    var unionType2 = ZodUnion2.create;
    exports.union = unionType2;
    var discriminatedUnionType2 = ZodDiscriminatedUnion2.create;
    exports.discriminatedUnion = discriminatedUnionType2;
    var intersectionType2 = ZodIntersection2.create;
    exports.intersection = intersectionType2;
    var tupleType2 = ZodTuple2.create;
    exports.tuple = tupleType2;
    var recordType2 = ZodRecord2.create;
    exports.record = recordType2;
    var mapType2 = ZodMap2.create;
    exports.map = mapType2;
    var setType2 = ZodSet2.create;
    exports.set = setType2;
    var functionType2 = ZodFunction2.create;
    exports.function = functionType2;
    var lazyType2 = ZodLazy2.create;
    exports.lazy = lazyType2;
    var literalType2 = ZodLiteral2.create;
    exports.literal = literalType2;
    var enumType2 = ZodEnum2.create;
    exports.enum = enumType2;
    var nativeEnumType2 = ZodNativeEnum2.create;
    exports.nativeEnum = nativeEnumType2;
    var promiseType2 = ZodPromise2.create;
    exports.promise = promiseType2;
    var effectsType2 = ZodEffects2.create;
    exports.effect = effectsType2;
    exports.transformer = effectsType2;
    var optionalType2 = ZodOptional2.create;
    exports.optional = optionalType2;
    var nullableType2 = ZodNullable2.create;
    exports.nullable = nullableType2;
    var preprocessType2 = ZodEffects2.createWithPreprocess;
    exports.preprocess = preprocessType2;
    var pipelineType2 = ZodPipeline2.create;
    exports.pipeline = pipelineType2;
    var ostring2 = /* @__PURE__ */ __name(() => stringType2().optional(), "ostring");
    exports.ostring = ostring2;
    var onumber2 = /* @__PURE__ */ __name(() => numberType2().optional(), "onumber");
    exports.onumber = onumber2;
    var oboolean2 = /* @__PURE__ */ __name(() => booleanType2().optional(), "oboolean");
    exports.oboolean = oboolean2;
    exports.coerce = {
      string: /* @__PURE__ */ __name((arg) => ZodString2.create({ ...arg, coerce: true }), "string"),
      number: /* @__PURE__ */ __name((arg) => ZodNumber2.create({ ...arg, coerce: true }), "number"),
      boolean: /* @__PURE__ */ __name((arg) => ZodBoolean2.create({
        ...arg,
        coerce: true
      }), "boolean"),
      bigint: /* @__PURE__ */ __name((arg) => ZodBigInt2.create({ ...arg, coerce: true }), "bigint"),
      date: /* @__PURE__ */ __name((arg) => ZodDate2.create({ ...arg, coerce: true }), "date")
    };
    exports.NEVER = parseUtil_js_1.INVALID;
  }
});

// node_modules/zod/v3/external.cjs
var require_external = __commonJS({
  "node_modules/zod/v3/external.cjs"(exports) {
    "use strict";
    init_esm();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m2[k];
        }, "get") };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m2[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors(), exports);
    __exportStar(require_parseUtil(), exports);
    __exportStar(require_typeAliases(), exports);
    __exportStar(require_util(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_ZodError(), exports);
  }
});

// node_modules/zod/index.cjs
var require_zod = __commonJS({
  "node_modules/zod/index.cjs"(exports) {
    "use strict";
    init_esm();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m2[k];
        }, "get") };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.z = void 0;
    var z = __importStar(require_external());
    exports.z = z;
    __exportStar(require_external(), exports);
    exports.default = z;
  }
});

// node_modules/zod-validation-error/dist/cjs/utils/joinPath.js
var require_joinPath = __commonJS({
  "node_modules/zod-validation-error/dist/cjs/utils/joinPath.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPath = void 0;
    var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
    function joinPath(path) {
      if (path.length === 1) {
        return path[0].toString();
      }
      return path.reduce((acc, item) => {
        if (typeof item === "number") {
          return acc + "[" + item.toString() + "]";
        }
        if (item.includes('"')) {
          return acc + '["' + escapeQuotes(item) + '"]';
        }
        if (!identifierRegex.test(item)) {
          return acc + '["' + item + '"]';
        }
        const separator = acc.length === 0 ? "" : ".";
        return acc + separator + item;
      }, "");
    }
    __name(joinPath, "joinPath");
    exports.joinPath = joinPath;
    function escapeQuotes(str) {
      return str.replace(/"/g, '\\"');
    }
    __name(escapeQuotes, "escapeQuotes");
  }
});

// node_modules/zod-validation-error/dist/cjs/utils/NonEmptyArray.js
var require_NonEmptyArray = __commonJS({
  "node_modules/zod-validation-error/dist/cjs/utils/NonEmptyArray.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNonEmptyArray = void 0;
    function isNonEmptyArray(value) {
      return value.length !== 0;
    }
    __name(isNonEmptyArray, "isNonEmptyArray");
    exports.isNonEmptyArray = isNonEmptyArray;
  }
});

// node_modules/zod-validation-error/dist/cjs/ValidationError.js
var require_ValidationError = __commonJS({
  "node_modules/zod-validation-error/dist/cjs/ValidationError.js"(exports) {
    "use strict";
    init_esm();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m2[k];
        }, "get") };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorMap = exports.isValidationErrorLike = exports.isValidationError = exports.toValidationError = exports.fromZodError = exports.fromZodIssue = exports.ValidationError = void 0;
    var zod = __importStar(require_zod());
    var joinPath_1 = require_joinPath();
    var NonEmptyArray_1 = require_NonEmptyArray();
    var MAX_ISSUES_IN_MESSAGE = 99;
    var ISSUE_SEPARATOR = "; ";
    var UNION_SEPARATOR = ", or ";
    var PREFIX = "Validation error";
    var PREFIX_SEPARATOR = ": ";
    var ValidationError2 = class extends Error {
      static {
        __name(this, "ValidationError");
      }
      details;
      name;
      constructor(message, details = []) {
        super(message);
        this.details = details;
        this.name = "ZodValidationError";
      }
      toString() {
        return this.message;
      }
    };
    exports.ValidationError = ValidationError2;
    function getMessageFromZodIssue(issue, issueSeparator, unionSeparator) {
      if (issue.code === "invalid_union") {
        return issue.unionErrors.reduce((acc, zodError) => {
          const newIssues = zodError.issues.map((issue2) => getMessageFromZodIssue(issue2, issueSeparator, unionSeparator)).join(issueSeparator);
          if (!acc.includes(newIssues)) {
            acc.push(newIssues);
          }
          return acc;
        }, []).join(unionSeparator);
      }
      if ((0, NonEmptyArray_1.isNonEmptyArray)(issue.path)) {
        if (issue.path.length === 1) {
          const identifier = issue.path[0];
          if (typeof identifier === "number") {
            return `${issue.message} at index ${identifier}`;
          }
        }
        return `${issue.message} at "${(0, joinPath_1.joinPath)(issue.path)}"`;
      }
      return issue.message;
    }
    __name(getMessageFromZodIssue, "getMessageFromZodIssue");
    function conditionallyPrefixMessage(reason, prefix, prefixSeparator) {
      if (prefix !== null) {
        if (reason.length > 0) {
          return [prefix, reason].join(prefixSeparator);
        }
        return prefix;
      }
      if (reason.length > 0) {
        return reason;
      }
      return PREFIX;
    }
    __name(conditionallyPrefixMessage, "conditionallyPrefixMessage");
    function fromZodIssue(issue, options = {}) {
      const { issueSeparator = ISSUE_SEPARATOR, unionSeparator = UNION_SEPARATOR, prefixSeparator = PREFIX_SEPARATOR, prefix = PREFIX } = options;
      const reason = getMessageFromZodIssue(issue, issueSeparator, unionSeparator);
      const message = conditionallyPrefixMessage(reason, prefix, prefixSeparator);
      return new ValidationError2(message, [issue]);
    }
    __name(fromZodIssue, "fromZodIssue");
    exports.fromZodIssue = fromZodIssue;
    function fromZodError2(zodError, options = {}) {
      const { maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE, issueSeparator = ISSUE_SEPARATOR, unionSeparator = UNION_SEPARATOR, prefixSeparator = PREFIX_SEPARATOR, prefix = PREFIX } = options;
      const reason = zodError.errors.slice(0, maxIssuesInMessage).map((issue) => getMessageFromZodIssue(issue, issueSeparator, unionSeparator)).join(issueSeparator);
      const message = conditionallyPrefixMessage(reason, prefix, prefixSeparator);
      return new ValidationError2(message, zodError.errors);
    }
    __name(fromZodError2, "fromZodError");
    exports.fromZodError = fromZodError2;
    var toValidationError = /* @__PURE__ */ __name((options = {}) => (err) => {
      if (err instanceof zod.ZodError) {
        return fromZodError2(err, options);
      }
      if (err instanceof Error) {
        return err;
      }
      return new Error("Unknown error");
    }, "toValidationError");
    exports.toValidationError = toValidationError;
    function isValidationError(err) {
      return err instanceof ValidationError2;
    }
    __name(isValidationError, "isValidationError");
    exports.isValidationError = isValidationError;
    function isValidationErrorLike(err) {
      return err instanceof Error && err.name === "ZodValidationError";
    }
    __name(isValidationErrorLike, "isValidationErrorLike");
    exports.isValidationErrorLike = isValidationErrorLike;
    var errorMap2 = /* @__PURE__ */ __name((issue, ctx) => {
      const error = fromZodIssue({
        ...issue,
        message: issue.message ?? ctx.defaultError
      });
      return {
        message: error.message
      };
    }, "errorMap");
    exports.errorMap = errorMap2;
  }
});

// node_modules/zod-validation-error/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/zod-validation-error/dist/cjs/index.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorMap = exports.fromZodIssue = exports.fromZodError = exports.isValidationErrorLike = exports.isValidationError = exports.toValidationError = exports.ValidationError = void 0;
    var ValidationError_1 = require_ValidationError();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ValidationError_1.ValidationError;
    }, "get") });
    Object.defineProperty(exports, "toValidationError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ValidationError_1.toValidationError;
    }, "get") });
    Object.defineProperty(exports, "isValidationError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ValidationError_1.isValidationError;
    }, "get") });
    Object.defineProperty(exports, "isValidationErrorLike", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ValidationError_1.isValidationErrorLike;
    }, "get") });
    Object.defineProperty(exports, "fromZodError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ValidationError_1.fromZodError;
    }, "get") });
    Object.defineProperty(exports, "fromZodIssue", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ValidationError_1.fromZodIssue;
    }, "get") });
    Object.defineProperty(exports, "errorMap", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ValidationError_1.errorMap;
    }, "get") });
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis2;
var init_globalThis = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    init_esm();
    _globalThis2 = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/index.js
var init_node = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    init_esm();
    init_globalThis();
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/index.js
var init_platform = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    init_esm();
    init_node();
  }
});

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION2;
var init_version = __esm({
  "node_modules/@opentelemetry/api/build/esm/version.js"() {
    init_esm();
    VERSION2 = "1.9.0";
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return /* @__PURE__ */ __name(function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    }, "isExactmatch");
  }
  function _reject(v2) {
    rejectedVersions.add(v2);
    return false;
  }
  __name(_reject, "_reject");
  function _accept(v2) {
    acceptedVersions.add(v2);
    return true;
  }
  __name(_accept, "_accept");
  return /* @__PURE__ */ __name(function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  }, "isCompatible");
}
var re, isCompatible;
var init_semver = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    init_esm();
    init_version();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    __name(_makeCompatibilityCheck, "_makeCompatibilityCheck");
    isCompatible = _makeCompatibilityCheck(VERSION2);
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal2(type, instance, diag3, allowOverride) {
  var _a;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global2[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global2[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION2
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION2) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION2);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION2 + ".");
  return true;
}
function getGlobal2(type) {
  var _a, _b;
  var globalVersion = (_a = _global2[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global2[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal2(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION2 + ".");
  var api = _global2[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global2;
var init_global_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    init_esm();
    init_platform();
    init_version();
    init_semver();
    major = VERSION2.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global2 = _globalThis2;
    __name(registerGlobal2, "registerGlobal");
    __name(getGlobal2, "getGlobal");
    __name(unregisterGlobal2, "unregisterGlobal");
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args) {
  var logger2 = getGlobal2("diag");
  if (!logger2) {
    return;
  }
  args.unshift(namespace);
  return logger2[funcName].apply(logger2, __spreadArray([], __read(args), false));
}
var __read, __spreadArray, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    init_esm();
    init_global_utils();
    __read = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2) return o2;
      var i2 = m2.call(o2), r2, ar = [], e;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
        if (ar || !(i2 in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
          ar[i2] = from[i2];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    DiagComponentLogger = /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      __name(DiagComponentLogger2, "DiagComponentLogger");
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }();
    __name(logProxy, "logProxy");
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    init_esm();
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger2) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger2 = logger2 || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger2[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger2);
    }
    return function() {
    };
  }
  __name(_filterFunc, "_filterFunc");
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    init_esm();
    init_types();
    __name(createLogLevelDiagLogger, "createLogLevelDiagLogger");
  }
});

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME2, DiagAPI;
var init_diag = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    init_esm();
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2) return o2;
      var i2 = m2.call(o2), r2, ar = [], e;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
        if (ar || !(i2 in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
          ar[i2] = from[i2];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME2 = "diag";
    DiagAPI = /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger2 = getGlobal2("diag");
            if (!logger2)
              return;
            return logger2[funcName].apply(logger2, __spreadArray2([], __read2(args), false));
          };
        }
        __name(_logProxy, "_logProxy");
        var self = this;
        var setLogger = /* @__PURE__ */ __name(function(logger2, optionsOrLogLevel) {
          var _a, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger2 === self) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal2("diag");
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger2);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal2("diag", newLogger, self, true);
        }, "setLogger");
        self.setLogger = setLogger;
        self.disable = function() {
          unregisterGlobal2(API_NAME2, self);
        };
        self.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
      }
      __name(DiagAPI2, "DiagAPI");
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3, __values, BaggageImpl;
var init_baggage_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    init_esm();
    __read3 = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2) return o2;
      var i2 = m2.call(o2), r2, ar = [], e;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __values = function(o2) {
      var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o2[s], i2 = 0;
      if (m2) return m2.call(o2);
      if (o2 && typeof o2.length === "number") return {
        next: /* @__PURE__ */ __name(function() {
          if (o2 && i2 >= o2.length) o2 = void 0;
          return { value: o2 && o2[i2++], done: !o2 };
        }, "next")
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    BaggageImpl = /** @class */
    function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      __name(BaggageImpl2, "BaggageImpl");
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a) {
          var _b = __read3(_a, 2), k = _b[0], v2 = _b[1];
          return [k, v2];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol;
var init_symbol = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    init_esm();
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/utils.js
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
function baggageEntryMetadataFromString(str) {
  if (typeof str !== "string") {
    diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
    str = "";
  }
  return {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: /* @__PURE__ */ __name(function() {
      return str;
    }, "toString")
  };
}
var diag;
var init_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    init_esm();
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
    __name(createBaggage, "createBaggage");
    __name(baggageEntryMetadataFromString, "baggageEntryMetadataFromString");
  }
});

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    init_esm();
    __name(createContextKey, "createContextKey");
    BaseContext = /** @class */
    /* @__PURE__ */ function() {
      function BaseContext2(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
          return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
          var context2 = new BaseContext2(self._currentContext);
          context2._currentContext.set(key, value);
          return context2;
        };
        self.deleteValue = function(key) {
          var context2 = new BaseContext2(self._currentContext);
          context2._currentContext.delete(key);
          return context2;
        };
      }
      __name(BaseContext2, "BaseContext");
      return BaseContext2;
    }();
    ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
var consoleMap, DiagConsoleLogger;
var init_consoleLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js"() {
    init_esm();
    consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    DiagConsoleLogger = /** @class */
    /* @__PURE__ */ function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        __name(_consoleFunc, "_consoleFunc");
        for (var i2 = 0; i2 < consoleMap.length; i2++) {
          this[consoleMap[i2].n] = _consoleFunc(consoleMap[i2].c);
        }
      }
      __name(DiagConsoleLogger2, "DiagConsoleLogger");
      return DiagConsoleLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
function createNoopMeter() {
  return NOOP_METER;
}
var __extends, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopGaugeMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_GAUGE_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
var init_NoopMeter = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    init_esm();
    __extends = /* @__PURE__ */ function() {
      var extendStatics = /* @__PURE__ */ __name(function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      }, "extendStatics");
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        __name(__, "__");
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    NoopMeter = /** @class */
    function() {
      function NoopMeter2() {
      }
      __name(NoopMeter2, "NoopMeter");
      NoopMeter2.prototype.createGauge = function(_name, _options) {
        return NOOP_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      };
      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      };
      return NoopMeter2;
    }();
    NoopMetric = /** @class */
    /* @__PURE__ */ function() {
      function NoopMetric2() {
      }
      __name(NoopMetric2, "NoopMetric");
      return NoopMetric2;
    }();
    NoopCounterMetric = /** @class */
    function(_super) {
      __extends(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopCounterMetric2, "NoopCounterMetric");
      NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopCounterMetric2;
    }(NoopMetric);
    NoopUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopUpDownCounterMetric2, "NoopUpDownCounterMetric");
      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopUpDownCounterMetric2;
    }(NoopMetric);
    NoopGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopGaugeMetric2, _super);
      function NoopGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopGaugeMetric2, "NoopGaugeMetric");
      NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopGaugeMetric2;
    }(NoopMetric);
    NoopHistogramMetric = /** @class */
    function(_super) {
      __extends(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopHistogramMetric2, "NoopHistogramMetric");
      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopHistogramMetric2;
    }(NoopMetric);
    NoopObservableMetric = /** @class */
    function() {
      function NoopObservableMetric2() {
      }
      __name(NoopObservableMetric2, "NoopObservableMetric");
      NoopObservableMetric2.prototype.addCallback = function(_callback) {
      };
      NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      };
      return NoopObservableMetric2;
    }();
    NoopObservableCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopObservableCounterMetric2, "NoopObservableCounterMetric");
      return NoopObservableCounterMetric2;
    }(NoopObservableMetric);
    NoopObservableGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopObservableGaugeMetric2, "NoopObservableGaugeMetric");
      return NoopObservableGaugeMetric2;
    }(NoopObservableMetric);
    NoopObservableUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(NoopObservableUpDownCounterMetric2, "NoopObservableUpDownCounterMetric");
      return NoopObservableUpDownCounterMetric2;
    }(NoopObservableMetric);
    NOOP_METER = new NoopMeter();
    NOOP_COUNTER_METRIC = new NoopCounterMetric();
    NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
    __name(createNoopMeter, "createNoopMeter");
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType;
var init_Metric = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/Metric.js"() {
    init_esm();
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter, defaultTextMapSetter;
var init_TextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    init_esm();
    defaultTextMapGetter = {
      get: /* @__PURE__ */ __name(function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      }, "get"),
      keys: /* @__PURE__ */ __name(function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }, "keys")
    };
    defaultTextMapSetter = {
      set: /* @__PURE__ */ __name(function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }, "set")
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4, __spreadArray3, NoopContextManager;
var init_NoopContextManager = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    init_esm();
    init_context();
    __read4 = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2) return o2;
      var i2 = m2.call(o2), r2, ar = [], e;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
        if (ar || !(i2 in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
          ar[i2] = from[i2];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    NoopContextManager = /** @class */
    function() {
      function NoopContextManager2() {
      }
      __name(NoopContextManager2, "NoopContextManager");
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5, __spreadArray4, API_NAME3, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    init_esm();
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read5 = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2) return o2;
      var i2 = m2.call(o2), r2, ar = [], e;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
        if (ar || !(i2 in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
          ar[i2] = from[i2];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME3 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    function() {
      function ContextAPI2() {
      }
      __name(ContextAPI2, "ContextAPI");
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal2(API_NAME3, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context2, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray4([context2, fn, thisArg], __read5(args), false));
      };
      ContextAPI2.prototype.bind = function(context2, target) {
        return this._getContextManager().bind(context2, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal2(API_NAME3) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal2(API_NAME3, DiagAPI.instance());
      };
      return ContextAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    init_esm();
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    init_esm();
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    init_esm();
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      __name(NonRecordingSpan2, "NonRecordingSpan");
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status2) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a;
  return (_a = getSpan(context2)) === null || _a === void 0 ? void 0 : _a.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    init_esm();
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
    __name(getSpan, "getSpan");
    __name(getActiveSpan, "getActiveSpan");
    __name(setSpan, "setSpan");
    __name(deleteSpan, "deleteSpan");
    __name(setSpanContext, "setSpanContext");
    __name(getSpanContext, "getSpanContext");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    init_esm();
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
    __name(isValidTraceId, "isValidTraceId");
    __name(isValidSpanId, "isValidSpanId");
    __name(isSpanContextValid, "isSpanContextValid");
    __name(wrapSpanContext, "wrapSpanContext");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    init_esm();
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    function() {
      function NoopTracer2() {
      }
      __name(NoopTracer2, "NoopTracer");
      NoopTracer2.prototype.startSpan = function(name2, options, context2) {
        if (context2 === void 0) {
          context2 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context2 && getSpanContext(context2);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name2, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name2, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }();
    __name(isSpanContext, "isSpanContext");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    init_esm();
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    function() {
      function ProxyTracer2(_provider, name2, version, options) {
        this._provider = _provider;
        this.name = name2;
        this.version = version;
        this.options = options;
      }
      __name(ProxyTracer2, "ProxyTracer");
      ProxyTracer2.prototype.startSpan = function(name2, options, context2) {
        return this._getTracer().startSpan(name2, options, context2);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer2 = this._getTracer();
        return Reflect.apply(tracer2.startActiveSpan, tracer2, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer2 = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer2) {
          return NOOP_TRACER;
        }
        this._delegate = tracer2;
        return this._delegate;
      };
      return ProxyTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    init_esm();
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      __name(NoopTracerProvider2, "NoopTracerProvider");
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    init_esm();
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      __name(ProxyTracerProvider2, "ProxyTracerProvider");
      ProxyTracerProvider2.prototype.getTracer = function(name2, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name2, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name2, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name2, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name2, version, options);
      };
      return ProxyTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
var init_SamplingResult = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    init_esm();
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
var init_span_kind = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    init_esm();
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    init_esm();
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX;
var init_tracestate_validators = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js"() {
    init_esm();
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    __name(validateKey, "validateKey");
    __name(validateValue, "validateValue");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceStateImpl;
var init_tracestate_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js"() {
    init_esm();
    init_tracestate_validators();
    MAX_TRACE_STATE_ITEMS = 32;
    MAX_TRACE_STATE_LEN = 512;
    LIST_MEMBERS_SEPARATOR = ",";
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    TraceStateImpl = /** @class */
    function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      __name(TraceStateImpl2, "TraceStateImpl");
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i2 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i2 !== -1) {
            var key = listMember.slice(0, i2);
            var value = listMember.slice(i2 + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js
function createTraceState(rawTraceState) {
  return new TraceStateImpl(rawTraceState);
}
var init_utils2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js"() {
    init_esm();
    init_tracestate_impl();
    __name(createTraceState, "createTraceState");
  }
});

// node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    init_esm();
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2;
var init_diag_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    init_esm();
    init_diag();
    diag2 = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider, NOOP_METER_PROVIDER;
var init_NoopMeterProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    init_esm();
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    function() {
      function NoopMeterProvider2() {
      }
      __name(NoopMeterProvider2, "NoopMeterProvider");
      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider2;
    }();
    NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME4, MetricsAPI;
var init_metrics = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    init_esm();
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME4 = "metrics";
    MetricsAPI = /** @class */
    function() {
      function MetricsAPI2() {
      }
      __name(MetricsAPI2, "MetricsAPI");
      MetricsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new MetricsAPI2();
        }
        return this._instance;
      };
      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal2(API_NAME4, provider, DiagAPI.instance());
      };
      MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal2(API_NAME4) || NOOP_METER_PROVIDER;
      };
      MetricsAPI2.prototype.getMeter = function(name2, version, options) {
        return this.getMeterProvider().getMeter(name2, version, options);
      };
      MetricsAPI2.prototype.disable = function() {
        unregisterGlobal2(API_NAME4, DiagAPI.instance());
      };
      return MetricsAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics;
var init_metrics_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    init_esm();
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator;
var init_NoopTextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    init_esm();
    NoopTextMapPropagator = /** @class */
    function() {
      function NoopTextMapPropagator2() {
      }
      __name(NoopTextMapPropagator2, "NoopTextMapPropagator");
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context2, _carrier) {
        return context2;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
function getBaggage(context2) {
  return context2.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context2, baggage) {
  return context2.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context2) {
  return context2.deleteValue(BAGGAGE_KEY);
}
var BAGGAGE_KEY;
var init_context_helpers = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    init_esm();
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
    __name(getBaggage, "getBaggage");
    __name(getActiveBaggage, "getActiveBaggage");
    __name(setBaggage, "setBaggage");
    __name(deleteBaggage, "deleteBaggage");
  }
});

// node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME5, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI;
var init_propagation = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    init_esm();
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils();
    init_diag();
    API_NAME5 = "propagation";
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    PropagationAPI = /** @class */
    function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      __name(PropagationAPI2, "PropagationAPI");
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal2(API_NAME5, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context2, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context2, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context2, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context2, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal2(API_NAME5, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal2(API_NAME5) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation;
var init_propagation_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    init_esm();
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME6, TraceAPI;
var init_trace = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    init_esm();
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME6 = "trace";
    TraceAPI = /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      __name(TraceAPI2, "TraceAPI");
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal2(API_NAME6, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal2(API_NAME6) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name2, version) {
        return this.getTracerProvider().getTracer(name2, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal2(API_NAME6, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    init_esm();
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DiagConsoleLogger: () => DiagConsoleLogger,
  DiagLogLevel: () => DiagLogLevel,
  INVALID_SPANID: () => INVALID_SPANID,
  INVALID_SPAN_CONTEXT: () => INVALID_SPAN_CONTEXT,
  INVALID_TRACEID: () => INVALID_TRACEID,
  ProxyTracer: () => ProxyTracer,
  ProxyTracerProvider: () => ProxyTracerProvider,
  ROOT_CONTEXT: () => ROOT_CONTEXT,
  SamplingDecision: () => SamplingDecision,
  SpanKind: () => SpanKind,
  SpanStatusCode: () => SpanStatusCode,
  TraceFlags: () => TraceFlags,
  ValueType: () => ValueType,
  baggageEntryMetadataFromString: () => baggageEntryMetadataFromString,
  context: () => context,
  createContextKey: () => createContextKey,
  createNoopMeter: () => createNoopMeter,
  createTraceState: () => createTraceState,
  default: () => esm_default,
  defaultTextMapGetter: () => defaultTextMapGetter,
  defaultTextMapSetter: () => defaultTextMapSetter,
  diag: () => diag2,
  isSpanContextValid: () => isSpanContextValid,
  isValidSpanId: () => isValidSpanId,
  isValidTraceId: () => isValidTraceId,
  metrics: () => metrics,
  propagation: () => propagation,
  trace: () => trace
});
var esm_default;
var init_esm2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/index.js"() {
    init_esm();
    init_utils();
    init_context();
    init_consoleLogger();
    init_types();
    init_NoopMeter();
    init_Metric();
    init_TextMapPropagator();
    init_ProxyTracer();
    init_ProxyTracerProvider();
    init_SamplingResult();
    init_span_kind();
    init_status();
    init_trace_flags();
    init_utils2();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
    esm_default = {
      context,
      diag: diag2,
      metrics,
      propagation,
      trace
    };
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = void 0;
    var api_1 = (init_esm2(), __toCommonJS(esm_exports));
    var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing2(context2) {
      return context2.setValue(SUPPRESS_TRACING_KEY, true);
    }
    __name(suppressTracing2, "suppressTracing");
    exports.suppressTracing = suppressTracing2;
    function unsuppressTracing(context2) {
      return context2.deleteValue(SUPPRESS_TRACING_KEY);
    }
    __name(unsuppressTracing, "unsuppressTracing");
    exports.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context2) {
      return context2.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    __name(isTracingSuppressed, "isTracingSuppressed");
    exports.isTracingSuppressed = isTracingSuppressed;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports.BAGGAGE_HEADER = "baggage";
    exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = void 0;
    var api_1 = (init_esm2(), __toCommonJS(esm_exports));
    var constants_1 = require_constants();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    __name(serializeKeyPairs, "serializeKeyPairs");
    exports.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        if (value.metadata !== void 0) {
          entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    __name(getKeyPairs, "getKeyPairs");
    exports.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      const keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      let metadata2;
      if (valueProps.length > 0) {
        metadata2 = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata: metadata2 };
    }
    __name(parsePairKeyValue, "parsePairKeyValue");
    exports.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      const result = {};
      if (typeof value === "string" && value.length > 0) {
        value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).forEach((entry) => {
          const keyPair = parsePairKeyValue(entry);
          if (keyPair !== void 0 && keyPair.value.length > 0) {
            result[keyPair.key] = keyPair.value;
          }
        });
      }
      return result;
    }
    __name(parseKeyPairsIntoRecord, "parseKeyPairsIntoRecord");
    exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CBaggagePropagator = void 0;
    var api_1 = (init_esm2(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    var constants_1 = require_constants();
    var utils_1 = require_utils();
    var W3CBaggagePropagator = class {
      static {
        __name(this, "W3CBaggagePropagator");
      }
      inject(context2, carrier, setter) {
        const baggage = api_1.propagation.getBaggage(context2);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context2))
          return;
        const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
          return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
        }
      }
      extract(context2, carrier, getter) {
        const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context2;
        const baggage = {};
        if (baggageString.length === 0) {
          return context2;
        }
        const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach((entry) => {
          const keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            const baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context2;
        }
        return api_1.propagation.setBaggage(context2, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnchoredClock = void 0;
    var AnchoredClock = class {
      static {
        __name(this, "AnchoredClock");
      }
      _monotonicClock;
      _epochMillis;
      _performanceMillis;
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        const delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports.AnchoredClock = AnchoredClock;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = void 0;
    var api_1 = (init_esm2(), __toCommonJS(esm_exports));
    function sanitizeAttributes(attributes) {
      const out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        if (Array.isArray(val)) {
          out[key] = val.slice();
        } else {
          out[key] = val;
        }
      }
      return out;
    }
    __name(sanitizeAttributes, "sanitizeAttributes");
    exports.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    __name(isAttributeKey, "isAttributeKey");
    exports.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    __name(isAttributeValue, "isAttributeValue");
    exports.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (const element of arr) {
        if (element == null)
          continue;
        if (!type) {
          if (isValidPrimitiveAttributeValue(element)) {
            type = typeof element;
            continue;
          }
          return false;
        }
        if (typeof element === type) {
          continue;
        }
        return false;
      }
      return true;
    }
    __name(isHomogeneousAttributeValueArray, "isHomogeneousAttributeValueArray");
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
    __name(isValidPrimitiveAttributeValue, "isValidPrimitiveAttributeValue");
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loggingErrorHandler = void 0;
    var api_1 = (init_esm2(), __toCommonJS(esm_exports));
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    __name(loggingErrorHandler, "loggingErrorHandler");
    exports.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    __name(stringifyException, "stringifyException");
    function flattenException(ex) {
      const result = {};
      let current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result[propertyName])
            return;
          const value = current[propertyName];
          if (value) {
            result[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result;
    }
    __name(flattenException, "flattenException");
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.globalErrorHandler = exports.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler();
    var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    __name(setGlobalErrorHandler, "setGlobalErrorHandler");
    exports.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch {
      }
    }
    __name(globalErrorHandler, "globalErrorHandler");
    exports.globalErrorHandler = globalErrorHandler;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStringListFromEnv = exports.getBooleanFromEnv = exports.getStringFromEnv = exports.getNumberFromEnv = void 0;
    var api_1 = (init_esm2(), __toCommonJS(esm_exports));
    var util_1 = __require("util");
    function getNumberFromEnv(key) {
      const raw2 = process.env[key];
      if (raw2 == null || raw2.trim() === "") {
        return void 0;
      }
      const value = Number(raw2);
      if (isNaN(value)) {
        api_1.diag.warn(`Unknown value ${(0, util_1.inspect)(raw2)} for ${key}, expected a number, using defaults`);
        return void 0;
      }
      return value;
    }
    __name(getNumberFromEnv, "getNumberFromEnv");
    exports.getNumberFromEnv = getNumberFromEnv;
    function getStringFromEnv(key) {
      const raw2 = process.env[key];
      if (raw2 == null || raw2.trim() === "") {
        return void 0;
      }
      return raw2;
    }
    __name(getStringFromEnv, "getStringFromEnv");
    exports.getStringFromEnv = getStringFromEnv;
    function getBooleanFromEnv(key) {
      const raw2 = process.env[key]?.trim().toLowerCase();
      if (raw2 == null || raw2 === "") {
        return false;
      }
      if (raw2 === "true") {
        return true;
      } else if (raw2 === "false") {
        return false;
      } else {
        api_1.diag.warn(`Unknown value ${(0, util_1.inspect)(raw2)} for ${key}, expected 'true' or 'false', falling back to 'false' (default)`);
        return false;
      }
    }
    __name(getBooleanFromEnv, "getBooleanFromEnv");
    exports.getBooleanFromEnv = getBooleanFromEnv;
    function getStringListFromEnv(key) {
      return getStringFromEnv(key)?.split(",").map((v2) => v2.trim()).filter((s) => s !== "");
    }
    __name(getStringListFromEnv, "getStringListFromEnv");
    exports.getStringListFromEnv = getStringListFromEnv;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.otperformance = void 0;
    var perf_hooks_1 = __require("perf_hooks");
    exports.otperformance = perf_hooks_1.performance;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/version.js
var require_version = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/version.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "2.0.1";
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js
// @__NO_SIDE_EFFECTS__
function createConstMap(values) {
  let res = {};
  const len = values.length;
  for (let lp = 0; lp < len; lp++) {
    const val = values[lp];
    if (val) {
      res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
    }
  }
  return res;
}
var init_utils3 = __esm({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js"() {
    init_esm();
    __name(createConstMap, "createConstMap");
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_AWS_LAMBDA_INVOKED_ARN, TMP_DB_SYSTEM, TMP_DB_CONNECTION_STRING, TMP_DB_USER, TMP_DB_JDBC_DRIVER_CLASSNAME, TMP_DB_NAME, TMP_DB_STATEMENT, TMP_DB_OPERATION, TMP_DB_MSSQL_INSTANCE_NAME, TMP_DB_CASSANDRA_KEYSPACE, TMP_DB_CASSANDRA_PAGE_SIZE, TMP_DB_CASSANDRA_CONSISTENCY_LEVEL, TMP_DB_CASSANDRA_TABLE, TMP_DB_CASSANDRA_IDEMPOTENCE, TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, TMP_DB_CASSANDRA_COORDINATOR_ID, TMP_DB_CASSANDRA_COORDINATOR_DC, TMP_DB_HBASE_NAMESPACE, TMP_DB_REDIS_DATABASE_INDEX, TMP_DB_MONGODB_COLLECTION, TMP_DB_SQL_TABLE, TMP_EXCEPTION_TYPE, TMP_EXCEPTION_MESSAGE, TMP_EXCEPTION_STACKTRACE, TMP_EXCEPTION_ESCAPED, TMP_FAAS_TRIGGER, TMP_FAAS_EXECUTION, TMP_FAAS_DOCUMENT_COLLECTION, TMP_FAAS_DOCUMENT_OPERATION, TMP_FAAS_DOCUMENT_TIME, TMP_FAAS_DOCUMENT_NAME, TMP_FAAS_TIME, TMP_FAAS_CRON, TMP_FAAS_COLDSTART, TMP_FAAS_INVOKED_NAME, TMP_FAAS_INVOKED_PROVIDER, TMP_FAAS_INVOKED_REGION, TMP_NET_TRANSPORT, TMP_NET_PEER_IP, TMP_NET_PEER_PORT, TMP_NET_PEER_NAME, TMP_NET_HOST_IP, TMP_NET_HOST_PORT, TMP_NET_HOST_NAME, TMP_NET_HOST_CONNECTION_TYPE, TMP_NET_HOST_CONNECTION_SUBTYPE, TMP_NET_HOST_CARRIER_NAME, TMP_NET_HOST_CARRIER_MCC, TMP_NET_HOST_CARRIER_MNC, TMP_NET_HOST_CARRIER_ICC, TMP_PEER_SERVICE, TMP_ENDUSER_ID, TMP_ENDUSER_ROLE, TMP_ENDUSER_SCOPE, TMP_THREAD_ID, TMP_THREAD_NAME, TMP_CODE_FUNCTION, TMP_CODE_NAMESPACE, TMP_CODE_FILEPATH, TMP_CODE_LINENO, TMP_HTTP_METHOD, TMP_HTTP_URL, TMP_HTTP_TARGET, TMP_HTTP_HOST, TMP_HTTP_SCHEME, TMP_HTTP_STATUS_CODE, TMP_HTTP_FLAVOR, TMP_HTTP_USER_AGENT, TMP_HTTP_REQUEST_CONTENT_LENGTH, TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_RESPONSE_CONTENT_LENGTH, TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_SERVER_NAME, TMP_HTTP_ROUTE, TMP_HTTP_CLIENT_IP, TMP_AWS_DYNAMODB_TABLE_NAMES, TMP_AWS_DYNAMODB_CONSUMED_CAPACITY, TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, TMP_AWS_DYNAMODB_CONSISTENT_READ, TMP_AWS_DYNAMODB_PROJECTION, TMP_AWS_DYNAMODB_LIMIT, TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET, TMP_AWS_DYNAMODB_INDEX_NAME, TMP_AWS_DYNAMODB_SELECT, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, TMP_AWS_DYNAMODB_TABLE_COUNT, TMP_AWS_DYNAMODB_SCAN_FORWARD, TMP_AWS_DYNAMODB_SEGMENT, TMP_AWS_DYNAMODB_TOTAL_SEGMENTS, TMP_AWS_DYNAMODB_COUNT, TMP_AWS_DYNAMODB_SCANNED_COUNT, TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, TMP_MESSAGING_SYSTEM, TMP_MESSAGING_DESTINATION, TMP_MESSAGING_DESTINATION_KIND, TMP_MESSAGING_TEMP_DESTINATION, TMP_MESSAGING_PROTOCOL, TMP_MESSAGING_PROTOCOL_VERSION, TMP_MESSAGING_URL, TMP_MESSAGING_MESSAGE_ID, TMP_MESSAGING_CONVERSATION_ID, TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, TMP_MESSAGING_OPERATION, TMP_MESSAGING_CONSUMER_ID, TMP_MESSAGING_RABBITMQ_ROUTING_KEY, TMP_MESSAGING_KAFKA_MESSAGE_KEY, TMP_MESSAGING_KAFKA_CONSUMER_GROUP, TMP_MESSAGING_KAFKA_CLIENT_ID, TMP_MESSAGING_KAFKA_PARTITION, TMP_MESSAGING_KAFKA_TOMBSTONE, TMP_RPC_SYSTEM, TMP_RPC_SERVICE, TMP_RPC_METHOD, TMP_RPC_GRPC_STATUS_CODE, TMP_RPC_JSONRPC_VERSION, TMP_RPC_JSONRPC_REQUEST_ID, TMP_RPC_JSONRPC_ERROR_CODE, TMP_RPC_JSONRPC_ERROR_MESSAGE, TMP_MESSAGE_TYPE, TMP_MESSAGE_ID, TMP_MESSAGE_COMPRESSED_SIZE, TMP_MESSAGE_UNCOMPRESSED_SIZE, SEMATTRS_AWS_LAMBDA_INVOKED_ARN, SEMATTRS_DB_SYSTEM, SEMATTRS_DB_CONNECTION_STRING, SEMATTRS_DB_USER, SEMATTRS_DB_JDBC_DRIVER_CLASSNAME, SEMATTRS_DB_NAME, SEMATTRS_DB_STATEMENT, SEMATTRS_DB_OPERATION, SEMATTRS_DB_MSSQL_INSTANCE_NAME, SEMATTRS_DB_CASSANDRA_KEYSPACE, SEMATTRS_DB_CASSANDRA_PAGE_SIZE, SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL, SEMATTRS_DB_CASSANDRA_TABLE, SEMATTRS_DB_CASSANDRA_IDEMPOTENCE, SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, SEMATTRS_DB_CASSANDRA_COORDINATOR_ID, SEMATTRS_DB_CASSANDRA_COORDINATOR_DC, SEMATTRS_DB_HBASE_NAMESPACE, SEMATTRS_DB_REDIS_DATABASE_INDEX, SEMATTRS_DB_MONGODB_COLLECTION, SEMATTRS_DB_SQL_TABLE, SEMATTRS_EXCEPTION_TYPE, SEMATTRS_EXCEPTION_MESSAGE, SEMATTRS_EXCEPTION_STACKTRACE, SEMATTRS_EXCEPTION_ESCAPED, SEMATTRS_FAAS_TRIGGER, SEMATTRS_FAAS_EXECUTION, SEMATTRS_FAAS_DOCUMENT_COLLECTION, SEMATTRS_FAAS_DOCUMENT_OPERATION, SEMATTRS_FAAS_DOCUMENT_TIME, SEMATTRS_FAAS_DOCUMENT_NAME, SEMATTRS_FAAS_TIME, SEMATTRS_FAAS_CRON, SEMATTRS_FAAS_COLDSTART, SEMATTRS_FAAS_INVOKED_NAME, SEMATTRS_FAAS_INVOKED_PROVIDER, SEMATTRS_FAAS_INVOKED_REGION, SEMATTRS_NET_TRANSPORT, SEMATTRS_NET_PEER_IP, SEMATTRS_NET_PEER_PORT, SEMATTRS_NET_PEER_NAME, SEMATTRS_NET_HOST_IP, SEMATTRS_NET_HOST_PORT, SEMATTRS_NET_HOST_NAME, SEMATTRS_NET_HOST_CONNECTION_TYPE, SEMATTRS_NET_HOST_CONNECTION_SUBTYPE, SEMATTRS_NET_HOST_CARRIER_NAME, SEMATTRS_NET_HOST_CARRIER_MCC, SEMATTRS_NET_HOST_CARRIER_MNC, SEMATTRS_NET_HOST_CARRIER_ICC, SEMATTRS_PEER_SERVICE, SEMATTRS_ENDUSER_ID, SEMATTRS_ENDUSER_ROLE, SEMATTRS_ENDUSER_SCOPE, SEMATTRS_THREAD_ID, SEMATTRS_THREAD_NAME, SEMATTRS_CODE_FUNCTION, SEMATTRS_CODE_NAMESPACE, SEMATTRS_CODE_FILEPATH, SEMATTRS_CODE_LINENO, SEMATTRS_HTTP_METHOD, SEMATTRS_HTTP_URL, SEMATTRS_HTTP_TARGET, SEMATTRS_HTTP_HOST, SEMATTRS_HTTP_SCHEME, SEMATTRS_HTTP_STATUS_CODE, SEMATTRS_HTTP_FLAVOR, SEMATTRS_HTTP_USER_AGENT, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_SERVER_NAME, SEMATTRS_HTTP_ROUTE, SEMATTRS_HTTP_CLIENT_IP, SEMATTRS_AWS_DYNAMODB_TABLE_NAMES, SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY, SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ, SEMATTRS_AWS_DYNAMODB_PROJECTION, SEMATTRS_AWS_DYNAMODB_LIMIT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET, SEMATTRS_AWS_DYNAMODB_INDEX_NAME, SEMATTRS_AWS_DYNAMODB_SELECT, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, SEMATTRS_AWS_DYNAMODB_TABLE_COUNT, SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD, SEMATTRS_AWS_DYNAMODB_SEGMENT, SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS, SEMATTRS_AWS_DYNAMODB_COUNT, SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, SEMATTRS_MESSAGING_SYSTEM, SEMATTRS_MESSAGING_DESTINATION, SEMATTRS_MESSAGING_DESTINATION_KIND, SEMATTRS_MESSAGING_TEMP_DESTINATION, SEMATTRS_MESSAGING_PROTOCOL, SEMATTRS_MESSAGING_PROTOCOL_VERSION, SEMATTRS_MESSAGING_URL, SEMATTRS_MESSAGING_MESSAGE_ID, SEMATTRS_MESSAGING_CONVERSATION_ID, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, SEMATTRS_MESSAGING_OPERATION, SEMATTRS_MESSAGING_CONSUMER_ID, SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY, SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY, SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP, SEMATTRS_MESSAGING_KAFKA_CLIENT_ID, SEMATTRS_MESSAGING_KAFKA_PARTITION, SEMATTRS_MESSAGING_KAFKA_TOMBSTONE, SEMATTRS_RPC_SYSTEM, SEMATTRS_RPC_SERVICE, SEMATTRS_RPC_METHOD, SEMATTRS_RPC_GRPC_STATUS_CODE, SEMATTRS_RPC_JSONRPC_VERSION, SEMATTRS_RPC_JSONRPC_REQUEST_ID, SEMATTRS_RPC_JSONRPC_ERROR_CODE, SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE, SEMATTRS_MESSAGE_TYPE, SEMATTRS_MESSAGE_ID, SEMATTRS_MESSAGE_COMPRESSED_SIZE, SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE, SemanticAttributes, TMP_DBSYSTEMVALUES_OTHER_SQL, TMP_DBSYSTEMVALUES_MSSQL, TMP_DBSYSTEMVALUES_MYSQL, TMP_DBSYSTEMVALUES_ORACLE, TMP_DBSYSTEMVALUES_DB2, TMP_DBSYSTEMVALUES_POSTGRESQL, TMP_DBSYSTEMVALUES_REDSHIFT, TMP_DBSYSTEMVALUES_HIVE, TMP_DBSYSTEMVALUES_CLOUDSCAPE, TMP_DBSYSTEMVALUES_HSQLDB, TMP_DBSYSTEMVALUES_PROGRESS, TMP_DBSYSTEMVALUES_MAXDB, TMP_DBSYSTEMVALUES_HANADB, TMP_DBSYSTEMVALUES_INGRES, TMP_DBSYSTEMVALUES_FIRSTSQL, TMP_DBSYSTEMVALUES_EDB, TMP_DBSYSTEMVALUES_CACHE, TMP_DBSYSTEMVALUES_ADABAS, TMP_DBSYSTEMVALUES_FIREBIRD, TMP_DBSYSTEMVALUES_DERBY, TMP_DBSYSTEMVALUES_FILEMAKER, TMP_DBSYSTEMVALUES_INFORMIX, TMP_DBSYSTEMVALUES_INSTANTDB, TMP_DBSYSTEMVALUES_INTERBASE, TMP_DBSYSTEMVALUES_MARIADB, TMP_DBSYSTEMVALUES_NETEZZA, TMP_DBSYSTEMVALUES_PERVASIVE, TMP_DBSYSTEMVALUES_POINTBASE, TMP_DBSYSTEMVALUES_SQLITE, TMP_DBSYSTEMVALUES_SYBASE, TMP_DBSYSTEMVALUES_TERADATA, TMP_DBSYSTEMVALUES_VERTICA, TMP_DBSYSTEMVALUES_H2, TMP_DBSYSTEMVALUES_COLDFUSION, TMP_DBSYSTEMVALUES_CASSANDRA, TMP_DBSYSTEMVALUES_HBASE, TMP_DBSYSTEMVALUES_MONGODB, TMP_DBSYSTEMVALUES_REDIS, TMP_DBSYSTEMVALUES_COUCHBASE, TMP_DBSYSTEMVALUES_COUCHDB, TMP_DBSYSTEMVALUES_COSMOSDB, TMP_DBSYSTEMVALUES_DYNAMODB, TMP_DBSYSTEMVALUES_NEO4J, TMP_DBSYSTEMVALUES_GEODE, TMP_DBSYSTEMVALUES_ELASTICSEARCH, TMP_DBSYSTEMVALUES_MEMCACHED, TMP_DBSYSTEMVALUES_COCKROACHDB, DBSYSTEMVALUES_OTHER_SQL, DBSYSTEMVALUES_MSSQL, DBSYSTEMVALUES_MYSQL, DBSYSTEMVALUES_ORACLE, DBSYSTEMVALUES_DB2, DBSYSTEMVALUES_POSTGRESQL, DBSYSTEMVALUES_REDSHIFT, DBSYSTEMVALUES_HIVE, DBSYSTEMVALUES_CLOUDSCAPE, DBSYSTEMVALUES_HSQLDB, DBSYSTEMVALUES_PROGRESS, DBSYSTEMVALUES_MAXDB, DBSYSTEMVALUES_HANADB, DBSYSTEMVALUES_INGRES, DBSYSTEMVALUES_FIRSTSQL, DBSYSTEMVALUES_EDB, DBSYSTEMVALUES_CACHE, DBSYSTEMVALUES_ADABAS, DBSYSTEMVALUES_FIREBIRD, DBSYSTEMVALUES_DERBY, DBSYSTEMVALUES_FILEMAKER, DBSYSTEMVALUES_INFORMIX, DBSYSTEMVALUES_INSTANTDB, DBSYSTEMVALUES_INTERBASE, DBSYSTEMVALUES_MARIADB, DBSYSTEMVALUES_NETEZZA, DBSYSTEMVALUES_PERVASIVE, DBSYSTEMVALUES_POINTBASE, DBSYSTEMVALUES_SQLITE, DBSYSTEMVALUES_SYBASE, DBSYSTEMVALUES_TERADATA, DBSYSTEMVALUES_VERTICA, DBSYSTEMVALUES_H2, DBSYSTEMVALUES_COLDFUSION, DBSYSTEMVALUES_CASSANDRA, DBSYSTEMVALUES_HBASE, DBSYSTEMVALUES_MONGODB, DBSYSTEMVALUES_REDIS, DBSYSTEMVALUES_COUCHBASE, DBSYSTEMVALUES_COUCHDB, DBSYSTEMVALUES_COSMOSDB, DBSYSTEMVALUES_DYNAMODB, DBSYSTEMVALUES_NEO4J, DBSYSTEMVALUES_GEODE, DBSYSTEMVALUES_ELASTICSEARCH, DBSYSTEMVALUES_MEMCACHED, DBSYSTEMVALUES_COCKROACHDB, DbSystemValues, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_ALL, DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_TWO, DBCASSANDRACONSISTENCYLEVELVALUES_THREE, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_ANY, DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DbCassandraConsistencyLevelValues, TMP_FAASTRIGGERVALUES_DATASOURCE, TMP_FAASTRIGGERVALUES_HTTP, TMP_FAASTRIGGERVALUES_PUBSUB, TMP_FAASTRIGGERVALUES_TIMER, TMP_FAASTRIGGERVALUES_OTHER, FAASTRIGGERVALUES_DATASOURCE, FAASTRIGGERVALUES_HTTP, FAASTRIGGERVALUES_PUBSUB, FAASTRIGGERVALUES_TIMER, FAASTRIGGERVALUES_OTHER, FaasTriggerValues, TMP_FAASDOCUMENTOPERATIONVALUES_INSERT, TMP_FAASDOCUMENTOPERATIONVALUES_EDIT, TMP_FAASDOCUMENTOPERATIONVALUES_DELETE, FAASDOCUMENTOPERATIONVALUES_INSERT, FAASDOCUMENTOPERATIONVALUES_EDIT, FAASDOCUMENTOPERATIONVALUES_DELETE, FaasDocumentOperationValues, TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, TMP_FAASINVOKEDPROVIDERVALUES_AWS, TMP_FAASINVOKEDPROVIDERVALUES_AZURE, TMP_FAASINVOKEDPROVIDERVALUES_GCP, FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, FAASINVOKEDPROVIDERVALUES_AWS, FAASINVOKEDPROVIDERVALUES_AZURE, FAASINVOKEDPROVIDERVALUES_GCP, FaasInvokedProviderValues, TMP_NETTRANSPORTVALUES_IP_TCP, TMP_NETTRANSPORTVALUES_IP_UDP, TMP_NETTRANSPORTVALUES_IP, TMP_NETTRANSPORTVALUES_UNIX, TMP_NETTRANSPORTVALUES_PIPE, TMP_NETTRANSPORTVALUES_INPROC, TMP_NETTRANSPORTVALUES_OTHER, NETTRANSPORTVALUES_IP_TCP, NETTRANSPORTVALUES_IP_UDP, NETTRANSPORTVALUES_IP, NETTRANSPORTVALUES_UNIX, NETTRANSPORTVALUES_PIPE, NETTRANSPORTVALUES_INPROC, NETTRANSPORTVALUES_OTHER, NetTransportValues, TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI, TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED, TMP_NETHOSTCONNECTIONTYPEVALUES_CELL, TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NETHOSTCONNECTIONTYPEVALUES_WIFI, NETHOSTCONNECTIONTYPEVALUES_WIRED, NETHOSTCONNECTIONTYPEVALUES_CELL, NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NetHostConnectionTypeValues, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, NETHOSTCONNECTIONSUBTYPEVALUES_LTE, NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, NETHOSTCONNECTIONSUBTYPEVALUES_GSM, NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, NETHOSTCONNECTIONSUBTYPEVALUES_NR, NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NetHostConnectionSubtypeValues, TMP_HTTPFLAVORVALUES_HTTP_1_0, TMP_HTTPFLAVORVALUES_HTTP_1_1, TMP_HTTPFLAVORVALUES_HTTP_2_0, TMP_HTTPFLAVORVALUES_SPDY, TMP_HTTPFLAVORVALUES_QUIC, HTTPFLAVORVALUES_HTTP_1_0, HTTPFLAVORVALUES_HTTP_1_1, HTTPFLAVORVALUES_HTTP_2_0, HTTPFLAVORVALUES_SPDY, HTTPFLAVORVALUES_QUIC, HttpFlavorValues, TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE, TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC, MESSAGINGDESTINATIONKINDVALUES_QUEUE, MESSAGINGDESTINATIONKINDVALUES_TOPIC, MessagingDestinationKindValues, TMP_MESSAGINGOPERATIONVALUES_RECEIVE, TMP_MESSAGINGOPERATIONVALUES_PROCESS, MESSAGINGOPERATIONVALUES_RECEIVE, MESSAGINGOPERATIONVALUES_PROCESS, MessagingOperationValues, TMP_RPCGRPCSTATUSCODEVALUES_OK, TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED, TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN, TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND, TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, TMP_RPCGRPCSTATUSCODEVALUES_ABORTED, TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL, TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS, TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RPCGRPCSTATUSCODEVALUES_OK, RPCGRPCSTATUSCODEVALUES_CANCELLED, RPCGRPCSTATUSCODEVALUES_UNKNOWN, RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, RPCGRPCSTATUSCODEVALUES_NOT_FOUND, RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, RPCGRPCSTATUSCODEVALUES_ABORTED, RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, RPCGRPCSTATUSCODEVALUES_INTERNAL, RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, RPCGRPCSTATUSCODEVALUES_DATA_LOSS, RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RpcGrpcStatusCodeValues, TMP_MESSAGETYPEVALUES_SENT, TMP_MESSAGETYPEVALUES_RECEIVED, MESSAGETYPEVALUES_SENT, MESSAGETYPEVALUES_RECEIVED, MessageTypeValues;
var init_SemanticAttributes = __esm({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js"() {
    init_esm();
    init_utils3();
    TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
    TMP_DB_SYSTEM = "db.system";
    TMP_DB_CONNECTION_STRING = "db.connection_string";
    TMP_DB_USER = "db.user";
    TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
    TMP_DB_NAME = "db.name";
    TMP_DB_STATEMENT = "db.statement";
    TMP_DB_OPERATION = "db.operation";
    TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
    TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
    TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
    TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
    TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
    TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
    TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
    TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
    TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
    TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
    TMP_DB_SQL_TABLE = "db.sql.table";
    TMP_EXCEPTION_TYPE = "exception.type";
    TMP_EXCEPTION_MESSAGE = "exception.message";
    TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
    TMP_EXCEPTION_ESCAPED = "exception.escaped";
    TMP_FAAS_TRIGGER = "faas.trigger";
    TMP_FAAS_EXECUTION = "faas.execution";
    TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
    TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
    TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
    TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
    TMP_FAAS_TIME = "faas.time";
    TMP_FAAS_CRON = "faas.cron";
    TMP_FAAS_COLDSTART = "faas.coldstart";
    TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
    TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
    TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
    TMP_NET_TRANSPORT = "net.transport";
    TMP_NET_PEER_IP = "net.peer.ip";
    TMP_NET_PEER_PORT = "net.peer.port";
    TMP_NET_PEER_NAME = "net.peer.name";
    TMP_NET_HOST_IP = "net.host.ip";
    TMP_NET_HOST_PORT = "net.host.port";
    TMP_NET_HOST_NAME = "net.host.name";
    TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
    TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
    TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
    TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
    TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
    TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
    TMP_PEER_SERVICE = "peer.service";
    TMP_ENDUSER_ID = "enduser.id";
    TMP_ENDUSER_ROLE = "enduser.role";
    TMP_ENDUSER_SCOPE = "enduser.scope";
    TMP_THREAD_ID = "thread.id";
    TMP_THREAD_NAME = "thread.name";
    TMP_CODE_FUNCTION = "code.function";
    TMP_CODE_NAMESPACE = "code.namespace";
    TMP_CODE_FILEPATH = "code.filepath";
    TMP_CODE_LINENO = "code.lineno";
    TMP_HTTP_METHOD = "http.method";
    TMP_HTTP_URL = "http.url";
    TMP_HTTP_TARGET = "http.target";
    TMP_HTTP_HOST = "http.host";
    TMP_HTTP_SCHEME = "http.scheme";
    TMP_HTTP_STATUS_CODE = "http.status_code";
    TMP_HTTP_FLAVOR = "http.flavor";
    TMP_HTTP_USER_AGENT = "http.user_agent";
    TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
    TMP_HTTP_SERVER_NAME = "http.server_name";
    TMP_HTTP_ROUTE = "http.route";
    TMP_HTTP_CLIENT_IP = "http.client_ip";
    TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
    TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
    TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
    TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
    TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
    TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
    TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
    TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
    TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
    TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
    TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
    TMP_MESSAGING_SYSTEM = "messaging.system";
    TMP_MESSAGING_DESTINATION = "messaging.destination";
    TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
    TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
    TMP_MESSAGING_PROTOCOL = "messaging.protocol";
    TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
    TMP_MESSAGING_URL = "messaging.url";
    TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
    TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
    TMP_MESSAGING_OPERATION = "messaging.operation";
    TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
    TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
    TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
    TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
    TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
    TMP_RPC_SYSTEM = "rpc.system";
    TMP_RPC_SERVICE = "rpc.service";
    TMP_RPC_METHOD = "rpc.method";
    TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
    TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
    TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
    TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
    TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
    TMP_MESSAGE_TYPE = "message.type";
    TMP_MESSAGE_ID = "message.id";
    TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
    TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
    SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
    SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
    SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
    SEMATTRS_DB_USER = TMP_DB_USER;
    SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
    SEMATTRS_DB_NAME = TMP_DB_NAME;
    SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
    SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
    SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
    SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
    SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
    SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
    SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
    SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
    SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
    SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
    SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
    SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
    SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
    SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
    SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
    SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
    SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
    SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
    SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
    SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
    SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
    SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
    SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
    SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
    SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
    SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
    SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
    SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
    SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
    SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
    SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
    SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
    SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
    SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
    SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
    SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
    SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
    SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
    SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
    SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
    SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
    SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
    SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
    SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
    SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
    SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
    SEMATTRS_THREAD_ID = TMP_THREAD_ID;
    SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
    SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
    SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
    SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
    SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
    SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
    SEMATTRS_HTTP_URL = TMP_HTTP_URL;
    SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
    SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
    SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
    SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
    SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
    SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
    SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
    SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
    SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
    SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
    SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
    SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
    SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
    SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
    SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
    SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
    SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
    SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
    SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
    SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
    SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
    SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
    SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
    SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
    SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
    SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
    SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
    SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
    SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
    SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
    SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
    SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
    SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
    SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
    SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
    SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
    SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
    SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
    SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
    SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
    SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
    SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
    SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
    SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
    SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
    SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
    SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
    SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
    SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
    SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
    SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
    SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
    SemanticAttributes = /* @__PURE__ */ createConstMap([
      TMP_AWS_LAMBDA_INVOKED_ARN,
      TMP_DB_SYSTEM,
      TMP_DB_CONNECTION_STRING,
      TMP_DB_USER,
      TMP_DB_JDBC_DRIVER_CLASSNAME,
      TMP_DB_NAME,
      TMP_DB_STATEMENT,
      TMP_DB_OPERATION,
      TMP_DB_MSSQL_INSTANCE_NAME,
      TMP_DB_CASSANDRA_KEYSPACE,
      TMP_DB_CASSANDRA_PAGE_SIZE,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
      TMP_DB_CASSANDRA_TABLE,
      TMP_DB_CASSANDRA_IDEMPOTENCE,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
      TMP_DB_CASSANDRA_COORDINATOR_ID,
      TMP_DB_CASSANDRA_COORDINATOR_DC,
      TMP_DB_HBASE_NAMESPACE,
      TMP_DB_REDIS_DATABASE_INDEX,
      TMP_DB_MONGODB_COLLECTION,
      TMP_DB_SQL_TABLE,
      TMP_EXCEPTION_TYPE,
      TMP_EXCEPTION_MESSAGE,
      TMP_EXCEPTION_STACKTRACE,
      TMP_EXCEPTION_ESCAPED,
      TMP_FAAS_TRIGGER,
      TMP_FAAS_EXECUTION,
      TMP_FAAS_DOCUMENT_COLLECTION,
      TMP_FAAS_DOCUMENT_OPERATION,
      TMP_FAAS_DOCUMENT_TIME,
      TMP_FAAS_DOCUMENT_NAME,
      TMP_FAAS_TIME,
      TMP_FAAS_CRON,
      TMP_FAAS_COLDSTART,
      TMP_FAAS_INVOKED_NAME,
      TMP_FAAS_INVOKED_PROVIDER,
      TMP_FAAS_INVOKED_REGION,
      TMP_NET_TRANSPORT,
      TMP_NET_PEER_IP,
      TMP_NET_PEER_PORT,
      TMP_NET_PEER_NAME,
      TMP_NET_HOST_IP,
      TMP_NET_HOST_PORT,
      TMP_NET_HOST_NAME,
      TMP_NET_HOST_CONNECTION_TYPE,
      TMP_NET_HOST_CONNECTION_SUBTYPE,
      TMP_NET_HOST_CARRIER_NAME,
      TMP_NET_HOST_CARRIER_MCC,
      TMP_NET_HOST_CARRIER_MNC,
      TMP_NET_HOST_CARRIER_ICC,
      TMP_PEER_SERVICE,
      TMP_ENDUSER_ID,
      TMP_ENDUSER_ROLE,
      TMP_ENDUSER_SCOPE,
      TMP_THREAD_ID,
      TMP_THREAD_NAME,
      TMP_CODE_FUNCTION,
      TMP_CODE_NAMESPACE,
      TMP_CODE_FILEPATH,
      TMP_CODE_LINENO,
      TMP_HTTP_METHOD,
      TMP_HTTP_URL,
      TMP_HTTP_TARGET,
      TMP_HTTP_HOST,
      TMP_HTTP_SCHEME,
      TMP_HTTP_STATUS_CODE,
      TMP_HTTP_FLAVOR,
      TMP_HTTP_USER_AGENT,
      TMP_HTTP_REQUEST_CONTENT_LENGTH,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_SERVER_NAME,
      TMP_HTTP_ROUTE,
      TMP_HTTP_CLIENT_IP,
      TMP_AWS_DYNAMODB_TABLE_NAMES,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
      TMP_AWS_DYNAMODB_CONSISTENT_READ,
      TMP_AWS_DYNAMODB_PROJECTION,
      TMP_AWS_DYNAMODB_LIMIT,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
      TMP_AWS_DYNAMODB_INDEX_NAME,
      TMP_AWS_DYNAMODB_SELECT,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
      TMP_AWS_DYNAMODB_TABLE_COUNT,
      TMP_AWS_DYNAMODB_SCAN_FORWARD,
      TMP_AWS_DYNAMODB_SEGMENT,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
      TMP_AWS_DYNAMODB_COUNT,
      TMP_AWS_DYNAMODB_SCANNED_COUNT,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
      TMP_MESSAGING_SYSTEM,
      TMP_MESSAGING_DESTINATION,
      TMP_MESSAGING_DESTINATION_KIND,
      TMP_MESSAGING_TEMP_DESTINATION,
      TMP_MESSAGING_PROTOCOL,
      TMP_MESSAGING_PROTOCOL_VERSION,
      TMP_MESSAGING_URL,
      TMP_MESSAGING_MESSAGE_ID,
      TMP_MESSAGING_CONVERSATION_ID,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
      TMP_MESSAGING_OPERATION,
      TMP_MESSAGING_CONSUMER_ID,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
      TMP_MESSAGING_KAFKA_CLIENT_ID,
      TMP_MESSAGING_KAFKA_PARTITION,
      TMP_MESSAGING_KAFKA_TOMBSTONE,
      TMP_RPC_SYSTEM,
      TMP_RPC_SERVICE,
      TMP_RPC_METHOD,
      TMP_RPC_GRPC_STATUS_CODE,
      TMP_RPC_JSONRPC_VERSION,
      TMP_RPC_JSONRPC_REQUEST_ID,
      TMP_RPC_JSONRPC_ERROR_CODE,
      TMP_RPC_JSONRPC_ERROR_MESSAGE,
      TMP_MESSAGE_TYPE,
      TMP_MESSAGE_ID,
      TMP_MESSAGE_COMPRESSED_SIZE,
      TMP_MESSAGE_UNCOMPRESSED_SIZE
    ]);
    TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
    TMP_DBSYSTEMVALUES_MSSQL = "mssql";
    TMP_DBSYSTEMVALUES_MYSQL = "mysql";
    TMP_DBSYSTEMVALUES_ORACLE = "oracle";
    TMP_DBSYSTEMVALUES_DB2 = "db2";
    TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
    TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
    TMP_DBSYSTEMVALUES_HIVE = "hive";
    TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
    TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
    TMP_DBSYSTEMVALUES_PROGRESS = "progress";
    TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
    TMP_DBSYSTEMVALUES_HANADB = "hanadb";
    TMP_DBSYSTEMVALUES_INGRES = "ingres";
    TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
    TMP_DBSYSTEMVALUES_EDB = "edb";
    TMP_DBSYSTEMVALUES_CACHE = "cache";
    TMP_DBSYSTEMVALUES_ADABAS = "adabas";
    TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
    TMP_DBSYSTEMVALUES_DERBY = "derby";
    TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
    TMP_DBSYSTEMVALUES_INFORMIX = "informix";
    TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
    TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
    TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
    TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
    TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
    TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
    TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
    TMP_DBSYSTEMVALUES_SYBASE = "sybase";
    TMP_DBSYSTEMVALUES_TERADATA = "teradata";
    TMP_DBSYSTEMVALUES_VERTICA = "vertica";
    TMP_DBSYSTEMVALUES_H2 = "h2";
    TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
    TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
    TMP_DBSYSTEMVALUES_HBASE = "hbase";
    TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
    TMP_DBSYSTEMVALUES_REDIS = "redis";
    TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
    TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
    TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
    TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
    TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
    TMP_DBSYSTEMVALUES_GEODE = "geode";
    TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
    TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
    TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
    DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
    DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
    DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
    DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
    DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
    DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
    DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
    DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
    DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
    DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
    DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
    DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
    DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
    DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
    DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
    DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
    DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
    DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
    DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
    DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
    DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
    DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
    DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
    DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
    DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
    DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
    DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
    DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
    DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
    DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
    DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
    DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
    DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
    DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
    DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
    DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
    DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
    DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
    DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
    DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
    DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
    DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
    DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
    DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
    DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
    DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
    DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
    DbSystemValues = /* @__PURE__ */ createConstMap([
      TMP_DBSYSTEMVALUES_OTHER_SQL,
      TMP_DBSYSTEMVALUES_MSSQL,
      TMP_DBSYSTEMVALUES_MYSQL,
      TMP_DBSYSTEMVALUES_ORACLE,
      TMP_DBSYSTEMVALUES_DB2,
      TMP_DBSYSTEMVALUES_POSTGRESQL,
      TMP_DBSYSTEMVALUES_REDSHIFT,
      TMP_DBSYSTEMVALUES_HIVE,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE,
      TMP_DBSYSTEMVALUES_HSQLDB,
      TMP_DBSYSTEMVALUES_PROGRESS,
      TMP_DBSYSTEMVALUES_MAXDB,
      TMP_DBSYSTEMVALUES_HANADB,
      TMP_DBSYSTEMVALUES_INGRES,
      TMP_DBSYSTEMVALUES_FIRSTSQL,
      TMP_DBSYSTEMVALUES_EDB,
      TMP_DBSYSTEMVALUES_CACHE,
      TMP_DBSYSTEMVALUES_ADABAS,
      TMP_DBSYSTEMVALUES_FIREBIRD,
      TMP_DBSYSTEMVALUES_DERBY,
      TMP_DBSYSTEMVALUES_FILEMAKER,
      TMP_DBSYSTEMVALUES_INFORMIX,
      TMP_DBSYSTEMVALUES_INSTANTDB,
      TMP_DBSYSTEMVALUES_INTERBASE,
      TMP_DBSYSTEMVALUES_MARIADB,
      TMP_DBSYSTEMVALUES_NETEZZA,
      TMP_DBSYSTEMVALUES_PERVASIVE,
      TMP_DBSYSTEMVALUES_POINTBASE,
      TMP_DBSYSTEMVALUES_SQLITE,
      TMP_DBSYSTEMVALUES_SYBASE,
      TMP_DBSYSTEMVALUES_TERADATA,
      TMP_DBSYSTEMVALUES_VERTICA,
      TMP_DBSYSTEMVALUES_H2,
      TMP_DBSYSTEMVALUES_COLDFUSION,
      TMP_DBSYSTEMVALUES_CASSANDRA,
      TMP_DBSYSTEMVALUES_HBASE,
      TMP_DBSYSTEMVALUES_MONGODB,
      TMP_DBSYSTEMVALUES_REDIS,
      TMP_DBSYSTEMVALUES_COUCHBASE,
      TMP_DBSYSTEMVALUES_COUCHDB,
      TMP_DBSYSTEMVALUES_COSMOSDB,
      TMP_DBSYSTEMVALUES_DYNAMODB,
      TMP_DBSYSTEMVALUES_NEO4J,
      TMP_DBSYSTEMVALUES_GEODE,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH,
      TMP_DBSYSTEMVALUES_MEMCACHED,
      TMP_DBSYSTEMVALUES_COCKROACHDB
    ]);
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
    DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
    DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
    DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
    DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
    DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
    DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
    DbCassandraConsistencyLevelValues = /* @__PURE__ */ createConstMap([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
    ]);
    TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
    TMP_FAASTRIGGERVALUES_HTTP = "http";
    TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
    TMP_FAASTRIGGERVALUES_TIMER = "timer";
    TMP_FAASTRIGGERVALUES_OTHER = "other";
    FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
    FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
    FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
    FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
    FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
    FaasTriggerValues = /* @__PURE__ */ createConstMap([
      TMP_FAASTRIGGERVALUES_DATASOURCE,
      TMP_FAASTRIGGERVALUES_HTTP,
      TMP_FAASTRIGGERVALUES_PUBSUB,
      TMP_FAASTRIGGERVALUES_TIMER,
      TMP_FAASTRIGGERVALUES_OTHER
    ]);
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
    FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
    FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
    FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
    FaasDocumentOperationValues = /* @__PURE__ */ createConstMap([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
    ]);
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
    TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
    FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
    FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
    FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
    FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
    FaasInvokedProviderValues = /* @__PURE__ */ createConstMap([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP
    ]);
    TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
    TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
    TMP_NETTRANSPORTVALUES_IP = "ip";
    TMP_NETTRANSPORTVALUES_UNIX = "unix";
    TMP_NETTRANSPORTVALUES_PIPE = "pipe";
    TMP_NETTRANSPORTVALUES_INPROC = "inproc";
    TMP_NETTRANSPORTVALUES_OTHER = "other";
    NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
    NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
    NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
    NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
    NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
    NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
    NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
    NetTransportValues = /* @__PURE__ */ createConstMap([
      TMP_NETTRANSPORTVALUES_IP_TCP,
      TMP_NETTRANSPORTVALUES_IP_UDP,
      TMP_NETTRANSPORTVALUES_IP,
      TMP_NETTRANSPORTVALUES_UNIX,
      TMP_NETTRANSPORTVALUES_PIPE,
      TMP_NETTRANSPORTVALUES_INPROC,
      TMP_NETTRANSPORTVALUES_OTHER
    ]);
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
    NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
    NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
    NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
    NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
    NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
    NetHostConnectionTypeValues = /* @__PURE__ */ createConstMap([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
    ]);
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
    NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
    NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
    NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
    NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
    NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
    NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
    NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
    NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
    NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
    NetHostConnectionSubtypeValues = /* @__PURE__ */ createConstMap([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
    ]);
    TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
    TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
    TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
    TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
    TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
    HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
    HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
    HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
    HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
    HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
    HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC
    };
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
    MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
    MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
    MessagingDestinationKindValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
    ]);
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
    TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
    MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
    MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
    MessagingOperationValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS
    ]);
    TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
    TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
    TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
    TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
    TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
    TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
    TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
    TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
    TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
    TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
    TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
    TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
    TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
    TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
    TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
    RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
    RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
    RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
    RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
    RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
    RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
    RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
    RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
    RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
    RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
    RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
    RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
    RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
    RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
    RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
    RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
    RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
    RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
    };
    TMP_MESSAGETYPEVALUES_SENT = "SENT";
    TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
    MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
    MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
    MessageTypeValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGETYPEVALUES_SENT,
      TMP_MESSAGETYPEVALUES_RECEIVED
    ]);
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
var init_trace2 = __esm({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js"() {
    init_esm();
    init_SemanticAttributes();
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
var TMP_CLOUD_PROVIDER, TMP_CLOUD_ACCOUNT_ID, TMP_CLOUD_REGION, TMP_CLOUD_AVAILABILITY_ZONE, TMP_CLOUD_PLATFORM, TMP_AWS_ECS_CONTAINER_ARN, TMP_AWS_ECS_CLUSTER_ARN, TMP_AWS_ECS_LAUNCHTYPE, TMP_AWS_ECS_TASK_ARN, TMP_AWS_ECS_TASK_FAMILY, TMP_AWS_ECS_TASK_REVISION, TMP_AWS_EKS_CLUSTER_ARN, TMP_AWS_LOG_GROUP_NAMES, TMP_AWS_LOG_GROUP_ARNS, TMP_AWS_LOG_STREAM_NAMES, TMP_AWS_LOG_STREAM_ARNS, TMP_CONTAINER_NAME, TMP_CONTAINER_ID, TMP_CONTAINER_RUNTIME, TMP_CONTAINER_IMAGE_NAME, TMP_CONTAINER_IMAGE_TAG, TMP_DEPLOYMENT_ENVIRONMENT, TMP_DEVICE_ID, TMP_DEVICE_MODEL_IDENTIFIER, TMP_DEVICE_MODEL_NAME, TMP_FAAS_NAME, TMP_FAAS_ID, TMP_FAAS_VERSION, TMP_FAAS_INSTANCE, TMP_FAAS_MAX_MEMORY, TMP_HOST_ID, TMP_HOST_NAME, TMP_HOST_TYPE, TMP_HOST_ARCH, TMP_HOST_IMAGE_NAME, TMP_HOST_IMAGE_ID, TMP_HOST_IMAGE_VERSION, TMP_K8S_CLUSTER_NAME, TMP_K8S_NODE_NAME, TMP_K8S_NODE_UID, TMP_K8S_NAMESPACE_NAME, TMP_K8S_POD_UID, TMP_K8S_POD_NAME, TMP_K8S_CONTAINER_NAME, TMP_K8S_REPLICASET_UID, TMP_K8S_REPLICASET_NAME, TMP_K8S_DEPLOYMENT_UID, TMP_K8S_DEPLOYMENT_NAME, TMP_K8S_STATEFULSET_UID, TMP_K8S_STATEFULSET_NAME, TMP_K8S_DAEMONSET_UID, TMP_K8S_DAEMONSET_NAME, TMP_K8S_JOB_UID, TMP_K8S_JOB_NAME, TMP_K8S_CRONJOB_UID, TMP_K8S_CRONJOB_NAME, TMP_OS_TYPE, TMP_OS_DESCRIPTION, TMP_OS_NAME, TMP_OS_VERSION, TMP_PROCESS_PID, TMP_PROCESS_EXECUTABLE_NAME, TMP_PROCESS_EXECUTABLE_PATH, TMP_PROCESS_COMMAND, TMP_PROCESS_COMMAND_LINE, TMP_PROCESS_COMMAND_ARGS, TMP_PROCESS_OWNER, TMP_PROCESS_RUNTIME_NAME, TMP_PROCESS_RUNTIME_VERSION, TMP_PROCESS_RUNTIME_DESCRIPTION, TMP_SERVICE_NAME, TMP_SERVICE_NAMESPACE, TMP_SERVICE_INSTANCE_ID, TMP_SERVICE_VERSION, TMP_TELEMETRY_SDK_NAME, TMP_TELEMETRY_SDK_LANGUAGE, TMP_TELEMETRY_SDK_VERSION, TMP_TELEMETRY_AUTO_VERSION, TMP_WEBENGINE_NAME, TMP_WEBENGINE_VERSION, TMP_WEBENGINE_DESCRIPTION, SEMRESATTRS_CLOUD_PROVIDER, SEMRESATTRS_CLOUD_ACCOUNT_ID, SEMRESATTRS_CLOUD_REGION, SEMRESATTRS_CLOUD_AVAILABILITY_ZONE, SEMRESATTRS_CLOUD_PLATFORM, SEMRESATTRS_AWS_ECS_CONTAINER_ARN, SEMRESATTRS_AWS_ECS_CLUSTER_ARN, SEMRESATTRS_AWS_ECS_LAUNCHTYPE, SEMRESATTRS_AWS_ECS_TASK_ARN, SEMRESATTRS_AWS_ECS_TASK_FAMILY, SEMRESATTRS_AWS_ECS_TASK_REVISION, SEMRESATTRS_AWS_EKS_CLUSTER_ARN, SEMRESATTRS_AWS_LOG_GROUP_NAMES, SEMRESATTRS_AWS_LOG_GROUP_ARNS, SEMRESATTRS_AWS_LOG_STREAM_NAMES, SEMRESATTRS_AWS_LOG_STREAM_ARNS, SEMRESATTRS_CONTAINER_NAME, SEMRESATTRS_CONTAINER_ID, SEMRESATTRS_CONTAINER_RUNTIME, SEMRESATTRS_CONTAINER_IMAGE_NAME, SEMRESATTRS_CONTAINER_IMAGE_TAG, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT, SEMRESATTRS_DEVICE_ID, SEMRESATTRS_DEVICE_MODEL_IDENTIFIER, SEMRESATTRS_DEVICE_MODEL_NAME, SEMRESATTRS_FAAS_NAME, SEMRESATTRS_FAAS_ID, SEMRESATTRS_FAAS_VERSION, SEMRESATTRS_FAAS_INSTANCE, SEMRESATTRS_FAAS_MAX_MEMORY, SEMRESATTRS_HOST_ID, SEMRESATTRS_HOST_NAME, SEMRESATTRS_HOST_TYPE, SEMRESATTRS_HOST_ARCH, SEMRESATTRS_HOST_IMAGE_NAME, SEMRESATTRS_HOST_IMAGE_ID, SEMRESATTRS_HOST_IMAGE_VERSION, SEMRESATTRS_K8S_CLUSTER_NAME, SEMRESATTRS_K8S_NODE_NAME, SEMRESATTRS_K8S_NODE_UID, SEMRESATTRS_K8S_NAMESPACE_NAME, SEMRESATTRS_K8S_POD_UID, SEMRESATTRS_K8S_POD_NAME, SEMRESATTRS_K8S_CONTAINER_NAME, SEMRESATTRS_K8S_REPLICASET_UID, SEMRESATTRS_K8S_REPLICASET_NAME, SEMRESATTRS_K8S_DEPLOYMENT_UID, SEMRESATTRS_K8S_DEPLOYMENT_NAME, SEMRESATTRS_K8S_STATEFULSET_UID, SEMRESATTRS_K8S_STATEFULSET_NAME, SEMRESATTRS_K8S_DAEMONSET_UID, SEMRESATTRS_K8S_DAEMONSET_NAME, SEMRESATTRS_K8S_JOB_UID, SEMRESATTRS_K8S_JOB_NAME, SEMRESATTRS_K8S_CRONJOB_UID, SEMRESATTRS_K8S_CRONJOB_NAME, SEMRESATTRS_OS_TYPE, SEMRESATTRS_OS_DESCRIPTION, SEMRESATTRS_OS_NAME, SEMRESATTRS_OS_VERSION, SEMRESATTRS_PROCESS_PID, SEMRESATTRS_PROCESS_EXECUTABLE_NAME, SEMRESATTRS_PROCESS_EXECUTABLE_PATH, SEMRESATTRS_PROCESS_COMMAND, SEMRESATTRS_PROCESS_COMMAND_LINE, SEMRESATTRS_PROCESS_COMMAND_ARGS, SEMRESATTRS_PROCESS_OWNER, SEMRESATTRS_PROCESS_RUNTIME_NAME, SEMRESATTRS_PROCESS_RUNTIME_VERSION, SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION, SEMRESATTRS_SERVICE_NAME, SEMRESATTRS_SERVICE_NAMESPACE, SEMRESATTRS_SERVICE_INSTANCE_ID, SEMRESATTRS_SERVICE_VERSION, SEMRESATTRS_TELEMETRY_SDK_NAME, SEMRESATTRS_TELEMETRY_SDK_LANGUAGE, SEMRESATTRS_TELEMETRY_SDK_VERSION, SEMRESATTRS_TELEMETRY_AUTO_VERSION, SEMRESATTRS_WEBENGINE_NAME, SEMRESATTRS_WEBENGINE_VERSION, SEMRESATTRS_WEBENGINE_DESCRIPTION, SemanticResourceAttributes, TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD, TMP_CLOUDPROVIDERVALUES_AWS, TMP_CLOUDPROVIDERVALUES_AZURE, TMP_CLOUDPROVIDERVALUES_GCP, CLOUDPROVIDERVALUES_ALIBABA_CLOUD, CLOUDPROVIDERVALUES_AWS, CLOUDPROVIDERVALUES_AZURE, CLOUDPROVIDERVALUES_GCP, CloudProviderValues, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, TMP_CLOUDPLATFORMVALUES_AWS_EC2, TMP_CLOUDPLATFORMVALUES_AWS_ECS, TMP_CLOUDPLATFORMVALUES_AWS_EKS, TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA, TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, TMP_CLOUDPLATFORMVALUES_AZURE_VM, TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, TMP_CLOUDPLATFORMVALUES_AZURE_AKS, TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, CLOUDPLATFORMVALUES_AWS_EC2, CLOUDPLATFORMVALUES_AWS_ECS, CLOUDPLATFORMVALUES_AWS_EKS, CLOUDPLATFORMVALUES_AWS_LAMBDA, CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, CLOUDPLATFORMVALUES_AZURE_VM, CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, CLOUDPLATFORMVALUES_AZURE_AKS, CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CloudPlatformValues, TMP_AWSECSLAUNCHTYPEVALUES_EC2, TMP_AWSECSLAUNCHTYPEVALUES_FARGATE, AWSECSLAUNCHTYPEVALUES_EC2, AWSECSLAUNCHTYPEVALUES_FARGATE, AwsEcsLaunchtypeValues, TMP_HOSTARCHVALUES_AMD64, TMP_HOSTARCHVALUES_ARM32, TMP_HOSTARCHVALUES_ARM64, TMP_HOSTARCHVALUES_IA64, TMP_HOSTARCHVALUES_PPC32, TMP_HOSTARCHVALUES_PPC64, TMP_HOSTARCHVALUES_X86, HOSTARCHVALUES_AMD64, HOSTARCHVALUES_ARM32, HOSTARCHVALUES_ARM64, HOSTARCHVALUES_IA64, HOSTARCHVALUES_PPC32, HOSTARCHVALUES_PPC64, HOSTARCHVALUES_X86, HostArchValues, TMP_OSTYPEVALUES_WINDOWS, TMP_OSTYPEVALUES_LINUX, TMP_OSTYPEVALUES_DARWIN, TMP_OSTYPEVALUES_FREEBSD, TMP_OSTYPEVALUES_NETBSD, TMP_OSTYPEVALUES_OPENBSD, TMP_OSTYPEVALUES_DRAGONFLYBSD, TMP_OSTYPEVALUES_HPUX, TMP_OSTYPEVALUES_AIX, TMP_OSTYPEVALUES_SOLARIS, TMP_OSTYPEVALUES_Z_OS, OSTYPEVALUES_WINDOWS, OSTYPEVALUES_LINUX, OSTYPEVALUES_DARWIN, OSTYPEVALUES_FREEBSD, OSTYPEVALUES_NETBSD, OSTYPEVALUES_OPENBSD, OSTYPEVALUES_DRAGONFLYBSD, OSTYPEVALUES_HPUX, OSTYPEVALUES_AIX, OSTYPEVALUES_SOLARIS, OSTYPEVALUES_Z_OS, OsTypeValues, TMP_TELEMETRYSDKLANGUAGEVALUES_CPP, TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET, TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG, TMP_TELEMETRYSDKLANGUAGEVALUES_GO, TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA, TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS, TMP_TELEMETRYSDKLANGUAGEVALUES_PHP, TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON, TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY, TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS, TELEMETRYSDKLANGUAGEVALUES_CPP, TELEMETRYSDKLANGUAGEVALUES_DOTNET, TELEMETRYSDKLANGUAGEVALUES_ERLANG, TELEMETRYSDKLANGUAGEVALUES_GO, TELEMETRYSDKLANGUAGEVALUES_JAVA, TELEMETRYSDKLANGUAGEVALUES_NODEJS, TELEMETRYSDKLANGUAGEVALUES_PHP, TELEMETRYSDKLANGUAGEVALUES_PYTHON, TELEMETRYSDKLANGUAGEVALUES_RUBY, TELEMETRYSDKLANGUAGEVALUES_WEBJS, TelemetrySdkLanguageValues;
var init_SemanticResourceAttributes = __esm({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js"() {
    init_esm();
    init_utils3();
    TMP_CLOUD_PROVIDER = "cloud.provider";
    TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
    TMP_CLOUD_REGION = "cloud.region";
    TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
    TMP_CLOUD_PLATFORM = "cloud.platform";
    TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
    TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
    TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
    TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
    TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
    TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
    TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
    TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
    TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
    TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
    TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
    TMP_CONTAINER_NAME = "container.name";
    TMP_CONTAINER_ID = "container.id";
    TMP_CONTAINER_RUNTIME = "container.runtime";
    TMP_CONTAINER_IMAGE_NAME = "container.image.name";
    TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
    TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
    TMP_DEVICE_ID = "device.id";
    TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
    TMP_DEVICE_MODEL_NAME = "device.model.name";
    TMP_FAAS_NAME = "faas.name";
    TMP_FAAS_ID = "faas.id";
    TMP_FAAS_VERSION = "faas.version";
    TMP_FAAS_INSTANCE = "faas.instance";
    TMP_FAAS_MAX_MEMORY = "faas.max_memory";
    TMP_HOST_ID = "host.id";
    TMP_HOST_NAME = "host.name";
    TMP_HOST_TYPE = "host.type";
    TMP_HOST_ARCH = "host.arch";
    TMP_HOST_IMAGE_NAME = "host.image.name";
    TMP_HOST_IMAGE_ID = "host.image.id";
    TMP_HOST_IMAGE_VERSION = "host.image.version";
    TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
    TMP_K8S_NODE_NAME = "k8s.node.name";
    TMP_K8S_NODE_UID = "k8s.node.uid";
    TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
    TMP_K8S_POD_UID = "k8s.pod.uid";
    TMP_K8S_POD_NAME = "k8s.pod.name";
    TMP_K8S_CONTAINER_NAME = "k8s.container.name";
    TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
    TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
    TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
    TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
    TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
    TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
    TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
    TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
    TMP_K8S_JOB_UID = "k8s.job.uid";
    TMP_K8S_JOB_NAME = "k8s.job.name";
    TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
    TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
    TMP_OS_TYPE = "os.type";
    TMP_OS_DESCRIPTION = "os.description";
    TMP_OS_NAME = "os.name";
    TMP_OS_VERSION = "os.version";
    TMP_PROCESS_PID = "process.pid";
    TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
    TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
    TMP_PROCESS_COMMAND = "process.command";
    TMP_PROCESS_COMMAND_LINE = "process.command_line";
    TMP_PROCESS_COMMAND_ARGS = "process.command_args";
    TMP_PROCESS_OWNER = "process.owner";
    TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
    TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
    TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
    TMP_SERVICE_NAME = "service.name";
    TMP_SERVICE_NAMESPACE = "service.namespace";
    TMP_SERVICE_INSTANCE_ID = "service.instance.id";
    TMP_SERVICE_VERSION = "service.version";
    TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
    TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
    TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
    TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
    TMP_WEBENGINE_NAME = "webengine.name";
    TMP_WEBENGINE_VERSION = "webengine.version";
    TMP_WEBENGINE_DESCRIPTION = "webengine.description";
    SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
    SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
    SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
    SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
    SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
    SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
    SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
    SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
    SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
    SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
    SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
    SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
    SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
    SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
    SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
    SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
    SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
    SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
    SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
    SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
    SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
    SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
    SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
    SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
    SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
    SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
    SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
    SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
    SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
    SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
    SEMRESATTRS_HOST_ID = TMP_HOST_ID;
    SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
    SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
    SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
    SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
    SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
    SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
    SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
    SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
    SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
    SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
    SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
    SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
    SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
    SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
    SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
    SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
    SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
    SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
    SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
    SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
    SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
    SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
    SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
    SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
    SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
    SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
    SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
    SEMRESATTRS_OS_NAME = TMP_OS_NAME;
    SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
    SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
    SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
    SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
    SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
    SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
    SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
    SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
    SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
    SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
    SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
    SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
    SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
    SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
    SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
    SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
    SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
    SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
    SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
    SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
    SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
    SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
    SemanticResourceAttributes = /* @__PURE__ */ createConstMap([
      TMP_CLOUD_PROVIDER,
      TMP_CLOUD_ACCOUNT_ID,
      TMP_CLOUD_REGION,
      TMP_CLOUD_AVAILABILITY_ZONE,
      TMP_CLOUD_PLATFORM,
      TMP_AWS_ECS_CONTAINER_ARN,
      TMP_AWS_ECS_CLUSTER_ARN,
      TMP_AWS_ECS_LAUNCHTYPE,
      TMP_AWS_ECS_TASK_ARN,
      TMP_AWS_ECS_TASK_FAMILY,
      TMP_AWS_ECS_TASK_REVISION,
      TMP_AWS_EKS_CLUSTER_ARN,
      TMP_AWS_LOG_GROUP_NAMES,
      TMP_AWS_LOG_GROUP_ARNS,
      TMP_AWS_LOG_STREAM_NAMES,
      TMP_AWS_LOG_STREAM_ARNS,
      TMP_CONTAINER_NAME,
      TMP_CONTAINER_ID,
      TMP_CONTAINER_RUNTIME,
      TMP_CONTAINER_IMAGE_NAME,
      TMP_CONTAINER_IMAGE_TAG,
      TMP_DEPLOYMENT_ENVIRONMENT,
      TMP_DEVICE_ID,
      TMP_DEVICE_MODEL_IDENTIFIER,
      TMP_DEVICE_MODEL_NAME,
      TMP_FAAS_NAME,
      TMP_FAAS_ID,
      TMP_FAAS_VERSION,
      TMP_FAAS_INSTANCE,
      TMP_FAAS_MAX_MEMORY,
      TMP_HOST_ID,
      TMP_HOST_NAME,
      TMP_HOST_TYPE,
      TMP_HOST_ARCH,
      TMP_HOST_IMAGE_NAME,
      TMP_HOST_IMAGE_ID,
      TMP_HOST_IMAGE_VERSION,
      TMP_K8S_CLUSTER_NAME,
      TMP_K8S_NODE_NAME,
      TMP_K8S_NODE_UID,
      TMP_K8S_NAMESPACE_NAME,
      TMP_K8S_POD_UID,
      TMP_K8S_POD_NAME,
      TMP_K8S_CONTAINER_NAME,
      TMP_K8S_REPLICASET_UID,
      TMP_K8S_REPLICASET_NAME,
      TMP_K8S_DEPLOYMENT_UID,
      TMP_K8S_DEPLOYMENT_NAME,
      TMP_K8S_STATEFULSET_UID,
      TMP_K8S_STATEFULSET_NAME,
      TMP_K8S_DAEMONSET_UID,
      TMP_K8S_DAEMONSET_NAME,
      TMP_K8S_JOB_UID,
      TMP_K8S_JOB_NAME,
      TMP_K8S_CRONJOB_UID,
      TMP_K8S_CRONJOB_NAME,
      TMP_OS_TYPE,
      TMP_OS_DESCRIPTION,
      TMP_OS_NAME,
      TMP_OS_VERSION,
      TMP_PROCESS_PID,
      TMP_PROCESS_EXECUTABLE_NAME,
      TMP_PROCESS_EXECUTABLE_PATH,
      TMP_PROCESS_COMMAND,
      TMP_PROCESS_COMMAND_LINE,
      TMP_PROCESS_COMMAND_ARGS,
      TMP_PROCESS_OWNER,
      TMP_PROCESS_RUNTIME_NAME,
      TMP_PROCESS_RUNTIME_VERSION,
      TMP_PROCESS_RUNTIME_DESCRIPTION,
      TMP_SERVICE_NAME,
      TMP_SERVICE_NAMESPACE,
      TMP_SERVICE_INSTANCE_ID,
      TMP_SERVICE_VERSION,
      TMP_TELEMETRY_SDK_NAME,
      TMP_TELEMETRY_SDK_LANGUAGE,
      TMP_TELEMETRY_SDK_VERSION,
      TMP_TELEMETRY_AUTO_VERSION,
      TMP_WEBENGINE_NAME,
      TMP_WEBENGINE_VERSION,
      TMP_WEBENGINE_DESCRIPTION
    ]);
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    TMP_CLOUDPROVIDERVALUES_AWS = "aws";
    TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
    TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
    CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
    CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
    CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
    CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
    CloudProviderValues = /* @__PURE__ */ createConstMap([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_CLOUDPROVIDERVALUES_AWS,
      TMP_CLOUDPROVIDERVALUES_AZURE,
      TMP_CLOUDPROVIDERVALUES_GCP
    ]);
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
    TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
    TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
    TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
    TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
    CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
    CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
    CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
    CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
    CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
    CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
    CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
    CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
    CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
    CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
    CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
    CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
    CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
    CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
    CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
    CloudPlatformValues = /* @__PURE__ */ createConstMap([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
      TMP_CLOUDPLATFORMVALUES_AWS_EC2,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
    ]);
    TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
    AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
    AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
    AwsEcsLaunchtypeValues = /* @__PURE__ */ createConstMap([
      TMP_AWSECSLAUNCHTYPEVALUES_EC2,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
    ]);
    TMP_HOSTARCHVALUES_AMD64 = "amd64";
    TMP_HOSTARCHVALUES_ARM32 = "arm32";
    TMP_HOSTARCHVALUES_ARM64 = "arm64";
    TMP_HOSTARCHVALUES_IA64 = "ia64";
    TMP_HOSTARCHVALUES_PPC32 = "ppc32";
    TMP_HOSTARCHVALUES_PPC64 = "ppc64";
    TMP_HOSTARCHVALUES_X86 = "x86";
    HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
    HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
    HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
    HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
    HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
    HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
    HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
    HostArchValues = /* @__PURE__ */ createConstMap([
      TMP_HOSTARCHVALUES_AMD64,
      TMP_HOSTARCHVALUES_ARM32,
      TMP_HOSTARCHVALUES_ARM64,
      TMP_HOSTARCHVALUES_IA64,
      TMP_HOSTARCHVALUES_PPC32,
      TMP_HOSTARCHVALUES_PPC64,
      TMP_HOSTARCHVALUES_X86
    ]);
    TMP_OSTYPEVALUES_WINDOWS = "windows";
    TMP_OSTYPEVALUES_LINUX = "linux";
    TMP_OSTYPEVALUES_DARWIN = "darwin";
    TMP_OSTYPEVALUES_FREEBSD = "freebsd";
    TMP_OSTYPEVALUES_NETBSD = "netbsd";
    TMP_OSTYPEVALUES_OPENBSD = "openbsd";
    TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
    TMP_OSTYPEVALUES_HPUX = "hpux";
    TMP_OSTYPEVALUES_AIX = "aix";
    TMP_OSTYPEVALUES_SOLARIS = "solaris";
    TMP_OSTYPEVALUES_Z_OS = "z_os";
    OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
    OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
    OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
    OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
    OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
    OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
    OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
    OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
    OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
    OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
    OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
    OsTypeValues = /* @__PURE__ */ createConstMap([
      TMP_OSTYPEVALUES_WINDOWS,
      TMP_OSTYPEVALUES_LINUX,
      TMP_OSTYPEVALUES_DARWIN,
      TMP_OSTYPEVALUES_FREEBSD,
      TMP_OSTYPEVALUES_NETBSD,
      TMP_OSTYPEVALUES_OPENBSD,
      TMP_OSTYPEVALUES_DRAGONFLYBSD,
      TMP_OSTYPEVALUES_HPUX,
      TMP_OSTYPEVALUES_AIX,
      TMP_OSTYPEVALUES_SOLARIS,
      TMP_OSTYPEVALUES_Z_OS
    ]);
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
    TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
    TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
    TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
    TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
    TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
    TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
    TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
    TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
    TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
    TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
    TelemetrySdkLanguageValues = /* @__PURE__ */ createConstMap([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
    ]);
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
var init_resource = __esm({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js"() {
    init_esm();
    init_SemanticResourceAttributes();
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js
var ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED, ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE, ATTR_ASPNETCORE_RATE_LIMITING_POLICY, ATTR_ASPNETCORE_RATE_LIMITING_RESULT, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED, ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED, ATTR_ASPNETCORE_ROUTING_IS_FALLBACK, ATTR_ASPNETCORE_ROUTING_MATCH_STATUS, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS, ATTR_CLIENT_ADDRESS, ATTR_CLIENT_PORT, ATTR_CODE_COLUMN_NUMBER, ATTR_CODE_FILE_PATH, ATTR_CODE_FUNCTION_NAME, ATTR_CODE_LINE_NUMBER, ATTR_CODE_STACKTRACE, ATTR_DB_COLLECTION_NAME, ATTR_DB_NAMESPACE, ATTR_DB_OPERATION_BATCH_SIZE, ATTR_DB_OPERATION_NAME, ATTR_DB_QUERY_SUMMARY, ATTR_DB_QUERY_TEXT, ATTR_DB_RESPONSE_STATUS_CODE, ATTR_DB_STORED_PROCEDURE_NAME, ATTR_DB_SYSTEM_NAME, DB_SYSTEM_NAME_VALUE_MARIADB, DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER, DB_SYSTEM_NAME_VALUE_MYSQL, DB_SYSTEM_NAME_VALUE_POSTGRESQL, ATTR_DOTNET_GC_HEAP_GENERATION, DOTNET_GC_HEAP_GENERATION_VALUE_GEN0, DOTNET_GC_HEAP_GENERATION_VALUE_GEN1, DOTNET_GC_HEAP_GENERATION_VALUE_GEN2, DOTNET_GC_HEAP_GENERATION_VALUE_LOH, DOTNET_GC_HEAP_GENERATION_VALUE_POH, ATTR_ERROR_TYPE, ERROR_TYPE_VALUE_OTHER, ATTR_EXCEPTION_ESCAPED, ATTR_EXCEPTION_MESSAGE, ATTR_EXCEPTION_STACKTRACE, ATTR_EXCEPTION_TYPE, ATTR_HTTP_REQUEST_HEADER, ATTR_HTTP_REQUEST_METHOD, HTTP_REQUEST_METHOD_VALUE_OTHER, HTTP_REQUEST_METHOD_VALUE_CONNECT, HTTP_REQUEST_METHOD_VALUE_DELETE, HTTP_REQUEST_METHOD_VALUE_GET, HTTP_REQUEST_METHOD_VALUE_HEAD, HTTP_REQUEST_METHOD_VALUE_OPTIONS, HTTP_REQUEST_METHOD_VALUE_PATCH, HTTP_REQUEST_METHOD_VALUE_POST, HTTP_REQUEST_METHOD_VALUE_PUT, HTTP_REQUEST_METHOD_VALUE_TRACE, ATTR_HTTP_REQUEST_METHOD_ORIGINAL, ATTR_HTTP_REQUEST_RESEND_COUNT, ATTR_HTTP_RESPONSE_HEADER, ATTR_HTTP_RESPONSE_STATUS_CODE, ATTR_HTTP_ROUTE, ATTR_JVM_GC_ACTION, ATTR_JVM_GC_NAME, ATTR_JVM_MEMORY_POOL_NAME, ATTR_JVM_MEMORY_TYPE, JVM_MEMORY_TYPE_VALUE_HEAP, JVM_MEMORY_TYPE_VALUE_NON_HEAP, ATTR_JVM_THREAD_DAEMON, ATTR_JVM_THREAD_STATE, JVM_THREAD_STATE_VALUE_BLOCKED, JVM_THREAD_STATE_VALUE_NEW, JVM_THREAD_STATE_VALUE_RUNNABLE, JVM_THREAD_STATE_VALUE_TERMINATED, JVM_THREAD_STATE_VALUE_TIMED_WAITING, JVM_THREAD_STATE_VALUE_WAITING, ATTR_NETWORK_LOCAL_ADDRESS, ATTR_NETWORK_LOCAL_PORT, ATTR_NETWORK_PEER_ADDRESS, ATTR_NETWORK_PEER_PORT, ATTR_NETWORK_PROTOCOL_NAME, ATTR_NETWORK_PROTOCOL_VERSION, ATTR_NETWORK_TRANSPORT, NETWORK_TRANSPORT_VALUE_PIPE, NETWORK_TRANSPORT_VALUE_QUIC, NETWORK_TRANSPORT_VALUE_TCP, NETWORK_TRANSPORT_VALUE_UDP, NETWORK_TRANSPORT_VALUE_UNIX, ATTR_NETWORK_TYPE, NETWORK_TYPE_VALUE_IPV4, NETWORK_TYPE_VALUE_IPV6, ATTR_OTEL_SCOPE_NAME, ATTR_OTEL_SCOPE_VERSION, ATTR_OTEL_STATUS_CODE, OTEL_STATUS_CODE_VALUE_ERROR, OTEL_STATUS_CODE_VALUE_OK, ATTR_OTEL_STATUS_DESCRIPTION, ATTR_SERVER_ADDRESS, ATTR_SERVER_PORT, ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION, ATTR_SIGNALR_CONNECTION_STATUS, SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN, SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE, SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT, ATTR_SIGNALR_TRANSPORT, SIGNALR_TRANSPORT_VALUE_LONG_POLLING, SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS, SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS, ATTR_TELEMETRY_SDK_LANGUAGE, TELEMETRY_SDK_LANGUAGE_VALUE_CPP, TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET, TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG, TELEMETRY_SDK_LANGUAGE_VALUE_GO, TELEMETRY_SDK_LANGUAGE_VALUE_JAVA, TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS, TELEMETRY_SDK_LANGUAGE_VALUE_PHP, TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON, TELEMETRY_SDK_LANGUAGE_VALUE_RUBY, TELEMETRY_SDK_LANGUAGE_VALUE_RUST, TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT, TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS, ATTR_TELEMETRY_SDK_NAME, ATTR_TELEMETRY_SDK_VERSION, ATTR_URL_FRAGMENT, ATTR_URL_FULL, ATTR_URL_PATH, ATTR_URL_QUERY, ATTR_URL_SCHEME, ATTR_USER_AGENT_ORIGINAL;
var init_stable_attributes = __esm({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js"() {
    init_esm();
    ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
    ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type";
    ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy";
    ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
    ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled";
    ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback";
    ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
    ATTR_CLIENT_ADDRESS = "client.address";
    ATTR_CLIENT_PORT = "client.port";
    ATTR_CODE_COLUMN_NUMBER = "code.column.number";
    ATTR_CODE_FILE_PATH = "code.file.path";
    ATTR_CODE_FUNCTION_NAME = "code.function.name";
    ATTR_CODE_LINE_NUMBER = "code.line.number";
    ATTR_CODE_STACKTRACE = "code.stacktrace";
    ATTR_DB_COLLECTION_NAME = "db.collection.name";
    ATTR_DB_NAMESPACE = "db.namespace";
    ATTR_DB_OPERATION_BATCH_SIZE = "db.operation.batch.size";
    ATTR_DB_OPERATION_NAME = "db.operation.name";
    ATTR_DB_QUERY_SUMMARY = "db.query.summary";
    ATTR_DB_QUERY_TEXT = "db.query.text";
    ATTR_DB_RESPONSE_STATUS_CODE = "db.response.status_code";
    ATTR_DB_STORED_PROCEDURE_NAME = "db.stored_procedure.name";
    ATTR_DB_SYSTEM_NAME = "db.system.name";
    DB_SYSTEM_NAME_VALUE_MARIADB = "mariadb";
    DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER = "microsoft.sql_server";
    DB_SYSTEM_NAME_VALUE_MYSQL = "mysql";
    DB_SYSTEM_NAME_VALUE_POSTGRESQL = "postgresql";
    ATTR_DOTNET_GC_HEAP_GENERATION = "dotnet.gc.heap.generation";
    DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 = "gen0";
    DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 = "gen1";
    DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 = "gen2";
    DOTNET_GC_HEAP_GENERATION_VALUE_LOH = "loh";
    DOTNET_GC_HEAP_GENERATION_VALUE_POH = "poh";
    ATTR_ERROR_TYPE = "error.type";
    ERROR_TYPE_VALUE_OTHER = "_OTHER";
    ATTR_EXCEPTION_ESCAPED = "exception.escaped";
    ATTR_EXCEPTION_MESSAGE = "exception.message";
    ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
    ATTR_EXCEPTION_TYPE = "exception.type";
    ATTR_HTTP_REQUEST_HEADER = /* @__PURE__ */ __name((key) => `http.request.header.${key}`, "ATTR_HTTP_REQUEST_HEADER");
    ATTR_HTTP_REQUEST_METHOD = "http.request.method";
    HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
    HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
    HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
    HTTP_REQUEST_METHOD_VALUE_GET = "GET";
    HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
    HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
    HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
    HTTP_REQUEST_METHOD_VALUE_POST = "POST";
    HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
    HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
    ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original";
    ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count";
    ATTR_HTTP_RESPONSE_HEADER = /* @__PURE__ */ __name((key) => `http.response.header.${key}`, "ATTR_HTTP_RESPONSE_HEADER");
    ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
    ATTR_HTTP_ROUTE = "http.route";
    ATTR_JVM_GC_ACTION = "jvm.gc.action";
    ATTR_JVM_GC_NAME = "jvm.gc.name";
    ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name";
    ATTR_JVM_MEMORY_TYPE = "jvm.memory.type";
    JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
    JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
    ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon";
    ATTR_JVM_THREAD_STATE = "jvm.thread.state";
    JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
    JVM_THREAD_STATE_VALUE_NEW = "new";
    JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
    JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
    JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
    JVM_THREAD_STATE_VALUE_WAITING = "waiting";
    ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address";
    ATTR_NETWORK_LOCAL_PORT = "network.local.port";
    ATTR_NETWORK_PEER_ADDRESS = "network.peer.address";
    ATTR_NETWORK_PEER_PORT = "network.peer.port";
    ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name";
    ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version";
    ATTR_NETWORK_TRANSPORT = "network.transport";
    NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
    NETWORK_TRANSPORT_VALUE_QUIC = "quic";
    NETWORK_TRANSPORT_VALUE_TCP = "tcp";
    NETWORK_TRANSPORT_VALUE_UDP = "udp";
    NETWORK_TRANSPORT_VALUE_UNIX = "unix";
    ATTR_NETWORK_TYPE = "network.type";
    NETWORK_TYPE_VALUE_IPV4 = "ipv4";
    NETWORK_TYPE_VALUE_IPV6 = "ipv6";
    ATTR_OTEL_SCOPE_NAME = "otel.scope.name";
    ATTR_OTEL_SCOPE_VERSION = "otel.scope.version";
    ATTR_OTEL_STATUS_CODE = "otel.status_code";
    OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
    OTEL_STATUS_CODE_VALUE_OK = "OK";
    ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description";
    ATTR_SERVER_ADDRESS = "server.address";
    ATTR_SERVER_PORT = "server.port";
    ATTR_SERVICE_NAME = "service.name";
    ATTR_SERVICE_VERSION = "service.version";
    ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status";
    SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
    SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
    SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
    ATTR_SIGNALR_TRANSPORT = "signalr.transport";
    SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
    SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
    SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
    ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
    TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
    TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
    TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
    TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
    TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
    TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
    TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
    TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
    TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
    TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
    ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
    ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
    ATTR_URL_FRAGMENT = "url.fragment";
    ATTR_URL_FULL = "url.full";
    ATTR_URL_PATH = "url.path";
    ATTR_URL_QUERY = "url.query";
    ATTR_URL_SCHEME = "url.scheme";
    ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js
var METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS, METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES, METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION, METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS, METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS, METRIC_DB_CLIENT_OPERATION_DURATION, METRIC_DOTNET_ASSEMBLY_COUNT, METRIC_DOTNET_EXCEPTIONS, METRIC_DOTNET_GC_COLLECTIONS, METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED, METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE, METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE, METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE, METRIC_DOTNET_GC_PAUSE_TIME, METRIC_DOTNET_JIT_COMPILATION_TIME, METRIC_DOTNET_JIT_COMPILED_IL_SIZE, METRIC_DOTNET_JIT_COMPILED_METHODS, METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS, METRIC_DOTNET_PROCESS_CPU_COUNT, METRIC_DOTNET_PROCESS_CPU_TIME, METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET, METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH, METRIC_DOTNET_THREAD_POOL_THREAD_COUNT, METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT, METRIC_DOTNET_TIMER_COUNT, METRIC_HTTP_CLIENT_REQUEST_DURATION, METRIC_HTTP_SERVER_REQUEST_DURATION, METRIC_JVM_CLASS_COUNT, METRIC_JVM_CLASS_LOADED, METRIC_JVM_CLASS_UNLOADED, METRIC_JVM_CPU_COUNT, METRIC_JVM_CPU_RECENT_UTILIZATION, METRIC_JVM_CPU_TIME, METRIC_JVM_GC_DURATION, METRIC_JVM_MEMORY_COMMITTED, METRIC_JVM_MEMORY_LIMIT, METRIC_JVM_MEMORY_USED, METRIC_JVM_MEMORY_USED_AFTER_LAST_GC, METRIC_JVM_THREAD_COUNT, METRIC_KESTREL_ACTIVE_CONNECTIONS, METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES, METRIC_KESTREL_CONNECTION_DURATION, METRIC_KESTREL_QUEUED_CONNECTIONS, METRIC_KESTREL_QUEUED_REQUESTS, METRIC_KESTREL_REJECTED_CONNECTIONS, METRIC_KESTREL_TLS_HANDSHAKE_DURATION, METRIC_KESTREL_UPGRADED_CONNECTIONS, METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS, METRIC_SIGNALR_SERVER_CONNECTION_DURATION;
var init_stable_metrics = __esm({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js"() {
    init_esm();
    METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions";
    METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases";
    METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests";
    METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts";
    METRIC_DB_CLIENT_OPERATION_DURATION = "db.client.operation.duration";
    METRIC_DOTNET_ASSEMBLY_COUNT = "dotnet.assembly.count";
    METRIC_DOTNET_EXCEPTIONS = "dotnet.exceptions";
    METRIC_DOTNET_GC_COLLECTIONS = "dotnet.gc.collections";
    METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED = "dotnet.gc.heap.total_allocated";
    METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE = "dotnet.gc.last_collection.heap.fragmentation.size";
    METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE = "dotnet.gc.last_collection.heap.size";
    METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE = "dotnet.gc.last_collection.memory.committed_size";
    METRIC_DOTNET_GC_PAUSE_TIME = "dotnet.gc.pause.time";
    METRIC_DOTNET_JIT_COMPILATION_TIME = "dotnet.jit.compilation.time";
    METRIC_DOTNET_JIT_COMPILED_IL_SIZE = "dotnet.jit.compiled_il.size";
    METRIC_DOTNET_JIT_COMPILED_METHODS = "dotnet.jit.compiled_methods";
    METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS = "dotnet.monitor.lock_contentions";
    METRIC_DOTNET_PROCESS_CPU_COUNT = "dotnet.process.cpu.count";
    METRIC_DOTNET_PROCESS_CPU_TIME = "dotnet.process.cpu.time";
    METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET = "dotnet.process.memory.working_set";
    METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH = "dotnet.thread_pool.queue.length";
    METRIC_DOTNET_THREAD_POOL_THREAD_COUNT = "dotnet.thread_pool.thread.count";
    METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT = "dotnet.thread_pool.work_item.count";
    METRIC_DOTNET_TIMER_COUNT = "dotnet.timer.count";
    METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration";
    METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration";
    METRIC_JVM_CLASS_COUNT = "jvm.class.count";
    METRIC_JVM_CLASS_LOADED = "jvm.class.loaded";
    METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded";
    METRIC_JVM_CPU_COUNT = "jvm.cpu.count";
    METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization";
    METRIC_JVM_CPU_TIME = "jvm.cpu.time";
    METRIC_JVM_GC_DURATION = "jvm.gc.duration";
    METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed";
    METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit";
    METRIC_JVM_MEMORY_USED = "jvm.memory.used";
    METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc";
    METRIC_JVM_THREAD_COUNT = "jvm.thread.count";
    METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections";
    METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes";
    METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration";
    METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections";
    METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests";
    METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections";
    METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration";
    METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections";
    METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections";
    METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS,
  ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT: () => ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT,
  ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE: () => ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE,
  ATTR_ASPNETCORE_RATE_LIMITING_POLICY: () => ATTR_ASPNETCORE_RATE_LIMITING_POLICY,
  ATTR_ASPNETCORE_RATE_LIMITING_RESULT: () => ATTR_ASPNETCORE_RATE_LIMITING_RESULT,
  ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED: () => ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED,
  ATTR_ASPNETCORE_ROUTING_IS_FALLBACK: () => ATTR_ASPNETCORE_ROUTING_IS_FALLBACK,
  ATTR_ASPNETCORE_ROUTING_MATCH_STATUS: () => ATTR_ASPNETCORE_ROUTING_MATCH_STATUS,
  ATTR_CLIENT_ADDRESS: () => ATTR_CLIENT_ADDRESS,
  ATTR_CLIENT_PORT: () => ATTR_CLIENT_PORT,
  ATTR_CODE_COLUMN_NUMBER: () => ATTR_CODE_COLUMN_NUMBER,
  ATTR_CODE_FILE_PATH: () => ATTR_CODE_FILE_PATH,
  ATTR_CODE_FUNCTION_NAME: () => ATTR_CODE_FUNCTION_NAME,
  ATTR_CODE_LINE_NUMBER: () => ATTR_CODE_LINE_NUMBER,
  ATTR_CODE_STACKTRACE: () => ATTR_CODE_STACKTRACE,
  ATTR_DB_COLLECTION_NAME: () => ATTR_DB_COLLECTION_NAME,
  ATTR_DB_NAMESPACE: () => ATTR_DB_NAMESPACE,
  ATTR_DB_OPERATION_BATCH_SIZE: () => ATTR_DB_OPERATION_BATCH_SIZE,
  ATTR_DB_OPERATION_NAME: () => ATTR_DB_OPERATION_NAME,
  ATTR_DB_QUERY_SUMMARY: () => ATTR_DB_QUERY_SUMMARY,
  ATTR_DB_QUERY_TEXT: () => ATTR_DB_QUERY_TEXT,
  ATTR_DB_RESPONSE_STATUS_CODE: () => ATTR_DB_RESPONSE_STATUS_CODE,
  ATTR_DB_STORED_PROCEDURE_NAME: () => ATTR_DB_STORED_PROCEDURE_NAME,
  ATTR_DB_SYSTEM_NAME: () => ATTR_DB_SYSTEM_NAME,
  ATTR_DOTNET_GC_HEAP_GENERATION: () => ATTR_DOTNET_GC_HEAP_GENERATION,
  ATTR_ERROR_TYPE: () => ATTR_ERROR_TYPE,
  ATTR_EXCEPTION_ESCAPED: () => ATTR_EXCEPTION_ESCAPED,
  ATTR_EXCEPTION_MESSAGE: () => ATTR_EXCEPTION_MESSAGE,
  ATTR_EXCEPTION_STACKTRACE: () => ATTR_EXCEPTION_STACKTRACE,
  ATTR_EXCEPTION_TYPE: () => ATTR_EXCEPTION_TYPE,
  ATTR_HTTP_REQUEST_HEADER: () => ATTR_HTTP_REQUEST_HEADER,
  ATTR_HTTP_REQUEST_METHOD: () => ATTR_HTTP_REQUEST_METHOD,
  ATTR_HTTP_REQUEST_METHOD_ORIGINAL: () => ATTR_HTTP_REQUEST_METHOD_ORIGINAL,
  ATTR_HTTP_REQUEST_RESEND_COUNT: () => ATTR_HTTP_REQUEST_RESEND_COUNT,
  ATTR_HTTP_RESPONSE_HEADER: () => ATTR_HTTP_RESPONSE_HEADER,
  ATTR_HTTP_RESPONSE_STATUS_CODE: () => ATTR_HTTP_RESPONSE_STATUS_CODE,
  ATTR_HTTP_ROUTE: () => ATTR_HTTP_ROUTE,
  ATTR_JVM_GC_ACTION: () => ATTR_JVM_GC_ACTION,
  ATTR_JVM_GC_NAME: () => ATTR_JVM_GC_NAME,
  ATTR_JVM_MEMORY_POOL_NAME: () => ATTR_JVM_MEMORY_POOL_NAME,
  ATTR_JVM_MEMORY_TYPE: () => ATTR_JVM_MEMORY_TYPE,
  ATTR_JVM_THREAD_DAEMON: () => ATTR_JVM_THREAD_DAEMON,
  ATTR_JVM_THREAD_STATE: () => ATTR_JVM_THREAD_STATE,
  ATTR_NETWORK_LOCAL_ADDRESS: () => ATTR_NETWORK_LOCAL_ADDRESS,
  ATTR_NETWORK_LOCAL_PORT: () => ATTR_NETWORK_LOCAL_PORT,
  ATTR_NETWORK_PEER_ADDRESS: () => ATTR_NETWORK_PEER_ADDRESS,
  ATTR_NETWORK_PEER_PORT: () => ATTR_NETWORK_PEER_PORT,
  ATTR_NETWORK_PROTOCOL_NAME: () => ATTR_NETWORK_PROTOCOL_NAME,
  ATTR_NETWORK_PROTOCOL_VERSION: () => ATTR_NETWORK_PROTOCOL_VERSION,
  ATTR_NETWORK_TRANSPORT: () => ATTR_NETWORK_TRANSPORT,
  ATTR_NETWORK_TYPE: () => ATTR_NETWORK_TYPE,
  ATTR_OTEL_SCOPE_NAME: () => ATTR_OTEL_SCOPE_NAME,
  ATTR_OTEL_SCOPE_VERSION: () => ATTR_OTEL_SCOPE_VERSION,
  ATTR_OTEL_STATUS_CODE: () => ATTR_OTEL_STATUS_CODE,
  ATTR_OTEL_STATUS_DESCRIPTION: () => ATTR_OTEL_STATUS_DESCRIPTION,
  ATTR_SERVER_ADDRESS: () => ATTR_SERVER_ADDRESS,
  ATTR_SERVER_PORT: () => ATTR_SERVER_PORT,
  ATTR_SERVICE_NAME: () => ATTR_SERVICE_NAME,
  ATTR_SERVICE_VERSION: () => ATTR_SERVICE_VERSION,
  ATTR_SIGNALR_CONNECTION_STATUS: () => ATTR_SIGNALR_CONNECTION_STATUS,
  ATTR_SIGNALR_TRANSPORT: () => ATTR_SIGNALR_TRANSPORT,
  ATTR_TELEMETRY_SDK_LANGUAGE: () => ATTR_TELEMETRY_SDK_LANGUAGE,
  ATTR_TELEMETRY_SDK_NAME: () => ATTR_TELEMETRY_SDK_NAME,
  ATTR_TELEMETRY_SDK_VERSION: () => ATTR_TELEMETRY_SDK_VERSION,
  ATTR_URL_FRAGMENT: () => ATTR_URL_FRAGMENT,
  ATTR_URL_FULL: () => ATTR_URL_FULL,
  ATTR_URL_PATH: () => ATTR_URL_PATH,
  ATTR_URL_QUERY: () => ATTR_URL_QUERY,
  ATTR_URL_SCHEME: () => ATTR_URL_SCHEME,
  ATTR_USER_AGENT_ORIGINAL: () => ATTR_USER_AGENT_ORIGINAL,
  AWSECSLAUNCHTYPEVALUES_EC2: () => AWSECSLAUNCHTYPEVALUES_EC2,
  AWSECSLAUNCHTYPEVALUES_FARGATE: () => AWSECSLAUNCHTYPEVALUES_FARGATE,
  AwsEcsLaunchtypeValues: () => AwsEcsLaunchtypeValues,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
  CLOUDPLATFORMVALUES_AWS_EC2: () => CLOUDPLATFORMVALUES_AWS_EC2,
  CLOUDPLATFORMVALUES_AWS_ECS: () => CLOUDPLATFORMVALUES_AWS_ECS,
  CLOUDPLATFORMVALUES_AWS_EKS: () => CLOUDPLATFORMVALUES_AWS_EKS,
  CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: () => CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
  CLOUDPLATFORMVALUES_AWS_LAMBDA: () => CLOUDPLATFORMVALUES_AWS_LAMBDA,
  CLOUDPLATFORMVALUES_AZURE_AKS: () => CLOUDPLATFORMVALUES_AZURE_AKS,
  CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: () => CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
  CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: () => CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
  CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: () => CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
  CLOUDPLATFORMVALUES_AZURE_VM: () => CLOUDPLATFORMVALUES_AZURE_VM,
  CLOUDPLATFORMVALUES_GCP_APP_ENGINE: () => CLOUDPLATFORMVALUES_GCP_APP_ENGINE,
  CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: () => CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
  CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: () => CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
  CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: () => CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
  CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: () => CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
  CLOUDPROVIDERVALUES_ALIBABA_CLOUD: () => CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
  CLOUDPROVIDERVALUES_AWS: () => CLOUDPROVIDERVALUES_AWS,
  CLOUDPROVIDERVALUES_AZURE: () => CLOUDPROVIDERVALUES_AZURE,
  CLOUDPROVIDERVALUES_GCP: () => CLOUDPROVIDERVALUES_GCP,
  CloudPlatformValues: () => CloudPlatformValues,
  CloudProviderValues: () => CloudProviderValues,
  DBCASSANDRACONSISTENCYLEVELVALUES_ALL: () => DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
  DBCASSANDRACONSISTENCYLEVELVALUES_ANY: () => DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
  DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL,
  DBCASSANDRACONSISTENCYLEVELVALUES_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
  DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
  DBCASSANDRACONSISTENCYLEVELVALUES_THREE: () => DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
  DBCASSANDRACONSISTENCYLEVELVALUES_TWO: () => DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
  DBSYSTEMVALUES_ADABAS: () => DBSYSTEMVALUES_ADABAS,
  DBSYSTEMVALUES_CACHE: () => DBSYSTEMVALUES_CACHE,
  DBSYSTEMVALUES_CASSANDRA: () => DBSYSTEMVALUES_CASSANDRA,
  DBSYSTEMVALUES_CLOUDSCAPE: () => DBSYSTEMVALUES_CLOUDSCAPE,
  DBSYSTEMVALUES_COCKROACHDB: () => DBSYSTEMVALUES_COCKROACHDB,
  DBSYSTEMVALUES_COLDFUSION: () => DBSYSTEMVALUES_COLDFUSION,
  DBSYSTEMVALUES_COSMOSDB: () => DBSYSTEMVALUES_COSMOSDB,
  DBSYSTEMVALUES_COUCHBASE: () => DBSYSTEMVALUES_COUCHBASE,
  DBSYSTEMVALUES_COUCHDB: () => DBSYSTEMVALUES_COUCHDB,
  DBSYSTEMVALUES_DB2: () => DBSYSTEMVALUES_DB2,
  DBSYSTEMVALUES_DERBY: () => DBSYSTEMVALUES_DERBY,
  DBSYSTEMVALUES_DYNAMODB: () => DBSYSTEMVALUES_DYNAMODB,
  DBSYSTEMVALUES_EDB: () => DBSYSTEMVALUES_EDB,
  DBSYSTEMVALUES_ELASTICSEARCH: () => DBSYSTEMVALUES_ELASTICSEARCH,
  DBSYSTEMVALUES_FILEMAKER: () => DBSYSTEMVALUES_FILEMAKER,
  DBSYSTEMVALUES_FIREBIRD: () => DBSYSTEMVALUES_FIREBIRD,
  DBSYSTEMVALUES_FIRSTSQL: () => DBSYSTEMVALUES_FIRSTSQL,
  DBSYSTEMVALUES_GEODE: () => DBSYSTEMVALUES_GEODE,
  DBSYSTEMVALUES_H2: () => DBSYSTEMVALUES_H2,
  DBSYSTEMVALUES_HANADB: () => DBSYSTEMVALUES_HANADB,
  DBSYSTEMVALUES_HBASE: () => DBSYSTEMVALUES_HBASE,
  DBSYSTEMVALUES_HIVE: () => DBSYSTEMVALUES_HIVE,
  DBSYSTEMVALUES_HSQLDB: () => DBSYSTEMVALUES_HSQLDB,
  DBSYSTEMVALUES_INFORMIX: () => DBSYSTEMVALUES_INFORMIX,
  DBSYSTEMVALUES_INGRES: () => DBSYSTEMVALUES_INGRES,
  DBSYSTEMVALUES_INSTANTDB: () => DBSYSTEMVALUES_INSTANTDB,
  DBSYSTEMVALUES_INTERBASE: () => DBSYSTEMVALUES_INTERBASE,
  DBSYSTEMVALUES_MARIADB: () => DBSYSTEMVALUES_MARIADB,
  DBSYSTEMVALUES_MAXDB: () => DBSYSTEMVALUES_MAXDB,
  DBSYSTEMVALUES_MEMCACHED: () => DBSYSTEMVALUES_MEMCACHED,
  DBSYSTEMVALUES_MONGODB: () => DBSYSTEMVALUES_MONGODB,
  DBSYSTEMVALUES_MSSQL: () => DBSYSTEMVALUES_MSSQL,
  DBSYSTEMVALUES_MYSQL: () => DBSYSTEMVALUES_MYSQL,
  DBSYSTEMVALUES_NEO4J: () => DBSYSTEMVALUES_NEO4J,
  DBSYSTEMVALUES_NETEZZA: () => DBSYSTEMVALUES_NETEZZA,
  DBSYSTEMVALUES_ORACLE: () => DBSYSTEMVALUES_ORACLE,
  DBSYSTEMVALUES_OTHER_SQL: () => DBSYSTEMVALUES_OTHER_SQL,
  DBSYSTEMVALUES_PERVASIVE: () => DBSYSTEMVALUES_PERVASIVE,
  DBSYSTEMVALUES_POINTBASE: () => DBSYSTEMVALUES_POINTBASE,
  DBSYSTEMVALUES_POSTGRESQL: () => DBSYSTEMVALUES_POSTGRESQL,
  DBSYSTEMVALUES_PROGRESS: () => DBSYSTEMVALUES_PROGRESS,
  DBSYSTEMVALUES_REDIS: () => DBSYSTEMVALUES_REDIS,
  DBSYSTEMVALUES_REDSHIFT: () => DBSYSTEMVALUES_REDSHIFT,
  DBSYSTEMVALUES_SQLITE: () => DBSYSTEMVALUES_SQLITE,
  DBSYSTEMVALUES_SYBASE: () => DBSYSTEMVALUES_SYBASE,
  DBSYSTEMVALUES_TERADATA: () => DBSYSTEMVALUES_TERADATA,
  DBSYSTEMVALUES_VERTICA: () => DBSYSTEMVALUES_VERTICA,
  DB_SYSTEM_NAME_VALUE_MARIADB: () => DB_SYSTEM_NAME_VALUE_MARIADB,
  DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER: () => DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER,
  DB_SYSTEM_NAME_VALUE_MYSQL: () => DB_SYSTEM_NAME_VALUE_MYSQL,
  DB_SYSTEM_NAME_VALUE_POSTGRESQL: () => DB_SYSTEM_NAME_VALUE_POSTGRESQL,
  DOTNET_GC_HEAP_GENERATION_VALUE_GEN0: () => DOTNET_GC_HEAP_GENERATION_VALUE_GEN0,
  DOTNET_GC_HEAP_GENERATION_VALUE_GEN1: () => DOTNET_GC_HEAP_GENERATION_VALUE_GEN1,
  DOTNET_GC_HEAP_GENERATION_VALUE_GEN2: () => DOTNET_GC_HEAP_GENERATION_VALUE_GEN2,
  DOTNET_GC_HEAP_GENERATION_VALUE_LOH: () => DOTNET_GC_HEAP_GENERATION_VALUE_LOH,
  DOTNET_GC_HEAP_GENERATION_VALUE_POH: () => DOTNET_GC_HEAP_GENERATION_VALUE_POH,
  DbCassandraConsistencyLevelValues: () => DbCassandraConsistencyLevelValues,
  DbSystemValues: () => DbSystemValues,
  ERROR_TYPE_VALUE_OTHER: () => ERROR_TYPE_VALUE_OTHER,
  FAASDOCUMENTOPERATIONVALUES_DELETE: () => FAASDOCUMENTOPERATIONVALUES_DELETE,
  FAASDOCUMENTOPERATIONVALUES_EDIT: () => FAASDOCUMENTOPERATIONVALUES_EDIT,
  FAASDOCUMENTOPERATIONVALUES_INSERT: () => FAASDOCUMENTOPERATIONVALUES_INSERT,
  FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: () => FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
  FAASINVOKEDPROVIDERVALUES_AWS: () => FAASINVOKEDPROVIDERVALUES_AWS,
  FAASINVOKEDPROVIDERVALUES_AZURE: () => FAASINVOKEDPROVIDERVALUES_AZURE,
  FAASINVOKEDPROVIDERVALUES_GCP: () => FAASINVOKEDPROVIDERVALUES_GCP,
  FAASTRIGGERVALUES_DATASOURCE: () => FAASTRIGGERVALUES_DATASOURCE,
  FAASTRIGGERVALUES_HTTP: () => FAASTRIGGERVALUES_HTTP,
  FAASTRIGGERVALUES_OTHER: () => FAASTRIGGERVALUES_OTHER,
  FAASTRIGGERVALUES_PUBSUB: () => FAASTRIGGERVALUES_PUBSUB,
  FAASTRIGGERVALUES_TIMER: () => FAASTRIGGERVALUES_TIMER,
  FaasDocumentOperationValues: () => FaasDocumentOperationValues,
  FaasInvokedProviderValues: () => FaasInvokedProviderValues,
  FaasTriggerValues: () => FaasTriggerValues,
  HOSTARCHVALUES_AMD64: () => HOSTARCHVALUES_AMD64,
  HOSTARCHVALUES_ARM32: () => HOSTARCHVALUES_ARM32,
  HOSTARCHVALUES_ARM64: () => HOSTARCHVALUES_ARM64,
  HOSTARCHVALUES_IA64: () => HOSTARCHVALUES_IA64,
  HOSTARCHVALUES_PPC32: () => HOSTARCHVALUES_PPC32,
  HOSTARCHVALUES_PPC64: () => HOSTARCHVALUES_PPC64,
  HOSTARCHVALUES_X86: () => HOSTARCHVALUES_X86,
  HTTPFLAVORVALUES_HTTP_1_0: () => HTTPFLAVORVALUES_HTTP_1_0,
  HTTPFLAVORVALUES_HTTP_1_1: () => HTTPFLAVORVALUES_HTTP_1_1,
  HTTPFLAVORVALUES_HTTP_2_0: () => HTTPFLAVORVALUES_HTTP_2_0,
  HTTPFLAVORVALUES_QUIC: () => HTTPFLAVORVALUES_QUIC,
  HTTPFLAVORVALUES_SPDY: () => HTTPFLAVORVALUES_SPDY,
  HTTP_REQUEST_METHOD_VALUE_CONNECT: () => HTTP_REQUEST_METHOD_VALUE_CONNECT,
  HTTP_REQUEST_METHOD_VALUE_DELETE: () => HTTP_REQUEST_METHOD_VALUE_DELETE,
  HTTP_REQUEST_METHOD_VALUE_GET: () => HTTP_REQUEST_METHOD_VALUE_GET,
  HTTP_REQUEST_METHOD_VALUE_HEAD: () => HTTP_REQUEST_METHOD_VALUE_HEAD,
  HTTP_REQUEST_METHOD_VALUE_OPTIONS: () => HTTP_REQUEST_METHOD_VALUE_OPTIONS,
  HTTP_REQUEST_METHOD_VALUE_OTHER: () => HTTP_REQUEST_METHOD_VALUE_OTHER,
  HTTP_REQUEST_METHOD_VALUE_PATCH: () => HTTP_REQUEST_METHOD_VALUE_PATCH,
  HTTP_REQUEST_METHOD_VALUE_POST: () => HTTP_REQUEST_METHOD_VALUE_POST,
  HTTP_REQUEST_METHOD_VALUE_PUT: () => HTTP_REQUEST_METHOD_VALUE_PUT,
  HTTP_REQUEST_METHOD_VALUE_TRACE: () => HTTP_REQUEST_METHOD_VALUE_TRACE,
  HostArchValues: () => HostArchValues,
  HttpFlavorValues: () => HttpFlavorValues,
  JVM_MEMORY_TYPE_VALUE_HEAP: () => JVM_MEMORY_TYPE_VALUE_HEAP,
  JVM_MEMORY_TYPE_VALUE_NON_HEAP: () => JVM_MEMORY_TYPE_VALUE_NON_HEAP,
  JVM_THREAD_STATE_VALUE_BLOCKED: () => JVM_THREAD_STATE_VALUE_BLOCKED,
  JVM_THREAD_STATE_VALUE_NEW: () => JVM_THREAD_STATE_VALUE_NEW,
  JVM_THREAD_STATE_VALUE_RUNNABLE: () => JVM_THREAD_STATE_VALUE_RUNNABLE,
  JVM_THREAD_STATE_VALUE_TERMINATED: () => JVM_THREAD_STATE_VALUE_TERMINATED,
  JVM_THREAD_STATE_VALUE_TIMED_WAITING: () => JVM_THREAD_STATE_VALUE_TIMED_WAITING,
  JVM_THREAD_STATE_VALUE_WAITING: () => JVM_THREAD_STATE_VALUE_WAITING,
  MESSAGETYPEVALUES_RECEIVED: () => MESSAGETYPEVALUES_RECEIVED,
  MESSAGETYPEVALUES_SENT: () => MESSAGETYPEVALUES_SENT,
  MESSAGINGDESTINATIONKINDVALUES_QUEUE: () => MESSAGINGDESTINATIONKINDVALUES_QUEUE,
  MESSAGINGDESTINATIONKINDVALUES_TOPIC: () => MESSAGINGDESTINATIONKINDVALUES_TOPIC,
  MESSAGINGOPERATIONVALUES_PROCESS: () => MESSAGINGOPERATIONVALUES_PROCESS,
  MESSAGINGOPERATIONVALUES_RECEIVE: () => MESSAGINGOPERATIONVALUES_RECEIVE,
  METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS: () => METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS,
  METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES: () => METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES,
  METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE,
  METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS: () => METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS,
  METRIC_DB_CLIENT_OPERATION_DURATION: () => METRIC_DB_CLIENT_OPERATION_DURATION,
  METRIC_DOTNET_ASSEMBLY_COUNT: () => METRIC_DOTNET_ASSEMBLY_COUNT,
  METRIC_DOTNET_EXCEPTIONS: () => METRIC_DOTNET_EXCEPTIONS,
  METRIC_DOTNET_GC_COLLECTIONS: () => METRIC_DOTNET_GC_COLLECTIONS,
  METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED: () => METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED,
  METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE: () => METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE,
  METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE: () => METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE,
  METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE: () => METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE,
  METRIC_DOTNET_GC_PAUSE_TIME: () => METRIC_DOTNET_GC_PAUSE_TIME,
  METRIC_DOTNET_JIT_COMPILATION_TIME: () => METRIC_DOTNET_JIT_COMPILATION_TIME,
  METRIC_DOTNET_JIT_COMPILED_IL_SIZE: () => METRIC_DOTNET_JIT_COMPILED_IL_SIZE,
  METRIC_DOTNET_JIT_COMPILED_METHODS: () => METRIC_DOTNET_JIT_COMPILED_METHODS,
  METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS: () => METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS,
  METRIC_DOTNET_PROCESS_CPU_COUNT: () => METRIC_DOTNET_PROCESS_CPU_COUNT,
  METRIC_DOTNET_PROCESS_CPU_TIME: () => METRIC_DOTNET_PROCESS_CPU_TIME,
  METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET: () => METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET,
  METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH: () => METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH,
  METRIC_DOTNET_THREAD_POOL_THREAD_COUNT: () => METRIC_DOTNET_THREAD_POOL_THREAD_COUNT,
  METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT: () => METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT,
  METRIC_DOTNET_TIMER_COUNT: () => METRIC_DOTNET_TIMER_COUNT,
  METRIC_HTTP_CLIENT_REQUEST_DURATION: () => METRIC_HTTP_CLIENT_REQUEST_DURATION,
  METRIC_HTTP_SERVER_REQUEST_DURATION: () => METRIC_HTTP_SERVER_REQUEST_DURATION,
  METRIC_JVM_CLASS_COUNT: () => METRIC_JVM_CLASS_COUNT,
  METRIC_JVM_CLASS_LOADED: () => METRIC_JVM_CLASS_LOADED,
  METRIC_JVM_CLASS_UNLOADED: () => METRIC_JVM_CLASS_UNLOADED,
  METRIC_JVM_CPU_COUNT: () => METRIC_JVM_CPU_COUNT,
  METRIC_JVM_CPU_RECENT_UTILIZATION: () => METRIC_JVM_CPU_RECENT_UTILIZATION,
  METRIC_JVM_CPU_TIME: () => METRIC_JVM_CPU_TIME,
  METRIC_JVM_GC_DURATION: () => METRIC_JVM_GC_DURATION,
  METRIC_JVM_MEMORY_COMMITTED: () => METRIC_JVM_MEMORY_COMMITTED,
  METRIC_JVM_MEMORY_LIMIT: () => METRIC_JVM_MEMORY_LIMIT,
  METRIC_JVM_MEMORY_USED: () => METRIC_JVM_MEMORY_USED,
  METRIC_JVM_MEMORY_USED_AFTER_LAST_GC: () => METRIC_JVM_MEMORY_USED_AFTER_LAST_GC,
  METRIC_JVM_THREAD_COUNT: () => METRIC_JVM_THREAD_COUNT,
  METRIC_KESTREL_ACTIVE_CONNECTIONS: () => METRIC_KESTREL_ACTIVE_CONNECTIONS,
  METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES: () => METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES,
  METRIC_KESTREL_CONNECTION_DURATION: () => METRIC_KESTREL_CONNECTION_DURATION,
  METRIC_KESTREL_QUEUED_CONNECTIONS: () => METRIC_KESTREL_QUEUED_CONNECTIONS,
  METRIC_KESTREL_QUEUED_REQUESTS: () => METRIC_KESTREL_QUEUED_REQUESTS,
  METRIC_KESTREL_REJECTED_CONNECTIONS: () => METRIC_KESTREL_REJECTED_CONNECTIONS,
  METRIC_KESTREL_TLS_HANDSHAKE_DURATION: () => METRIC_KESTREL_TLS_HANDSHAKE_DURATION,
  METRIC_KESTREL_UPGRADED_CONNECTIONS: () => METRIC_KESTREL_UPGRADED_CONNECTIONS,
  METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS: () => METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS,
  METRIC_SIGNALR_SERVER_CONNECTION_DURATION: () => METRIC_SIGNALR_SERVER_CONNECTION_DURATION,
  MessageTypeValues: () => MessageTypeValues,
  MessagingDestinationKindValues: () => MessagingDestinationKindValues,
  MessagingOperationValues: () => MessagingOperationValues,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
  NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: () => NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
  NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: () => NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
  NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: () => NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
  NETHOSTCONNECTIONSUBTYPEVALUES_GSM: () => NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
  NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA,
  NETHOSTCONNECTIONSUBTYPEVALUES_NR: () => NETHOSTCONNECTIONSUBTYPEVALUES_NR,
  NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: () => NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
  NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
  NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: () => NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
  NETHOSTCONNECTIONTYPEVALUES_CELL: () => NETHOSTCONNECTIONTYPEVALUES_CELL,
  NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: () => NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
  NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: () => NETHOSTCONNECTIONTYPEVALUES_UNKNOWN,
  NETHOSTCONNECTIONTYPEVALUES_WIFI: () => NETHOSTCONNECTIONTYPEVALUES_WIFI,
  NETHOSTCONNECTIONTYPEVALUES_WIRED: () => NETHOSTCONNECTIONTYPEVALUES_WIRED,
  NETTRANSPORTVALUES_INPROC: () => NETTRANSPORTVALUES_INPROC,
  NETTRANSPORTVALUES_IP: () => NETTRANSPORTVALUES_IP,
  NETTRANSPORTVALUES_IP_TCP: () => NETTRANSPORTVALUES_IP_TCP,
  NETTRANSPORTVALUES_IP_UDP: () => NETTRANSPORTVALUES_IP_UDP,
  NETTRANSPORTVALUES_OTHER: () => NETTRANSPORTVALUES_OTHER,
  NETTRANSPORTVALUES_PIPE: () => NETTRANSPORTVALUES_PIPE,
  NETTRANSPORTVALUES_UNIX: () => NETTRANSPORTVALUES_UNIX,
  NETWORK_TRANSPORT_VALUE_PIPE: () => NETWORK_TRANSPORT_VALUE_PIPE,
  NETWORK_TRANSPORT_VALUE_QUIC: () => NETWORK_TRANSPORT_VALUE_QUIC,
  NETWORK_TRANSPORT_VALUE_TCP: () => NETWORK_TRANSPORT_VALUE_TCP,
  NETWORK_TRANSPORT_VALUE_UDP: () => NETWORK_TRANSPORT_VALUE_UDP,
  NETWORK_TRANSPORT_VALUE_UNIX: () => NETWORK_TRANSPORT_VALUE_UNIX,
  NETWORK_TYPE_VALUE_IPV4: () => NETWORK_TYPE_VALUE_IPV4,
  NETWORK_TYPE_VALUE_IPV6: () => NETWORK_TYPE_VALUE_IPV6,
  NetHostConnectionSubtypeValues: () => NetHostConnectionSubtypeValues,
  NetHostConnectionTypeValues: () => NetHostConnectionTypeValues,
  NetTransportValues: () => NetTransportValues,
  OSTYPEVALUES_AIX: () => OSTYPEVALUES_AIX,
  OSTYPEVALUES_DARWIN: () => OSTYPEVALUES_DARWIN,
  OSTYPEVALUES_DRAGONFLYBSD: () => OSTYPEVALUES_DRAGONFLYBSD,
  OSTYPEVALUES_FREEBSD: () => OSTYPEVALUES_FREEBSD,
  OSTYPEVALUES_HPUX: () => OSTYPEVALUES_HPUX,
  OSTYPEVALUES_LINUX: () => OSTYPEVALUES_LINUX,
  OSTYPEVALUES_NETBSD: () => OSTYPEVALUES_NETBSD,
  OSTYPEVALUES_OPENBSD: () => OSTYPEVALUES_OPENBSD,
  OSTYPEVALUES_SOLARIS: () => OSTYPEVALUES_SOLARIS,
  OSTYPEVALUES_WINDOWS: () => OSTYPEVALUES_WINDOWS,
  OSTYPEVALUES_Z_OS: () => OSTYPEVALUES_Z_OS,
  OTEL_STATUS_CODE_VALUE_ERROR: () => OTEL_STATUS_CODE_VALUE_ERROR,
  OTEL_STATUS_CODE_VALUE_OK: () => OTEL_STATUS_CODE_VALUE_OK,
  OsTypeValues: () => OsTypeValues,
  RPCGRPCSTATUSCODEVALUES_ABORTED: () => RPCGRPCSTATUSCODEVALUES_ABORTED,
  RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: () => RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
  RPCGRPCSTATUSCODEVALUES_CANCELLED: () => RPCGRPCSTATUSCODEVALUES_CANCELLED,
  RPCGRPCSTATUSCODEVALUES_DATA_LOSS: () => RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
  RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: () => RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
  RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: () => RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
  RPCGRPCSTATUSCODEVALUES_INTERNAL: () => RPCGRPCSTATUSCODEVALUES_INTERNAL,
  RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: () => RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
  RPCGRPCSTATUSCODEVALUES_NOT_FOUND: () => RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
  RPCGRPCSTATUSCODEVALUES_OK: () => RPCGRPCSTATUSCODEVALUES_OK,
  RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: () => RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
  RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: () => RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
  RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: () => RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
  RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: () => RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED,
  RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: () => RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
  RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: () => RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
  RPCGRPCSTATUSCODEVALUES_UNKNOWN: () => RPCGRPCSTATUSCODEVALUES_UNKNOWN,
  RpcGrpcStatusCodeValues: () => RpcGrpcStatusCodeValues,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
  SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: () => SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ,
  SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_COUNT: () => SEMATTRS_AWS_DYNAMODB_COUNT,
  SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: () => SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
  SEMATTRS_AWS_DYNAMODB_INDEX_NAME: () => SEMATTRS_AWS_DYNAMODB_INDEX_NAME,
  SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: () => SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
  SEMATTRS_AWS_DYNAMODB_LIMIT: () => SEMATTRS_AWS_DYNAMODB_LIMIT,
  SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
  SEMATTRS_AWS_DYNAMODB_PROJECTION: () => SEMATTRS_AWS_DYNAMODB_PROJECTION,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: () => SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT,
  SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: () => SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD,
  SEMATTRS_AWS_DYNAMODB_SEGMENT: () => SEMATTRS_AWS_DYNAMODB_SEGMENT,
  SEMATTRS_AWS_DYNAMODB_SELECT: () => SEMATTRS_AWS_DYNAMODB_SELECT,
  SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: () => SEMATTRS_AWS_DYNAMODB_TABLE_COUNT,
  SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: () => SEMATTRS_AWS_DYNAMODB_TABLE_NAMES,
  SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: () => SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS,
  SEMATTRS_AWS_LAMBDA_INVOKED_ARN: () => SEMATTRS_AWS_LAMBDA_INVOKED_ARN,
  SEMATTRS_CODE_FILEPATH: () => SEMATTRS_CODE_FILEPATH,
  SEMATTRS_CODE_FUNCTION: () => SEMATTRS_CODE_FUNCTION,
  SEMATTRS_CODE_LINENO: () => SEMATTRS_CODE_LINENO,
  SEMATTRS_CODE_NAMESPACE: () => SEMATTRS_CODE_NAMESPACE,
  SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: () => SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_DC,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_ID,
  SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: () => SEMATTRS_DB_CASSANDRA_IDEMPOTENCE,
  SEMATTRS_DB_CASSANDRA_KEYSPACE: () => SEMATTRS_DB_CASSANDRA_KEYSPACE,
  SEMATTRS_DB_CASSANDRA_PAGE_SIZE: () => SEMATTRS_DB_CASSANDRA_PAGE_SIZE,
  SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: () => SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
  SEMATTRS_DB_CASSANDRA_TABLE: () => SEMATTRS_DB_CASSANDRA_TABLE,
  SEMATTRS_DB_CONNECTION_STRING: () => SEMATTRS_DB_CONNECTION_STRING,
  SEMATTRS_DB_HBASE_NAMESPACE: () => SEMATTRS_DB_HBASE_NAMESPACE,
  SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: () => SEMATTRS_DB_JDBC_DRIVER_CLASSNAME,
  SEMATTRS_DB_MONGODB_COLLECTION: () => SEMATTRS_DB_MONGODB_COLLECTION,
  SEMATTRS_DB_MSSQL_INSTANCE_NAME: () => SEMATTRS_DB_MSSQL_INSTANCE_NAME,
  SEMATTRS_DB_NAME: () => SEMATTRS_DB_NAME,
  SEMATTRS_DB_OPERATION: () => SEMATTRS_DB_OPERATION,
  SEMATTRS_DB_REDIS_DATABASE_INDEX: () => SEMATTRS_DB_REDIS_DATABASE_INDEX,
  SEMATTRS_DB_SQL_TABLE: () => SEMATTRS_DB_SQL_TABLE,
  SEMATTRS_DB_STATEMENT: () => SEMATTRS_DB_STATEMENT,
  SEMATTRS_DB_SYSTEM: () => SEMATTRS_DB_SYSTEM,
  SEMATTRS_DB_USER: () => SEMATTRS_DB_USER,
  SEMATTRS_ENDUSER_ID: () => SEMATTRS_ENDUSER_ID,
  SEMATTRS_ENDUSER_ROLE: () => SEMATTRS_ENDUSER_ROLE,
  SEMATTRS_ENDUSER_SCOPE: () => SEMATTRS_ENDUSER_SCOPE,
  SEMATTRS_EXCEPTION_ESCAPED: () => SEMATTRS_EXCEPTION_ESCAPED,
  SEMATTRS_EXCEPTION_MESSAGE: () => SEMATTRS_EXCEPTION_MESSAGE,
  SEMATTRS_EXCEPTION_STACKTRACE: () => SEMATTRS_EXCEPTION_STACKTRACE,
  SEMATTRS_EXCEPTION_TYPE: () => SEMATTRS_EXCEPTION_TYPE,
  SEMATTRS_FAAS_COLDSTART: () => SEMATTRS_FAAS_COLDSTART,
  SEMATTRS_FAAS_CRON: () => SEMATTRS_FAAS_CRON,
  SEMATTRS_FAAS_DOCUMENT_COLLECTION: () => SEMATTRS_FAAS_DOCUMENT_COLLECTION,
  SEMATTRS_FAAS_DOCUMENT_NAME: () => SEMATTRS_FAAS_DOCUMENT_NAME,
  SEMATTRS_FAAS_DOCUMENT_OPERATION: () => SEMATTRS_FAAS_DOCUMENT_OPERATION,
  SEMATTRS_FAAS_DOCUMENT_TIME: () => SEMATTRS_FAAS_DOCUMENT_TIME,
  SEMATTRS_FAAS_EXECUTION: () => SEMATTRS_FAAS_EXECUTION,
  SEMATTRS_FAAS_INVOKED_NAME: () => SEMATTRS_FAAS_INVOKED_NAME,
  SEMATTRS_FAAS_INVOKED_PROVIDER: () => SEMATTRS_FAAS_INVOKED_PROVIDER,
  SEMATTRS_FAAS_INVOKED_REGION: () => SEMATTRS_FAAS_INVOKED_REGION,
  SEMATTRS_FAAS_TIME: () => SEMATTRS_FAAS_TIME,
  SEMATTRS_FAAS_TRIGGER: () => SEMATTRS_FAAS_TRIGGER,
  SEMATTRS_HTTP_CLIENT_IP: () => SEMATTRS_HTTP_CLIENT_IP,
  SEMATTRS_HTTP_FLAVOR: () => SEMATTRS_HTTP_FLAVOR,
  SEMATTRS_HTTP_HOST: () => SEMATTRS_HTTP_HOST,
  SEMATTRS_HTTP_METHOD: () => SEMATTRS_HTTP_METHOD,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_ROUTE: () => SEMATTRS_HTTP_ROUTE,
  SEMATTRS_HTTP_SCHEME: () => SEMATTRS_HTTP_SCHEME,
  SEMATTRS_HTTP_SERVER_NAME: () => SEMATTRS_HTTP_SERVER_NAME,
  SEMATTRS_HTTP_STATUS_CODE: () => SEMATTRS_HTTP_STATUS_CODE,
  SEMATTRS_HTTP_TARGET: () => SEMATTRS_HTTP_TARGET,
  SEMATTRS_HTTP_URL: () => SEMATTRS_HTTP_URL,
  SEMATTRS_HTTP_USER_AGENT: () => SEMATTRS_HTTP_USER_AGENT,
  SEMATTRS_MESSAGE_COMPRESSED_SIZE: () => SEMATTRS_MESSAGE_COMPRESSED_SIZE,
  SEMATTRS_MESSAGE_ID: () => SEMATTRS_MESSAGE_ID,
  SEMATTRS_MESSAGE_TYPE: () => SEMATTRS_MESSAGE_TYPE,
  SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: () => SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE,
  SEMATTRS_MESSAGING_CONSUMER_ID: () => SEMATTRS_MESSAGING_CONSUMER_ID,
  SEMATTRS_MESSAGING_CONVERSATION_ID: () => SEMATTRS_MESSAGING_CONVERSATION_ID,
  SEMATTRS_MESSAGING_DESTINATION: () => SEMATTRS_MESSAGING_DESTINATION,
  SEMATTRS_MESSAGING_DESTINATION_KIND: () => SEMATTRS_MESSAGING_DESTINATION_KIND,
  SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: () => SEMATTRS_MESSAGING_KAFKA_CLIENT_ID,
  SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: () => SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP,
  SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: () => SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY,
  SEMATTRS_MESSAGING_KAFKA_PARTITION: () => SEMATTRS_MESSAGING_KAFKA_PARTITION,
  SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: () => SEMATTRS_MESSAGING_KAFKA_TOMBSTONE,
  SEMATTRS_MESSAGING_MESSAGE_ID: () => SEMATTRS_MESSAGING_MESSAGE_ID,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
  SEMATTRS_MESSAGING_OPERATION: () => SEMATTRS_MESSAGING_OPERATION,
  SEMATTRS_MESSAGING_PROTOCOL: () => SEMATTRS_MESSAGING_PROTOCOL,
  SEMATTRS_MESSAGING_PROTOCOL_VERSION: () => SEMATTRS_MESSAGING_PROTOCOL_VERSION,
  SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: () => SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY,
  SEMATTRS_MESSAGING_SYSTEM: () => SEMATTRS_MESSAGING_SYSTEM,
  SEMATTRS_MESSAGING_TEMP_DESTINATION: () => SEMATTRS_MESSAGING_TEMP_DESTINATION,
  SEMATTRS_MESSAGING_URL: () => SEMATTRS_MESSAGING_URL,
  SEMATTRS_NET_HOST_CARRIER_ICC: () => SEMATTRS_NET_HOST_CARRIER_ICC,
  SEMATTRS_NET_HOST_CARRIER_MCC: () => SEMATTRS_NET_HOST_CARRIER_MCC,
  SEMATTRS_NET_HOST_CARRIER_MNC: () => SEMATTRS_NET_HOST_CARRIER_MNC,
  SEMATTRS_NET_HOST_CARRIER_NAME: () => SEMATTRS_NET_HOST_CARRIER_NAME,
  SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: () => SEMATTRS_NET_HOST_CONNECTION_SUBTYPE,
  SEMATTRS_NET_HOST_CONNECTION_TYPE: () => SEMATTRS_NET_HOST_CONNECTION_TYPE,
  SEMATTRS_NET_HOST_IP: () => SEMATTRS_NET_HOST_IP,
  SEMATTRS_NET_HOST_NAME: () => SEMATTRS_NET_HOST_NAME,
  SEMATTRS_NET_HOST_PORT: () => SEMATTRS_NET_HOST_PORT,
  SEMATTRS_NET_PEER_IP: () => SEMATTRS_NET_PEER_IP,
  SEMATTRS_NET_PEER_NAME: () => SEMATTRS_NET_PEER_NAME,
  SEMATTRS_NET_PEER_PORT: () => SEMATTRS_NET_PEER_PORT,
  SEMATTRS_NET_TRANSPORT: () => SEMATTRS_NET_TRANSPORT,
  SEMATTRS_PEER_SERVICE: () => SEMATTRS_PEER_SERVICE,
  SEMATTRS_RPC_GRPC_STATUS_CODE: () => SEMATTRS_RPC_GRPC_STATUS_CODE,
  SEMATTRS_RPC_JSONRPC_ERROR_CODE: () => SEMATTRS_RPC_JSONRPC_ERROR_CODE,
  SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: () => SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE,
  SEMATTRS_RPC_JSONRPC_REQUEST_ID: () => SEMATTRS_RPC_JSONRPC_REQUEST_ID,
  SEMATTRS_RPC_JSONRPC_VERSION: () => SEMATTRS_RPC_JSONRPC_VERSION,
  SEMATTRS_RPC_METHOD: () => SEMATTRS_RPC_METHOD,
  SEMATTRS_RPC_SERVICE: () => SEMATTRS_RPC_SERVICE,
  SEMATTRS_RPC_SYSTEM: () => SEMATTRS_RPC_SYSTEM,
  SEMATTRS_THREAD_ID: () => SEMATTRS_THREAD_ID,
  SEMATTRS_THREAD_NAME: () => SEMATTRS_THREAD_NAME,
  SEMRESATTRS_AWS_ECS_CLUSTER_ARN: () => SEMRESATTRS_AWS_ECS_CLUSTER_ARN,
  SEMRESATTRS_AWS_ECS_CONTAINER_ARN: () => SEMRESATTRS_AWS_ECS_CONTAINER_ARN,
  SEMRESATTRS_AWS_ECS_LAUNCHTYPE: () => SEMRESATTRS_AWS_ECS_LAUNCHTYPE,
  SEMRESATTRS_AWS_ECS_TASK_ARN: () => SEMRESATTRS_AWS_ECS_TASK_ARN,
  SEMRESATTRS_AWS_ECS_TASK_FAMILY: () => SEMRESATTRS_AWS_ECS_TASK_FAMILY,
  SEMRESATTRS_AWS_ECS_TASK_REVISION: () => SEMRESATTRS_AWS_ECS_TASK_REVISION,
  SEMRESATTRS_AWS_EKS_CLUSTER_ARN: () => SEMRESATTRS_AWS_EKS_CLUSTER_ARN,
  SEMRESATTRS_AWS_LOG_GROUP_ARNS: () => SEMRESATTRS_AWS_LOG_GROUP_ARNS,
  SEMRESATTRS_AWS_LOG_GROUP_NAMES: () => SEMRESATTRS_AWS_LOG_GROUP_NAMES,
  SEMRESATTRS_AWS_LOG_STREAM_ARNS: () => SEMRESATTRS_AWS_LOG_STREAM_ARNS,
  SEMRESATTRS_AWS_LOG_STREAM_NAMES: () => SEMRESATTRS_AWS_LOG_STREAM_NAMES,
  SEMRESATTRS_CLOUD_ACCOUNT_ID: () => SEMRESATTRS_CLOUD_ACCOUNT_ID,
  SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: () => SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
  SEMRESATTRS_CLOUD_PLATFORM: () => SEMRESATTRS_CLOUD_PLATFORM,
  SEMRESATTRS_CLOUD_PROVIDER: () => SEMRESATTRS_CLOUD_PROVIDER,
  SEMRESATTRS_CLOUD_REGION: () => SEMRESATTRS_CLOUD_REGION,
  SEMRESATTRS_CONTAINER_ID: () => SEMRESATTRS_CONTAINER_ID,
  SEMRESATTRS_CONTAINER_IMAGE_NAME: () => SEMRESATTRS_CONTAINER_IMAGE_NAME,
  SEMRESATTRS_CONTAINER_IMAGE_TAG: () => SEMRESATTRS_CONTAINER_IMAGE_TAG,
  SEMRESATTRS_CONTAINER_NAME: () => SEMRESATTRS_CONTAINER_NAME,
  SEMRESATTRS_CONTAINER_RUNTIME: () => SEMRESATTRS_CONTAINER_RUNTIME,
  SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: () => SEMRESATTRS_DEPLOYMENT_ENVIRONMENT,
  SEMRESATTRS_DEVICE_ID: () => SEMRESATTRS_DEVICE_ID,
  SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: () => SEMRESATTRS_DEVICE_MODEL_IDENTIFIER,
  SEMRESATTRS_DEVICE_MODEL_NAME: () => SEMRESATTRS_DEVICE_MODEL_NAME,
  SEMRESATTRS_FAAS_ID: () => SEMRESATTRS_FAAS_ID,
  SEMRESATTRS_FAAS_INSTANCE: () => SEMRESATTRS_FAAS_INSTANCE,
  SEMRESATTRS_FAAS_MAX_MEMORY: () => SEMRESATTRS_FAAS_MAX_MEMORY,
  SEMRESATTRS_FAAS_NAME: () => SEMRESATTRS_FAAS_NAME,
  SEMRESATTRS_FAAS_VERSION: () => SEMRESATTRS_FAAS_VERSION,
  SEMRESATTRS_HOST_ARCH: () => SEMRESATTRS_HOST_ARCH,
  SEMRESATTRS_HOST_ID: () => SEMRESATTRS_HOST_ID,
  SEMRESATTRS_HOST_IMAGE_ID: () => SEMRESATTRS_HOST_IMAGE_ID,
  SEMRESATTRS_HOST_IMAGE_NAME: () => SEMRESATTRS_HOST_IMAGE_NAME,
  SEMRESATTRS_HOST_IMAGE_VERSION: () => SEMRESATTRS_HOST_IMAGE_VERSION,
  SEMRESATTRS_HOST_NAME: () => SEMRESATTRS_HOST_NAME,
  SEMRESATTRS_HOST_TYPE: () => SEMRESATTRS_HOST_TYPE,
  SEMRESATTRS_K8S_CLUSTER_NAME: () => SEMRESATTRS_K8S_CLUSTER_NAME,
  SEMRESATTRS_K8S_CONTAINER_NAME: () => SEMRESATTRS_K8S_CONTAINER_NAME,
  SEMRESATTRS_K8S_CRONJOB_NAME: () => SEMRESATTRS_K8S_CRONJOB_NAME,
  SEMRESATTRS_K8S_CRONJOB_UID: () => SEMRESATTRS_K8S_CRONJOB_UID,
  SEMRESATTRS_K8S_DAEMONSET_NAME: () => SEMRESATTRS_K8S_DAEMONSET_NAME,
  SEMRESATTRS_K8S_DAEMONSET_UID: () => SEMRESATTRS_K8S_DAEMONSET_UID,
  SEMRESATTRS_K8S_DEPLOYMENT_NAME: () => SEMRESATTRS_K8S_DEPLOYMENT_NAME,
  SEMRESATTRS_K8S_DEPLOYMENT_UID: () => SEMRESATTRS_K8S_DEPLOYMENT_UID,
  SEMRESATTRS_K8S_JOB_NAME: () => SEMRESATTRS_K8S_JOB_NAME,
  SEMRESATTRS_K8S_JOB_UID: () => SEMRESATTRS_K8S_JOB_UID,
  SEMRESATTRS_K8S_NAMESPACE_NAME: () => SEMRESATTRS_K8S_NAMESPACE_NAME,
  SEMRESATTRS_K8S_NODE_NAME: () => SEMRESATTRS_K8S_NODE_NAME,
  SEMRESATTRS_K8S_NODE_UID: () => SEMRESATTRS_K8S_NODE_UID,
  SEMRESATTRS_K8S_POD_NAME: () => SEMRESATTRS_K8S_POD_NAME,
  SEMRESATTRS_K8S_POD_UID: () => SEMRESATTRS_K8S_POD_UID,
  SEMRESATTRS_K8S_REPLICASET_NAME: () => SEMRESATTRS_K8S_REPLICASET_NAME,
  SEMRESATTRS_K8S_REPLICASET_UID: () => SEMRESATTRS_K8S_REPLICASET_UID,
  SEMRESATTRS_K8S_STATEFULSET_NAME: () => SEMRESATTRS_K8S_STATEFULSET_NAME,
  SEMRESATTRS_K8S_STATEFULSET_UID: () => SEMRESATTRS_K8S_STATEFULSET_UID,
  SEMRESATTRS_OS_DESCRIPTION: () => SEMRESATTRS_OS_DESCRIPTION,
  SEMRESATTRS_OS_NAME: () => SEMRESATTRS_OS_NAME,
  SEMRESATTRS_OS_TYPE: () => SEMRESATTRS_OS_TYPE,
  SEMRESATTRS_OS_VERSION: () => SEMRESATTRS_OS_VERSION,
  SEMRESATTRS_PROCESS_COMMAND: () => SEMRESATTRS_PROCESS_COMMAND,
  SEMRESATTRS_PROCESS_COMMAND_ARGS: () => SEMRESATTRS_PROCESS_COMMAND_ARGS,
  SEMRESATTRS_PROCESS_COMMAND_LINE: () => SEMRESATTRS_PROCESS_COMMAND_LINE,
  SEMRESATTRS_PROCESS_EXECUTABLE_NAME: () => SEMRESATTRS_PROCESS_EXECUTABLE_NAME,
  SEMRESATTRS_PROCESS_EXECUTABLE_PATH: () => SEMRESATTRS_PROCESS_EXECUTABLE_PATH,
  SEMRESATTRS_PROCESS_OWNER: () => SEMRESATTRS_PROCESS_OWNER,
  SEMRESATTRS_PROCESS_PID: () => SEMRESATTRS_PROCESS_PID,
  SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: () => SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION,
  SEMRESATTRS_PROCESS_RUNTIME_NAME: () => SEMRESATTRS_PROCESS_RUNTIME_NAME,
  SEMRESATTRS_PROCESS_RUNTIME_VERSION: () => SEMRESATTRS_PROCESS_RUNTIME_VERSION,
  SEMRESATTRS_SERVICE_INSTANCE_ID: () => SEMRESATTRS_SERVICE_INSTANCE_ID,
  SEMRESATTRS_SERVICE_NAME: () => SEMRESATTRS_SERVICE_NAME,
  SEMRESATTRS_SERVICE_NAMESPACE: () => SEMRESATTRS_SERVICE_NAMESPACE,
  SEMRESATTRS_SERVICE_VERSION: () => SEMRESATTRS_SERVICE_VERSION,
  SEMRESATTRS_TELEMETRY_AUTO_VERSION: () => SEMRESATTRS_TELEMETRY_AUTO_VERSION,
  SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: () => SEMRESATTRS_TELEMETRY_SDK_LANGUAGE,
  SEMRESATTRS_TELEMETRY_SDK_NAME: () => SEMRESATTRS_TELEMETRY_SDK_NAME,
  SEMRESATTRS_TELEMETRY_SDK_VERSION: () => SEMRESATTRS_TELEMETRY_SDK_VERSION,
  SEMRESATTRS_WEBENGINE_DESCRIPTION: () => SEMRESATTRS_WEBENGINE_DESCRIPTION,
  SEMRESATTRS_WEBENGINE_NAME: () => SEMRESATTRS_WEBENGINE_NAME,
  SEMRESATTRS_WEBENGINE_VERSION: () => SEMRESATTRS_WEBENGINE_VERSION,
  SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN: () => SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN,
  SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE: () => SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE,
  SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT: () => SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT,
  SIGNALR_TRANSPORT_VALUE_LONG_POLLING: () => SIGNALR_TRANSPORT_VALUE_LONG_POLLING,
  SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS: () => SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS,
  SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS: () => SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS,
  SemanticAttributes: () => SemanticAttributes,
  SemanticResourceAttributes: () => SemanticResourceAttributes,
  TELEMETRYSDKLANGUAGEVALUES_CPP: () => TELEMETRYSDKLANGUAGEVALUES_CPP,
  TELEMETRYSDKLANGUAGEVALUES_DOTNET: () => TELEMETRYSDKLANGUAGEVALUES_DOTNET,
  TELEMETRYSDKLANGUAGEVALUES_ERLANG: () => TELEMETRYSDKLANGUAGEVALUES_ERLANG,
  TELEMETRYSDKLANGUAGEVALUES_GO: () => TELEMETRYSDKLANGUAGEVALUES_GO,
  TELEMETRYSDKLANGUAGEVALUES_JAVA: () => TELEMETRYSDKLANGUAGEVALUES_JAVA,
  TELEMETRYSDKLANGUAGEVALUES_NODEJS: () => TELEMETRYSDKLANGUAGEVALUES_NODEJS,
  TELEMETRYSDKLANGUAGEVALUES_PHP: () => TELEMETRYSDKLANGUAGEVALUES_PHP,
  TELEMETRYSDKLANGUAGEVALUES_PYTHON: () => TELEMETRYSDKLANGUAGEVALUES_PYTHON,
  TELEMETRYSDKLANGUAGEVALUES_RUBY: () => TELEMETRYSDKLANGUAGEVALUES_RUBY,
  TELEMETRYSDKLANGUAGEVALUES_WEBJS: () => TELEMETRYSDKLANGUAGEVALUES_WEBJS,
  TELEMETRY_SDK_LANGUAGE_VALUE_CPP: () => TELEMETRY_SDK_LANGUAGE_VALUE_CPP,
  TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET: () => TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET,
  TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG: () => TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG,
  TELEMETRY_SDK_LANGUAGE_VALUE_GO: () => TELEMETRY_SDK_LANGUAGE_VALUE_GO,
  TELEMETRY_SDK_LANGUAGE_VALUE_JAVA: () => TELEMETRY_SDK_LANGUAGE_VALUE_JAVA,
  TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
  TELEMETRY_SDK_LANGUAGE_VALUE_PHP: () => TELEMETRY_SDK_LANGUAGE_VALUE_PHP,
  TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON: () => TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUBY: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUBY,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUST: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUST,
  TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT: () => TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT,
  TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS,
  TelemetrySdkLanguageValues: () => TelemetrySdkLanguageValues
});
var init_esm3 = __esm({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js"() {
    init_esm();
    init_trace2();
    init_resource();
    init_stable_attributes();
    init_stable_metrics();
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/semconv.js
var require_semconv = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/semconv.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATTR_PROCESS_RUNTIME_NAME = void 0;
    exports.ATTR_PROCESS_RUNTIME_NAME = "process.runtime.name";
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_INFO = void 0;
    var version_1 = require_version();
    var semantic_conventions_1 = (init_esm3(), __toCommonJS(esm_exports2));
    var semconv_1 = require_semconv();
    exports.SDK_INFO = {
      [semantic_conventions_1.ATTR_TELEMETRY_SDK_NAME]: "opentelemetry",
      [semconv_1.ATTR_PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.ATTR_TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
      [semantic_conventions_1.ATTR_TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    __name(unrefTimer, "unrefTimer");
    exports.unrefTimer = unrefTimer;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unrefTimer = exports.SDK_INFO = exports.otperformance = exports._globalThis = exports.getStringListFromEnv = exports.getNumberFromEnv = exports.getBooleanFromEnv = exports.getStringFromEnv = void 0;
    var environment_1 = require_environment();
    Object.defineProperty(exports, "getStringFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return environment_1.getStringFromEnv;
    }, "get") });
    Object.defineProperty(exports, "getBooleanFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return environment_1.getBooleanFromEnv;
    }, "get") });
    Object.defineProperty(exports, "getNumberFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return environment_1.getNumberFromEnv;
    }, "get") });
    Object.defineProperty(exports, "getStringListFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return environment_1.getStringListFromEnv;
    }, "get") });
    var globalThis_1 = require_globalThis();
    Object.defineProperty(exports, "_globalThis", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return globalThis_1._globalThis;
    }, "get") });
    var performance_1 = require_performance();
    Object.defineProperty(exports, "otperformance", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return performance_1.otperformance;
    }, "get") });
    var sdk_info_1 = require_sdk_info();
    Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return sdk_info_1.SDK_INFO;
    }, "get") });
    var timer_util_1 = require_timer_util();
    Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return timer_util_1.unrefTimer;
    }, "get") });
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/platform/index.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStringListFromEnv = exports.getNumberFromEnv = exports.getStringFromEnv = exports.getBooleanFromEnv = exports.unrefTimer = exports.otperformance = exports._globalThis = exports.SDK_INFO = void 0;
    var node_1 = require_node();
    Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_1.SDK_INFO;
    }, "get") });
    Object.defineProperty(exports, "_globalThis", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_1._globalThis;
    }, "get") });
    Object.defineProperty(exports, "otperformance", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_1.otperformance;
    }, "get") });
    Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_1.unrefTimer;
    }, "get") });
    Object.defineProperty(exports, "getBooleanFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_1.getBooleanFromEnv;
    }, "get") });
    Object.defineProperty(exports, "getStringFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_1.getStringFromEnv;
    }, "get") });
    Object.defineProperty(exports, "getNumberFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_1.getNumberFromEnv;
    }, "get") });
    Object.defineProperty(exports, "getStringListFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_1.getStringListFromEnv;
    }, "get") });
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/common/time.js
var require_time = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/common/time.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = void 0;
    var platform_1 = require_platform();
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      const epochSeconds = epochMillis / 1e3;
      const seconds = Math.trunc(epochSeconds);
      const nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    __name(millisToHrTime, "millisToHrTime");
    exports.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        const perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    __name(getTimeOrigin, "getTimeOrigin");
    exports.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      const timeOrigin = millisToHrTime(getTimeOrigin());
      const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    __name(hrTime, "hrTime");
    exports.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    __name(timeInputToHrTime, "timeInputToHrTime");
    exports.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0];
      let nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    __name(hrTimeDuration, "hrTimeDuration");
    exports.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      const precision = NANOSECOND_DIGITS;
      const tmp = `${"0".repeat(precision)}${time[1]}Z`;
      const nanoString = tmp.substring(tmp.length - precision - 1);
      const date = new Date(time[0] * 1e3).toISOString();
      return date.replace("000Z", nanoString);
    }
    __name(hrTimeToTimeStamp, "hrTimeToTimeStamp");
    exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    __name(hrTimeToNanoseconds, "hrTimeToNanoseconds");
    exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    __name(hrTimeToMilliseconds, "hrTimeToMilliseconds");
    exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    __name(hrTimeToMicroseconds, "hrTimeToMicroseconds");
    exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    __name(isTimeInputHrTime, "isTimeInputHrTime");
    exports.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    __name(isTimeInput, "isTimeInput");
    exports.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      const out = [time1[0] + time2[0], time1[1] + time2[1]];
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }
    __name(addHrTimes, "addHrTimes");
    exports.addHrTimes = addHrTimes;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExportResultCode = void 0;
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompositePropagator = void 0;
    var api_1 = (init_esm2(), __toCommonJS(esm_exports));
    var CompositePropagator = class {
      static {
        __name(this, "CompositePropagator");
      }
      _propagators;
      _fields;
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        this._propagators = config.propagators ?? [];
        this._fields = Array.from(new Set(this._propagators.map((p2) => typeof p2.fields === "function" ? p2.fields() : []).reduce((x, y2) => x.concat(y2), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context2, carrier, setter) {
        for (const propagator of this._propagators) {
          try {
            propagator.inject(context2, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
        }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context2, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context2);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports.CompositePropagator = CompositePropagator;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`;
    var VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`;
    var VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`);
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    __name(validateKey2, "validateKey");
    exports.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    __name(validateValue2, "validateValue");
    exports.validateValue = validateValue2;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceState = void 0;
    var validators_1 = require_validators();
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = class _TraceState {
      static {
        __name(this, "TraceState");
      }
      _internalState = /* @__PURE__ */ new Map();
      constructor(rawTraceState) {
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i2 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i2 !== -1) {
            const key = listMember.slice(0, i2);
            const value = listMember.slice(i2 + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports.TraceState = TraceState;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = void 0;
    var api_1 = (init_esm2(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    var TraceState_1 = require_TraceState();
    exports.TRACE_PARENT_HEADER = "traceparent";
    exports.TRACE_STATE_HEADER = "tracestate";
    var VERSION4 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      const match = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match)
        return null;
      if (match[1] === "00" && match[5])
        return null;
      return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    __name(parseTraceParent, "parseTraceParent");
    exports.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      static {
        __name(this, "W3CTraceContextPropagator");
      }
      inject(context2, carrier, setter) {
        const spanContext = api_1.trace.getSpanContext(context2);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context2) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        const traceParent = `${VERSION4}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      }
      extract(context2, carrier, getter) {
        const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context2;
        const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context2;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context2;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context2, spanContext);
      }
      fields() {
        return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
      }
    };
    exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = void 0;
    var api_1 = (init_esm2(), __toCommonJS(esm_exports));
    var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType = exports.RPCType || (exports.RPCType = {}));
    function setRPCMetadata(context2, meta) {
      return context2.setValue(RPC_METADATA_KEY, meta);
    }
    __name(setRPCMetadata, "setRPCMetadata");
    exports.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context2) {
      return context2.deleteValue(RPC_METADATA_KEY);
    }
    __name(deleteRPCMetadata, "deleteRPCMetadata");
    exports.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context2) {
      return context2.getValue(RPC_METADATA_KEY);
    }
    __name(getRPCMetadata, "getRPCMetadata");
    exports.getRPCMetadata = getRPCMetadata;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPlainObject = void 0;
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototypeOf = Object.getPrototypeOf;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      const proto = getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      const Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    __name(isPlainObject, "isPlainObject");
    exports.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    __name(baseGetTag, "baseGetTag");
    function getRawTag(value) {
      const isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      let unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e) {
      }
      const result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    __name(getRawTag, "getRawTag");
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    __name(objectToString, "objectToString");
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lodash_merge_1 = require_lodash_merge();
    var MAX_LEVEL = 20;
    function merge(...args) {
      let result = args.shift();
      const objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      }
      return result;
    }
    __name(merge, "merge");
    exports.merge = merge;
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    __name(takeValue, "takeValue");
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result = takeValue(two);
      } else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
          for (let i2 = 0, j = two.length; i2 < j; i2++) {
            result.push(takeValue(two[i2]));
          }
        } else if (isObject(two)) {
          const keys = Object.keys(two);
          for (let i2 = 0, j = keys.length; i2 < j; i2++) {
            const key = keys[i2];
            result[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result = Object.assign({}, one);
          const keys = Object.keys(two);
          for (let i2 = 0, j = keys.length; i2 < j; i2++) {
            const key = keys[i2];
            const twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result[key];
              } else {
                result[key] = twoValue;
              }
            } else {
              const obj1 = result[key];
              const obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  const arr1 = objects.get(obj1) || [];
                  const arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result = two;
        }
      }
      return result;
    }
    __name(mergeTwoObjects, "mergeTwoObjects");
    function wasObjectReferenced(obj, key, objects) {
      const arr = objects.get(obj[key]) || [];
      for (let i2 = 0, j = arr.length; i2 < j; i2++) {
        const info = arr[i2];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    __name(wasObjectReferenced, "wasObjectReferenced");
    function isArray(value) {
      return Array.isArray(value);
    }
    __name(isArray, "isArray");
    function isFunction(value) {
      return typeof value === "function";
    }
    __name(isFunction, "isFunction");
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    __name(isObject, "isObject");
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    __name(isPrimitive, "isPrimitive");
    function shouldMerge(one, two) {
      if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
        return false;
      }
      return true;
    }
    __name(shouldMerge, "shouldMerge");
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callWithTimeout = exports.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      static {
        __name(this, "TimeoutError");
      }
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout3) {
      let timeoutHandle;
      const timeoutPromise = new Promise(/* @__PURE__ */ __name(function timeoutFunction(_resolve, reject) {
        timeoutHandle = setTimeout(/* @__PURE__ */ __name(function timeoutHandler() {
          reject(new TimeoutError("Operation timed out."));
        }, "timeoutHandler"), timeout3);
      }, "timeoutFunction"));
      return Promise.race([promise, timeoutPromise]).then((result) => {
        clearTimeout(timeoutHandle);
        return result;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    __name(callWithTimeout, "callWithTimeout");
    exports.callWithTimeout = callWithTimeout;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/url.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUrlIgnored = exports.urlMatches = void 0;
    function urlMatches(url, urlToMatch) {
      if (typeof urlToMatch === "string") {
        return url === urlToMatch;
      } else {
        return !!url.match(urlToMatch);
      }
    }
    __name(urlMatches, "urlMatches");
    exports.urlMatches = urlMatches;
    function isUrlIgnored(url, ignoredUrls) {
      if (!ignoredUrls) {
        return false;
      }
      for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url, ignoreUrl)) {
          return true;
        }
      }
      return false;
    }
    __name(isUrlIgnored, "isUrlIgnored");
    exports.isUrlIgnored = isUrlIgnored;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deferred = void 0;
    var Deferred = class {
      static {
        __name(this, "Deferred");
      }
      _promise;
      _resolve;
      _reject;
      constructor() {
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports.Deferred = Deferred;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindOnceFuture = void 0;
    var promise_1 = require_promise();
    var BindOnceFuture = class {
      static {
        __name(this, "BindOnceFuture");
      }
      _callback;
      _that;
      _isCalled = false;
      _deferred = new promise_1.Deferred();
      constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports.BindOnceFuture = BindOnceFuture;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/configuration.js
var require_configuration = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/utils/configuration.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.diagLogLevelFromString = void 0;
    var api_1 = (init_esm2(), __toCommonJS(esm_exports));
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function diagLogLevelFromString(value) {
      if (value == null) {
        return void 0;
      }
      const resolvedLogLevel = logLevelMap[value.toUpperCase()];
      if (resolvedLogLevel == null) {
        api_1.diag.warn(`Unknown log level "${value}", expected one of ${Object.keys(logLevelMap)}, using default`);
        return api_1.DiagLogLevel.INFO;
      }
      return resolvedLogLevel;
    }
    __name(diagLogLevelFromString, "diagLogLevelFromString");
    exports.diagLogLevelFromString = diagLogLevelFromString;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._export = void 0;
    var api_1 = (init_esm2(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result) => {
            resolve(result);
          });
        });
      });
    }
    __name(_export, "_export");
    exports._export = _export;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/index.js
var require_src = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/core/build/src/index.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internal = exports.diagLogLevelFromString = exports.BindOnceFuture = exports.urlMatches = exports.isUrlIgnored = exports.callWithTimeout = exports.TimeoutError = exports.merge = exports.TraceState = exports.unsuppressTracing = exports.suppressTracing = exports.isTracingSuppressed = exports.setRPCMetadata = exports.getRPCMetadata = exports.deleteRPCMetadata = exports.RPCType = exports.parseTraceParent = exports.W3CTraceContextPropagator = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = exports.CompositePropagator = exports.unrefTimer = exports.otperformance = exports.getStringListFromEnv = exports.getNumberFromEnv = exports.getBooleanFromEnv = exports.getStringFromEnv = exports._globalThis = exports.SDK_INFO = exports.parseKeyPairsIntoRecord = exports.ExportResultCode = exports.timeInputToHrTime = exports.millisToHrTime = exports.isTimeInputHrTime = exports.isTimeInput = exports.hrTimeToTimeStamp = exports.hrTimeToNanoseconds = exports.hrTimeToMilliseconds = exports.hrTimeToMicroseconds = exports.hrTimeDuration = exports.hrTime = exports.getTimeOrigin = exports.addHrTimes = exports.loggingErrorHandler = exports.setGlobalErrorHandler = exports.globalErrorHandler = exports.sanitizeAttributes = exports.isAttributeValue = exports.AnchoredClock = exports.W3CBaggagePropagator = void 0;
    var W3CBaggagePropagator_1 = require_W3CBaggagePropagator();
    Object.defineProperty(exports, "W3CBaggagePropagator", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return W3CBaggagePropagator_1.W3CBaggagePropagator;
    }, "get") });
    var anchored_clock_1 = require_anchored_clock();
    Object.defineProperty(exports, "AnchoredClock", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return anchored_clock_1.AnchoredClock;
    }, "get") });
    var attributes_1 = require_attributes();
    Object.defineProperty(exports, "isAttributeValue", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return attributes_1.isAttributeValue;
    }, "get") });
    Object.defineProperty(exports, "sanitizeAttributes", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return attributes_1.sanitizeAttributes;
    }, "get") });
    var global_error_handler_1 = require_global_error_handler();
    Object.defineProperty(exports, "globalErrorHandler", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return global_error_handler_1.globalErrorHandler;
    }, "get") });
    Object.defineProperty(exports, "setGlobalErrorHandler", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return global_error_handler_1.setGlobalErrorHandler;
    }, "get") });
    var logging_error_handler_1 = require_logging_error_handler();
    Object.defineProperty(exports, "loggingErrorHandler", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return logging_error_handler_1.loggingErrorHandler;
    }, "get") });
    var time_1 = require_time();
    Object.defineProperty(exports, "addHrTimes", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.addHrTimes;
    }, "get") });
    Object.defineProperty(exports, "getTimeOrigin", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.getTimeOrigin;
    }, "get") });
    Object.defineProperty(exports, "hrTime", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.hrTime;
    }, "get") });
    Object.defineProperty(exports, "hrTimeDuration", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.hrTimeDuration;
    }, "get") });
    Object.defineProperty(exports, "hrTimeToMicroseconds", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.hrTimeToMicroseconds;
    }, "get") });
    Object.defineProperty(exports, "hrTimeToMilliseconds", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.hrTimeToMilliseconds;
    }, "get") });
    Object.defineProperty(exports, "hrTimeToNanoseconds", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.hrTimeToNanoseconds;
    }, "get") });
    Object.defineProperty(exports, "hrTimeToTimeStamp", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.hrTimeToTimeStamp;
    }, "get") });
    Object.defineProperty(exports, "isTimeInput", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.isTimeInput;
    }, "get") });
    Object.defineProperty(exports, "isTimeInputHrTime", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.isTimeInputHrTime;
    }, "get") });
    Object.defineProperty(exports, "millisToHrTime", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.millisToHrTime;
    }, "get") });
    Object.defineProperty(exports, "timeInputToHrTime", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return time_1.timeInputToHrTime;
    }, "get") });
    var ExportResult_1 = require_ExportResult();
    Object.defineProperty(exports, "ExportResultCode", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ExportResult_1.ExportResultCode;
    }, "get") });
    var utils_1 = require_utils();
    Object.defineProperty(exports, "parseKeyPairsIntoRecord", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return utils_1.parseKeyPairsIntoRecord;
    }, "get") });
    var platform_1 = require_platform();
    Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return platform_1.SDK_INFO;
    }, "get") });
    Object.defineProperty(exports, "_globalThis", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return platform_1._globalThis;
    }, "get") });
    Object.defineProperty(exports, "getStringFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return platform_1.getStringFromEnv;
    }, "get") });
    Object.defineProperty(exports, "getBooleanFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return platform_1.getBooleanFromEnv;
    }, "get") });
    Object.defineProperty(exports, "getNumberFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return platform_1.getNumberFromEnv;
    }, "get") });
    Object.defineProperty(exports, "getStringListFromEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return platform_1.getStringListFromEnv;
    }, "get") });
    Object.defineProperty(exports, "otperformance", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return platform_1.otperformance;
    }, "get") });
    Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return platform_1.unrefTimer;
    }, "get") });
    var composite_1 = require_composite();
    Object.defineProperty(exports, "CompositePropagator", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return composite_1.CompositePropagator;
    }, "get") });
    var W3CTraceContextPropagator_1 = require_W3CTraceContextPropagator();
    Object.defineProperty(exports, "TRACE_PARENT_HEADER", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return W3CTraceContextPropagator_1.TRACE_PARENT_HEADER;
    }, "get") });
    Object.defineProperty(exports, "TRACE_STATE_HEADER", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return W3CTraceContextPropagator_1.TRACE_STATE_HEADER;
    }, "get") });
    Object.defineProperty(exports, "W3CTraceContextPropagator", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return W3CTraceContextPropagator_1.W3CTraceContextPropagator;
    }, "get") });
    Object.defineProperty(exports, "parseTraceParent", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return W3CTraceContextPropagator_1.parseTraceParent;
    }, "get") });
    var rpc_metadata_1 = require_rpc_metadata();
    Object.defineProperty(exports, "RPCType", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return rpc_metadata_1.RPCType;
    }, "get") });
    Object.defineProperty(exports, "deleteRPCMetadata", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return rpc_metadata_1.deleteRPCMetadata;
    }, "get") });
    Object.defineProperty(exports, "getRPCMetadata", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return rpc_metadata_1.getRPCMetadata;
    }, "get") });
    Object.defineProperty(exports, "setRPCMetadata", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return rpc_metadata_1.setRPCMetadata;
    }, "get") });
    var suppress_tracing_1 = require_suppress_tracing();
    Object.defineProperty(exports, "isTracingSuppressed", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return suppress_tracing_1.isTracingSuppressed;
    }, "get") });
    Object.defineProperty(exports, "suppressTracing", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return suppress_tracing_1.suppressTracing;
    }, "get") });
    Object.defineProperty(exports, "unsuppressTracing", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return suppress_tracing_1.unsuppressTracing;
    }, "get") });
    var TraceState_1 = require_TraceState();
    Object.defineProperty(exports, "TraceState", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return TraceState_1.TraceState;
    }, "get") });
    var merge_1 = require_merge();
    Object.defineProperty(exports, "merge", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return merge_1.merge;
    }, "get") });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return timeout_1.TimeoutError;
    }, "get") });
    Object.defineProperty(exports, "callWithTimeout", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return timeout_1.callWithTimeout;
    }, "get") });
    var url_1 = require_url();
    Object.defineProperty(exports, "isUrlIgnored", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return url_1.isUrlIgnored;
    }, "get") });
    Object.defineProperty(exports, "urlMatches", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return url_1.urlMatches;
    }, "get") });
    var callback_1 = require_callback();
    Object.defineProperty(exports, "BindOnceFuture", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return callback_1.BindOnceFuture;
    }, "get") });
    var configuration_1 = require_configuration();
    Object.defineProperty(exports, "diagLogLevelFromString", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return configuration_1.diagLogLevelFromString;
    }, "get") });
    var exporter_1 = require_exporter();
    exports.internal = {
      _export: exporter_1._export
    };
  }
});

// node_modules/@jsonhero/path/lib/path/query-result.js
var require_query_result = __commonJS({
  "node_modules/@jsonhero/path/lib/path/query-result.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    var QueryResult = (
      /** @class */
      function() {
        function QueryResult2(depth, path, object) {
          this.depth = 0;
          this.depth = depth;
          this.path = path;
          this.object = object;
        }
        __name(QueryResult2, "QueryResult");
        QueryResult2.prototype.flatten = function() {
          var flattenedObject = this.object;
          if (typeof this.object === "object" && Array.isArray(this.object) && this.depth > 0) {
            flattenedObject = this.object.flat(this.depth);
          }
          return new QueryResult2(0, this.path, flattenedObject);
        };
        return QueryResult2;
      }()
    );
    exports.default = QueryResult;
  }
});

// node_modules/@jsonhero/path/lib/path/simple-key-path-component.js
var require_simple_key_path_component = __commonJS({
  "node_modules/@jsonhero/path/lib/path/simple-key-path-component.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleKeyPathComponent = void 0;
    var query_result_1 = require_query_result();
    var SimpleKeyPathComponent = (
      /** @class */
      function() {
        function SimpleKeyPathComponent2(keyName) {
          this.isArray = false;
          this.keyName = keyName;
          var keyAsInteger = parseInt(this.keyName, 10);
          if (isNaN(keyAsInteger)) {
            return;
          }
          var isInteger = Number.isInteger(keyAsInteger);
          if (!isInteger) {
            return;
          }
          if (keyAsInteger < 0) {
            return;
          }
          this.isArray = true;
        }
        __name(SimpleKeyPathComponent2, "SimpleKeyPathComponent");
        SimpleKeyPathComponent2.fromString = function(string) {
          var keyName = string;
          SimpleKeyPathComponent2.unescapeExpressions.forEach(function(unescapePair) {
            keyName = keyName.replace(unescapePair.search, unescapePair.replacement);
          });
          return new SimpleKeyPathComponent2(keyName);
        };
        SimpleKeyPathComponent2.prototype.toString = function() {
          var escapedString = this.keyName;
          SimpleKeyPathComponent2.escapeExpressions.forEach(function(escapePair) {
            escapedString = escapedString.replace(escapePair.search, escapePair.replacement);
          });
          return escapedString;
        };
        SimpleKeyPathComponent2.prototype.jsonPointer = function() {
          var escapedString = this.keyName;
          escapedString = escapedString.replace(/(\~)/g, "~0");
          escapedString = escapedString.replace(/(\/)/g, "~1");
          return escapedString;
        };
        SimpleKeyPathComponent2.prototype.query = function(results) {
          var newResults = [];
          for (var i2 = 0; i2 < results.length; i2++) {
            var result = results[i2];
            var object = result.object;
            if (typeof object !== "object") {
              continue;
            }
            var newObject = object[this.keyName];
            if (newObject === null) {
              continue;
            }
            var newResult = new query_result_1.default(result.depth, result.path.child(this.keyName), newObject);
            newResults.push(newResult);
          }
          return newResults;
        };
        SimpleKeyPathComponent2.escapeExpressions = [
          { search: new RegExp(/(\\)/g), replacement: "\\" },
          { search: new RegExp(/(\.)/g), replacement: "\\." }
        ];
        SimpleKeyPathComponent2.unescapeExpressions = [
          { search: new RegExp(/(\\\.)/g), replacement: "." },
          { search: new RegExp(/(\\\\)/g), replacement: "\\" },
          { search: "~1", replacement: "/" }
        ];
        return SimpleKeyPathComponent2;
      }()
    );
    exports.SimpleKeyPathComponent = SimpleKeyPathComponent;
  }
});

// node_modules/@jsonhero/path/lib/path/wildcard-path-component.js
var require_wildcard_path_component = __commonJS({
  "node_modules/@jsonhero/path/lib/path/wildcard-path-component.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WildcardPathComponent = void 0;
    var query_result_1 = require_query_result();
    var WildcardPathComponent = (
      /** @class */
      function() {
        function WildcardPathComponent2() {
          this.keyName = "*";
          this.isArray = true;
        }
        __name(WildcardPathComponent2, "WildcardPathComponent");
        WildcardPathComponent2.fromString = function(string) {
          if (string === "*") {
            return new WildcardPathComponent2();
          }
          return null;
        };
        WildcardPathComponent2.prototype.toString = function() {
          return this.keyName;
        };
        WildcardPathComponent2.prototype.jsonPointer = function() {
          throw Error("JSON Pointers don't work with wildcards");
        };
        WildcardPathComponent2.prototype.query = function(results) {
          var newResults = [];
          for (var i2 = 0; i2 < results.length; i2++) {
            var result = results[i2];
            var object = result.object;
            if (typeof object !== "object") {
              continue;
            }
            for (var key in object) {
              var newObject = object[key];
              var newResult = new query_result_1.default(result.depth + 1, result.path.child(key), newObject);
              newResults.push(newResult);
            }
          }
          return newResults;
        };
        return WildcardPathComponent2;
      }()
    );
    exports.WildcardPathComponent = WildcardPathComponent;
  }
});

// node_modules/@jsonhero/path/lib/path/start-path-component.js
var require_start_path_component = __commonJS({
  "node_modules/@jsonhero/path/lib/path/start-path-component.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    var StartPathComponent = (
      /** @class */
      function() {
        function StartPathComponent2() {
          this.keyName = "$";
          this.isArray = false;
        }
        __name(StartPathComponent2, "StartPathComponent");
        StartPathComponent2.fromString = function(string) {
          if (string === "$") {
            return new StartPathComponent2();
          }
          return null;
        };
        StartPathComponent2.prototype.toString = function() {
          return this.keyName;
        };
        StartPathComponent2.prototype.jsonPointer = function() {
          return "";
        };
        StartPathComponent2.prototype.query = function(objects) {
          return objects;
        };
        return StartPathComponent2;
      }()
    );
    exports.default = StartPathComponent;
  }
});

// node_modules/@jsonhero/path/lib/path/slice-path-component.js
var require_slice_path_component = __commonJS({
  "node_modules/@jsonhero/path/lib/path/slice-path-component.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SlicePathComponent = void 0;
    var query_result_1 = require_query_result();
    var SlicePathComponent = (
      /** @class */
      function() {
        function SlicePathComponent2(startIndex, endIndex) {
          this.endIndex = null;
          this.isArray = true;
          this.startIndex = startIndex;
          this.endIndex = endIndex;
        }
        __name(SlicePathComponent2, "SlicePathComponent");
        SlicePathComponent2.fromString = function(string) {
          if (!SlicePathComponent2.regex.test(string)) {
            return null;
          }
          SlicePathComponent2.regex.lastIndex = 0;
          var result = SlicePathComponent2.regex.exec(string);
          if (result == null || result.groups == null) {
            return null;
          }
          var startResult = result.groups.startIndex;
          var endResult = result.groups.endIndex;
          var startIndex = startResult == null || startResult === "" ? 0 : parseInt(startResult, 10);
          var endIndex = endResult == null ? null : parseInt(endResult, 10);
          if (startIndex == null && endIndex == null) {
            return null;
          }
          var isStartInteger = Number.isInteger(startIndex);
          if (!isStartInteger) {
            return null;
          }
          return new SlicePathComponent2(startIndex, endIndex);
        };
        SlicePathComponent2.prototype.toString = function() {
          return "[".concat(this.startIndex).concat(this.endIndex == null ? "" : ":" + this.endIndex, "]");
        };
        SlicePathComponent2.prototype.jsonPointer = function() {
          throw Error("JSON Pointers don't work with wildcards");
        };
        SlicePathComponent2.prototype.query = function(results) {
          var newResults = [];
          for (var i2 = 0; i2 < results.length; i2++) {
            var result = results[i2];
            var object = result.object;
            if (typeof object !== "object")
              continue;
            if (!Array.isArray(object))
              continue;
            var slicedItems = void 0;
            if (this.endIndex == null) {
              slicedItems = object.slice(this.startIndex);
            } else {
              slicedItems = object.slice(this.startIndex, this.endIndex);
            }
            for (var j = 0; j < slicedItems.length; j++) {
              var slicedItem = slicedItems[j];
              newResults.push(new query_result_1.default(result.depth + 1, result.path.child("".concat(j + this.startIndex)), slicedItem));
            }
          }
          return newResults;
        };
        SlicePathComponent2.regex = /^\[(?<startIndex>[0-9]*):(?<endIndex>\-?[0-9]*)?\]$/g;
        return SlicePathComponent2;
      }()
    );
    exports.SlicePathComponent = SlicePathComponent;
  }
});

// node_modules/@jsonhero/path/lib/path/path-builder.js
var require_path_builder = __commonJS({
  "node_modules/@jsonhero/path/lib/path/path-builder.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    var simple_key_path_component_1 = require_simple_key_path_component();
    var wildcard_path_component_1 = require_wildcard_path_component();
    var start_path_component_1 = require_start_path_component();
    var slice_path_component_1 = require_slice_path_component();
    var PathBuilder = (
      /** @class */
      function() {
        function PathBuilder2() {
        }
        __name(PathBuilder2, "PathBuilder");
        PathBuilder2.prototype.parse = function(path) {
          PathBuilder2.pathPattern.lastIndex = 0;
          var subPaths = path.match(PathBuilder2.pathPattern);
          var components = [new start_path_component_1.default()];
          if (subPaths == null || subPaths.length == 0 || subPaths.length == 1 && subPaths[0] == "") {
            return components;
          }
          var startIndex = 0;
          if (subPaths[0] == "$") {
            startIndex = 1;
          }
          for (var i2 = startIndex; i2 < subPaths.length; i2++) {
            var subPath = subPaths[i2];
            var pathComponent = this.parseComponent(subPath);
            components.push(pathComponent);
          }
          return components;
        };
        PathBuilder2.prototype.parsePointer = function(pointer) {
          PathBuilder2.pathPattern.lastIndex = 0;
          var subPaths = pointer.match(PathBuilder2.pointerPattern);
          var components = [new start_path_component_1.default()];
          if (subPaths == null || subPaths.length == 0 || subPaths.length == 1 && subPaths[0] == "") {
            return components;
          }
          for (var _i = 0, subPaths_1 = subPaths; _i < subPaths_1.length; _i++) {
            var subPath = subPaths_1[_i];
            components.push(this.parseComponent(subPath));
          }
          return components;
        };
        PathBuilder2.prototype.parseComponent = function(string) {
          var wildcardComponent = wildcard_path_component_1.WildcardPathComponent.fromString(string);
          if (wildcardComponent != null) {
            return wildcardComponent;
          }
          if (string == null) {
            throw new SyntaxError("Cannot create a path from null");
          }
          if (string == "") {
            throw new SyntaxError("Cannot create a path from an empty string");
          }
          var sliceComponent = slice_path_component_1.SlicePathComponent.fromString(string);
          if (sliceComponent != null) {
            return sliceComponent;
          }
          return simple_key_path_component_1.SimpleKeyPathComponent.fromString(string);
        };
        PathBuilder2.pathPattern = /(?:[^\.\\]|\\.)+/g;
        PathBuilder2.pointerPattern = /(?:[^\/\\]|\\\/)+/g;
        return PathBuilder2;
      }()
    );
    exports.default = PathBuilder;
  }
});

// node_modules/@jsonhero/path/lib/index.js
var require_lib = __commonJS({
  "node_modules/@jsonhero/path/lib/index.js"(exports) {
    "use strict";
    init_esm();
    var __spreadArray5 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
        if (ar || !(i2 in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
          ar[i2] = from[i2];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONHeroPath = void 0;
    var path_builder_1 = require_path_builder();
    var query_result_1 = require_query_result();
    var start_path_component_1 = require_start_path_component();
    var JSONHeroPath3 = (
      /** @class */
      function() {
        function JSONHeroPath4(components) {
          if (typeof components == "string") {
            var pathBuilder = new path_builder_1.default();
            this.components = pathBuilder.parse(components);
            return;
          }
          if (components.length == 0) {
            components.push(new start_path_component_1.default());
          }
          if (!(components[0] instanceof start_path_component_1.default)) {
            components.unshift(new start_path_component_1.default());
          }
          this.components = components;
        }
        __name(JSONHeroPath4, "JSONHeroPath");
        JSONHeroPath4.fromPointer = function(pointer) {
          var pathBuilder = new path_builder_1.default();
          return new JSONHeroPath4(pathBuilder.parsePointer(pointer));
        };
        Object.defineProperty(JSONHeroPath4.prototype, "root", {
          get: /* @__PURE__ */ __name(function() {
            return new JSONHeroPath4(this.components.slice(0, 1));
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(JSONHeroPath4.prototype, "isRoot", {
          get: /* @__PURE__ */ __name(function() {
            if (this.components.length > 1)
              return false;
            return this.components[0] instanceof start_path_component_1.default;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(JSONHeroPath4.prototype, "parent", {
          get: /* @__PURE__ */ __name(function() {
            if (this.components.length == 1) {
              return null;
            }
            return new JSONHeroPath4(this.components.slice(0, -1));
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(JSONHeroPath4.prototype, "lastComponent", {
          get: /* @__PURE__ */ __name(function() {
            if (this.components.length === 0)
              return;
            return this.components[this.components.length - 1];
          }, "get"),
          enumerable: false,
          configurable: true
        });
        JSONHeroPath4.prototype.child = function(key) {
          var string = this.toString();
          return new JSONHeroPath4(string.concat(".".concat(key)));
        };
        JSONHeroPath4.prototype.replaceComponent = function(index, newKey) {
          var pathBuilder = new path_builder_1.default();
          var newComponent = pathBuilder.parseComponent(newKey);
          var newComponents = __spreadArray5([], this.components, true);
          newComponents[index] = newComponent;
          return new JSONHeroPath4(newComponents);
        };
        JSONHeroPath4.prototype.toString = function() {
          return this.components.map(function(component) {
            return component.toString();
          }).join(".");
        };
        JSONHeroPath4.prototype.jsonPointer = function() {
          if (this.components.length === 1)
            return "";
          return this.components.map(function(component) {
            return component.jsonPointer();
          }).join("/");
        };
        JSONHeroPath4.prototype.first = function(object, options) {
          if (options === void 0) {
            options = { includePath: false };
          }
          var results = this.all(object, options);
          if (results === null || results.length === 0) {
            return null;
          }
          return results[0];
        };
        JSONHeroPath4.prototype.all = function(object, options) {
          if (options === void 0) {
            options = { includePath: false };
          }
          if (this.components.length == 0)
            return [object];
          if (this.components.length == 1 && this.components[0] instanceof start_path_component_1.default)
            return [object];
          var results = [];
          var firstResult = new query_result_1.default(0, this.root, object);
          results.push(firstResult);
          for (var i2 = 0; i2 < this.components.length; i2++) {
            var component = this.components[i2];
            results = component.query(results);
            if (results === null || results.length === 0) {
              return [];
            }
          }
          var flattenedResults = results.map(function(result) {
            return result.flatten();
          });
          if (!options.includePath) {
            return flattenedResults.map(function(result) {
              return result.object;
            });
          }
          var all = [];
          for (var i2 = 0; i2 < flattenedResults.length; i2++) {
            var flattenedResult = flattenedResults[i2];
            var object_1 = {
              value: flattenedResult.object
            };
            if (options.includePath) {
              object_1.path = flattenedResult.path;
            }
            all.push(object_1);
          }
          return all;
        };
        JSONHeroPath4.prototype.set = function(object, newValue) {
          var allResults = this.all(object, { includePath: true });
          allResults.forEach(function(_a) {
            var path = _a.path;
            var parentPath = path.parent;
            var parentObject = parentPath === null || parentPath === void 0 ? void 0 : parentPath.first(object);
            if (!path.lastComponent)
              return;
            parentObject[path.lastComponent.toString()] = newValue;
          });
        };
        JSONHeroPath4.prototype.merge = function(object, mergeValue) {
          var allResults = this.all(object, { includePath: true });
          allResults.forEach(function(_a) {
            var path = _a.path;
            var parentPath = path.parent;
            var parentObject = parentPath === null || parentPath === void 0 ? void 0 : parentPath.first(object);
            if (!path.lastComponent)
              return;
            var existingValue = parentObject[path.lastComponent.toString()];
            if (Array.isArray(existingValue)) {
              parentObject[path.lastComponent.toString()] = existingValue.concat([mergeValue].flat());
            } else {
              if (typeof mergeValue != "object" || Array.isArray(mergeValue))
                return;
              for (var key in mergeValue) {
                existingValue[key] = mergeValue[key];
              }
            }
          });
        };
        return JSONHeroPath4;
      }()
    );
    exports.JSONHeroPath = JSONHeroPath3;
  }
});

// node_modules/@microsoft/fetch-event-source/lib/cjs/parse.js
var require_parse = __commonJS({
  "node_modules/@microsoft/fetch-event-source/lib/cjs/parse.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessages = exports.getLines = exports.getBytes = void 0;
    async function getBytes(stream2, onChunk) {
      const reader = stream2.getReader();
      let result;
      while (!(result = await reader.read()).done) {
        onChunk(result.value);
      }
    }
    __name(getBytes, "getBytes");
    exports.getBytes = getBytes;
    function getLines(onLine) {
      let buffer;
      let position;
      let fieldLength;
      let discardTrailingNewline = false;
      return /* @__PURE__ */ __name(function onChunk(arr) {
        if (buffer === void 0) {
          buffer = arr;
          position = 0;
          fieldLength = -1;
        } else {
          buffer = concat(buffer, arr);
        }
        const bufLength = buffer.length;
        let lineStart = 0;
        while (position < bufLength) {
          if (discardTrailingNewline) {
            if (buffer[position] === 10) {
              lineStart = ++position;
            }
            discardTrailingNewline = false;
          }
          let lineEnd = -1;
          for (; position < bufLength && lineEnd === -1; ++position) {
            switch (buffer[position]) {
              case 58:
                if (fieldLength === -1) {
                  fieldLength = position - lineStart;
                }
                break;
              case 13:
                discardTrailingNewline = true;
              case 10:
                lineEnd = position;
                break;
            }
          }
          if (lineEnd === -1) {
            break;
          }
          onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
          lineStart = position;
          fieldLength = -1;
        }
        if (lineStart === bufLength) {
          buffer = void 0;
        } else if (lineStart !== 0) {
          buffer = buffer.subarray(lineStart);
          position -= lineStart;
        }
      }, "onChunk");
    }
    __name(getLines, "getLines");
    exports.getLines = getLines;
    function getMessages(onId, onRetry, onMessage) {
      let message = newMessage();
      const decoder = new TextDecoder();
      return /* @__PURE__ */ __name(function onLine(line, fieldLength) {
        if (line.length === 0) {
          onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);
          message = newMessage();
        } else if (fieldLength > 0) {
          const field = decoder.decode(line.subarray(0, fieldLength));
          const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);
          const value = decoder.decode(line.subarray(valueOffset));
          switch (field) {
            case "data":
              message.data = message.data ? message.data + "\n" + value : value;
              break;
            case "event":
              message.event = value;
              break;
            case "id":
              onId(message.id = value);
              break;
            case "retry":
              const retry2 = parseInt(value, 10);
              if (!isNaN(retry2)) {
                onRetry(message.retry = retry2);
              }
              break;
          }
        }
      }, "onLine");
    }
    __name(getMessages, "getMessages");
    exports.getMessages = getMessages;
    function concat(a2, b2) {
      const res = new Uint8Array(a2.length + b2.length);
      res.set(a2);
      res.set(b2, a2.length);
      return res;
    }
    __name(concat, "concat");
    function newMessage() {
      return {
        data: "",
        event: "",
        id: "",
        retry: void 0
      };
    }
    __name(newMessage, "newMessage");
  }
});

// node_modules/@microsoft/fetch-event-source/lib/cjs/fetch.js
var require_fetch = __commonJS({
  "node_modules/@microsoft/fetch-event-source/lib/cjs/fetch.js"(exports) {
    "use strict";
    init_esm();
    var __rest = exports && exports.__rest || function(s, e) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
        t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fetchEventSource = exports.EventStreamContentType = void 0;
    var parse_1 = require_parse();
    exports.EventStreamContentType = "text/event-stream";
    var DefaultRetryInterval = 1e3;
    var LastEventId = "last-event-id";
    function fetchEventSource2(input, _a) {
      var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
      return new Promise((resolve, reject) => {
        const headers = Object.assign({}, inputHeaders);
        if (!headers.accept) {
          headers.accept = exports.EventStreamContentType;
        }
        let curRequestController;
        function onVisibilityChange() {
          curRequestController.abort();
          if (!document.hidden) {
            create2();
          }
        }
        __name(onVisibilityChange, "onVisibilityChange");
        if (!openWhenHidden) {
          document.addEventListener("visibilitychange", onVisibilityChange);
        }
        let retryInterval = DefaultRetryInterval;
        let retryTimer = 0;
        function dispose() {
          document.removeEventListener("visibilitychange", onVisibilityChange);
          window.clearTimeout(retryTimer);
          curRequestController.abort();
        }
        __name(dispose, "dispose");
        inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener("abort", () => {
          dispose();
          resolve();
        });
        const fetch2 = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;
        const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;
        async function create2() {
          var _a2;
          curRequestController = new AbortController();
          try {
            const response = await fetch2(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));
            await onopen(response);
            await parse_1.getBytes(response.body, parse_1.getLines(parse_1.getMessages((id) => {
              if (id) {
                headers[LastEventId] = id;
              } else {
                delete headers[LastEventId];
              }
            }, (retry2) => {
              retryInterval = retry2;
            }, onmessage)));
            onclose === null || onclose === void 0 ? void 0 : onclose();
            dispose();
            resolve();
          } catch (err) {
            if (!curRequestController.signal.aborted) {
              try {
                const interval = (_a2 = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a2 !== void 0 ? _a2 : retryInterval;
                window.clearTimeout(retryTimer);
                retryTimer = window.setTimeout(create2, interval);
              } catch (innerErr) {
                dispose();
                reject(innerErr);
              }
            }
          }
        }
        __name(create2, "create");
        create2();
      });
    }
    __name(fetchEventSource2, "fetchEventSource");
    exports.fetchEventSource = fetchEventSource2;
    function defaultOnOpen(response) {
      const contentType = response.headers.get("content-type");
      if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(exports.EventStreamContentType))) {
        throw new Error(`Expected content-type to be ${exports.EventStreamContentType}, Actual: ${contentType}`);
      }
    }
    __name(defaultOnOpen, "defaultOnOpen");
  }
});

// node_modules/@microsoft/fetch-event-source/lib/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@microsoft/fetch-event-source/lib/cjs/index.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventStreamContentType = exports.fetchEventSource = void 0;
    var fetch_1 = require_fetch();
    Object.defineProperty(exports, "fetchEventSource", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return fetch_1.fetchEventSource;
    }, "get") });
    Object.defineProperty(exports, "EventStreamContentType", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return fetch_1.EventStreamContentType;
    }, "get") });
  }
});

// node_modules/@google-cloud/precise-date/build/src/index.js
var require_src2 = __commonJS({
  "node_modules/@google-cloud/precise-date/build/src/index.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PreciseDate = void 0;
    var FULL_ISO_REG = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d{4,9}Z/;
    var NO_BIG_INT = "BigInt only available in Node >= v10.7. Consider using getFullTimeString instead.";
    var Sign;
    (function(Sign2) {
      Sign2[Sign2["NEGATIVE"] = -1] = "NEGATIVE";
      Sign2[Sign2["POSITIVE"] = 1] = "POSITIVE";
      Sign2[Sign2["ZERO"] = 0] = "ZERO";
    })(Sign || (Sign = {}));
    var PreciseDate2 = class _PreciseDate extends Date {
      static {
        __name(this, "PreciseDate");
      }
      constructor(time) {
        super();
        this._micros = 0;
        this._nanos = 0;
        if (time && typeof time !== "number" && !(time instanceof Date)) {
          this.setFullTime(_PreciseDate.parseFull(time));
          return;
        }
        const args = Array.from(arguments);
        const dateFields = args.slice(0, 7);
        const date = new Date(...dateFields);
        const nanos = args.length === 9 ? args.pop() : 0;
        const micros = args.length === 8 ? args.pop() : 0;
        this.setTime(date.getTime());
        this.setMicroseconds(micros);
        this.setNanoseconds(nanos);
      }
      /**
       * Returns the specified date represented in nanoseconds according to
       * universal time.
       *
       * **NOTE:** Because this method returns a `BigInt` it requires Node >= v10.7.
       * Use {@link PreciseDate#getFullTimeString} to get the time as a string.
       *
       * @see {@link https://github.com/tc39/proposal-bigint|BigInt}
       *
       * @throws {error} If `BigInt` is unavailable.
       * @returns {bigint}
       *
       * @example
       * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');
       *
       * console.log(date.getFullTime());
       * // expected output: 1549622069481145231n
       */
      getFullTime() {
        if (typeof BigInt !== "function") {
          throw new Error(NO_BIG_INT);
        }
        return BigInt(this.getFullTimeString());
      }
      /**
       * Returns a string of the specified date represented in nanoseconds according
       * to universal time.
       *
       * @returns {string}
       *
       * @example
       * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');
       *
       * console.log(date.getFullTimeString());
       * // expected output: "1549622069481145231"
       */
      getFullTimeString() {
        const seconds = this._getSeconds();
        let nanos = this._getNanos();
        if (nanos && Math.sign(seconds) === Sign.NEGATIVE) {
          nanos = 1e9 - nanos;
        }
        return `${seconds}${padLeft(nanos, 9)}`;
      }
      /**
       * Returns the microseconds in the specified date according to universal time.
       *
       * @returns {number}
       *
       * @example
       * const date = new PreciseDate('2019-02-08T10:34:29.481145Z');
       *
       * console.log(date.getMicroseconds());
       * // expected output: 145
       */
      getMicroseconds() {
        return this._micros;
      }
      /**
       * Returns the nanoseconds in the specified date according to universal time.
       *
       * @returns {number}
       *
       * @example
       * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');
       *
       * console.log(date.getNanoseconds());
       * // expected output: 231
       */
      getNanoseconds() {
        return this._nanos;
      }
      /**
       * Sets the microseconds for a specified date according to universal time.
       *
       * @param {number} microseconds A number representing the microseconds.
       * @returns {string} Returns a string representing the nanoseconds in the
       *     specified date according to universal time.
       *
       * @example
       * const date = new PreciseDate();
       *
       * date.setMicroseconds(149);
       *
       * console.log(date.getMicroseconds());
       * // expected output: 149
       */
      setMicroseconds(micros) {
        const abs = Math.abs(micros);
        let millis = this.getUTCMilliseconds();
        if (abs >= 1e3) {
          millis += Math.floor(abs / 1e3) * Math.sign(micros);
          micros %= 1e3;
        }
        if (Math.sign(micros) === Sign.NEGATIVE) {
          millis -= 1;
          micros += 1e3;
        }
        this._micros = micros;
        this.setUTCMilliseconds(millis);
        return this.getFullTimeString();
      }
      /**
       * Sets the nanoseconds for a specified date according to universal time.
       *
       * @param {number} nanoseconds A number representing the nanoseconds.
       * @returns {string} Returns a string representing the nanoseconds in the
       *     specified date according to universal time.
       *
       * @example
       * const date = new PreciseDate();
       *
       * date.setNanoseconds(231);
       *
       * console.log(date.getNanoseconds());
       * // expected output: 231
       */
      setNanoseconds(nanos) {
        const abs = Math.abs(nanos);
        let micros = this._micros;
        if (abs >= 1e3) {
          micros += Math.floor(abs / 1e3) * Math.sign(nanos);
          nanos %= 1e3;
        }
        if (Math.sign(nanos) === Sign.NEGATIVE) {
          micros -= 1;
          nanos += 1e3;
        }
        this._nanos = nanos;
        return this.setMicroseconds(micros);
      }
      /**
       * Sets the PreciseDate object to the time represented by a number of
       * nanoseconds since January 1, 1970, 00:00:00 UTC.
       *
       * @param {bigint|number|string} time Value representing the number of
       *     nanoseconds since January 1, 1970, 00:00:00 UTC.
       * @returns {string} Returns a string representing the nanoseconds in the
       *     specified date according to universal time (effectively, the value of
       *     the argument).
       *
       * @see {@link https://github.com/tc39/proposal-bigint|BigInt}
       *
       * @example <caption>With a nanosecond string.</caption>
       * const date = new PreciseDate();
       * date.setFullTime('1549622069481145231');
       *
       * @example <caption>With a BigInt</caption>
       * date.setFullTime(1549622069481145231n);
       */
      setFullTime(time) {
        if (typeof time !== "string") {
          time = time.toString();
        }
        const sign = Math.sign(Number(time));
        time = time.replace(/^-/, "");
        const seconds = Number(time.substr(0, time.length - 9)) * sign;
        const nanos = Number(time.substr(-9)) * sign;
        this.setTime(seconds * 1e3);
        return this.setNanoseconds(nanos);
      }
      /**
       * Sets the PreciseDate object to the time represented by a number of
       * milliseconds since January 1, 1970, 00:00:00 UTC. Calling this method will
       * reset both the microseconds and nanoseconds to 0.
       *
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime|Date#setTime}
       *
       * @param {number} time Value representing the number of milliseconds since
       *     January 1, 1970, 00:00:00 UTC.
       * @returns {string} The number of milliseconds between January 1, 1970,
       *     00:00:00 UTC and the updated date (effectively, the value of the
       *     argument).
       */
      setTime(time) {
        this._micros = 0;
        this._nanos = 0;
        return super.setTime(time);
      }
      /**
       * Returns a string in RFC 3339 format. Unlike the native `Date#toISOString`,
       * this will return 9 digits to represent sub-second precision.
       *
       * @see {@link https://tools.ietf.org/html/rfc3339|RFC 3339}
       *
       * @returns {string}
       *
       * @example
       * const date = new PreciseDate(1549622069481145231n);
       *
       * console.log(date.toISOString());
       * // expected output: "2019-02-08T10:34:29.481145231Z"
       */
      toISOString() {
        const micros = padLeft(this._micros, 3);
        const nanos = padLeft(this._nanos, 3);
        return super.toISOString().replace(/z$/i, `${micros}${nanos}Z`);
      }
      /**
       * Returns an object representing the specified date according to universal
       * time.
       *
       * @see {@link https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#timestamp|google.protobuf.Timestamp}
       *
       * @returns {DateStruct}
       *
       * @example
       * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');
       *
       * console.log(date.toStruct());
       * // expected output: {seconds: 1549622069, nanos: 481145231}
       */
      toStruct() {
        let seconds = this._getSeconds();
        const nanos = this._getNanos();
        const sign = Math.sign(seconds);
        if (sign === Sign.NEGATIVE && nanos) {
          seconds -= 1;
        }
        return { seconds, nanos };
      }
      /**
       * Returns a tuple representing the specified date according to universal
       * time.
       *
       * @returns {DateTuple}
       *
       * @example
       * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');
       *
       * console.log(date.toTuple());
       * // expected output: [1549622069, 481145231]
       */
      toTuple() {
        const { seconds, nanos } = this.toStruct();
        return [seconds, nanos];
      }
      /**
       * Returns the total number of seconds in the specified date since Unix epoch.
       * Numbers representing < epoch will be negative.
       *
       * @private
       *
       * @returns {number}
       */
      _getSeconds() {
        const time = this.getTime();
        const sign = Math.sign(time);
        return Math.floor(Math.abs(time) / 1e3) * sign;
      }
      /**
       * Returns the sub-second precision of the specified date. This will always be
       * a positive number.
       *
       * @private
       *
       * @returns {number}
       */
      _getNanos() {
        const msInNanos = this.getUTCMilliseconds() * 1e6;
        const microsInNanos = this._micros * 1e3;
        return this._nanos + msInNanos + microsInNanos;
      }
      /**
       * Parses a precise time.
       *
       * @static
       *
       * @param {string|bigint|DateTuple|DateStruct} time The precise time value.
       * @returns {string} Returns a string representing the nanoseconds in the
       *     specified date according to universal time.
       *
       * @example <caption>From a RFC 3339 formatted string.</caption>
       * const time = PreciseDate.parseFull('2019-02-08T10:34:29.481145231Z');
       * console.log(time); // expected output: "1549622069481145231"
       *
       * @example <caption>From a nanosecond timestamp string.</caption>
       * const time = PreciseDate.parseFull('1549622069481145231');
       * console.log(time); // expected output: "1549622069481145231"
       *
       * @example <caption>From a BigInt (requires Node >= v10.7)</caption>
       * const time = PreciseDate.parseFull(1549622069481145231n);
       * console.log(time); // expected output: "1549622069481145231"
       *
       * @example <caption>From a tuple.</caption>
       * const time = PreciseDate.parseFull([1549622069, 481145231]);
       * console.log(time); // expected output: "1549622069481145231"
       *
       * @example <caption>From an object.</caption>
       * const struct = {seconds: 1549622069, nanos: 481145231};
       * const time = PreciseDate.parseFull(struct);
       * console.log(time); // expected output: "1549622069481145231"
       */
      static parseFull(time) {
        const date = new _PreciseDate();
        if (Array.isArray(time)) {
          const [seconds, nanos] = time;
          time = { seconds, nanos };
        }
        if (isFullTime(time)) {
          date.setFullTime(time);
        } else if (isStruct(time)) {
          const { seconds, nanos } = parseProto(time);
          date.setTime(seconds * 1e3);
          date.setNanoseconds(nanos);
        } else if (isFullISOString(time)) {
          date.setFullTime(parseFullISO(time));
        } else {
          date.setTime(new Date(time).getTime());
        }
        return date.getFullTimeString();
      }
      /**
       * Accepts the same number parameters as the PreciseDate constructor, but
       * treats them as UTC. It returns a string that represents the number of
       * nanoseconds since January 1, 1970, 00:00:00 UTC.
       *
       * **NOTE:** Because this method returns a `BigInt` it requires Node >= v10.7.
       *
       * @see {@link https://github.com/tc39/proposal-bigint|BigInt}
       *
       * @static
       *
       * @throws {error} If `BigInt` is unavailable.
       *
       * @param {...number} [dateFields] The date fields.
       * @returns {bigint}
       *
       * @example
       * const time = PreciseDate.fullUTC(2019, 1, 8, 10, 34, 29, 481, 145, 231);
       * console.log(time); // expected output: 1549622069481145231n
       */
      static fullUTC(...args) {
        if (typeof BigInt !== "function") {
          throw new Error(NO_BIG_INT);
        }
        return BigInt(_PreciseDate.fullUTCString(...args));
      }
      /**
       * Accepts the same number parameters as the PreciseDate constructor, but
       * treats them as UTC. It returns a string that represents the number of
       * nanoseconds since January 1, 1970, 00:00:00 UTC.
       *
       * @static
       *
       * @param {...number} [dateFields] The date fields.
       * @returns {string}
       *
       * @example
       * const time = PreciseDate.fullUTCString(2019, 1, 8, 10, 34, 29, 481, 145,
       * 231); console.log(time); // expected output: '1549622069481145231'
       */
      static fullUTCString(...args) {
        const milliseconds = Date.UTC(...args.slice(0, 7));
        const date = new _PreciseDate(milliseconds);
        if (args.length === 9) {
          date.setNanoseconds(args.pop());
        }
        if (args.length === 8) {
          date.setMicroseconds(args.pop());
        }
        return date.getFullTimeString();
      }
    };
    exports.PreciseDate = PreciseDate2;
    function parseFullISO(time) {
      let digits = "0";
      time = time.replace(/\.(\d+)/, ($0, $1) => {
        digits = $1;
        return ".000";
      });
      const nanos = Number(padRight(digits, 9));
      const date = new PreciseDate2(time);
      return date.setNanoseconds(nanos);
    }
    __name(parseFullISO, "parseFullISO");
    function parseProto({ seconds = 0, nanos = 0 }) {
      if (typeof seconds.toNumber === "function") {
        seconds = seconds.toNumber();
      }
      seconds = Number(seconds);
      nanos = Number(nanos);
      return { seconds, nanos };
    }
    __name(parseProto, "parseProto");
    function isFullTime(time) {
      return typeof time === "bigint" || typeof time === "string" && /^\d+$/.test(time);
    }
    __name(isFullTime, "isFullTime");
    function isStruct(time) {
      return typeof time === "object" && typeof time.seconds !== "undefined" || typeof time.nanos === "number";
    }
    __name(isStruct, "isStruct");
    function isFullISOString(time) {
      return typeof time === "string" && FULL_ISO_REG.test(time);
    }
    __name(isFullISOString, "isFullISOString");
    function padLeft(n2, min) {
      const padding = getPadding(n2, min);
      return `${padding}${n2}`;
    }
    __name(padLeft, "padLeft");
    function padRight(n2, min) {
      const padding = getPadding(n2, min);
      return `${n2}${padding}`;
    }
    __name(padRight, "padRight");
    function getPadding(n2, min) {
      const size = Math.max(min - n2.toString().length, 0);
      return "0".repeat(size);
    }
    __name(getPadding, "getPadding");
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js
var require_LogRecord = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SeverityNumber = void 0;
    var SeverityNumber;
    (function(SeverityNumber2) {
      SeverityNumber2[SeverityNumber2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
      SeverityNumber2[SeverityNumber2["TRACE"] = 1] = "TRACE";
      SeverityNumber2[SeverityNumber2["TRACE2"] = 2] = "TRACE2";
      SeverityNumber2[SeverityNumber2["TRACE3"] = 3] = "TRACE3";
      SeverityNumber2[SeverityNumber2["TRACE4"] = 4] = "TRACE4";
      SeverityNumber2[SeverityNumber2["DEBUG"] = 5] = "DEBUG";
      SeverityNumber2[SeverityNumber2["DEBUG2"] = 6] = "DEBUG2";
      SeverityNumber2[SeverityNumber2["DEBUG3"] = 7] = "DEBUG3";
      SeverityNumber2[SeverityNumber2["DEBUG4"] = 8] = "DEBUG4";
      SeverityNumber2[SeverityNumber2["INFO"] = 9] = "INFO";
      SeverityNumber2[SeverityNumber2["INFO2"] = 10] = "INFO2";
      SeverityNumber2[SeverityNumber2["INFO3"] = 11] = "INFO3";
      SeverityNumber2[SeverityNumber2["INFO4"] = 12] = "INFO4";
      SeverityNumber2[SeverityNumber2["WARN"] = 13] = "WARN";
      SeverityNumber2[SeverityNumber2["WARN2"] = 14] = "WARN2";
      SeverityNumber2[SeverityNumber2["WARN3"] = 15] = "WARN3";
      SeverityNumber2[SeverityNumber2["WARN4"] = 16] = "WARN4";
      SeverityNumber2[SeverityNumber2["ERROR"] = 17] = "ERROR";
      SeverityNumber2[SeverityNumber2["ERROR2"] = 18] = "ERROR2";
      SeverityNumber2[SeverityNumber2["ERROR3"] = 19] = "ERROR3";
      SeverityNumber2[SeverityNumber2["ERROR4"] = 20] = "ERROR4";
      SeverityNumber2[SeverityNumber2["FATAL"] = 21] = "FATAL";
      SeverityNumber2[SeverityNumber2["FATAL2"] = 22] = "FATAL2";
      SeverityNumber2[SeverityNumber2["FATAL3"] = 23] = "FATAL3";
      SeverityNumber2[SeverityNumber2["FATAL4"] = 24] = "FATAL4";
    })(SeverityNumber = exports.SeverityNumber || (exports.SeverityNumber = {}));
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js
var require_NoopLogger = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NOOP_LOGGER = exports.NoopLogger = void 0;
    var NoopLogger = class {
      static {
        __name(this, "NoopLogger");
      }
      emit(_logRecord) {
      }
    };
    exports.NoopLogger = NoopLogger;
    exports.NOOP_LOGGER = new NoopLogger();
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js
var require_NoopLoggerProvider = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NOOP_LOGGER_PROVIDER = exports.NoopLoggerProvider = void 0;
    var NoopLogger_1 = require_NoopLogger();
    var NoopLoggerProvider = class {
      static {
        __name(this, "NoopLoggerProvider");
      }
      getLogger(_name, _version, _options) {
        return new NoopLogger_1.NoopLogger();
      }
    };
    exports.NoopLoggerProvider = NoopLoggerProvider;
    exports.NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/ProxyLogger.js
var require_ProxyLogger = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/ProxyLogger.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyLogger = void 0;
    var NoopLogger_1 = require_NoopLogger();
    var ProxyLogger = class {
      static {
        __name(this, "ProxyLogger");
      }
      constructor(_provider, name2, version, options) {
        this._provider = _provider;
        this.name = name2;
        this.version = version;
        this.options = options;
      }
      /**
       * Emit a log record. This method should only be used by log appenders.
       *
       * @param logRecord
       */
      emit(logRecord) {
        this._getLogger().emit(logRecord);
      }
      /**
       * Try to get a logger from the proxy logger provider.
       * If the proxy logger provider has no delegate, return a noop logger.
       */
      _getLogger() {
        if (this._delegate) {
          return this._delegate;
        }
        const logger2 = this._provider.getDelegateLogger(this.name, this.version, this.options);
        if (!logger2) {
          return NoopLogger_1.NOOP_LOGGER;
        }
        this._delegate = logger2;
        return this._delegate;
      }
    };
    exports.ProxyLogger = ProxyLogger;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/ProxyLoggerProvider.js
var require_ProxyLoggerProvider = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/ProxyLoggerProvider.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyLoggerProvider = void 0;
    var NoopLoggerProvider_1 = require_NoopLoggerProvider();
    var ProxyLogger_1 = require_ProxyLogger();
    var ProxyLoggerProvider = class {
      static {
        __name(this, "ProxyLoggerProvider");
      }
      getLogger(name2, version, options) {
        var _a;
        return (_a = this.getDelegateLogger(name2, version, options)) !== null && _a !== void 0 ? _a : new ProxyLogger_1.ProxyLogger(this, name2, version, options);
      }
      getDelegate() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
      }
      /**
       * Set the delegate logger provider
       */
      setDelegate(delegate) {
        this._delegate = delegate;
      }
      getDelegateLogger(name2, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getLogger(name2, version, options);
      }
    };
    exports.ProxyLoggerProvider = ProxyLoggerProvider;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js
var require_globalThis2 = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js
var require_node2 = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    var globalThis_1 = require_globalThis2();
    Object.defineProperty(exports, "_globalThis", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return globalThis_1._globalThis;
    }, "get") });
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/platform/index.js
var require_platform2 = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/platform/index.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    var node_1 = require_node2();
    Object.defineProperty(exports, "_globalThis", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_1._globalThis;
    }, "get") });
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js
var require_global_utils = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.API_BACKWARDS_COMPATIBILITY_VERSION = exports.makeGetter = exports._global = exports.GLOBAL_LOGS_API_KEY = void 0;
    var platform_1 = require_platform2();
    exports.GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
    exports._global = platform_1._globalThis;
    function makeGetter(requiredVersion, instance, fallback) {
      return (version) => version === requiredVersion ? instance : fallback;
    }
    __name(makeGetter, "makeGetter");
    exports.makeGetter = makeGetter;
    exports.API_BACKWARDS_COMPATIBILITY_VERSION = 1;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/api/logs.js
var require_logs = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/api/logs.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LogsAPI = void 0;
    var global_utils_1 = require_global_utils();
    var NoopLoggerProvider_1 = require_NoopLoggerProvider();
    var ProxyLoggerProvider_1 = require_ProxyLoggerProvider();
    var LogsAPI = class _LogsAPI {
      static {
        __name(this, "LogsAPI");
      }
      constructor() {
        this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider();
      }
      static getInstance() {
        if (!this._instance) {
          this._instance = new _LogsAPI();
        }
        return this._instance;
      }
      setGlobalLoggerProvider(provider) {
        if (global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) {
          return this.getLoggerProvider();
        }
        global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY] = (0, global_utils_1.makeGetter)(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER);
        this._proxyLoggerProvider.setDelegate(provider);
        return provider;
      }
      /**
       * Returns the global logger provider.
       *
       * @returns LoggerProvider
       */
      getLoggerProvider() {
        var _a, _b;
        return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : this._proxyLoggerProvider;
      }
      /**
       * Returns a logger from the global logger provider.
       *
       * @returns Logger
       */
      getLogger(name2, version, options) {
        return this.getLoggerProvider().getLogger(name2, version, options);
      }
      /** Remove the global logger provider */
      disable() {
        delete global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY];
        this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider();
      }
    };
    exports.LogsAPI = LogsAPI;
  }
});

// node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/index.js
var require_src3 = __commonJS({
  "node_modules/@trigger.dev/core/node_modules/@opentelemetry/api-logs/build/src/index.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logs = exports.ProxyLoggerProvider = exports.ProxyLogger = exports.NoopLoggerProvider = exports.NOOP_LOGGER_PROVIDER = exports.NoopLogger = exports.NOOP_LOGGER = exports.SeverityNumber = void 0;
    var LogRecord_1 = require_LogRecord();
    Object.defineProperty(exports, "SeverityNumber", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return LogRecord_1.SeverityNumber;
    }, "get") });
    var NoopLogger_1 = require_NoopLogger();
    Object.defineProperty(exports, "NOOP_LOGGER", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return NoopLogger_1.NOOP_LOGGER;
    }, "get") });
    Object.defineProperty(exports, "NoopLogger", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return NoopLogger_1.NoopLogger;
    }, "get") });
    var NoopLoggerProvider_1 = require_NoopLoggerProvider();
    Object.defineProperty(exports, "NOOP_LOGGER_PROVIDER", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
    }, "get") });
    Object.defineProperty(exports, "NoopLoggerProvider", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return NoopLoggerProvider_1.NoopLoggerProvider;
    }, "get") });
    var ProxyLogger_1 = require_ProxyLogger();
    Object.defineProperty(exports, "ProxyLogger", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ProxyLogger_1.ProxyLogger;
    }, "get") });
    var ProxyLoggerProvider_1 = require_ProxyLoggerProvider();
    Object.defineProperty(exports, "ProxyLoggerProvider", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ProxyLoggerProvider_1.ProxyLoggerProvider;
    }, "get") });
    var logs_1 = require_logs();
    exports.logs = logs_1.LogsAPI.getInstance();
  }
});

// node_modules/humanize-duration/humanize-duration.js
var require_humanize_duration = __commonJS({
  "node_modules/humanize-duration/humanize-duration.js"(exports, module) {
    init_esm();
    (function() {
      var assign = Object.assign || /** @param {...any} destination */
      function(destination) {
        var source;
        for (var i2 = 1; i2 < arguments.length; i2++) {
          source = arguments[i2];
          for (var prop in source) {
            if (has(source, prop)) {
              destination[prop] = source[prop];
            }
          }
        }
        return destination;
      };
      var isArray = Array.isArray || function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
      var GREEK = onesLanguage(
        ["", ""],
        ["", ""],
        ["", ""],
        ["", ""],
        ["", ""],
        ["", ""],
        ["", ""],
        ["  ", "  "],
        ","
      );
      var LANGUAGES = {
        af: onesLanguage(
          ["jaar", "jaar"],
          ["maand", "maande"],
          ["week", "weke"],
          ["dag", "dae"],
          ["uur", "ure"],
          ["minuut", "minute"],
          ["sekonde", "sekondes"],
          ["millisekonde", "millisekondes"],
          ","
        ),
        am: language("", "", "", "", "", "", "", ""),
        ar: assign(
          language(
            function(c2) {
              return ["", "", ""][getArabicForm(c2)];
            },
            function(c2) {
              return ["", "", ""][getArabicForm(c2)];
            },
            function(c2) {
              return ["", "", ""][getArabicForm(c2)];
            },
            function(c2) {
              return ["", "", ""][getArabicForm(c2)];
            },
            function(c2) {
              return ["", "", ""][getArabicForm(c2)];
            },
            function(c2) {
              return ["", "", ""][getArabicForm(c2)];
            },
            function(c2) {
              return ["", "", ""][getArabicForm(c2)];
            },
            function(c2) {
              return ["  ", "  ", "  "][getArabicForm(c2)];
            },
            ","
          ),
          {
            delimiter: "  ",
            _hideCountIf2: true,
            _digitReplacements: ["", "", "", "", "", "", "", "", "", ""]
          }
        ),
        bg: slavicLanguage(
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""]
        ),
        bn: language(
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ),
        ca: onesLanguage(
          ["any", "anys"],
          ["mes", "mesos"],
          ["setmana", "setmanes"],
          ["dia", "dies"],
          ["hora", "hores"],
          ["minut", "minuts"],
          ["segon", "segons"],
          ["milisegon", "milisegons"],
          ","
        ),
        ckb: language(
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          " ",
          "."
        ),
        cs: language(
          function(c2) {
            return ["rok", "roku", "roky", "let"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["msc", "msce", "msce", "msc"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["tden", "tdne", "tdny", "tdn"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["den", "dne", "dny", "dn"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["hodina", "hodiny", "hodiny", "hodin"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["minuta", "minuty", "minuty", "minut"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["sekunda", "sekundy", "sekundy", "sekund"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["milisekunda", "milisekundy", "milisekundy", "milisekund"][getCzechOrSlovakForm(c2)];
          },
          ","
        ),
        cy: language(
          "flwyddyn",
          "mis",
          "wythnos",
          "diwrnod",
          "awr",
          "munud",
          "eiliad",
          "milieiliad"
        ),
        da: onesLanguage(
          ["r", "r"],
          ["mned", "mneder"],
          ["uge", "uger"],
          ["dag", "dage"],
          ["time", "timer"],
          ["minut", "minutter"],
          ["sekund", "sekunder"],
          ["millisekund", "millisekunder"],
          ","
        ),
        de: onesLanguage(
          ["Jahr", "Jahre"],
          ["Monat", "Monate"],
          ["Woche", "Wochen"],
          ["Tag", "Tage"],
          ["Stunde", "Stunden"],
          ["Minute", "Minuten"],
          ["Sekunde", "Sekunden"],
          ["Millisekunde", "Millisekunden"],
          ","
        ),
        el: GREEK,
        en: onesLanguage(
          ["year", "years"],
          ["month", "months"],
          ["week", "weeks"],
          ["day", "days"],
          ["hour", "hours"],
          ["minute", "minutes"],
          ["second", "seconds"],
          ["millisecond", "milliseconds"]
        ),
        eo: onesLanguage(
          ["jaro", "jaroj"],
          ["monato", "monatoj"],
          ["semajno", "semajnoj"],
          ["tago", "tagoj"],
          ["horo", "horoj"],
          ["minuto", "minutoj"],
          ["sekundo", "sekundoj"],
          ["milisekundo", "milisekundoj"],
          ","
        ),
        es: onesLanguage(
          ["ao", "aos"],
          ["mes", "meses"],
          ["semana", "semanas"],
          ["da", "das"],
          ["hora", "horas"],
          ["minuto", "minutos"],
          ["segundo", "segundos"],
          ["milisegundo", "milisegundos"],
          ","
        ),
        et: onesLanguage(
          ["aasta", "aastat"],
          ["kuu", "kuud"],
          ["ndal", "ndalat"],
          ["pev", "peva"],
          ["tund", "tundi"],
          ["minut", "minutit"],
          ["sekund", "sekundit"],
          ["millisekund", "millisekundit"],
          ","
        ),
        eu: language(
          "urte",
          "hilabete",
          "aste",
          "egun",
          "ordu",
          "minutu",
          "segundo",
          "milisegundo",
          ","
        ),
        fa: language(
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          " "
        ),
        fi: onesLanguage(
          ["vuosi", "vuotta"],
          ["kuukausi", "kuukautta"],
          ["viikko", "viikkoa"],
          ["piv", "piv"],
          ["tunti", "tuntia"],
          ["minuutti", "minuuttia"],
          ["sekunti", "sekuntia"],
          ["millisekunti", "millisekuntia"],
          ","
        ),
        fo: onesLanguage(
          ["r", "r"],
          ["mnaur", "mnair"],
          ["vika", "vikur"],
          ["dagur", "dagar"],
          ["tmi", "tmar"],
          ["minuttur", "minuttir"],
          ["sekund", "sekund"],
          ["millisekund", "millisekund"],
          ","
        ),
        fr: language(
          function(c2) {
            return "an" + (c2 >= 2 ? "s" : "");
          },
          "mois",
          function(c2) {
            return "semaine" + (c2 >= 2 ? "s" : "");
          },
          function(c2) {
            return "jour" + (c2 >= 2 ? "s" : "");
          },
          function(c2) {
            return "heure" + (c2 >= 2 ? "s" : "");
          },
          function(c2) {
            return "minute" + (c2 >= 2 ? "s" : "");
          },
          function(c2) {
            return "seconde" + (c2 >= 2 ? "s" : "");
          },
          function(c2) {
            return "milliseconde" + (c2 >= 2 ? "s" : "");
          },
          ","
        ),
        gr: GREEK,
        he: onesLanguage(
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""]
        ),
        hr: language(
          function(c2) {
            if (c2 % 10 === 2 || c2 % 10 === 3 || c2 % 10 === 4) {
              return "godine";
            }
            return "godina";
          },
          function(c2) {
            if (c2 === 1) {
              return "mjesec";
            } else if (c2 === 2 || c2 === 3 || c2 === 4) {
              return "mjeseca";
            }
            return "mjeseci";
          },
          function(c2) {
            if (c2 % 10 === 1 && c2 !== 11) {
              return "tjedan";
            }
            return "tjedna";
          },
          onesUnit(["dan", "dana"]),
          function(c2) {
            if (c2 === 1) {
              return "sat";
            } else if (c2 === 2 || c2 === 3 || c2 === 4) {
              return "sata";
            }
            return "sati";
          },
          function(c2) {
            var mod10 = c2 % 10;
            if ((mod10 === 2 || mod10 === 3 || mod10 === 4) && (c2 < 10 || c2 > 14)) {
              return "minute";
            }
            return "minuta";
          },
          function(c2) {
            var mod10 = c2 % 10;
            if (mod10 === 5 || Math.floor(c2) === c2 && c2 >= 10 && c2 <= 19) {
              return "sekundi";
            } else if (mod10 === 1) {
              return "sekunda";
            } else if (mod10 === 2 || mod10 === 3 || mod10 === 4) {
              return "sekunde";
            }
            return "sekundi";
          },
          function(c2) {
            if (c2 === 1) {
              return "milisekunda";
            } else if (c2 % 10 === 2 || c2 % 10 === 3 || c2 % 10 === 4) {
              return "milisekunde";
            }
            return "milisekundi";
          },
          ","
        ),
        hi: language(
          "",
          onesUnit(["", ""]),
          onesUnit(["", ""]),
          "",
          onesUnit(["", ""]),
          "",
          "",
          ""
        ),
        hu: language(
          "v",
          "hnap",
          "ht",
          "nap",
          "ra",
          "perc",
          "msodperc",
          "ezredmsodperc",
          ","
        ),
        id: language(
          "tahun",
          "bulan",
          "minggu",
          "hari",
          "jam",
          "menit",
          "detik",
          "milidetik"
        ),
        is: onesLanguage(
          ["r", "r"],
          ["mnuur", "mnuir"],
          ["vika", "vikur"],
          ["dagur", "dagar"],
          ["klukkutmi", "klukkutmar"],
          ["mnta", "mntur"],
          ["seknda", "sekndur"],
          ["milliseknda", "millisekndur"]
        ),
        it: onesLanguage(
          ["anno", "anni"],
          ["mese", "mesi"],
          ["settimana", "settimane"],
          ["giorno", "giorni"],
          ["ora", "ore"],
          ["minuto", "minuti"],
          ["secondo", "secondi"],
          ["millisecondo", "millisecondi"],
          ","
        ),
        ja: language("", "", "", "", "", "", "", ""),
        km: language(
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ),
        kn: onesLanguage(
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""]
        ),
        ko: language("", "", "", "", "", "", "", " "),
        ku: language(
          "sal",
          "meh",
          "hefte",
          "roj",
          "seet",
          "deqe",
          "saniye",
          "mlirk",
          ","
        ),
        lo: language(
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ","
        ),
        lt: language(
          function(c2) {
            return c2 % 10 === 0 || c2 % 100 >= 10 && c2 % 100 <= 20 ? "met" : "metai";
          },
          function(c2) {
            return ["mnuo", "mnesiai", "mnesi"][getLithuanianForm(c2)];
          },
          function(c2) {
            return ["savait", "savaits", "savaii"][getLithuanianForm(c2)];
          },
          function(c2) {
            return ["diena", "dienos", "dien"][getLithuanianForm(c2)];
          },
          function(c2) {
            return ["valanda", "valandos", "valand"][getLithuanianForm(c2)];
          },
          function(c2) {
            return ["minut", "minuts", "minui"][getLithuanianForm(c2)];
          },
          function(c2) {
            return ["sekund", "sekunds", "sekundi"][getLithuanianForm(c2)];
          },
          function(c2) {
            return ["milisekund", "milisekunds", "milisekundi"][getLithuanianForm(c2)];
          },
          ","
        ),
        lv: language(
          function(c2) {
            return getLatvianForm(c2) ? "gads" : "gadi";
          },
          function(c2) {
            return getLatvianForm(c2) ? "mnesis" : "mnei";
          },
          function(c2) {
            return getLatvianForm(c2) ? "neda" : "nedas";
          },
          function(c2) {
            return getLatvianForm(c2) ? "diena" : "dienas";
          },
          function(c2) {
            return getLatvianForm(c2) ? "stunda" : "stundas";
          },
          function(c2) {
            return getLatvianForm(c2) ? "minte" : "mintes";
          },
          function(c2) {
            return getLatvianForm(c2) ? "sekunde" : "sekundes";
          },
          function(c2) {
            return getLatvianForm(c2) ? "milisekunde" : "milisekundes";
          },
          ","
        ),
        mk: onesLanguage(
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ","
        ),
        mn: language(
          "",
          "",
          " ",
          "",
          "",
          "",
          "",
          ""
        ),
        mr: language(
          onesUnit(["", ""]),
          onesUnit(["", ""]),
          onesUnit(["", ""]),
          "",
          "",
          onesUnit(["", ""]),
          "",
          ""
        ),
        ms: language(
          "tahun",
          "bulan",
          "minggu",
          "hari",
          "jam",
          "minit",
          "saat",
          "milisaat"
        ),
        nl: onesLanguage(
          ["jaar", "jaar"],
          ["maand", "maanden"],
          ["week", "weken"],
          ["dag", "dagen"],
          ["uur", "uur"],
          ["minuut", "minuten"],
          ["seconde", "seconden"],
          ["milliseconde", "milliseconden"],
          ","
        ),
        no: onesLanguage(
          ["r", "r"],
          ["mned", "mneder"],
          ["uke", "uker"],
          ["dag", "dager"],
          ["time", "timer"],
          ["minutt", "minutter"],
          ["sekund", "sekunder"],
          ["millisekund", "millisekunder"],
          ","
        ),
        pl: language(
          function(c2) {
            return ["rok", "roku", "lata", "lat"][getPolishForm(c2)];
          },
          function(c2) {
            return ["miesic", "miesica", "miesice", "miesicy"][getPolishForm(c2)];
          },
          function(c2) {
            return ["tydzie", "tygodnia", "tygodnie", "tygodni"][getPolishForm(c2)];
          },
          function(c2) {
            return ["dzie", "dnia", "dni", "dni"][getPolishForm(c2)];
          },
          function(c2) {
            return ["godzina", "godziny", "godziny", "godzin"][getPolishForm(c2)];
          },
          function(c2) {
            return ["minuta", "minuty", "minuty", "minut"][getPolishForm(c2)];
          },
          function(c2) {
            return ["sekunda", "sekundy", "sekundy", "sekund"][getPolishForm(c2)];
          },
          function(c2) {
            return ["milisekunda", "milisekundy", "milisekundy", "milisekund"][getPolishForm(c2)];
          },
          ","
        ),
        pt: onesLanguage(
          ["ano", "anos"],
          ["ms", "meses"],
          ["semana", "semanas"],
          ["dia", "dias"],
          ["hora", "horas"],
          ["minuto", "minutos"],
          ["segundo", "segundos"],
          ["milissegundo", "milissegundos"],
          ","
        ),
        ro: onesLanguage(
          ["an", "ani"],
          ["lun", "luni"],
          ["sptmn", "sptmni"],
          ["zi", "zile"],
          ["or", "ore"],
          ["minut", "minute"],
          ["secund", "secunde"],
          ["milisecund", "milisecunde"],
          ","
        ),
        ru: slavicLanguage(
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""]
        ),
        sq: language(
          onesUnit(["vit", "vjet"]),
          "muaj",
          "jav",
          "dit",
          "or",
          function(c2) {
            return "minut" + (c2 === 1 ? "" : "a");
          },
          function(c2) {
            return "sekond" + (c2 === 1 ? "" : "a");
          },
          function(c2) {
            return "milisekond" + (c2 === 1 ? "" : "a");
          },
          ","
        ),
        sr: slavicLanguage(
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""]
        ),
        sr_Latn: slavicLanguage(
          ["godini", "godina", "godine"],
          ["meseci", "mesec", "meseca"],
          ["nedelji", "nedelja", "nedelje"],
          ["dani", "dan", "dana"],
          ["sati", "sat", "sata"],
          ["minuta", "minut", "minuta"],
          ["sekundi", "sekunda", "sekunde"],
          ["milisekundi", "milisekunda", "milisekunde"]
        ),
        ta: onesLanguage(
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          [" ", " "]
        ),
        te: onesLanguage(
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""]
        ),
        uk: slavicLanguage(
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""]
        ),
        ur: language(
          "",
          onesUnit(["", ""]),
          onesUnit(["", ""]),
          "",
          onesUnit(["", ""]),
          "",
          "",
          " "
        ),
        sk: language(
          function(c2) {
            return ["rok", "roky", "roky", "rokov"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["mesiac", "mesiace", "mesiace", "mesiacov"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["tde", "tdne", "tdne", "tdov"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["de", "dni", "dni", "dn"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["hodina", "hodiny", "hodiny", "hodn"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["minta", "minty", "minty", "mint"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["sekunda", "sekundy", "sekundy", "seknd"][getCzechOrSlovakForm(c2)];
          },
          function(c2) {
            return ["milisekunda", "milisekundy", "milisekundy", "miliseknd"][getCzechOrSlovakForm(c2)];
          },
          ","
        ),
        sl: language(
          function(c2) {
            if (c2 % 10 === 1) {
              return "leto";
            } else if (c2 % 100 === 2) {
              return "leti";
            } else if (c2 % 100 === 3 || c2 % 100 === 4 || Math.floor(c2) !== c2 && c2 % 100 <= 5) {
              return "leta";
            } else {
              return "let";
            }
          },
          function(c2) {
            if (c2 % 10 === 1) {
              return "mesec";
            } else if (c2 % 100 === 2 || Math.floor(c2) !== c2 && c2 % 100 <= 5) {
              return "meseca";
            } else if (c2 % 10 === 3 || c2 % 10 === 4) {
              return "mesece";
            } else {
              return "mesecev";
            }
          },
          function(c2) {
            if (c2 % 10 === 1) {
              return "teden";
            } else if (c2 % 10 === 2 || Math.floor(c2) !== c2 && c2 % 100 <= 4) {
              return "tedna";
            } else if (c2 % 10 === 3 || c2 % 10 === 4) {
              return "tedne";
            } else {
              return "tednov";
            }
          },
          function(c2) {
            return c2 % 100 === 1 ? "dan" : "dni";
          },
          function(c2) {
            if (c2 % 10 === 1) {
              return "ura";
            } else if (c2 % 100 === 2) {
              return "uri";
            } else if (c2 % 10 === 3 || c2 % 10 === 4 || Math.floor(c2) !== c2) {
              return "ure";
            } else {
              return "ur";
            }
          },
          function(c2) {
            if (c2 % 10 === 1) {
              return "minuta";
            } else if (c2 % 10 === 2) {
              return "minuti";
            } else if (c2 % 10 === 3 || c2 % 10 === 4 || Math.floor(c2) !== c2 && c2 % 100 <= 4) {
              return "minute";
            } else {
              return "minut";
            }
          },
          function(c2) {
            if (c2 % 10 === 1) {
              return "sekunda";
            } else if (c2 % 100 === 2) {
              return "sekundi";
            } else if (c2 % 100 === 3 || c2 % 100 === 4 || Math.floor(c2) !== c2) {
              return "sekunde";
            } else {
              return "sekund";
            }
          },
          function(c2) {
            if (c2 % 10 === 1) {
              return "milisekunda";
            } else if (c2 % 100 === 2) {
              return "milisekundi";
            } else if (c2 % 100 === 3 || c2 % 100 === 4 || Math.floor(c2) !== c2) {
              return "milisekunde";
            } else {
              return "milisekund";
            }
          },
          ","
        ),
        sv: onesLanguage(
          ["r", "r"],
          ["mnad", "mnader"],
          ["vecka", "veckor"],
          ["dag", "dagar"],
          ["timme", "timmar"],
          ["minut", "minuter"],
          ["sekund", "sekunder"],
          ["millisekund", "millisekunder"],
          ","
        ),
        sw: assign(
          onesLanguage(
            ["mwaka", "miaka"],
            ["mwezi", "miezi"],
            ["wiki", "wiki"],
            ["siku", "masiku"],
            ["saa", "masaa"],
            ["dakika", "dakika"],
            ["sekunde", "sekunde"],
            ["milisekunde", "milisekunde"]
          ),
          { _numberFirst: true }
        ),
        tr: language(
          "yl",
          "ay",
          "hafta",
          "gn",
          "saat",
          "dakika",
          "saniye",
          "milisaniye",
          ","
        ),
        th: language(
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ),
        uz: language(
          "yil",
          "oy",
          "hafta",
          "kun",
          "soat",
          "minut",
          "sekund",
          "millisekund"
        ),
        uz_CYR: language(
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ),
        vi: language(
          "nm",
          "thng",
          "tun",
          "ngy",
          "gi",
          "pht",
          "giy",
          "mili giy",
          ","
        ),
        zh_CN: language("", "", "", "", "", "", "", ""),
        zh_TW: language("", "", "", "", "", "", "", "")
      };
      function language(y2, mo, w, d2, h, m2, s, ms, decimal) {
        var result = { y: y2, mo, w, d: d2, h, m: m2, s, ms };
        if (decimal) {
          result.decimal = decimal;
        }
        return result;
      }
      __name(language, "language");
      function onesUnit(unit) {
        return function(c2) {
          return c2 === 1 ? unit[0] : unit[1];
        };
      }
      __name(onesUnit, "onesUnit");
      function onesLanguage(y2, mo, w, d2, h, m2, s, ms, decimal) {
        return language(
          onesUnit(y2),
          onesUnit(mo),
          onesUnit(w),
          onesUnit(d2),
          onesUnit(h),
          onesUnit(m2),
          onesUnit(s),
          onesUnit(ms),
          decimal
        );
      }
      __name(onesLanguage, "onesLanguage");
      function slavicUnit(unit) {
        return function(c2) {
          if (Math.floor(c2) !== c2) {
            return unit[2];
          }
          if (c2 % 100 >= 5 && c2 % 100 <= 20 || c2 % 10 >= 5 && c2 % 10 <= 9 || c2 % 10 === 0) {
            return unit[0];
          }
          if (c2 % 10 === 1) {
            return unit[1];
          }
          if (c2 > 1) {
            return unit[2];
          }
          return unit[1];
        };
      }
      __name(slavicUnit, "slavicUnit");
      function slavicLanguage(y2, mo, w, d2, h, m2, s, ms) {
        return language(
          slavicUnit(y2),
          slavicUnit(mo),
          slavicUnit(w),
          slavicUnit(d2),
          slavicUnit(h),
          slavicUnit(m2),
          slavicUnit(s),
          slavicUnit(ms),
          ","
        );
      }
      __name(slavicLanguage, "slavicLanguage");
      function getArabicForm(c2) {
        if (c2 === 2) {
          return 1;
        }
        if (c2 > 2 && c2 < 11) {
          return 2;
        }
        return 0;
      }
      __name(getArabicForm, "getArabicForm");
      function getPolishForm(c2) {
        if (c2 === 1) {
          return 0;
        }
        if (Math.floor(c2) !== c2) {
          return 1;
        }
        if (c2 % 10 >= 2 && c2 % 10 <= 4 && !(c2 % 100 > 10 && c2 % 100 < 20)) {
          return 2;
        }
        return 3;
      }
      __name(getPolishForm, "getPolishForm");
      function getCzechOrSlovakForm(c2) {
        if (c2 === 1) {
          return 0;
        }
        if (Math.floor(c2) !== c2) {
          return 1;
        }
        if (c2 % 10 >= 2 && c2 % 10 <= 4 && c2 % 100 < 10) {
          return 2;
        }
        return 3;
      }
      __name(getCzechOrSlovakForm, "getCzechOrSlovakForm");
      function getLithuanianForm(c2) {
        if (c2 === 1 || c2 % 10 === 1 && c2 % 100 > 20) {
          return 0;
        }
        if (Math.floor(c2) !== c2 || c2 % 10 >= 2 && c2 % 100 > 20 || c2 % 10 >= 2 && c2 % 100 < 10) {
          return 1;
        }
        return 2;
      }
      __name(getLithuanianForm, "getLithuanianForm");
      function getLatvianForm(c2) {
        return c2 % 10 === 1 && c2 % 100 !== 11;
      }
      __name(getLatvianForm, "getLatvianForm");
      function has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      __name(has, "has");
      function getLanguage(options) {
        var possibleLanguages = [options.language];
        if (has(options, "fallbacks")) {
          if (isArray(options.fallbacks) && options.fallbacks.length) {
            possibleLanguages = possibleLanguages.concat(options.fallbacks);
          } else {
            throw new Error("fallbacks must be an array with at least one element");
          }
        }
        for (var i2 = 0; i2 < possibleLanguages.length; i2++) {
          var languageToTry = possibleLanguages[i2];
          if (has(options.languages, languageToTry)) {
            return options.languages[languageToTry];
          }
          if (has(LANGUAGES, languageToTry)) {
            return LANGUAGES[languageToTry];
          }
        }
        throw new Error("No language found.");
      }
      __name(getLanguage, "getLanguage");
      function renderPiece(piece, language2, options) {
        var unitName = piece.unitName;
        var unitCount = piece.unitCount;
        var spacer = options.spacer;
        var maxDecimalPoints = options.maxDecimalPoints;
        var decimal;
        if (has(options, "decimal")) {
          decimal = options.decimal;
        } else if (has(language2, "decimal")) {
          decimal = language2.decimal;
        } else {
          decimal = ".";
        }
        var digitReplacements;
        if ("digitReplacements" in options) {
          digitReplacements = options.digitReplacements;
        } else if ("_digitReplacements" in language2) {
          digitReplacements = language2._digitReplacements;
        }
        var formattedCount;
        var normalizedUnitCount = maxDecimalPoints === void 0 ? unitCount : Math.floor(unitCount * Math.pow(10, maxDecimalPoints)) / Math.pow(10, maxDecimalPoints);
        var countStr = normalizedUnitCount.toString();
        if (language2._hideCountIf2 && unitCount === 2) {
          formattedCount = "";
          spacer = "";
        } else {
          if (digitReplacements) {
            formattedCount = "";
            for (var i2 = 0; i2 < countStr.length; i2++) {
              var character = countStr[i2];
              if (character === ".") {
                formattedCount += decimal;
              } else {
                formattedCount += digitReplacements[
                  /** @type {"0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"} */
                  character
                ];
              }
            }
          } else {
            formattedCount = countStr.replace(".", decimal);
          }
        }
        var languageWord = language2[unitName];
        var word;
        if (typeof languageWord === "function") {
          word = languageWord(unitCount);
        } else {
          word = languageWord;
        }
        if (language2._numberFirst) {
          return word + spacer + formattedCount;
        }
        return formattedCount + spacer + word;
      }
      __name(renderPiece, "renderPiece");
      function getPieces(ms, options) {
        var unitName;
        var i2;
        var unitCount;
        var msRemaining;
        var units = options.units;
        var unitMeasures = options.unitMeasures;
        var largest = "largest" in options ? options.largest : Infinity;
        if (!units.length) return [];
        var unitCounts = {};
        msRemaining = ms;
        for (i2 = 0; i2 < units.length; i2++) {
          unitName = units[i2];
          var unitMs = unitMeasures[unitName];
          var isLast = i2 === units.length - 1;
          unitCount = isLast ? msRemaining / unitMs : Math.floor(msRemaining / unitMs);
          unitCounts[unitName] = unitCount;
          msRemaining -= unitCount * unitMs;
        }
        if (options.round) {
          var unitsRemainingBeforeRound = largest;
          for (i2 = 0; i2 < units.length; i2++) {
            unitName = units[i2];
            unitCount = unitCounts[unitName];
            if (unitCount === 0) continue;
            unitsRemainingBeforeRound--;
            if (unitsRemainingBeforeRound === 0) {
              for (var j = i2 + 1; j < units.length; j++) {
                var smallerUnitName = units[j];
                var smallerUnitCount = unitCounts[smallerUnitName];
                unitCounts[unitName] += smallerUnitCount * unitMeasures[smallerUnitName] / unitMeasures[unitName];
                unitCounts[smallerUnitName] = 0;
              }
              break;
            }
          }
          for (i2 = units.length - 1; i2 >= 0; i2--) {
            unitName = units[i2];
            unitCount = unitCounts[unitName];
            if (unitCount === 0) continue;
            var rounded = Math.round(unitCount);
            unitCounts[unitName] = rounded;
            if (i2 === 0) break;
            var previousUnitName = units[i2 - 1];
            var previousUnitMs = unitMeasures[previousUnitName];
            var amountOfPreviousUnit = Math.floor(
              rounded * unitMeasures[unitName] / previousUnitMs
            );
            if (amountOfPreviousUnit) {
              unitCounts[previousUnitName] += amountOfPreviousUnit;
              unitCounts[unitName] = 0;
            } else {
              break;
            }
          }
        }
        var result = [];
        for (i2 = 0; i2 < units.length && result.length < largest; i2++) {
          unitName = units[i2];
          unitCount = unitCounts[unitName];
          if (unitCount) {
            result.push({ unitName, unitCount });
          }
        }
        return result;
      }
      __name(getPieces, "getPieces");
      function formatPieces(pieces, options) {
        var language2 = getLanguage(options);
        if (!pieces.length) {
          var units = options.units;
          var smallestUnitName = units[units.length - 1];
          return renderPiece(
            { unitName: smallestUnitName, unitCount: 0 },
            language2,
            options
          );
        }
        var conjunction = options.conjunction;
        var serialComma = options.serialComma;
        var delimiter;
        if (has(options, "delimiter")) {
          delimiter = options.delimiter;
        } else if (has(language2, "delimiter")) {
          delimiter = language2.delimiter;
        } else {
          delimiter = ", ";
        }
        var renderedPieces = [];
        for (var i2 = 0; i2 < pieces.length; i2++) {
          renderedPieces.push(renderPiece(pieces[i2], language2, options));
        }
        if (!conjunction || pieces.length === 1) {
          return renderedPieces.join(delimiter);
        }
        if (pieces.length === 2) {
          return renderedPieces.join(conjunction);
        }
        return renderedPieces.slice(0, -1).join(delimiter) + (serialComma ? "," : "") + conjunction + renderedPieces.slice(-1);
      }
      __name(formatPieces, "formatPieces");
      function humanizer(passedOptions) {
        var result = /* @__PURE__ */ __name(function humanizer2(ms, humanizerOptions) {
          ms = Math.abs(ms);
          var options = assign({}, result, humanizerOptions || {});
          var pieces = getPieces(ms, options);
          return formatPieces(pieces, options);
        }, "humanizer");
        return assign(
          result,
          {
            language: "en",
            spacer: " ",
            conjunction: "",
            serialComma: true,
            units: ["y", "mo", "w", "d", "h", "m", "s"],
            languages: {},
            round: false,
            unitMeasures: {
              y: 315576e5,
              mo: 26298e5,
              w: 6048e5,
              d: 864e5,
              h: 36e5,
              m: 6e4,
              s: 1e3,
              ms: 1
            }
          },
          passedOptions
        );
      }
      __name(humanizer, "humanizer");
      var humanizeDuration2 = assign(humanizer({}), {
        getSupportedLanguages: /* @__PURE__ */ __name(function getSupportedLanguages() {
          var result = [];
          for (var language2 in LANGUAGES) {
            if (has(LANGUAGES, language2) && language2 !== "gr") {
              result.push(language2);
            }
          }
          return result;
        }, "getSupportedLanguages"),
        humanizer
      });
      if (typeof define === "function" && define.amd) {
        define(function() {
          return humanizeDuration2;
        });
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = humanizeDuration2;
      } else {
        this.humanizeDuration = humanizeDuration2;
      }
    })();
  }
});

// node_modules/@prisma/client/runtime/binary.js
var require_binary = __commonJS({
  "node_modules/@prisma/client/runtime/binary.js"(exports, module) {
    "use strict";
    init_esm();
    var mb = Object.create;
    var co = Object.defineProperty;
    var yb = Object.getOwnPropertyDescriptor;
    var wb = Object.getOwnPropertyNames;
    var Db = Object.getPrototypeOf;
    var Rb = Object.prototype.hasOwnProperty;
    var $h = /* @__PURE__ */ __name((t2, e) => () => (t2 && (e = t2(t2 = 0)), e), "$h");
    var C2 = /* @__PURE__ */ __name((t2, e) => () => (e || t2((e = { exports: {} }).exports, e), e.exports), "C");
    var Jn = /* @__PURE__ */ __name((t2, e) => {
      for (var r2 in e) co(t2, r2, { get: e[r2], enumerable: true });
    }, "Jn");
    var zh = /* @__PURE__ */ __name((t2, e, r2, n2) => {
      if (e && typeof e == "object" || typeof e == "function") for (let A2 of wb(e)) !Rb.call(t2, A2) && A2 !== r2 && co(t2, A2, { get: /* @__PURE__ */ __name(() => e[A2], "get"), enumerable: !(n2 = yb(e, A2)) || n2.enumerable });
      return t2;
    }, "zh");
    var G2 = /* @__PURE__ */ __name((t2, e, r2) => (r2 = t2 != null ? mb(Db(t2)) : {}, zh(e || !t2 || !t2.__esModule ? co(r2, "default", { value: t2, enumerable: true }) : r2, t2)), "G");
    var Sb = /* @__PURE__ */ __name((t2) => zh(co({}, "__esModule", { value: true }), t2), "Sb");
    var Df = C2((i9, wf) => {
      "use strict";
      wf.exports = yf;
      yf.sync = dN;
      var Bf = __require("node:fs");
      function EN(t2, e) {
        var r2 = e.pathExt !== void 0 ? e.pathExt : process.env.PATHEXT;
        if (!r2 || (r2 = r2.split(";"), r2.indexOf("") !== -1)) return true;
        for (var n2 = 0; n2 < r2.length; n2++) {
          var A2 = r2[n2].toLowerCase();
          if (A2 && t2.substr(-A2.length).toLowerCase() === A2) return true;
        }
        return false;
      }
      __name(EN, "EN");
      function mf(t2, e, r2) {
        return !t2.isSymbolicLink() && !t2.isFile() ? false : EN(e, r2);
      }
      __name(mf, "mf");
      function yf(t2, e, r2) {
        Bf.stat(t2, function(n2, A2) {
          r2(n2, n2 ? false : mf(A2, t2, e));
        });
      }
      __name(yf, "yf");
      function dN(t2, e) {
        return mf(Bf.statSync(t2), t2, e);
      }
      __name(dN, "dN");
    });
    var Ff = C2((s9, Nf) => {
      "use strict";
      Nf.exports = Sf;
      Sf.sync = hN;
      var Rf = __require("node:fs");
      function Sf(t2, e, r2) {
        Rf.stat(t2, function(n2, A2) {
          r2(n2, n2 ? false : bf(A2, e));
        });
      }
      __name(Sf, "Sf");
      function hN(t2, e) {
        return bf(Rf.statSync(t2), e);
      }
      __name(hN, "hN");
      function bf(t2, e) {
        return t2.isFile() && fN(t2, e);
      }
      __name(bf, "bf");
      function fN(t2, e) {
        var r2 = t2.mode, n2 = t2.uid, A2 = t2.gid, i2 = e.uid !== void 0 ? e.uid : process.getuid && process.getuid(), s = e.gid !== void 0 ? e.gid : process.getgid && process.getgid(), o2 = parseInt("100", 8), a2 = parseInt("010", 8), c2 = parseInt("001", 8), l2 = o2 | a2, u2 = r2 & c2 || r2 & a2 && A2 === s || r2 & o2 && n2 === i2 || r2 & l2 && i2 === 0;
        return u2;
      }
      __name(fN, "fN");
    });
    var xf = C2((a9, Tf) => {
      "use strict";
      var o9 = __require("node:fs"), Bo;
      process.platform === "win32" || global.TESTING_WINDOWS ? Bo = Df() : Bo = Ff();
      Tf.exports = Jl;
      Jl.sync = QN;
      function Jl(t2, e, r2) {
        if (typeof e == "function" && (r2 = e, e = {}), !r2) {
          if (typeof Promise != "function") throw new TypeError("callback not provided");
          return new Promise(function(n2, A2) {
            Jl(t2, e || {}, function(i2, s) {
              i2 ? A2(i2) : n2(s);
            });
          });
        }
        Bo(t2, e || {}, function(n2, A2) {
          n2 && (n2.code === "EACCES" || e && e.ignoreErrors) && (n2 = null, A2 = false), r2(n2, A2);
        });
      }
      __name(Jl, "Jl");
      function QN(t2, e) {
        try {
          return Bo.sync(t2, e || {});
        } catch (r2) {
          if (e && e.ignoreErrors || r2.code === "EACCES") return false;
          throw r2;
        }
      }
      __name(QN, "QN");
    });
    var Yf = C2((c9, Pf) => {
      "use strict";
      var _n = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", Uf = __require("node:path"), CN = _n ? ";" : ":", kf = xf(), Mf = /* @__PURE__ */ __name((t2) => Object.assign(new Error(`not found: ${t2}`), { code: "ENOENT" }), "Mf"), Lf = /* @__PURE__ */ __name((t2, e) => {
        let r2 = e.colon || CN, n2 = t2.match(/\//) || _n && t2.match(/\\/) ? [""] : [..._n ? [process.cwd()] : [], ...(e.path || process.env.PATH || "").split(r2)], A2 = _n ? e.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", i2 = _n ? A2.split(r2) : [""];
        return _n && t2.indexOf(".") !== -1 && i2[0] !== "" && i2.unshift(""), { pathEnv: n2, pathExt: i2, pathExtExe: A2 };
      }, "Lf"), vf = /* @__PURE__ */ __name((t2, e, r2) => {
        typeof e == "function" && (r2 = e, e = {}), e || (e = {});
        let { pathEnv: n2, pathExt: A2, pathExtExe: i2 } = Lf(t2, e), s = [], o2 = /* @__PURE__ */ __name((c2) => new Promise((l2, u2) => {
          if (c2 === n2.length) return e.all && s.length ? l2(s) : u2(Mf(t2));
          let g = n2[c2], E = /^".*"$/.test(g) ? g.slice(1, -1) : g, h = Uf.join(E, t2), f2 = !E && /^\.[\\\/]/.test(t2) ? t2.slice(0, 2) + h : h;
          l2(a2(f2, c2, 0));
        }), "o"), a2 = /* @__PURE__ */ __name((c2, l2, u2) => new Promise((g, E) => {
          if (u2 === A2.length) return g(o2(l2 + 1));
          let h = A2[u2];
          kf(c2 + h, { pathExt: i2 }, (f2, p2) => {
            if (!f2 && p2) if (e.all) s.push(c2 + h);
            else return g(c2 + h);
            return g(a2(c2, l2, u2 + 1));
          });
        }), "a");
        return r2 ? o2(0).then((c2) => r2(null, c2), r2) : o2(0);
      }, "vf"), IN = /* @__PURE__ */ __name((t2, e) => {
        e = e || {};
        let { pathEnv: r2, pathExt: n2, pathExtExe: A2 } = Lf(t2, e), i2 = [];
        for (let s = 0; s < r2.length; s++) {
          let o2 = r2[s], a2 = /^".*"$/.test(o2) ? o2.slice(1, -1) : o2, c2 = Uf.join(a2, t2), l2 = !a2 && /^\.[\\\/]/.test(t2) ? t2.slice(0, 2) + c2 : c2;
          for (let u2 = 0; u2 < n2.length; u2++) {
            let g = l2 + n2[u2];
            try {
              if (kf.sync(g, { pathExt: A2 })) if (e.all) i2.push(g);
              else return g;
            } catch {
            }
          }
        }
        if (e.all && i2.length) return i2;
        if (e.nothrow) return null;
        throw Mf(t2);
      }, "IN");
      Pf.exports = vf;
      vf.sync = IN;
    });
    var _l = C2((l9, Wl) => {
      "use strict";
      var Gf = /* @__PURE__ */ __name((t2 = {}) => {
        let e = t2.env || process.env;
        return (t2.platform || process.platform) !== "win32" ? "PATH" : Object.keys(e).reverse().find((n2) => n2.toUpperCase() === "PATH") || "Path";
      }, "Gf");
      Wl.exports = Gf;
      Wl.exports.default = Gf;
    });
    var qf = C2((u9, Hf) => {
      "use strict";
      var Of = __require("node:path"), pN = Yf(), BN = _l();
      function Vf(t2, e) {
        let r2 = t2.options.env || process.env, n2 = process.cwd(), A2 = t2.options.cwd != null, i2 = A2 && process.chdir !== void 0 && !process.chdir.disabled;
        if (i2) try {
          process.chdir(t2.options.cwd);
        } catch {
        }
        let s;
        try {
          s = pN.sync(t2.command, { path: r2[BN({ env: r2 })], pathExt: e ? Of.delimiter : void 0 });
        } catch {
        } finally {
          i2 && process.chdir(n2);
        }
        return s && (s = Of.resolve(A2 ? t2.options.cwd : "", s)), s;
      }
      __name(Vf, "Vf");
      function mN(t2) {
        return Vf(t2) || Vf(t2, true);
      }
      __name(mN, "mN");
      Hf.exports = mN;
    });
    var Jf = C2((g9, Zl) => {
      "use strict";
      var jl = /([()\][%!^"`<>&|;, *?])/g;
      function yN(t2) {
        return t2 = t2.replace(jl, "^$1"), t2;
      }
      __name(yN, "yN");
      function wN(t2, e) {
        return t2 = `${t2}`, t2 = t2.replace(/(\\*)"/g, '$1$1\\"'), t2 = t2.replace(/(\\*)$/, "$1$1"), t2 = `"${t2}"`, t2 = t2.replace(jl, "^$1"), e && (t2 = t2.replace(jl, "^$1")), t2;
      }
      __name(wN, "wN");
      Zl.exports.command = yN;
      Zl.exports.argument = wN;
    });
    var _f = C2((E9, Wf) => {
      "use strict";
      Wf.exports = /^#!(.*)/;
    });
    var Zf = C2((d9, jf) => {
      "use strict";
      var DN = _f();
      jf.exports = (t2 = "") => {
        let e = t2.match(DN);
        if (!e) return null;
        let [r2, n2] = e[0].replace(/#! ?/, "").split(" "), A2 = r2.split("/").pop();
        return A2 === "env" ? n2 : n2 ? `${A2} ${n2}` : A2;
      };
    });
    var Kf = C2((h9, Xf) => {
      "use strict";
      var Xl = __require("node:fs"), RN = Zf();
      function SN(t2) {
        let r2 = Buffer.alloc(150), n2;
        try {
          n2 = Xl.openSync(t2, "r"), Xl.readSync(n2, r2, 0, 150, 0), Xl.closeSync(n2);
        } catch {
        }
        return RN(r2.toString());
      }
      __name(SN, "SN");
      Xf.exports = SN;
    });
    var tQ = C2((f9, eQ) => {
      "use strict";
      var bN = __require("node:path"), $f = qf(), zf = Jf(), NN = Kf(), FN = process.platform === "win32", TN = /\.(?:com|exe)$/i, xN = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
      function UN(t2) {
        t2.file = $f(t2);
        let e = t2.file && NN(t2.file);
        return e ? (t2.args.unshift(t2.file), t2.command = e, $f(t2)) : t2.file;
      }
      __name(UN, "UN");
      function kN(t2) {
        if (!FN) return t2;
        let e = UN(t2), r2 = !TN.test(e);
        if (t2.options.forceShell || r2) {
          let n2 = xN.test(e);
          t2.command = bN.normalize(t2.command), t2.command = zf.command(t2.command), t2.args = t2.args.map((i2) => zf.argument(i2, n2));
          let A2 = [t2.command].concat(t2.args).join(" ");
          t2.args = ["/d", "/s", "/c", `"${A2}"`], t2.command = process.env.comspec || "cmd.exe", t2.options.windowsVerbatimArguments = true;
        }
        return t2;
      }
      __name(kN, "kN");
      function MN(t2, e, r2) {
        e && !Array.isArray(e) && (r2 = e, e = null), e = e ? e.slice(0) : [], r2 = Object.assign({}, r2);
        let n2 = { command: t2, args: e, options: r2, file: void 0, original: { command: t2, args: e } };
        return r2.shell ? n2 : kN(n2);
      }
      __name(MN, "MN");
      eQ.exports = MN;
    });
    var AQ = C2((Q9, nQ) => {
      "use strict";
      var Kl = process.platform === "win32";
      function $l(t2, e) {
        return Object.assign(new Error(`${e} ${t2.command} ENOENT`), { code: "ENOENT", errno: "ENOENT", syscall: `${e} ${t2.command}`, path: t2.command, spawnargs: t2.args });
      }
      __name($l, "$l");
      function LN(t2, e) {
        if (!Kl) return;
        let r2 = t2.emit;
        t2.emit = function(n2, A2) {
          if (n2 === "exit") {
            let i2 = rQ(A2, e, "spawn");
            if (i2) return r2.call(t2, "error", i2);
          }
          return r2.apply(t2, arguments);
        };
      }
      __name(LN, "LN");
      function rQ(t2, e) {
        return Kl && t2 === 1 && !e.file ? $l(e.original, "spawn") : null;
      }
      __name(rQ, "rQ");
      function vN(t2, e) {
        return Kl && t2 === 1 && !e.file ? $l(e.original, "spawnSync") : null;
      }
      __name(vN, "vN");
      nQ.exports = { hookChildProcess: LN, verifyENOENT: rQ, verifyENOENTSync: vN, notFoundError: $l };
    });
    var oQ = C2((C9, jn) => {
      "use strict";
      var iQ = __require("node:child_process"), zl = tQ(), eu = AQ();
      function sQ(t2, e, r2) {
        let n2 = zl(t2, e, r2), A2 = iQ.spawn(n2.command, n2.args, n2.options);
        return eu.hookChildProcess(A2, n2), A2;
      }
      __name(sQ, "sQ");
      function PN(t2, e, r2) {
        let n2 = zl(t2, e, r2), A2 = iQ.spawnSync(n2.command, n2.args, n2.options);
        return A2.error = A2.error || eu.verifyENOENTSync(A2.status, n2), A2;
      }
      __name(PN, "PN");
      jn.exports = sQ;
      jn.exports.spawn = sQ;
      jn.exports.sync = PN;
      jn.exports._parse = zl;
      jn.exports._enoent = eu;
    });
    var cQ = C2((I9, aQ) => {
      "use strict";
      aQ.exports = (t2) => {
        let e = typeof t2 == "string" ? `
` : 10, r2 = typeof t2 == "string" ? "\r" : 13;
        return t2[t2.length - 1] === e && (t2 = t2.slice(0, t2.length - 1)), t2[t2.length - 1] === r2 && (t2 = t2.slice(0, t2.length - 1)), t2;
      };
    });
    var gQ = C2((p9, pi) => {
      "use strict";
      var Ii = __require("node:path"), lQ = _l(), uQ = /* @__PURE__ */ __name((t2) => {
        t2 = { cwd: process.cwd(), path: process.env[lQ()], execPath: process.execPath, ...t2 };
        let e, r2 = Ii.resolve(t2.cwd), n2 = [];
        for (; e !== r2; ) n2.push(Ii.join(r2, "node_modules/.bin")), e = r2, r2 = Ii.resolve(r2, "..");
        let A2 = Ii.resolve(t2.cwd, t2.execPath, "..");
        return n2.push(A2), n2.concat(t2.path).join(Ii.delimiter);
      }, "uQ");
      pi.exports = uQ;
      pi.exports.default = uQ;
      pi.exports.env = (t2) => {
        t2 = { env: process.env, ...t2 };
        let e = { ...t2.env }, r2 = lQ({ env: e });
        return t2.path = e[r2], e[r2] = pi.exports(t2), e;
      };
    });
    var dQ = C2((B9, tu) => {
      "use strict";
      var EQ = /* @__PURE__ */ __name((t2, e) => {
        for (let r2 of Reflect.ownKeys(e)) Object.defineProperty(t2, r2, Object.getOwnPropertyDescriptor(e, r2));
        return t2;
      }, "EQ");
      tu.exports = EQ;
      tu.exports.default = EQ;
    });
    var fQ = C2((m9, yo) => {
      "use strict";
      var YN = dQ(), mo = /* @__PURE__ */ new WeakMap(), hQ = /* @__PURE__ */ __name((t2, e = {}) => {
        if (typeof t2 != "function") throw new TypeError("Expected a function");
        let r2, n2 = 0, A2 = t2.displayName || t2.name || "<anonymous>", i2 = /* @__PURE__ */ __name(function(...s) {
          if (mo.set(i2, ++n2), n2 === 1) r2 = t2.apply(this, s), t2 = null;
          else if (e.throw === true) throw new Error(`Function \`${A2}\` can only be called once`);
          return r2;
        }, "i");
        return YN(i2, t2), mo.set(i2, n2), i2;
      }, "hQ");
      yo.exports = hQ;
      yo.exports.default = hQ;
      yo.exports.callCount = (t2) => {
        if (!mo.has(t2)) throw new Error(`The given function \`${t2.name}\` is not wrapped by the \`onetime\` package`);
        return mo.get(t2);
      };
    });
    var QQ = C2((wo) => {
      "use strict";
      Object.defineProperty(wo, "__esModule", { value: true });
      wo.SIGNALS = void 0;
      var GN = [{ name: "SIGHUP", number: 1, action: "terminate", description: "Terminal closed", standard: "posix" }, { name: "SIGINT", number: 2, action: "terminate", description: "User interruption with CTRL-C", standard: "ansi" }, { name: "SIGQUIT", number: 3, action: "core", description: "User interruption with CTRL-\\", standard: "posix" }, { name: "SIGILL", number: 4, action: "core", description: "Invalid machine instruction", standard: "ansi" }, { name: "SIGTRAP", number: 5, action: "core", description: "Debugger breakpoint", standard: "posix" }, { name: "SIGABRT", number: 6, action: "core", description: "Aborted", standard: "ansi" }, { name: "SIGIOT", number: 6, action: "core", description: "Aborted", standard: "bsd" }, { name: "SIGBUS", number: 7, action: "core", description: "Bus error due to misaligned, non-existing address or paging error", standard: "bsd" }, { name: "SIGEMT", number: 7, action: "terminate", description: "Command should be emulated but is not implemented", standard: "other" }, { name: "SIGFPE", number: 8, action: "core", description: "Floating point arithmetic error", standard: "ansi" }, { name: "SIGKILL", number: 9, action: "terminate", description: "Forced termination", standard: "posix", forced: true }, { name: "SIGUSR1", number: 10, action: "terminate", description: "Application-specific signal", standard: "posix" }, { name: "SIGSEGV", number: 11, action: "core", description: "Segmentation fault", standard: "ansi" }, { name: "SIGUSR2", number: 12, action: "terminate", description: "Application-specific signal", standard: "posix" }, { name: "SIGPIPE", number: 13, action: "terminate", description: "Broken pipe or socket", standard: "posix" }, { name: "SIGALRM", number: 14, action: "terminate", description: "Timeout or timer", standard: "posix" }, { name: "SIGTERM", number: 15, action: "terminate", description: "Termination", standard: "ansi" }, { name: "SIGSTKFLT", number: 16, action: "terminate", description: "Stack is empty or overflowed", standard: "other" }, { name: "SIGCHLD", number: 17, action: "ignore", description: "Child process terminated, paused or unpaused", standard: "posix" }, { name: "SIGCLD", number: 17, action: "ignore", description: "Child process terminated, paused or unpaused", standard: "other" }, { name: "SIGCONT", number: 18, action: "unpause", description: "Unpaused", standard: "posix", forced: true }, { name: "SIGSTOP", number: 19, action: "pause", description: "Paused", standard: "posix", forced: true }, { name: "SIGTSTP", number: 20, action: "pause", description: 'Paused using CTRL-Z or "suspend"', standard: "posix" }, { name: "SIGTTIN", number: 21, action: "pause", description: "Background process cannot read terminal input", standard: "posix" }, { name: "SIGBREAK", number: 21, action: "terminate", description: "User interruption with CTRL-BREAK", standard: "other" }, { name: "SIGTTOU", number: 22, action: "pause", description: "Background process cannot write to terminal output", standard: "posix" }, { name: "SIGURG", number: 23, action: "ignore", description: "Socket received out-of-band data", standard: "bsd" }, { name: "SIGXCPU", number: 24, action: "core", description: "Process timed out", standard: "bsd" }, { name: "SIGXFSZ", number: 25, action: "core", description: "File too big", standard: "bsd" }, { name: "SIGVTALRM", number: 26, action: "terminate", description: "Timeout or timer", standard: "bsd" }, { name: "SIGPROF", number: 27, action: "terminate", description: "Timeout or timer", standard: "bsd" }, { name: "SIGWINCH", number: 28, action: "ignore", description: "Terminal window size changed", standard: "bsd" }, { name: "SIGIO", number: 29, action: "terminate", description: "I/O is available", standard: "other" }, { name: "SIGPOLL", number: 29, action: "terminate", description: "Watched event", standard: "other" }, { name: "SIGINFO", number: 29, action: "ignore", description: "Request for process information", standard: "other" }, { name: "SIGPWR", number: 30, action: "terminate", description: "Device running out of power", standard: "systemv" }, { name: "SIGSYS", number: 31, action: "core", description: "Invalid system call", standard: "other" }, { name: "SIGUNUSED", number: 31, action: "terminate", description: "Invalid system call", standard: "other" }];
      wo.SIGNALS = GN;
    });
    var ru = C2((Zn) => {
      "use strict";
      Object.defineProperty(Zn, "__esModule", { value: true });
      Zn.SIGRTMAX = Zn.getRealtimeSignals = void 0;
      var ON = /* @__PURE__ */ __name(function() {
        let t2 = IQ - CQ + 1;
        return Array.from({ length: t2 }, VN);
      }, "ON");
      Zn.getRealtimeSignals = ON;
      var VN = /* @__PURE__ */ __name(function(t2, e) {
        return { name: `SIGRT${e + 1}`, number: CQ + e, action: "terminate", description: "Application-specific signal (realtime)", standard: "posix" };
      }, "VN"), CQ = 34, IQ = 64;
      Zn.SIGRTMAX = IQ;
    });
    var pQ = C2((Do) => {
      "use strict";
      Object.defineProperty(Do, "__esModule", { value: true });
      Do.getSignals = void 0;
      var HN = __require("node:os"), qN = QQ(), JN = ru(), WN = /* @__PURE__ */ __name(function() {
        let t2 = (0, JN.getRealtimeSignals)();
        return [...qN.SIGNALS, ...t2].map(_N);
      }, "WN");
      Do.getSignals = WN;
      var _N = /* @__PURE__ */ __name(function({ name: t2, number: e, description: r2, action: n2, forced: A2 = false, standard: i2 }) {
        let { signals: { [t2]: s } } = HN.constants, o2 = s !== void 0;
        return { name: t2, number: o2 ? s : e, description: r2, supported: o2, action: n2, forced: A2, standard: i2 };
      }, "_N");
    });
    var mQ = C2((Xn) => {
      "use strict";
      Object.defineProperty(Xn, "__esModule", { value: true });
      Xn.signalsByNumber = Xn.signalsByName = void 0;
      var jN = __require("node:os"), BQ = pQ(), ZN = ru(), XN = /* @__PURE__ */ __name(function() {
        return (0, BQ.getSignals)().reduce(KN, {});
      }, "XN"), KN = /* @__PURE__ */ __name(function(t2, { name: e, number: r2, description: n2, supported: A2, action: i2, forced: s, standard: o2 }) {
        return { ...t2, [e]: { name: e, number: r2, description: n2, supported: A2, action: i2, forced: s, standard: o2 } };
      }, "KN"), $N = XN();
      Xn.signalsByName = $N;
      var zN = /* @__PURE__ */ __name(function() {
        let t2 = (0, BQ.getSignals)(), e = ZN.SIGRTMAX + 1, r2 = Array.from({ length: e }, (n2, A2) => eF(A2, t2));
        return Object.assign({}, ...r2);
      }, "zN"), eF = /* @__PURE__ */ __name(function(t2, e) {
        let r2 = tF(t2, e);
        if (r2 === void 0) return {};
        let { name: n2, description: A2, supported: i2, action: s, forced: o2, standard: a2 } = r2;
        return { [t2]: { name: n2, number: t2, description: A2, supported: i2, action: s, forced: o2, standard: a2 } };
      }, "eF"), tF = /* @__PURE__ */ __name(function(t2, e) {
        let r2 = e.find(({ name: n2 }) => jN.constants.signals[n2] === t2);
        return r2 !== void 0 ? r2 : e.find((n2) => n2.number === t2);
      }, "tF"), rF = zN();
      Xn.signalsByNumber = rF;
    });
    var wQ = C2((S9, yQ) => {
      "use strict";
      var { signalsByName: nF } = mQ(), AF = /* @__PURE__ */ __name(({ timedOut: t2, timeout: e, errorCode: r2, signal: n2, signalDescription: A2, exitCode: i2, isCanceled: s }) => t2 ? `timed out after ${e} milliseconds` : s ? "was canceled" : r2 !== void 0 ? `failed with ${r2}` : n2 !== void 0 ? `was killed with ${n2} (${A2})` : i2 !== void 0 ? `failed with exit code ${i2}` : "failed", "AF"), iF = /* @__PURE__ */ __name(({ stdout: t2, stderr: e, all: r2, error: n2, signal: A2, exitCode: i2, command: s, escapedCommand: o2, timedOut: a2, isCanceled: c2, killed: l2, parsed: { options: { timeout: u2 } } }) => {
        i2 = i2 === null ? void 0 : i2, A2 = A2 === null ? void 0 : A2;
        let g = A2 === void 0 ? void 0 : nF[A2].description, E = n2 && n2.code, f2 = `Command ${AF({ timedOut: a2, timeout: u2, errorCode: E, signal: A2, signalDescription: g, exitCode: i2, isCanceled: c2 })}: ${s}`, p2 = Object.prototype.toString.call(n2) === "[object Error]", Q = p2 ? `${f2}
${n2.message}` : f2, I2 = [Q, e, t2].filter(Boolean).join(`
`);
        return p2 ? (n2.originalMessage = n2.message, n2.message = I2) : n2 = new Error(I2), n2.shortMessage = Q, n2.command = s, n2.escapedCommand = o2, n2.exitCode = i2, n2.signal = A2, n2.signalDescription = g, n2.stdout = t2, n2.stderr = e, r2 !== void 0 && (n2.all = r2), "bufferedData" in n2 && delete n2.bufferedData, n2.failed = true, n2.timedOut = !!a2, n2.isCanceled = c2, n2.killed = l2 && !a2, n2;
      }, "iF");
      yQ.exports = iF;
    });
    var RQ = C2((b9, nu) => {
      "use strict";
      var Ro = ["stdin", "stdout", "stderr"], sF = /* @__PURE__ */ __name((t2) => Ro.some((e) => t2[e] !== void 0), "sF"), DQ = /* @__PURE__ */ __name((t2) => {
        if (!t2) return;
        let { stdio: e } = t2;
        if (e === void 0) return Ro.map((n2) => t2[n2]);
        if (sF(t2)) throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${Ro.map((n2) => `\`${n2}\``).join(", ")}`);
        if (typeof e == "string") return e;
        if (!Array.isArray(e)) throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof e}\``);
        let r2 = Math.max(e.length, Ro.length);
        return Array.from({ length: r2 }, (n2, A2) => e[A2]);
      }, "DQ");
      nu.exports = DQ;
      nu.exports.node = (t2) => {
        let e = DQ(t2);
        return e === "ipc" ? "ipc" : e === void 0 || typeof e == "string" ? [e, e, e, "ipc"] : e.includes("ipc") ? e : [...e, "ipc"];
      };
    });
    var SQ = C2((N9, So) => {
      "use strict";
      So.exports = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"];
      process.platform !== "win32" && So.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
      process.platform === "linux" && So.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    });
    var xQ = C2((F9, zn) => {
      "use strict";
      var ue = global.process, on = /* @__PURE__ */ __name(function(t2) {
        return t2 && typeof t2 == "object" && typeof t2.removeListener == "function" && typeof t2.emit == "function" && typeof t2.reallyExit == "function" && typeof t2.listeners == "function" && typeof t2.kill == "function" && typeof t2.pid == "number" && typeof t2.on == "function";
      }, "on");
      on(ue) ? (bQ = __require("node:assert"), Kn = SQ(), NQ = /^win/i.test(ue.platform), Bi = __require("node:events"), typeof Bi != "function" && (Bi = Bi.EventEmitter), ue.__signal_exit_emitter__ ? we = ue.__signal_exit_emitter__ : (we = ue.__signal_exit_emitter__ = new Bi(), we.count = 0, we.emitted = {}), we.infinite || (we.setMaxListeners(1 / 0), we.infinite = true), zn.exports = function(t2, e) {
        if (!on(global.process)) return function() {
        };
        bQ.equal(typeof t2, "function", "a callback must be provided for exit handler"), $n === false && Au();
        var r2 = "exit";
        e && e.alwaysLast && (r2 = "afterexit");
        var n2 = /* @__PURE__ */ __name(function() {
          we.removeListener(r2, t2), we.listeners("exit").length === 0 && we.listeners("afterexit").length === 0 && bo();
        }, "n");
        return we.on(r2, t2), n2;
      }, bo = /* @__PURE__ */ __name(function() {
        !$n || !on(global.process) || ($n = false, Kn.forEach(function(e) {
          try {
            ue.removeListener(e, No[e]);
          } catch {
          }
        }), ue.emit = Fo, ue.reallyExit = iu, we.count -= 1);
      }, "bo"), zn.exports.unload = bo, an = /* @__PURE__ */ __name(function(e, r2, n2) {
        we.emitted[e] || (we.emitted[e] = true, we.emit(e, r2, n2));
      }, "an"), No = {}, Kn.forEach(function(t2) {
        No[t2] = function() {
          if (on(global.process)) {
            var r2 = ue.listeners(t2);
            r2.length === we.count && (bo(), an("exit", null, t2), an("afterexit", null, t2), NQ && t2 === "SIGHUP" && (t2 = "SIGINT"), ue.kill(ue.pid, t2));
          }
        };
      }), zn.exports.signals = function() {
        return Kn;
      }, $n = false, Au = /* @__PURE__ */ __name(function() {
        $n || !on(global.process) || ($n = true, we.count += 1, Kn = Kn.filter(function(e) {
          try {
            return ue.on(e, No[e]), true;
          } catch {
            return false;
          }
        }), ue.emit = TQ, ue.reallyExit = FQ);
      }, "Au"), zn.exports.load = Au, iu = ue.reallyExit, FQ = /* @__PURE__ */ __name(function(e) {
        on(global.process) && (ue.exitCode = e || 0, an("exit", ue.exitCode, null), an("afterexit", ue.exitCode, null), iu.call(ue, ue.exitCode));
      }, "FQ"), Fo = ue.emit, TQ = /* @__PURE__ */ __name(function(e, r2) {
        if (e === "exit" && on(global.process)) {
          r2 !== void 0 && (ue.exitCode = r2);
          var n2 = Fo.apply(this, arguments);
          return an("exit", ue.exitCode, null), an("afterexit", ue.exitCode, null), n2;
        } else return Fo.apply(this, arguments);
      }, "TQ")) : zn.exports = function() {
        return function() {
        };
      };
      var bQ, Kn, NQ, Bi, we, bo, an, No, $n, Au, iu, FQ, Fo, TQ;
    });
    var kQ = C2((T9, UQ) => {
      "use strict";
      var oF = __require("node:os"), aF = xQ(), cF = 1e3 * 5, lF = /* @__PURE__ */ __name((t2, e = "SIGTERM", r2 = {}) => {
        let n2 = t2(e);
        return uF(t2, e, r2, n2), n2;
      }, "lF"), uF = /* @__PURE__ */ __name((t2, e, r2, n2) => {
        if (!gF(e, r2, n2)) return;
        let A2 = dF(r2), i2 = setTimeout(() => {
          t2("SIGKILL");
        }, A2);
        i2.unref && i2.unref();
      }, "uF"), gF = /* @__PURE__ */ __name((t2, { forceKillAfterTimeout: e }, r2) => EF(t2) && e !== false && r2, "gF"), EF = /* @__PURE__ */ __name((t2) => t2 === oF.constants.signals.SIGTERM || typeof t2 == "string" && t2.toUpperCase() === "SIGTERM", "EF"), dF = /* @__PURE__ */ __name(({ forceKillAfterTimeout: t2 = true }) => {
        if (t2 === true) return cF;
        if (!Number.isFinite(t2) || t2 < 0) throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${t2}\` (${typeof t2})`);
        return t2;
      }, "dF"), hF = /* @__PURE__ */ __name((t2, e) => {
        t2.kill() && (e.isCanceled = true);
      }, "hF"), fF = /* @__PURE__ */ __name((t2, e, r2) => {
        t2.kill(e), r2(Object.assign(new Error("Timed out"), { timedOut: true, signal: e }));
      }, "fF"), QF = /* @__PURE__ */ __name((t2, { timeout: e, killSignal: r2 = "SIGTERM" }, n2) => {
        if (e === 0 || e === void 0) return n2;
        let A2, i2 = new Promise((o2, a2) => {
          A2 = setTimeout(() => {
            fF(t2, r2, a2);
          }, e);
        }), s = n2.finally(() => {
          clearTimeout(A2);
        });
        return Promise.race([i2, s]);
      }, "QF"), CF = /* @__PURE__ */ __name(({ timeout: t2 }) => {
        if (t2 !== void 0 && (!Number.isFinite(t2) || t2 < 0)) throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${t2}\` (${typeof t2})`);
      }, "CF"), IF = /* @__PURE__ */ __name(async (t2, { cleanup: e, detached: r2 }, n2) => {
        if (!e || r2) return n2;
        let A2 = aF(() => {
          t2.kill();
        });
        return n2.finally(() => {
          A2();
        });
      }, "IF");
      UQ.exports = { spawnedKill: lF, spawnedCancel: hF, setupTimeout: QF, validateTimeout: CF, setExitHandler: IF };
    });
    var LQ = C2((x9, MQ) => {
      "use strict";
      var Ut = /* @__PURE__ */ __name((t2) => t2 !== null && typeof t2 == "object" && typeof t2.pipe == "function", "Ut");
      Ut.writable = (t2) => Ut(t2) && t2.writable !== false && typeof t2._write == "function" && typeof t2._writableState == "object";
      Ut.readable = (t2) => Ut(t2) && t2.readable !== false && typeof t2._read == "function" && typeof t2._readableState == "object";
      Ut.duplex = (t2) => Ut.writable(t2) && Ut.readable(t2);
      Ut.transform = (t2) => Ut.duplex(t2) && typeof t2._transform == "function";
      MQ.exports = Ut;
    });
    var PQ = C2((U9, vQ) => {
      "use strict";
      var { PassThrough: pF } = __require("node:stream");
      vQ.exports = (t2) => {
        t2 = { ...t2 };
        let { array: e } = t2, { encoding: r2 } = t2, n2 = r2 === "buffer", A2 = false;
        e ? A2 = !(r2 || n2) : r2 = r2 || "utf8", n2 && (r2 = null);
        let i2 = new pF({ objectMode: A2 });
        r2 && i2.setEncoding(r2);
        let s = 0, o2 = [];
        return i2.on("data", (a2) => {
          o2.push(a2), A2 ? s = o2.length : s += a2.length;
        }), i2.getBufferedValue = () => e ? o2 : n2 ? Buffer.concat(o2, s) : o2.join(""), i2.getBufferedLength = () => s, i2;
      };
    });
    var ou = C2((k9, mi) => {
      "use strict";
      var { constants: BF } = __require("node:buffer"), mF = __require("node:stream"), { promisify: yF } = __require("node:util"), wF = PQ(), DF = yF(mF.pipeline), To = class extends Error {
        static {
          __name(this, "To");
        }
        constructor() {
          super("maxBuffer exceeded"), this.name = "MaxBufferError";
        }
      };
      async function su(t2, e) {
        if (!t2) throw new Error("Expected a stream");
        e = { maxBuffer: 1 / 0, ...e };
        let { maxBuffer: r2 } = e, n2 = wF(e);
        return await new Promise((A2, i2) => {
          let s = /* @__PURE__ */ __name((o2) => {
            o2 && n2.getBufferedLength() <= BF.MAX_LENGTH && (o2.bufferedData = n2.getBufferedValue()), i2(o2);
          }, "s");
          (async () => {
            try {
              await DF(t2, n2), A2();
            } catch (o2) {
              s(o2);
            }
          })(), n2.on("data", () => {
            n2.getBufferedLength() > r2 && s(new To());
          });
        }), n2.getBufferedValue();
      }
      __name(su, "su");
      mi.exports = su;
      mi.exports.buffer = (t2, e) => su(t2, { ...e, encoding: "buffer" });
      mi.exports.array = (t2, e) => su(t2, { ...e, array: true });
      mi.exports.MaxBufferError = To;
    });
    var GQ = C2((M9, YQ) => {
      "use strict";
      var { PassThrough: RF } = __require("node:stream");
      YQ.exports = function() {
        var t2 = [], e = new RF({ objectMode: true });
        return e.setMaxListeners(0), e.add = r2, e.isEmpty = n2, e.on("unpipe", A2), Array.prototype.slice.call(arguments).forEach(r2), e;
        function r2(i2) {
          return Array.isArray(i2) ? (i2.forEach(r2), this) : (t2.push(i2), i2.once("end", A2.bind(null, i2)), i2.once("error", e.emit.bind(e, "error")), i2.pipe(e, { end: false }), this);
        }
        __name(r2, "r");
        function n2() {
          return t2.length == 0;
        }
        __name(n2, "n");
        function A2(i2) {
          t2 = t2.filter(function(s) {
            return s !== i2;
          }), !t2.length && e.readable && e.end();
        }
        __name(A2, "A");
      };
    });
    var qQ = C2((L9, HQ) => {
      "use strict";
      var VQ = LQ(), OQ = ou(), SF = GQ(), bF = /* @__PURE__ */ __name((t2, e) => {
        e === void 0 || t2.stdin === void 0 || (VQ(e) ? e.pipe(t2.stdin) : t2.stdin.end(e));
      }, "bF"), NF = /* @__PURE__ */ __name((t2, { all: e }) => {
        if (!e || !t2.stdout && !t2.stderr) return;
        let r2 = SF();
        return t2.stdout && r2.add(t2.stdout), t2.stderr && r2.add(t2.stderr), r2;
      }, "NF"), au = /* @__PURE__ */ __name(async (t2, e) => {
        if (t2) {
          t2.destroy();
          try {
            return await e;
          } catch (r2) {
            return r2.bufferedData;
          }
        }
      }, "au"), cu = /* @__PURE__ */ __name((t2, { encoding: e, buffer: r2, maxBuffer: n2 }) => {
        if (!(!t2 || !r2)) return e ? OQ(t2, { encoding: e, maxBuffer: n2 }) : OQ.buffer(t2, { maxBuffer: n2 });
      }, "cu"), FF = /* @__PURE__ */ __name(async ({ stdout: t2, stderr: e, all: r2 }, { encoding: n2, buffer: A2, maxBuffer: i2 }, s) => {
        let o2 = cu(t2, { encoding: n2, buffer: A2, maxBuffer: i2 }), a2 = cu(e, { encoding: n2, buffer: A2, maxBuffer: i2 }), c2 = cu(r2, { encoding: n2, buffer: A2, maxBuffer: i2 * 2 });
        try {
          return await Promise.all([s, o2, a2, c2]);
        } catch (l2) {
          return Promise.all([{ error: l2, signal: l2.signal, timedOut: l2.timedOut }, au(t2, o2), au(e, a2), au(r2, c2)]);
        }
      }, "FF"), TF = /* @__PURE__ */ __name(({ input: t2 }) => {
        if (VQ(t2)) throw new TypeError("The `input` option cannot be a stream in sync mode");
      }, "TF");
      HQ.exports = { handleInput: bF, makeAllStream: NF, getSpawnedResult: FF, validateInputSync: TF };
    });
    var WQ = C2((v9, JQ) => {
      "use strict";
      var xF = (async () => {
      })().constructor.prototype, UF = ["then", "catch", "finally"].map((t2) => [t2, Reflect.getOwnPropertyDescriptor(xF, t2)]), kF = /* @__PURE__ */ __name((t2, e) => {
        for (let [r2, n2] of UF) {
          let A2 = typeof e == "function" ? (...i2) => Reflect.apply(n2.value, e(), i2) : n2.value.bind(e);
          Reflect.defineProperty(t2, r2, { ...n2, value: A2 });
        }
        return t2;
      }, "kF"), MF = /* @__PURE__ */ __name((t2) => new Promise((e, r2) => {
        t2.on("exit", (n2, A2) => {
          e({ exitCode: n2, signal: A2 });
        }), t2.on("error", (n2) => {
          r2(n2);
        }), t2.stdin && t2.stdin.on("error", (n2) => {
          r2(n2);
        });
      }), "MF");
      JQ.exports = { mergePromise: kF, getSpawnedPromise: MF };
    });
    var ZQ = C2((P9, jQ) => {
      "use strict";
      var _Q = /* @__PURE__ */ __name((t2, e = []) => Array.isArray(e) ? [t2, ...e] : [t2], "_Q"), LF = /^[\w.-]+$/, vF = /"/g, PF = /* @__PURE__ */ __name((t2) => typeof t2 != "string" || LF.test(t2) ? t2 : `"${t2.replace(vF, '\\"')}"`, "PF"), YF = /* @__PURE__ */ __name((t2, e) => _Q(t2, e).join(" "), "YF"), GF = /* @__PURE__ */ __name((t2, e) => _Q(t2, e).map((r2) => PF(r2)).join(" "), "GF"), OF = / +/g, VF = /* @__PURE__ */ __name((t2) => {
        let e = [];
        for (let r2 of t2.trim().split(OF)) {
          let n2 = e[e.length - 1];
          n2 && n2.endsWith("\\") ? e[e.length - 1] = `${n2.slice(0, -1)} ${r2}` : e.push(r2);
        }
        return e;
      }, "VF");
      jQ.exports = { joinCommand: YF, getEscapedCommand: GF, parseCommand: VF };
    });
    var rC = C2((Y9, eA) => {
      "use strict";
      var HF = __require("node:path"), lu = __require("node:child_process"), qF = oQ(), JF = cQ(), WF = gQ(), _F = fQ(), xo = wQ(), KQ = RQ(), { spawnedKill: jF, spawnedCancel: ZF, setupTimeout: XF, validateTimeout: KF, setExitHandler: $F } = kQ(), { handleInput: zF, getSpawnedResult: eT, makeAllStream: tT, validateInputSync: rT } = qQ(), { mergePromise: XQ, getSpawnedPromise: nT } = WQ(), { joinCommand: $Q, parseCommand: zQ, getEscapedCommand: eC } = ZQ(), AT = 1e3 * 1e3 * 100, iT = /* @__PURE__ */ __name(({ env: t2, extendEnv: e, preferLocal: r2, localDir: n2, execPath: A2 }) => {
        let i2 = e ? { ...process.env, ...t2 } : t2;
        return r2 ? WF.env({ env: i2, cwd: n2, execPath: A2 }) : i2;
      }, "iT"), tC = /* @__PURE__ */ __name((t2, e, r2 = {}) => {
        let n2 = qF._parse(t2, e, r2);
        return t2 = n2.command, e = n2.args, r2 = n2.options, r2 = { maxBuffer: AT, buffer: true, stripFinalNewline: true, extendEnv: true, preferLocal: false, localDir: r2.cwd || process.cwd(), execPath: process.execPath, encoding: "utf8", reject: true, cleanup: true, all: false, windowsHide: true, ...r2 }, r2.env = iT(r2), r2.stdio = KQ(r2), process.platform === "win32" && HF.basename(t2, ".exe") === "cmd" && e.unshift("/q"), { file: t2, args: e, options: r2, parsed: n2 };
      }, "tC"), yi = /* @__PURE__ */ __name((t2, e, r2) => typeof e != "string" && !Buffer.isBuffer(e) ? r2 === void 0 ? void 0 : "" : t2.stripFinalNewline ? JF(e) : e, "yi"), Uo = /* @__PURE__ */ __name((t2, e, r2) => {
        let n2 = tC(t2, e, r2), A2 = $Q(t2, e), i2 = eC(t2, e);
        KF(n2.options);
        let s;
        try {
          s = lu.spawn(n2.file, n2.args, n2.options);
        } catch (E) {
          let h = new lu.ChildProcess(), f2 = Promise.reject(xo({ error: E, stdout: "", stderr: "", all: "", command: A2, escapedCommand: i2, parsed: n2, timedOut: false, isCanceled: false, killed: false }));
          return XQ(h, f2);
        }
        let o2 = nT(s), a2 = XF(s, n2.options, o2), c2 = $F(s, n2.options, a2), l2 = { isCanceled: false };
        s.kill = jF.bind(null, s.kill.bind(s)), s.cancel = ZF.bind(null, s, l2);
        let g = _F(async () => {
          let [{ error: E, exitCode: h, signal: f2, timedOut: p2 }, Q, I2, B] = await eT(s, n2.options, c2), w = yi(n2.options, Q), D2 = yi(n2.options, I2), v2 = yi(n2.options, B);
          if (E || h !== 0 || f2 !== null) {
            let K2 = xo({ error: E, exitCode: h, signal: f2, stdout: w, stderr: D2, all: v2, command: A2, escapedCommand: i2, parsed: n2, timedOut: p2, isCanceled: l2.isCanceled, killed: s.killed });
            if (!n2.options.reject) return K2;
            throw K2;
          }
          return { command: A2, escapedCommand: i2, exitCode: 0, stdout: w, stderr: D2, all: v2, failed: false, timedOut: false, isCanceled: false, killed: false };
        });
        return zF(s, n2.options.input), s.all = tT(s, n2.options), XQ(s, g);
      }, "Uo");
      eA.exports = Uo;
      eA.exports.sync = (t2, e, r2) => {
        let n2 = tC(t2, e, r2), A2 = $Q(t2, e), i2 = eC(t2, e);
        rT(n2.options);
        let s;
        try {
          s = lu.spawnSync(n2.file, n2.args, n2.options);
        } catch (c2) {
          throw xo({ error: c2, stdout: "", stderr: "", all: "", command: A2, escapedCommand: i2, parsed: n2, timedOut: false, isCanceled: false, killed: false });
        }
        let o2 = yi(n2.options, s.stdout, s.error), a2 = yi(n2.options, s.stderr, s.error);
        if (s.error || s.status !== 0 || s.signal !== null) {
          let c2 = xo({ stdout: o2, stderr: a2, error: s.error, signal: s.signal, exitCode: s.status, command: A2, escapedCommand: i2, parsed: n2, timedOut: s.error && s.error.code === "ETIMEDOUT", isCanceled: false, killed: s.signal !== null });
          if (!n2.options.reject) return c2;
          throw c2;
        }
        return { command: A2, escapedCommand: i2, exitCode: 0, stdout: o2, stderr: a2, failed: false, timedOut: false, isCanceled: false, killed: false };
      };
      eA.exports.command = (t2, e) => {
        let [r2, ...n2] = zQ(t2);
        return Uo(r2, n2, e);
      };
      eA.exports.commandSync = (t2, e) => {
        let [r2, ...n2] = zQ(t2);
        return Uo.sync(r2, n2, e);
      };
      eA.exports.node = (t2, e, r2 = {}) => {
        e && !Array.isArray(e) && typeof e == "object" && (r2 = e, e = []);
        let n2 = KQ.node(r2), A2 = process.execArgv.filter((o2) => !o2.startsWith("--inspect")), { nodePath: i2 = process.execPath, nodeOptions: s = A2 } = r2;
        return Uo(i2, [...s, t2, ...Array.isArray(e) ? e : []], { ...r2, stdin: void 0, stdout: void 0, stderr: void 0, stdio: n2, shell: false });
      };
    });
    var nC = C2((W9, sT) => {
      sT.exports = { name: "@prisma/internals", version: "6.15.0", description: "This package is intended for Prisma's internal use", main: "dist/index.js", types: "dist/index.d.ts", repository: { type: "git", url: "https://github.com/prisma/prisma.git", directory: "packages/internals" }, homepage: "https://www.prisma.io", author: "Tim Suchanek <suchanek@prisma.io>", bugs: "https://github.com/prisma/prisma/issues", license: "Apache-2.0", scripts: { dev: "DEV=true tsx helpers/build.ts", build: "tsx helpers/build.ts", test: "dotenv -e ../../.db.env -- jest --silent", prepublishOnly: "pnpm run build" }, files: ["README.md", "dist", "!**/libquery_engine*", "!dist/get-generators/engines/*", "scripts"], devDependencies: { "@babel/helper-validator-identifier": "7.25.9", "@opentelemetry/api": "1.9.0", "@swc/core": "1.11.5", "@swc/jest": "0.2.37", "@types/babel__helper-validator-identifier": "7.15.2", "@types/jest": "29.5.14", "@types/node": "18.19.76", "@types/resolve": "1.20.6", archiver: "6.0.2", "checkpoint-client": "1.1.33", "cli-truncate": "4.0.0", dotenv: "16.5.0", empathic: "2.0.0", esbuild: "0.25.5", "escape-string-regexp": "5.0.0", execa: "5.1.1", "fast-glob": "3.3.3", "find-up": "7.0.0", "fp-ts": "2.16.9", "fs-extra": "11.3.0", "fs-jetpack": "5.1.0", "global-dirs": "4.0.0", globby: "11.1.0", "identifier-regex": "1.0.0", "indent-string": "4.0.0", "is-windows": "1.0.2", "is-wsl": "3.1.0", jest: "29.7.0", "jest-junit": "16.0.0", kleur: "4.1.5", "mock-stdin": "1.0.0", "new-github-issue-url": "0.2.1", "node-fetch": "3.3.2", "npm-packlist": "5.1.3", open: "7.4.2", "p-map": "4.0.0", resolve: "1.22.10", "string-width": "7.2.0", "strip-ansi": "6.0.1", "strip-indent": "4.0.0", "temp-dir": "2.0.0", tempy: "1.0.1", "terminal-link": "4.0.0", tmp: "0.2.3", "ts-node": "10.9.2", "ts-pattern": "5.6.2", "ts-toolbelt": "9.6.0", typescript: "5.4.5", yarn: "1.22.22" }, dependencies: { "@prisma/config": "workspace:*", "@prisma/debug": "workspace:*", "@prisma/dmmf": "workspace:*", "@prisma/driver-adapter-utils": "workspace:*", "@prisma/engines": "workspace:*", "@prisma/fetch-engine": "workspace:*", "@prisma/generator": "workspace:*", "@prisma/generator-helper": "workspace:*", "@prisma/get-platform": "workspace:*", "@prisma/prisma-schema-wasm": "6.15.0-5.85179d7826409ee107a6ba334b5e305ae3fba9fb", "@prisma/schema-engine-wasm": "6.15.0-5.85179d7826409ee107a6ba334b5e305ae3fba9fb", "@prisma/schema-files-loader": "workspace:*", arg: "5.0.2", prompts: "2.4.2" }, peerDependencies: { typescript: ">=5.1.0" }, peerDependenciesMeta: { typescript: { optional: true } }, sideEffects: false };
    });
    var Eu = C2((Z9, AC) => {
      "use strict";
      var lT = __require("node:fs"), uT = __require("node:os"), gu = Symbol.for("__RESOLVED_TEMP_DIRECTORY__");
      global[gu] || Object.defineProperty(global, gu, { value: lT.realpathSync(uT.tmpdir()) });
      AC.exports = global[gu];
    });
    var sC = C2((X9, iC) => {
      "use strict";
      function lt(t2, e) {
        typeof e == "boolean" && (e = { forever: e }), this._originalTimeouts = JSON.parse(JSON.stringify(t2)), this._timeouts = t2, this._options = e || {}, this._maxRetryTime = e && e.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
      }
      __name(lt, "lt");
      iC.exports = lt;
      lt.prototype.reset = function() {
        this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
      };
      lt.prototype.stop = function() {
        this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;
      };
      lt.prototype.retry = function(t2) {
        if (this._timeout && clearTimeout(this._timeout), !t2) return false;
        var e = (/* @__PURE__ */ new Date()).getTime();
        if (t2 && e - this._operationStart >= this._maxRetryTime) return this._errors.push(t2), this._errors.unshift(new Error("RetryOperation timeout occurred")), false;
        this._errors.push(t2);
        var r2 = this._timeouts.shift();
        if (r2 === void 0) if (this._cachedTimeouts) this._errors.splice(0, this._errors.length - 1), r2 = this._cachedTimeouts.slice(-1);
        else return false;
        var n2 = this;
        return this._timer = setTimeout(function() {
          n2._attempts++, n2._operationTimeoutCb && (n2._timeout = setTimeout(function() {
            n2._operationTimeoutCb(n2._attempts);
          }, n2._operationTimeout), n2._options.unref && n2._timeout.unref()), n2._fn(n2._attempts);
        }, r2), this._options.unref && this._timer.unref(), true;
      };
      lt.prototype.attempt = function(t2, e) {
        this._fn = t2, e && (e.timeout && (this._operationTimeout = e.timeout), e.cb && (this._operationTimeoutCb = e.cb));
        var r2 = this;
        this._operationTimeoutCb && (this._timeout = setTimeout(function() {
          r2._operationTimeoutCb();
        }, r2._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
      };
      lt.prototype.try = function(t2) {
        console.log("Using RetryOperation.try() is deprecated"), this.attempt(t2);
      };
      lt.prototype.start = function(t2) {
        console.log("Using RetryOperation.start() is deprecated"), this.attempt(t2);
      };
      lt.prototype.start = lt.prototype.try;
      lt.prototype.errors = function() {
        return this._errors;
      };
      lt.prototype.attempts = function() {
        return this._attempts;
      };
      lt.prototype.mainError = function() {
        if (this._errors.length === 0) return null;
        for (var t2 = {}, e = null, r2 = 0, n2 = 0; n2 < this._errors.length; n2++) {
          var A2 = this._errors[n2], i2 = A2.message, s = (t2[i2] || 0) + 1;
          t2[i2] = s, s >= r2 && (e = A2, r2 = s);
        }
        return e;
      };
    });
    var oC = C2((cn) => {
      "use strict";
      var gT = sC();
      cn.operation = function(t2) {
        var e = cn.timeouts(t2);
        return new gT(e, { forever: t2 && (t2.forever || t2.retries === 1 / 0), unref: t2 && t2.unref, maxRetryTime: t2 && t2.maxRetryTime });
      };
      cn.timeouts = function(t2) {
        if (t2 instanceof Array) return [].concat(t2);
        var e = { retries: 10, factor: 2, minTimeout: 1 * 1e3, maxTimeout: 1 / 0, randomize: false };
        for (var r2 in t2) e[r2] = t2[r2];
        if (e.minTimeout > e.maxTimeout) throw new Error("minTimeout is greater than maxTimeout");
        for (var n2 = [], A2 = 0; A2 < e.retries; A2++) n2.push(this.createTimeout(A2, e));
        return t2 && t2.forever && !n2.length && n2.push(this.createTimeout(A2, e)), n2.sort(function(i2, s) {
          return i2 - s;
        }), n2;
      };
      cn.createTimeout = function(t2, e) {
        var r2 = e.randomize ? Math.random() + 1 : 1, n2 = Math.round(r2 * Math.max(e.minTimeout, 1) * Math.pow(e.factor, t2));
        return n2 = Math.min(n2, e.maxTimeout), n2;
      };
      cn.wrap = function(t2, e, r2) {
        if (e instanceof Array && (r2 = e, e = null), !r2) {
          r2 = [];
          for (var n2 in t2) typeof t2[n2] == "function" && r2.push(n2);
        }
        for (var A2 = 0; A2 < r2.length; A2++) {
          var i2 = r2[A2], s = t2[i2];
          t2[i2] = function(a2) {
            var c2 = cn.operation(e), l2 = Array.prototype.slice.call(arguments, 1), u2 = l2.pop();
            l2.push(function(g) {
              c2.retry(g) || (g && (arguments[0] = c2.mainError()), u2.apply(this, arguments));
            }), c2.attempt(function() {
              a2.apply(t2, l2);
            });
          }.bind(t2, s), t2[i2].options = e;
        }
      };
    });
    var cC = C2(($9, aC) => {
      "use strict";
      aC.exports = oC();
    });
    var uC = C2((z9, Mo) => {
      "use strict";
      var ET = cC(), dT = ["Failed to fetch", "NetworkError when attempting to fetch resource.", "The Internet connection appears to be offline.", "Network request failed"], ko = class extends Error {
        static {
          __name(this, "ko");
        }
        constructor(e) {
          super(), e instanceof Error ? (this.originalError = e, { message: e } = e) : (this.originalError = new Error(e), this.originalError.stack = this.stack), this.name = "AbortError", this.message = e;
        }
      }, hT = /* @__PURE__ */ __name((t2, e, r2) => {
        let n2 = r2.retries - (e - 1);
        return t2.attemptNumber = e, t2.retriesLeft = n2, t2;
      }, "hT"), fT = /* @__PURE__ */ __name((t2) => dT.includes(t2), "fT"), lC = /* @__PURE__ */ __name((t2, e) => new Promise((r2, n2) => {
        e = { onFailedAttempt: /* @__PURE__ */ __name(() => {
        }, "onFailedAttempt"), retries: 10, ...e };
        let A2 = ET.operation(e);
        A2.attempt(async (i2) => {
          try {
            r2(await t2(i2));
          } catch (s) {
            if (!(s instanceof Error)) {
              n2(new TypeError(`Non-error was thrown: "${s}". You should only throw errors.`));
              return;
            }
            if (s instanceof ko) A2.stop(), n2(s.originalError);
            else if (s instanceof TypeError && !fT(s.message)) A2.stop(), n2(s);
            else {
              hT(s, i2, e);
              try {
                await e.onFailedAttempt(s);
              } catch (o2) {
                n2(o2);
                return;
              }
              A2.retry(s) || n2(A2.mainError());
            }
          }
        });
      }), "lC");
      Mo.exports = lC;
      Mo.exports.default = lC;
      Mo.exports.AbortError = ko;
    });
    var du = C2((Aj, QT) => {
      QT.exports = { name: "@prisma/engines-version", version: "6.15.0-5.85179d7826409ee107a6ba334b5e305ae3fba9fb", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "85179d7826409ee107a6ba334b5e305ae3fba9fb" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.76", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
    });
    var vo = C2((Lo) => {
      "use strict";
      Object.defineProperty(Lo, "__esModule", { value: true });
      Lo.enginesVersion = void 0;
      Lo.enginesVersion = du().prisma.enginesVersion;
    });
    var hC = C2((dj, dC) => {
      "use strict";
      dC.exports = (t2) => {
        let e = t2.match(/^[ \t]*(?=\S)/gm);
        return e ? e.reduce((r2, n2) => Math.min(r2, n2.length), 1 / 0) : 0;
      };
    });
    var Iu = C2((Qj, CC) => {
      "use strict";
      CC.exports = (t2, e = 1, r2) => {
        if (r2 = { indent: " ", includeEmptyLines: false, ...r2 }, typeof t2 != "string") throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof t2}\``);
        if (typeof e != "number") throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof e}\``);
        if (typeof r2.indent != "string") throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r2.indent}\``);
        if (e === 0) return t2;
        let n2 = r2.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return t2.replace(n2, r2.indent.repeat(e));
      };
    });
    var mC = C2((pj, BC) => {
      "use strict";
      BC.exports = ({ onlyFirst: t2 = false } = {}) => {
        let e = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(e, t2 ? void 0 : "g");
      };
    });
    var yu = C2((Bj, yC) => {
      "use strict";
      var ST = mC();
      yC.exports = (t2) => typeof t2 == "string" ? t2.replace(ST(), "") : t2;
    });
    var DC = C2((Dj, FT) => {
      FT.exports = { name: "dotenv", version: "16.5.0", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", pretest: "npm run lint && npm run dts-check", test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000", "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, homepage: "https://github.com/motdotla/dotenv#readme", funding: "https://dotenvx.com", keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^18.11.3", decache: "^4.6.2", sinon: "^14.0.1", standard: "^17.0.0", "standard-version": "^9.5.0", tap: "^19.2.0", typescript: "^4.8.4" }, engines: { node: ">=12" }, browser: { fs: false } };
    });
    var FC = C2((Rj, ir) => {
      "use strict";
      var Du = __require("node:fs"), Ru = __require("node:path"), TT = __require("node:os"), xT = __require("node:crypto"), UT = DC(), SC = UT.version, kT = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
      function MT(t2) {
        let e = {}, r2 = t2.toString();
        r2 = r2.replace(/\r\n?/mg, `
`);
        let n2;
        for (; (n2 = kT.exec(r2)) != null; ) {
          let A2 = n2[1], i2 = n2[2] || "";
          i2 = i2.trim();
          let s = i2[0];
          i2 = i2.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (i2 = i2.replace(/\\n/g, `
`), i2 = i2.replace(/\\r/g, "\r")), e[A2] = i2;
        }
        return e;
      }
      __name(MT, "MT");
      function LT(t2) {
        let e = NC(t2), r2 = pe.configDotenv({ path: e });
        if (!r2.parsed) {
          let s = new Error(`MISSING_DATA: Cannot parse ${e} for an unknown reason`);
          throw s.code = "MISSING_DATA", s;
        }
        let n2 = bC(t2).split(","), A2 = n2.length, i2;
        for (let s = 0; s < A2; s++) try {
          let o2 = n2[s].trim(), a2 = PT(r2, o2);
          i2 = pe.decrypt(a2.ciphertext, a2.key);
          break;
        } catch (o2) {
          if (s + 1 >= A2) throw o2;
        }
        return pe.parse(i2);
      }
      __name(LT, "LT");
      function vT(t2) {
        console.log(`[dotenv@${SC}][WARN] ${t2}`);
      }
      __name(vT, "vT");
      function bi(t2) {
        console.log(`[dotenv@${SC}][DEBUG] ${t2}`);
      }
      __name(bi, "bi");
      function bC(t2) {
        return t2 && t2.DOTENV_KEY && t2.DOTENV_KEY.length > 0 ? t2.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
      }
      __name(bC, "bC");
      function PT(t2, e) {
        let r2;
        try {
          r2 = new URL(e);
        } catch (o2) {
          if (o2.code === "ERR_INVALID_URL") {
            let a2 = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
            throw a2.code = "INVALID_DOTENV_KEY", a2;
          }
          throw o2;
        }
        let n2 = r2.password;
        if (!n2) {
          let o2 = new Error("INVALID_DOTENV_KEY: Missing key part");
          throw o2.code = "INVALID_DOTENV_KEY", o2;
        }
        let A2 = r2.searchParams.get("environment");
        if (!A2) {
          let o2 = new Error("INVALID_DOTENV_KEY: Missing environment part");
          throw o2.code = "INVALID_DOTENV_KEY", o2;
        }
        let i2 = `DOTENV_VAULT_${A2.toUpperCase()}`, s = t2.parsed[i2];
        if (!s) {
          let o2 = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${i2} in your .env.vault file.`);
          throw o2.code = "NOT_FOUND_DOTENV_ENVIRONMENT", o2;
        }
        return { ciphertext: s, key: n2 };
      }
      __name(PT, "PT");
      function NC(t2) {
        let e = null;
        if (t2 && t2.path && t2.path.length > 0) if (Array.isArray(t2.path)) for (let r2 of t2.path) Du.existsSync(r2) && (e = r2.endsWith(".vault") ? r2 : `${r2}.vault`);
        else e = t2.path.endsWith(".vault") ? t2.path : `${t2.path}.vault`;
        else e = Ru.resolve(process.cwd(), ".env.vault");
        return Du.existsSync(e) ? e : null;
      }
      __name(NC, "NC");
      function RC(t2) {
        return t2[0] === "~" ? Ru.join(TT.homedir(), t2.slice(1)) : t2;
      }
      __name(RC, "RC");
      function YT(t2) {
        !!(t2 && t2.debug) && bi("Loading env from encrypted .env.vault");
        let r2 = pe._parseVault(t2), n2 = process.env;
        return t2 && t2.processEnv != null && (n2 = t2.processEnv), pe.populate(n2, r2, t2), { parsed: r2 };
      }
      __name(YT, "YT");
      function GT(t2) {
        let e = Ru.resolve(process.cwd(), ".env"), r2 = "utf8", n2 = !!(t2 && t2.debug);
        t2 && t2.encoding ? r2 = t2.encoding : n2 && bi("No encoding is specified. UTF-8 is used by default");
        let A2 = [e];
        if (t2 && t2.path) if (!Array.isArray(t2.path)) A2 = [RC(t2.path)];
        else {
          A2 = [];
          for (let a2 of t2.path) A2.push(RC(a2));
        }
        let i2, s = {};
        for (let a2 of A2) try {
          let c2 = pe.parse(Du.readFileSync(a2, { encoding: r2 }));
          pe.populate(s, c2, t2);
        } catch (c2) {
          n2 && bi(`Failed to load ${a2} ${c2.message}`), i2 = c2;
        }
        let o2 = process.env;
        return t2 && t2.processEnv != null && (o2 = t2.processEnv), pe.populate(o2, s, t2), i2 ? { parsed: s, error: i2 } : { parsed: s };
      }
      __name(GT, "GT");
      function OT(t2) {
        if (bC(t2).length === 0) return pe.configDotenv(t2);
        let e = NC(t2);
        return e ? pe._configVault(t2) : (vT(`You set DOTENV_KEY but you are missing a .env.vault file at ${e}. Did you forget to build it?`), pe.configDotenv(t2));
      }
      __name(OT, "OT");
      function VT(t2, e) {
        let r2 = Buffer.from(e.slice(-64), "hex"), n2 = Buffer.from(t2, "base64"), A2 = n2.subarray(0, 12), i2 = n2.subarray(-16);
        n2 = n2.subarray(12, -16);
        try {
          let s = xT.createDecipheriv("aes-256-gcm", r2, A2);
          return s.setAuthTag(i2), `${s.update(n2)}${s.final()}`;
        } catch (s) {
          let o2 = s instanceof RangeError, a2 = s.message === "Invalid key length", c2 = s.message === "Unsupported state or unable to authenticate data";
          if (o2 || a2) {
            let l2 = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
            throw l2.code = "INVALID_DOTENV_KEY", l2;
          } else if (c2) {
            let l2 = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
            throw l2.code = "DECRYPTION_FAILED", l2;
          } else throw s;
        }
      }
      __name(VT, "VT");
      function HT(t2, e, r2 = {}) {
        let n2 = !!(r2 && r2.debug), A2 = !!(r2 && r2.override);
        if (typeof e != "object") {
          let i2 = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
          throw i2.code = "OBJECT_REQUIRED", i2;
        }
        for (let i2 of Object.keys(e)) Object.prototype.hasOwnProperty.call(t2, i2) ? (A2 === true && (t2[i2] = e[i2]), n2 && bi(A2 === true ? `"${i2}" is already defined and WAS overwritten` : `"${i2}" is already defined and was NOT overwritten`)) : t2[i2] = e[i2];
      }
      __name(HT, "HT");
      var pe = { configDotenv: GT, _configVault: YT, _parseVault: LT, config: OT, decrypt: VT, parse: MT, populate: HT };
      ir.exports.configDotenv = pe.configDotenv;
      ir.exports._configVault = pe._configVault;
      ir.exports._parseVault = pe._parseVault;
      ir.exports.config = pe.config;
      ir.exports.decrypt = pe.decrypt;
      ir.exports.parse = pe.parse;
      ir.exports.populate = pe.populate;
      ir.exports = pe;
    });
    var kC = C2((xj, Vo) => {
      "use strict";
      Vo.exports = (t2 = {}) => {
        let e;
        if (t2.repoUrl) e = t2.repoUrl;
        else if (t2.user && t2.repo) e = `https://github.com/${t2.user}/${t2.repo}`;
        else throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
        let r2 = new URL(`${e}/issues/new`), n2 = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
        for (let A2 of n2) {
          let i2 = t2[A2];
          if (i2 !== void 0) {
            if (A2 === "labels" || A2 === "projects") {
              if (!Array.isArray(i2)) throw new TypeError(`The \`${A2}\` option should be an array`);
              i2 = i2.join(",");
            }
            r2.searchParams.set(A2, i2);
          }
        }
        return r2.toString();
      };
      Vo.exports.default = Vo.exports;
    });
    var vu = C2((i3, nI) => {
      "use strict";
      nI.exports = /* @__PURE__ */ function() {
        function t2(e, r2, n2, A2, i2) {
          return e < r2 || n2 < r2 ? e > n2 ? n2 + 1 : e + 1 : A2 === i2 ? r2 : r2 + 1;
        }
        __name(t2, "t");
        return function(e, r2) {
          if (e === r2) return 0;
          if (e.length > r2.length) {
            var n2 = e;
            e = r2, r2 = n2;
          }
          for (var A2 = e.length, i2 = r2.length; A2 > 0 && e.charCodeAt(A2 - 1) === r2.charCodeAt(i2 - 1); ) A2--, i2--;
          for (var s = 0; s < A2 && e.charCodeAt(s) === r2.charCodeAt(s); ) s++;
          if (A2 -= s, i2 -= s, A2 === 0 || i2 < 3) return i2;
          var o2 = 0, a2, c2, l2, u2, g, E, h, f2, p2, Q, I2, B, w = [];
          for (a2 = 0; a2 < A2; a2++) w.push(a2 + 1), w.push(e.charCodeAt(s + a2));
          for (var D2 = w.length - 1; o2 < i2 - 3; ) for (p2 = r2.charCodeAt(s + (c2 = o2)), Q = r2.charCodeAt(s + (l2 = o2 + 1)), I2 = r2.charCodeAt(s + (u2 = o2 + 2)), B = r2.charCodeAt(s + (g = o2 + 3)), E = o2 += 4, a2 = 0; a2 < D2; a2 += 2) h = w[a2], f2 = w[a2 + 1], c2 = t2(h, c2, l2, p2, f2), l2 = t2(c2, l2, u2, Q, f2), u2 = t2(l2, u2, g, I2, f2), E = t2(u2, g, E, B, f2), w[a2] = E, g = u2, u2 = l2, l2 = c2, c2 = h;
          for (; o2 < i2; ) for (p2 = r2.charCodeAt(s + (c2 = o2)), E = ++o2, a2 = 0; a2 < D2; a2 += 2) h = w[a2], w[a2] = E = t2(h, c2, E, p2, w[a2 + 1]), c2 = h;
          return E;
        };
      }();
    });
    var aI = $h(() => {
      "use strict";
    });
    var cI = $h(() => {
      "use strict";
    });
    var ne = C2((mK, vp) => {
      "use strict";
      vp.exports = { kClose: Symbol("close"), kDestroy: Symbol("destroy"), kDispatch: Symbol("dispatch"), kUrl: Symbol("url"), kWriting: Symbol("writing"), kResuming: Symbol("resuming"), kQueue: Symbol("queue"), kConnect: Symbol("connect"), kConnecting: Symbol("connecting"), kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"), kKeepAliveMaxTimeout: Symbol("max keep alive timeout"), kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"), kKeepAliveTimeoutValue: Symbol("keep alive timeout"), kKeepAlive: Symbol("keep alive"), kHeadersTimeout: Symbol("headers timeout"), kBodyTimeout: Symbol("body timeout"), kServerName: Symbol("server name"), kLocalAddress: Symbol("local address"), kHost: Symbol("host"), kNoRef: Symbol("no ref"), kBodyUsed: Symbol("used"), kBody: Symbol("abstracted request body"), kRunning: Symbol("running"), kBlocking: Symbol("blocking"), kPending: Symbol("pending"), kSize: Symbol("size"), kBusy: Symbol("busy"), kQueued: Symbol("queued"), kFree: Symbol("free"), kConnected: Symbol("connected"), kClosed: Symbol("closed"), kNeedDrain: Symbol("need drain"), kReset: Symbol("reset"), kDestroyed: Symbol.for("nodejs.stream.destroyed"), kResume: Symbol("resume"), kOnError: Symbol("on error"), kMaxHeadersSize: Symbol("max headers size"), kRunningIdx: Symbol("running index"), kPendingIdx: Symbol("pending index"), kError: Symbol("error"), kClients: Symbol("clients"), kClient: Symbol("client"), kParser: Symbol("parser"), kOnDestroyed: Symbol("destroy callbacks"), kPipelining: Symbol("pipelining"), kSocket: Symbol("socket"), kHostHeader: Symbol("host header"), kConnector: Symbol("connector"), kStrictContentLength: Symbol("strict content length"), kMaxRedirections: Symbol("maxRedirections"), kMaxRequests: Symbol("maxRequestsPerClient"), kProxy: Symbol("proxy agent options"), kCounter: Symbol("socket request counter"), kMaxResponseSize: Symbol("max response size"), kHTTP2Session: Symbol("http2Session"), kHTTP2SessionState: Symbol("http2Session state"), kRetryHandlerDefaultRetry: Symbol("retry agent default retry"), kConstruct: Symbol("constructable"), kListeners: Symbol("listeners"), kHTTPContext: Symbol("http context"), kMaxConcurrentStreams: Symbol("max concurrent streams"), kNoProxyAgent: Symbol("no proxy agent"), kHttpProxyAgent: Symbol("http proxy agent"), kHttpsProxyAgent: Symbol("https proxy agent") };
    });
    var H = C2((yK, Pp) => {
      "use strict";
      var Ee = class extends Error {
        static {
          __name(this, "Ee");
        }
        constructor(e, r2) {
          super(e, r2), this.name = "UndiciError", this.code = "UND_ERR";
        }
      }, ig = class extends Ee {
        static {
          __name(this, "ig");
        }
        constructor(e) {
          super(e), this.name = "ConnectTimeoutError", this.message = e || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
        }
      }, sg = class extends Ee {
        static {
          __name(this, "sg");
        }
        constructor(e) {
          super(e), this.name = "HeadersTimeoutError", this.message = e || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
        }
      }, og = class extends Ee {
        static {
          __name(this, "og");
        }
        constructor(e) {
          super(e), this.name = "HeadersOverflowError", this.message = e || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
        }
      }, ag = class extends Ee {
        static {
          __name(this, "ag");
        }
        constructor(e) {
          super(e), this.name = "BodyTimeoutError", this.message = e || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
        }
      }, cg = class extends Ee {
        static {
          __name(this, "cg");
        }
        constructor(e, r2, n2, A2) {
          super(e), this.name = "ResponseStatusCodeError", this.message = e || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = A2, this.status = r2, this.statusCode = r2, this.headers = n2;
        }
      }, lg = class extends Ee {
        static {
          __name(this, "lg");
        }
        constructor(e) {
          super(e), this.name = "InvalidArgumentError", this.message = e || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
        }
      }, ug = class extends Ee {
        static {
          __name(this, "ug");
        }
        constructor(e) {
          super(e), this.name = "InvalidReturnValueError", this.message = e || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
        }
      }, Sa = class extends Ee {
        static {
          __name(this, "Sa");
        }
        constructor(e) {
          super(e), this.name = "AbortError", this.message = e || "The operation was aborted";
        }
      }, gg = class extends Sa {
        static {
          __name(this, "gg");
        }
        constructor(e) {
          super(e), this.name = "AbortError", this.message = e || "Request aborted", this.code = "UND_ERR_ABORTED";
        }
      }, Eg = class extends Ee {
        static {
          __name(this, "Eg");
        }
        constructor(e) {
          super(e), this.name = "InformationalError", this.message = e || "Request information", this.code = "UND_ERR_INFO";
        }
      }, dg = class extends Ee {
        static {
          __name(this, "dg");
        }
        constructor(e) {
          super(e), this.name = "RequestContentLengthMismatchError", this.message = e || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
        }
      }, hg = class extends Ee {
        static {
          __name(this, "hg");
        }
        constructor(e) {
          super(e), this.name = "ResponseContentLengthMismatchError", this.message = e || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
        }
      }, fg = class extends Ee {
        static {
          __name(this, "fg");
        }
        constructor(e) {
          super(e), this.name = "ClientDestroyedError", this.message = e || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
        }
      }, Qg = class extends Ee {
        static {
          __name(this, "Qg");
        }
        constructor(e) {
          super(e), this.name = "ClientClosedError", this.message = e || "The client is closed", this.code = "UND_ERR_CLOSED";
        }
      }, Cg = class extends Ee {
        static {
          __name(this, "Cg");
        }
        constructor(e, r2) {
          super(e), this.name = "SocketError", this.message = e || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = r2;
        }
      }, Ig = class extends Ee {
        static {
          __name(this, "Ig");
        }
        constructor(e) {
          super(e), this.name = "NotSupportedError", this.message = e || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
        }
      }, pg = class extends Ee {
        static {
          __name(this, "pg");
        }
        constructor(e) {
          super(e), this.name = "MissingUpstreamError", this.message = e || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
        }
      }, Bg = class extends Error {
        static {
          __name(this, "Bg");
        }
        constructor(e, r2, n2) {
          super(e), this.name = "HTTPParserError", this.code = r2 ? `HPE_${r2}` : void 0, this.data = n2 ? n2.toString() : void 0;
        }
      }, mg = class extends Ee {
        static {
          __name(this, "mg");
        }
        constructor(e) {
          super(e), this.name = "ResponseExceededMaxSizeError", this.message = e || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
        }
      }, yg = class extends Ee {
        static {
          __name(this, "yg");
        }
        constructor(e, r2, { headers: n2, data: A2 }) {
          super(e), this.name = "RequestRetryError", this.message = e || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = r2, this.data = A2, this.headers = n2;
        }
      }, wg = class extends Ee {
        static {
          __name(this, "wg");
        }
        constructor(e, r2, { headers: n2, body: A2 }) {
          super(e), this.name = "ResponseError", this.message = e || "Response error", this.code = "UND_ERR_RESPONSE", this.statusCode = r2, this.body = A2, this.headers = n2;
        }
      }, Dg = class extends Ee {
        static {
          __name(this, "Dg");
        }
        constructor(e, r2, n2 = {}) {
          super(r2, { cause: e, ...n2 }), this.name = "SecureProxyConnectionError", this.message = r2 || "Secure Proxy Connection failed", this.code = "UND_ERR_PRX_TLS", this.cause = e;
        }
      };
      Pp.exports = { AbortError: Sa, HTTPParserError: Bg, UndiciError: Ee, HeadersTimeoutError: sg, HeadersOverflowError: og, BodyTimeoutError: ag, RequestContentLengthMismatchError: dg, ConnectTimeoutError: ig, ResponseStatusCodeError: cg, InvalidArgumentError: lg, InvalidReturnValueError: ug, RequestAbortedError: gg, ClientDestroyedError: fg, ClientClosedError: Qg, InformationalError: Eg, SocketError: Cg, NotSupportedError: Ig, ResponseContentLengthMismatchError: hg, BalancedPoolMissingUpstreamError: pg, ResponseExceededMaxSizeError: mg, RequestRetryError: yg, ResponseError: wg, SecureProxyConnectionError: Dg };
    });
    var Na = C2((wK, Gp) => {
      "use strict";
      var Rg = ["Accept", "Accept-Encoding", "Accept-Language", "Accept-Ranges", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Age", "Allow", "Alt-Svc", "Alt-Used", "Authorization", "Cache-Control", "Clear-Site-Data", "Connection", "Content-Disposition", "Content-Encoding", "Content-Language", "Content-Length", "Content-Location", "Content-Range", "Content-Security-Policy", "Content-Security-Policy-Report-Only", "Content-Type", "Cookie", "Cross-Origin-Embedder-Policy", "Cross-Origin-Opener-Policy", "Cross-Origin-Resource-Policy", "Date", "Device-Memory", "Downlink", "ECT", "ETag", "Expect", "Expect-CT", "Expires", "Forwarded", "From", "Host", "If-Match", "If-Modified-Since", "If-None-Match", "If-Range", "If-Unmodified-Since", "Keep-Alive", "Last-Modified", "Link", "Location", "Max-Forwards", "Origin", "Permissions-Policy", "Pragma", "Proxy-Authenticate", "Proxy-Authorization", "RTT", "Range", "Referer", "Referrer-Policy", "Refresh", "Retry-After", "Sec-WebSocket-Accept", "Sec-WebSocket-Extensions", "Sec-WebSocket-Key", "Sec-WebSocket-Protocol", "Sec-WebSocket-Version", "Server", "Server-Timing", "Service-Worker-Allowed", "Service-Worker-Navigation-Preload", "Set-Cookie", "SourceMap", "Strict-Transport-Security", "Supports-Loading-Mode", "TE", "Timing-Allow-Origin", "Trailer", "Transfer-Encoding", "Upgrade", "Upgrade-Insecure-Requests", "User-Agent", "Vary", "Via", "WWW-Authenticate", "X-Content-Type-Options", "X-DNS-Prefetch-Control", "X-Frame-Options", "X-Permitted-Cross-Domain-Policies", "X-Powered-By", "X-Requested-With", "X-XSS-Protection"], ba = {};
      Object.setPrototypeOf(ba, null);
      var Yp = {};
      Object.setPrototypeOf(Yp, null);
      function Hk(t2) {
        let e = Yp[t2];
        return e === void 0 && (e = Buffer.from(t2)), e;
      }
      __name(Hk, "Hk");
      for (let t2 = 0; t2 < Rg.length; ++t2) {
        let e = Rg[t2], r2 = e.toLowerCase();
        ba[e] = ba[r2] = r2;
      }
      Gp.exports = { wellknownHeaderNames: Rg, headerNameLowerCasedRecord: ba, getHeaderNameAsBuffer: Hk };
    });
    var qp = C2((DK, Hp) => {
      "use strict";
      var { wellknownHeaderNames: Op, headerNameLowerCasedRecord: qk } = Na(), Sg = class t2 {
        static {
          __name(this, "t");
        }
        value = null;
        left = null;
        middle = null;
        right = null;
        code;
        constructor(e, r2, n2) {
          if (n2 === void 0 || n2 >= e.length) throw new TypeError("Unreachable");
          if ((this.code = e.charCodeAt(n2)) > 127) throw new TypeError("key must be ascii string");
          e.length !== ++n2 ? this.middle = new t2(e, r2, n2) : this.value = r2;
        }
        add(e, r2) {
          let n2 = e.length;
          if (n2 === 0) throw new TypeError("Unreachable");
          let A2 = 0, i2 = this;
          for (; ; ) {
            let s = e.charCodeAt(A2);
            if (s > 127) throw new TypeError("key must be ascii string");
            if (i2.code === s) if (n2 === ++A2) {
              i2.value = r2;
              break;
            } else if (i2.middle !== null) i2 = i2.middle;
            else {
              i2.middle = new t2(e, r2, A2);
              break;
            }
            else if (i2.code < s) if (i2.left !== null) i2 = i2.left;
            else {
              i2.left = new t2(e, r2, A2);
              break;
            }
            else if (i2.right !== null) i2 = i2.right;
            else {
              i2.right = new t2(e, r2, A2);
              break;
            }
          }
        }
        search(e) {
          let r2 = e.length, n2 = 0, A2 = this;
          for (; A2 !== null && n2 < r2; ) {
            let i2 = e[n2];
            for (i2 <= 90 && i2 >= 65 && (i2 |= 32); A2 !== null; ) {
              if (i2 === A2.code) {
                if (r2 === ++n2) return A2;
                A2 = A2.middle;
                break;
              }
              A2 = A2.code < i2 ? A2.left : A2.right;
            }
          }
          return null;
        }
      }, Fa = class {
        static {
          __name(this, "Fa");
        }
        node = null;
        insert(e, r2) {
          this.node === null ? this.node = new Sg(e, r2, 0) : this.node.add(e, r2);
        }
        lookup(e) {
          return this.node?.search(e)?.value ?? null;
        }
      }, Vp = new Fa();
      for (let t2 = 0; t2 < Op.length; ++t2) {
        let e = qk[Op[t2]];
        Vp.insert(e, e);
      }
      Hp.exports = { TernarySearchTree: Fa, tree: Vp };
    });
    var Y2 = C2((RK, oB) => {
      "use strict";
      var Xi = __require("node:assert"), { kDestroyed: Wp, kBodyUsed: BA, kListeners: Ta, kBody: Jp } = ne(), { IncomingMessage: Jk } = __require("node:http"), _p = __require("node:stream"), Wk = __require("node:net"), { Blob: _k } = __require("node:buffer"), jk = __require("node:util"), { stringify: Zk } = __require("node:querystring"), { EventEmitter: Xk } = __require("node:events"), { InvalidArgumentError: Re } = H(), { headerNameLowerCasedRecord: Kk } = Na(), { tree: jp } = qp(), [$k, zk] = process.versions.node.split(".").map((t2) => Number(t2)), Ua = class {
        static {
          __name(this, "Ua");
        }
        constructor(e) {
          this[Jp] = e, this[BA] = false;
        }
        async *[Symbol.asyncIterator]() {
          Xi(!this[BA], "disturbed"), this[BA] = true, yield* this[Jp];
        }
      };
      function eM(t2) {
        return ka(t2) ? (zp(t2) === 0 && t2.on("data", function() {
          Xi(false);
        }), typeof t2.readableDidRead != "boolean" && (t2[BA] = false, Xk.prototype.on.call(t2, "data", function() {
          this[BA] = true;
        })), t2) : t2 && typeof t2.pipeTo == "function" ? new Ua(t2) : t2 && typeof t2 != "string" && !ArrayBuffer.isView(t2) && $p(t2) ? new Ua(t2) : t2;
      }
      __name(eM, "eM");
      function ka(t2) {
        return t2 && typeof t2 == "object" && typeof t2.pipe == "function" && typeof t2.on == "function";
      }
      __name(ka, "ka");
      function Zp(t2) {
        if (t2 === null) return false;
        if (t2 instanceof _k) return true;
        if (typeof t2 != "object") return false;
        {
          let e = t2[Symbol.toStringTag];
          return (e === "Blob" || e === "File") && ("stream" in t2 && typeof t2.stream == "function" || "arrayBuffer" in t2 && typeof t2.arrayBuffer == "function");
        }
      }
      __name(Zp, "Zp");
      function tM(t2, e) {
        if (t2.includes("?") || t2.includes("#")) throw new Error('Query params cannot be passed when url already contains "?" or "#".');
        let r2 = Zk(e);
        return r2 && (t2 += "?" + r2), t2;
      }
      __name(tM, "tM");
      function Xp(t2) {
        let e = parseInt(t2, 10);
        return e === Number(t2) && e >= 0 && e <= 65535;
      }
      __name(Xp, "Xp");
      function xa(t2) {
        return t2 != null && t2[0] === "h" && t2[1] === "t" && t2[2] === "t" && t2[3] === "p" && (t2[4] === ":" || t2[4] === "s" && t2[5] === ":");
      }
      __name(xa, "xa");
      function Kp(t2) {
        if (typeof t2 == "string") {
          if (t2 = new URL(t2), !xa(t2.origin || t2.protocol)) throw new Re("Invalid URL protocol: the URL must start with `http:` or `https:`.");
          return t2;
        }
        if (!t2 || typeof t2 != "object") throw new Re("Invalid URL: The URL argument must be a non-null object.");
        if (!(t2 instanceof URL)) {
          if (t2.port != null && t2.port !== "" && Xp(t2.port) === false) throw new Re("Invalid URL: port must be a valid integer or a string representation of an integer.");
          if (t2.path != null && typeof t2.path != "string") throw new Re("Invalid URL path: the path must be a string or null/undefined.");
          if (t2.pathname != null && typeof t2.pathname != "string") throw new Re("Invalid URL pathname: the pathname must be a string or null/undefined.");
          if (t2.hostname != null && typeof t2.hostname != "string") throw new Re("Invalid URL hostname: the hostname must be a string or null/undefined.");
          if (t2.origin != null && typeof t2.origin != "string") throw new Re("Invalid URL origin: the origin must be a string or null/undefined.");
          if (!xa(t2.origin || t2.protocol)) throw new Re("Invalid URL protocol: the URL must start with `http:` or `https:`.");
          let e = t2.port != null ? t2.port : t2.protocol === "https:" ? 443 : 80, r2 = t2.origin != null ? t2.origin : `${t2.protocol || ""}//${t2.hostname || ""}:${e}`, n2 = t2.path != null ? t2.path : `${t2.pathname || ""}${t2.search || ""}`;
          return r2[r2.length - 1] === "/" && (r2 = r2.slice(0, r2.length - 1)), n2 && n2[0] !== "/" && (n2 = `/${n2}`), new URL(`${r2}${n2}`);
        }
        if (!xa(t2.origin || t2.protocol)) throw new Re("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        return t2;
      }
      __name(Kp, "Kp");
      function rM(t2) {
        if (t2 = Kp(t2), t2.pathname !== "/" || t2.search || t2.hash) throw new Re("invalid url");
        return t2;
      }
      __name(rM, "rM");
      function nM(t2) {
        if (t2[0] === "[") {
          let r2 = t2.indexOf("]");
          return Xi(r2 !== -1), t2.substring(1, r2);
        }
        let e = t2.indexOf(":");
        return e === -1 ? t2 : t2.substring(0, e);
      }
      __name(nM, "nM");
      function AM(t2) {
        if (!t2) return null;
        Xi(typeof t2 == "string");
        let e = nM(t2);
        return Wk.isIP(e) ? "" : e;
      }
      __name(AM, "AM");
      function iM(t2) {
        return JSON.parse(JSON.stringify(t2));
      }
      __name(iM, "iM");
      function sM(t2) {
        return t2 != null && typeof t2[Symbol.asyncIterator] == "function";
      }
      __name(sM, "sM");
      function $p(t2) {
        return t2 != null && (typeof t2[Symbol.iterator] == "function" || typeof t2[Symbol.asyncIterator] == "function");
      }
      __name($p, "$p");
      function zp(t2) {
        if (t2 == null) return 0;
        if (ka(t2)) {
          let e = t2._readableState;
          return e && e.objectMode === false && e.ended === true && Number.isFinite(e.length) ? e.length : null;
        } else {
          if (Zp(t2)) return t2.size != null ? t2.size : null;
          if (rB(t2)) return t2.byteLength;
        }
        return null;
      }
      __name(zp, "zp");
      function eB(t2) {
        return t2 && !!(t2.destroyed || t2[Wp] || _p.isDestroyed?.(t2));
      }
      __name(eB, "eB");
      function oM(t2, e) {
        t2 == null || !ka(t2) || eB(t2) || (typeof t2.destroy == "function" ? (Object.getPrototypeOf(t2).constructor === Jk && (t2.socket = null), t2.destroy(e)) : e && queueMicrotask(() => {
          t2.emit("error", e);
        }), t2.destroyed !== true && (t2[Wp] = true));
      }
      __name(oM, "oM");
      var aM = /timeout=(\d+)/;
      function cM(t2) {
        let e = t2.match(aM);
        return e ? parseInt(e[1], 10) * 1e3 : null;
      }
      __name(cM, "cM");
      function tB(t2) {
        return typeof t2 == "string" ? Kk[t2] ?? t2.toLowerCase() : jp.lookup(t2) ?? t2.toString("latin1").toLowerCase();
      }
      __name(tB, "tB");
      function lM(t2) {
        return jp.lookup(t2) ?? t2.toString("latin1").toLowerCase();
      }
      __name(lM, "lM");
      function uM(t2, e) {
        e === void 0 && (e = {});
        for (let r2 = 0; r2 < t2.length; r2 += 2) {
          let n2 = tB(t2[r2]), A2 = e[n2];
          if (A2) typeof A2 == "string" && (A2 = [A2], e[n2] = A2), A2.push(t2[r2 + 1].toString("utf8"));
          else {
            let i2 = t2[r2 + 1];
            typeof i2 == "string" ? e[n2] = i2 : e[n2] = Array.isArray(i2) ? i2.map((s) => s.toString("utf8")) : i2.toString("utf8");
          }
        }
        return "content-length" in e && "content-disposition" in e && (e["content-disposition"] = Buffer.from(e["content-disposition"]).toString("latin1")), e;
      }
      __name(uM, "uM");
      function gM(t2) {
        let e = t2.length, r2 = new Array(e), n2 = false, A2 = -1, i2, s, o2 = 0;
        for (let a2 = 0; a2 < e; a2 += 2) i2 = t2[a2], s = t2[a2 + 1], typeof i2 != "string" && (i2 = i2.toString()), typeof s != "string" && (s = s.toString("utf8")), o2 = i2.length, o2 === 14 && i2[7] === "-" && (i2 === "content-length" || i2.toLowerCase() === "content-length") ? n2 = true : o2 === 19 && i2[7] === "-" && (i2 === "content-disposition" || i2.toLowerCase() === "content-disposition") && (A2 = a2 + 1), r2[a2] = i2, r2[a2 + 1] = s;
        return n2 && A2 !== -1 && (r2[A2] = Buffer.from(r2[A2]).toString("latin1")), r2;
      }
      __name(gM, "gM");
      function EM(t2) {
        if (!Array.isArray(t2)) throw new TypeError("expected headers to be an array");
        return t2.map((e) => Buffer.from(e));
      }
      __name(EM, "EM");
      function rB(t2) {
        return t2 instanceof Uint8Array || Buffer.isBuffer(t2);
      }
      __name(rB, "rB");
      function dM(t2, e, r2) {
        if (!t2 || typeof t2 != "object") throw new Re("handler must be an object");
        if (typeof t2.onRequestStart != "function") {
          if (typeof t2.onConnect != "function") throw new Re("invalid onConnect method");
          if (typeof t2.onError != "function") throw new Re("invalid onError method");
          if (typeof t2.onBodySent != "function" && t2.onBodySent !== void 0) throw new Re("invalid onBodySent method");
          if (r2 || e === "CONNECT") {
            if (typeof t2.onUpgrade != "function") throw new Re("invalid onUpgrade method");
          } else {
            if (typeof t2.onHeaders != "function") throw new Re("invalid onHeaders method");
            if (typeof t2.onData != "function") throw new Re("invalid onData method");
            if (typeof t2.onComplete != "function") throw new Re("invalid onComplete method");
          }
        }
      }
      __name(dM, "dM");
      function hM(t2) {
        return !!(t2 && (_p.isDisturbed(t2) || t2[BA]));
      }
      __name(hM, "hM");
      function fM(t2) {
        return { localAddress: t2.localAddress, localPort: t2.localPort, remoteAddress: t2.remoteAddress, remotePort: t2.remotePort, remoteFamily: t2.remoteFamily, timeout: t2.timeout, bytesWritten: t2.bytesWritten, bytesRead: t2.bytesRead };
      }
      __name(fM, "fM");
      function QM(t2) {
        let e;
        return new ReadableStream({ async start() {
          e = t2[Symbol.asyncIterator]();
        }, pull(r2) {
          async function n2() {
            let { done: A2, value: i2 } = await e.next();
            if (A2) queueMicrotask(() => {
              r2.close(), r2.byobRequest?.respond(0);
            });
            else {
              let s = Buffer.isBuffer(i2) ? i2 : Buffer.from(i2);
              if (s.byteLength) r2.enqueue(new Uint8Array(s));
              else return await n2();
            }
          }
          __name(n2, "n");
          return n2();
        }, async cancel() {
          await e.return();
        }, type: "bytes" });
      }
      __name(QM, "QM");
      function CM(t2) {
        return t2 && typeof t2 == "object" && typeof t2.append == "function" && typeof t2.delete == "function" && typeof t2.get == "function" && typeof t2.getAll == "function" && typeof t2.has == "function" && typeof t2.set == "function" && t2[Symbol.toStringTag] === "FormData";
      }
      __name(CM, "CM");
      function IM(t2, e) {
        return "addEventListener" in t2 ? (t2.addEventListener("abort", e, { once: true }), () => t2.removeEventListener("abort", e)) : (t2.once("abort", e), () => t2.removeListener("abort", e));
      }
      __name(IM, "IM");
      var nB = typeof String.prototype.toWellFormed == "function" ? (t2) => `${t2}`.toWellFormed() : jk.toUSVString, pM = typeof String.prototype.isWellFormed == "function" ? (t2) => `${t2}`.isWellFormed() : (t2) => nB(t2) === `${t2}`;
      function AB(t2) {
        switch (t2) {
          case 34:
          case 40:
          case 41:
          case 44:
          case 47:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 91:
          case 92:
          case 93:
          case 123:
          case 125:
            return false;
          default:
            return t2 >= 33 && t2 <= 126;
        }
      }
      __name(AB, "AB");
      function BM(t2) {
        if (t2.length === 0) return false;
        for (let e = 0; e < t2.length; ++e) if (!AB(t2.charCodeAt(e))) return false;
        return true;
      }
      __name(BM, "BM");
      var mM = /[^\t\x20-\x7e\x80-\xff]/;
      function yM(t2) {
        return !mM.test(t2);
      }
      __name(yM, "yM");
      var wM = /^bytes (\d+)-(\d+)\/(\d+)?$/;
      function DM(t2) {
        if (t2 == null || t2 === "") return { start: 0, end: null, size: null };
        let e = t2 ? t2.match(wM) : null;
        return e ? { start: parseInt(e[1]), end: e[2] ? parseInt(e[2]) : null, size: e[3] ? parseInt(e[3]) : null } : null;
      }
      __name(DM, "DM");
      function RM(t2, e, r2) {
        return (t2[Ta] ??= []).push([e, r2]), t2.on(e, r2), t2;
      }
      __name(RM, "RM");
      function SM(t2) {
        if (t2[Ta] != null) {
          for (let [e, r2] of t2[Ta]) t2.removeListener(e, r2);
          t2[Ta] = null;
        }
        return t2;
      }
      __name(SM, "SM");
      function bM(t2, e, r2) {
        try {
          e.onError(r2), Xi(e.aborted);
        } catch (n2) {
          t2.emit("error", n2);
        }
      }
      __name(bM, "bM");
      var iB = /* @__PURE__ */ Object.create(null);
      iB.enumerable = true;
      var bg = { delete: "DELETE", DELETE: "DELETE", get: "GET", GET: "GET", head: "HEAD", HEAD: "HEAD", options: "OPTIONS", OPTIONS: "OPTIONS", post: "POST", POST: "POST", put: "PUT", PUT: "PUT" }, sB = { ...bg, patch: "patch", PATCH: "PATCH" };
      Object.setPrototypeOf(bg, null);
      Object.setPrototypeOf(sB, null);
      oB.exports = { kEnumerableProperty: iB, isDisturbed: hM, toUSVString: nB, isUSVString: pM, isBlobLike: Zp, parseOrigin: rM, parseURL: Kp, getServerName: AM, isStream: ka, isIterable: $p, isAsyncIterable: sM, isDestroyed: eB, headerNameToString: tB, bufferToLowerCasedHeaderName: lM, addListener: RM, removeAllListeners: SM, errorRequest: bM, parseRawHeaders: gM, encodeRawHeaders: EM, parseHeaders: uM, parseKeepAliveTimeout: cM, destroy: oM, bodyLength: zp, deepClone: iM, ReadableStreamFrom: QM, isBuffer: rB, assertRequestHandler: dM, getSocketInfo: fM, isFormDataLike: CM, serializePathWithQuery: tM, addAbortListener: IM, isValidHTTPToken: BM, isValidHeaderValue: yM, isTokenCharCode: AB, parseRangeHeader: DM, normalizedMethodRecordsBase: bg, normalizedMethodRecords: sB, isValidPort: Xp, isHttpOrHttpsPrefixed: xa, nodeMajor: $k, nodeMinor: zk, safeHTTPMethods: Object.freeze(["GET", "HEAD", "OPTIONS", "TRACE"]), wrapRequestBody: eM };
    });
    var lr = C2((SK, gB) => {
      "use strict";
      var se = __require("node:diagnostics_channel"), Ng = __require("node:util"), En = Ng.debuglog("undici"), Ki = Ng.debuglog("fetch"), Ma = Ng.debuglog("websocket"), NM = { beforeConnect: se.channel("undici:client:beforeConnect"), connected: se.channel("undici:client:connected"), connectError: se.channel("undici:client:connectError"), sendHeaders: se.channel("undici:client:sendHeaders"), create: se.channel("undici:request:create"), bodySent: se.channel("undici:request:bodySent"), headers: se.channel("undici:request:headers"), trailers: se.channel("undici:request:trailers"), error: se.channel("undici:request:error"), open: se.channel("undici:websocket:open"), close: se.channel("undici:websocket:close"), socketError: se.channel("undici:websocket:socket_error"), ping: se.channel("undici:websocket:ping"), pong: se.channel("undici:websocket:pong") }, aB = false;
      function uB(t2 = En) {
        aB || (aB = true, se.subscribe("undici:client:beforeConnect", (e) => {
          let { connectParams: { version: r2, protocol: n2, port: A2, host: i2 } } = e;
          t2("connecting to %s%s using %s%s", i2, A2 ? `:${A2}` : "", n2, r2);
        }), se.subscribe("undici:client:connected", (e) => {
          let { connectParams: { version: r2, protocol: n2, port: A2, host: i2 } } = e;
          t2("connected to %s%s using %s%s", i2, A2 ? `:${A2}` : "", n2, r2);
        }), se.subscribe("undici:client:connectError", (e) => {
          let { connectParams: { version: r2, protocol: n2, port: A2, host: i2 }, error: s } = e;
          t2("connection to %s%s using %s%s errored - %s", i2, A2 ? `:${A2}` : "", n2, r2, s.message);
        }), se.subscribe("undici:client:sendHeaders", (e) => {
          let { request: { method: r2, path: n2, origin: A2 } } = e;
          t2("sending request to %s %s/%s", r2, A2, n2);
        }));
      }
      __name(uB, "uB");
      var cB = false;
      function FM(t2 = En) {
        cB || (cB = true, se.subscribe("undici:request:headers", (e) => {
          let { request: { method: r2, path: n2, origin: A2 }, response: { statusCode: i2 } } = e;
          t2("received response to %s %s/%s - HTTP %d", r2, A2, n2, i2);
        }), se.subscribe("undici:request:trailers", (e) => {
          let { request: { method: r2, path: n2, origin: A2 } } = e;
          t2("trailers received from %s %s/%s", r2, A2, n2);
        }), se.subscribe("undici:request:error", (e) => {
          let { request: { method: r2, path: n2, origin: A2 }, error: i2 } = e;
          t2("request to %s %s/%s errored - %s", r2, A2, n2, i2.message);
        }));
      }
      __name(FM, "FM");
      var lB = false;
      function TM(t2 = Ma) {
        lB || (lB = true, se.subscribe("undici:websocket:open", (e) => {
          let { address: { address: r2, port: n2 } } = e;
          t2("connection opened %s%s", r2, n2 ? `:${n2}` : "");
        }), se.subscribe("undici:websocket:close", (e) => {
          let { websocket: r2, code: n2, reason: A2 } = e;
          t2("closed connection to %s - %s %s", r2.url, n2, A2);
        }), se.subscribe("undici:websocket:socket_error", (e) => {
          t2("connection errored - %s", e.message);
        }), se.subscribe("undici:websocket:ping", (e) => {
          t2("ping received");
        }), se.subscribe("undici:websocket:pong", (e) => {
          t2("pong received");
        }));
      }
      __name(TM, "TM");
      (En.enabled || Ki.enabled) && (uB(Ki.enabled ? Ki : En), FM(Ki.enabled ? Ki : En));
      Ma.enabled && (uB(En.enabled ? En : Ma), TM(Ma));
      gB.exports = { channels: NM };
    });
    var QB = C2((bK, fB) => {
      "use strict";
      var { InvalidArgumentError: ge, NotSupportedError: xM } = H(), Gt = __require("node:assert"), { isValidHTTPToken: hB, isValidHeaderValue: EB, isStream: UM, destroy: kM, isBuffer: MM, isFormDataLike: LM, isIterable: vM, isBlobLike: PM, serializePathWithQuery: YM, assertRequestHandler: GM, getServerName: OM, normalizedMethodRecords: VM } = Y2(), { channels: Ot } = lr(), { headerNameLowerCasedRecord: dB } = Na(), HM = /[^\u0021-\u00ff]/, gt = Symbol("handler"), Fg = class {
        static {
          __name(this, "Fg");
        }
        constructor(e, { path: r2, method: n2, body: A2, headers: i2, query: s, idempotent: o2, blocking: a2, upgrade: c2, headersTimeout: l2, bodyTimeout: u2, reset: g, expectContinue: E, servername: h, throwOnError: f2 }, p2) {
          if (typeof r2 != "string") throw new ge("path must be a string");
          if (r2[0] !== "/" && !(r2.startsWith("http://") || r2.startsWith("https://")) && n2 !== "CONNECT") throw new ge("path must be an absolute URL or start with a slash");
          if (HM.test(r2)) throw new ge("invalid request path");
          if (typeof n2 != "string") throw new ge("method must be a string");
          if (VM[n2] === void 0 && !hB(n2)) throw new ge("invalid request method");
          if (c2 && typeof c2 != "string") throw new ge("upgrade must be a string");
          if (l2 != null && (!Number.isFinite(l2) || l2 < 0)) throw new ge("invalid headersTimeout");
          if (u2 != null && (!Number.isFinite(u2) || u2 < 0)) throw new ge("invalid bodyTimeout");
          if (g != null && typeof g != "boolean") throw new ge("invalid reset");
          if (E != null && typeof E != "boolean") throw new ge("invalid expectContinue");
          if (f2 != null) throw new ge("invalid throwOnError");
          if (this.headersTimeout = l2, this.bodyTimeout = u2, this.method = n2, this.abort = null, A2 == null) this.body = null;
          else if (UM(A2)) {
            this.body = A2;
            let Q = this.body._readableState;
            (!Q || !Q.autoDestroy) && (this.endHandler = function() {
              kM(this);
            }, this.body.on("end", this.endHandler)), this.errorHandler = (I2) => {
              this.abort ? this.abort(I2) : this.error = I2;
            }, this.body.on("error", this.errorHandler);
          } else if (MM(A2)) this.body = A2.byteLength ? A2 : null;
          else if (ArrayBuffer.isView(A2)) this.body = A2.buffer.byteLength ? Buffer.from(A2.buffer, A2.byteOffset, A2.byteLength) : null;
          else if (A2 instanceof ArrayBuffer) this.body = A2.byteLength ? Buffer.from(A2) : null;
          else if (typeof A2 == "string") this.body = A2.length ? Buffer.from(A2) : null;
          else if (LM(A2) || vM(A2) || PM(A2)) this.body = A2;
          else throw new ge("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
          if (this.completed = false, this.aborted = false, this.upgrade = c2 || null, this.path = s ? YM(r2, s) : r2, this.origin = e, this.idempotent = o2 ?? (n2 === "HEAD" || n2 === "GET"), this.blocking = a2 ?? this.method !== "HEAD", this.reset = g ?? null, this.host = null, this.contentLength = null, this.contentType = null, this.headers = [], this.expectContinue = E ?? false, Array.isArray(i2)) {
            if (i2.length % 2 !== 0) throw new ge("headers array must be even");
            for (let Q = 0; Q < i2.length; Q += 2) La(this, i2[Q], i2[Q + 1]);
          } else if (i2 && typeof i2 == "object") if (i2[Symbol.iterator]) for (let Q of i2) {
            if (!Array.isArray(Q) || Q.length !== 2) throw new ge("headers must be in key-value pair format");
            La(this, Q[0], Q[1]);
          }
          else {
            let Q = Object.keys(i2);
            for (let I2 = 0; I2 < Q.length; ++I2) La(this, Q[I2], i2[Q[I2]]);
          }
          else if (i2 != null) throw new ge("headers must be an object or an array");
          GM(p2, n2, c2), this.servername = h || OM(this.host) || null, this[gt] = p2, Ot.create.hasSubscribers && Ot.create.publish({ request: this });
        }
        onBodySent(e) {
          if (this[gt].onBodySent) try {
            return this[gt].onBodySent(e);
          } catch (r2) {
            this.abort(r2);
          }
        }
        onRequestSent() {
          if (Ot.bodySent.hasSubscribers && Ot.bodySent.publish({ request: this }), this[gt].onRequestSent) try {
            return this[gt].onRequestSent();
          } catch (e) {
            this.abort(e);
          }
        }
        onConnect(e) {
          if (Gt(!this.aborted), Gt(!this.completed), this.error) e(this.error);
          else return this.abort = e, this[gt].onConnect(e);
        }
        onResponseStarted() {
          return this[gt].onResponseStarted?.();
        }
        onHeaders(e, r2, n2, A2) {
          Gt(!this.aborted), Gt(!this.completed), Ot.headers.hasSubscribers && Ot.headers.publish({ request: this, response: { statusCode: e, headers: r2, statusText: A2 } });
          try {
            return this[gt].onHeaders(e, r2, n2, A2);
          } catch (i2) {
            this.abort(i2);
          }
        }
        onData(e) {
          Gt(!this.aborted), Gt(!this.completed);
          try {
            return this[gt].onData(e);
          } catch (r2) {
            return this.abort(r2), false;
          }
        }
        onUpgrade(e, r2, n2) {
          return Gt(!this.aborted), Gt(!this.completed), this[gt].onUpgrade(e, r2, n2);
        }
        onComplete(e) {
          this.onFinally(), Gt(!this.aborted), Gt(!this.completed), this.completed = true, Ot.trailers.hasSubscribers && Ot.trailers.publish({ request: this, trailers: e });
          try {
            return this[gt].onComplete(e);
          } catch (r2) {
            this.onError(r2);
          }
        }
        onError(e) {
          if (this.onFinally(), Ot.error.hasSubscribers && Ot.error.publish({ request: this, error: e }), !this.aborted) return this.aborted = true, this[gt].onError(e);
        }
        onFinally() {
          this.errorHandler && (this.body.off("error", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off("end", this.endHandler), this.endHandler = null);
        }
        addHeader(e, r2) {
          return La(this, e, r2), this;
        }
      };
      function La(t2, e, r2) {
        if (r2 && typeof r2 == "object" && !Array.isArray(r2)) throw new ge(`invalid ${e} header`);
        if (r2 === void 0) return;
        let n2 = dB[e];
        if (n2 === void 0 && (n2 = e.toLowerCase(), dB[n2] === void 0 && !hB(n2))) throw new ge("invalid header key");
        if (Array.isArray(r2)) {
          let A2 = [];
          for (let i2 = 0; i2 < r2.length; i2++) if (typeof r2[i2] == "string") {
            if (!EB(r2[i2])) throw new ge(`invalid ${e} header`);
            A2.push(r2[i2]);
          } else if (r2[i2] === null) A2.push("");
          else {
            if (typeof r2[i2] == "object") throw new ge(`invalid ${e} header`);
            A2.push(`${r2[i2]}`);
          }
          r2 = A2;
        } else if (typeof r2 == "string") {
          if (!EB(r2)) throw new ge(`invalid ${e} header`);
        } else r2 === null ? r2 = "" : r2 = `${r2}`;
        if (t2.host === null && n2 === "host") {
          if (typeof r2 != "string") throw new ge("invalid host header");
          t2.host = r2;
        } else if (t2.contentLength === null && n2 === "content-length") {
          if (t2.contentLength = parseInt(r2, 10), !Number.isFinite(t2.contentLength)) throw new ge("invalid content-length header");
        } else if (t2.contentType === null && n2 === "content-type") t2.contentType = r2, t2.headers.push(e, r2);
        else {
          if (n2 === "transfer-encoding" || n2 === "keep-alive" || n2 === "upgrade") throw new ge(`invalid ${n2} header`);
          if (n2 === "connection") {
            let A2 = typeof r2 == "string" ? r2.toLowerCase() : null;
            if (A2 !== "close" && A2 !== "keep-alive") throw new ge("invalid connection header");
            A2 === "close" && (t2.reset = true);
          } else {
            if (n2 === "expect") throw new xM("expect header not supported");
            t2.headers.push(e, r2);
          }
        }
      }
      __name(La, "La");
      fB.exports = Fg;
    });
    var va = C2((NK, IB) => {
      "use strict";
      var { InvalidArgumentError: qM } = H();
      IB.exports = class CB {
        static {
          __name(this, "CB");
        }
        #e;
        constructor(e) {
          this.#e = e;
        }
        static wrap(e) {
          return e.onRequestStart ? e : new CB(e);
        }
        onConnect(e, r2) {
          return this.#e.onConnect?.(e, r2);
        }
        onHeaders(e, r2, n2, A2) {
          return this.#e.onHeaders?.(e, r2, n2, A2);
        }
        onUpgrade(e, r2, n2) {
          return this.#e.onUpgrade?.(e, r2, n2);
        }
        onData(e) {
          return this.#e.onData?.(e);
        }
        onComplete(e) {
          return this.#e.onComplete?.(e);
        }
        onError(e) {
          if (!this.#e.onError) throw e;
          return this.#e.onError?.(e);
        }
        onRequestStart(e, r2) {
          this.#e.onConnect?.((n2) => e.abort(n2), r2);
        }
        onRequestUpgrade(e, r2, n2, A2) {
          let i2 = [];
          for (let [s, o2] of Object.entries(n2)) i2.push(Buffer.from(s), Array.isArray(o2) ? o2.map((a2) => Buffer.from(a2)) : Buffer.from(o2));
          this.#e.onUpgrade?.(r2, i2, A2);
        }
        onResponseStart(e, r2, n2, A2) {
          let i2 = [];
          for (let [s, o2] of Object.entries(n2)) i2.push(Buffer.from(s), Array.isArray(o2) ? o2.map((a2) => Buffer.from(a2)) : Buffer.from(o2));
          this.#e.onHeaders?.(r2, i2, () => e.resume(), A2) === false && e.pause();
        }
        onResponseData(e, r2) {
          this.#e.onData?.(r2) === false && e.pause();
        }
        onResponseEnd(e, r2) {
          let n2 = [];
          for (let [A2, i2] of Object.entries(r2)) n2.push(Buffer.from(A2), Array.isArray(i2) ? i2.map((s) => Buffer.from(s)) : Buffer.from(i2));
          this.#e.onComplete?.(n2);
        }
        onResponseError(e, r2) {
          if (!this.#e.onError) throw new qM("invalid onError method");
          this.#e.onError?.(r2);
        }
      };
    });
    var $i = C2((FK, pB) => {
      "use strict";
      var JM = __require("node:events"), WM = va(), _M = /* @__PURE__ */ __name((t2) => (e, r2) => t2(e, WM.wrap(r2)), "_M"), Tg = class extends JM {
        static {
          __name(this, "Tg");
        }
        dispatch() {
          throw new Error("not implemented");
        }
        close() {
          throw new Error("not implemented");
        }
        destroy() {
          throw new Error("not implemented");
        }
        compose(...e) {
          let r2 = Array.isArray(e[0]) ? e[0] : e, n2 = this.dispatch.bind(this);
          for (let A2 of r2) if (A2 != null) {
            if (typeof A2 != "function") throw new TypeError(`invalid interceptor, expected function received ${typeof A2}`);
            if (n2 = A2(n2), n2 = _M(n2), n2 == null || typeof n2 != "function" || n2.length !== 2) throw new TypeError("invalid interceptor");
          }
          return new Proxy(this, { get: /* @__PURE__ */ __name((A2, i2) => i2 === "dispatch" ? n2 : A2[i2], "get") });
        }
      };
      pB.exports = Tg;
    });
    var yB = C2((TK, mB) => {
      "use strict";
      var { parseHeaders: xg } = Y2(), { InvalidArgumentError: jM } = H(), Ug = Symbol("resume"), kg = class {
        static {
          __name(this, "kg");
        }
        #e = false;
        #t = null;
        #r = false;
        #n;
        [Ug] = null;
        constructor(e) {
          this.#n = e;
        }
        pause() {
          this.#e = true;
        }
        resume() {
          this.#e && (this.#e = false, this[Ug]?.());
        }
        abort(e) {
          this.#r || (this.#r = true, this.#t = e, this.#n(e));
        }
        get aborted() {
          return this.#r;
        }
        get reason() {
          return this.#t;
        }
        get paused() {
          return this.#e;
        }
      };
      mB.exports = class BB {
        static {
          __name(this, "BB");
        }
        #e;
        #t;
        constructor(e) {
          this.#e = e;
        }
        static unwrap(e) {
          return e.onRequestStart ? new BB(e) : e;
        }
        onConnect(e, r2) {
          this.#t = new kg(e), this.#e.onRequestStart?.(this.#t, r2);
        }
        onUpgrade(e, r2, n2) {
          this.#e.onRequestUpgrade?.(this.#t, e, xg(r2), n2);
        }
        onHeaders(e, r2, n2, A2) {
          return this.#t[Ug] = n2, this.#e.onResponseStart?.(this.#t, e, xg(r2), A2), !this.#t.paused;
        }
        onData(e) {
          return this.#e.onResponseData?.(this.#t, e), !this.#t.paused;
        }
        onComplete(e) {
          this.#e.onResponseEnd?.(this.#t, xg(e));
        }
        onError(e) {
          if (!this.#e.onResponseError) throw new jM("invalid onError method");
          this.#e.onResponseError?.(this.#t, e);
        }
      };
    });
    var wA = C2((xK, wB) => {
      "use strict";
      var ZM = $i(), XM = yB(), { ClientDestroyedError: Mg, ClientClosedError: KM, InvalidArgumentError: Pa } = H(), { kDestroy: $M, kClose: zM, kClosed: zi, kDestroyed: mA, kDispatch: eL } = ne(), ur = Symbol("onDestroyed"), yA = Symbol("onClosed"), Lg = class extends ZM {
        static {
          __name(this, "Lg");
        }
        constructor() {
          super(), this[mA] = false, this[ur] = null, this[zi] = false, this[yA] = [];
        }
        get destroyed() {
          return this[mA];
        }
        get closed() {
          return this[zi];
        }
        close(e) {
          if (e === void 0) return new Promise((n2, A2) => {
            this.close((i2, s) => i2 ? A2(i2) : n2(s));
          });
          if (typeof e != "function") throw new Pa("invalid callback");
          if (this[mA]) {
            queueMicrotask(() => e(new Mg(), null));
            return;
          }
          if (this[zi]) {
            this[yA] ? this[yA].push(e) : queueMicrotask(() => e(null, null));
            return;
          }
          this[zi] = true, this[yA].push(e);
          let r2 = /* @__PURE__ */ __name(() => {
            let n2 = this[yA];
            this[yA] = null;
            for (let A2 = 0; A2 < n2.length; A2++) n2[A2](null, null);
          }, "r");
          this[zM]().then(() => this.destroy()).then(() => {
            queueMicrotask(r2);
          });
        }
        destroy(e, r2) {
          if (typeof e == "function" && (r2 = e, e = null), r2 === void 0) return new Promise((A2, i2) => {
            this.destroy(e, (s, o2) => s ? i2(s) : A2(o2));
          });
          if (typeof r2 != "function") throw new Pa("invalid callback");
          if (this[mA]) {
            this[ur] ? this[ur].push(r2) : queueMicrotask(() => r2(null, null));
            return;
          }
          e || (e = new Mg()), this[mA] = true, this[ur] = this[ur] || [], this[ur].push(r2);
          let n2 = /* @__PURE__ */ __name(() => {
            let A2 = this[ur];
            this[ur] = null;
            for (let i2 = 0; i2 < A2.length; i2++) A2[i2](null, null);
          }, "n");
          this[$M](e).then(() => {
            queueMicrotask(n2);
          });
        }
        dispatch(e, r2) {
          if (!r2 || typeof r2 != "object") throw new Pa("handler must be an object");
          r2 = XM.unwrap(r2);
          try {
            if (!e || typeof e != "object") throw new Pa("opts must be an object.");
            if (this[mA] || this[ur]) throw new Mg();
            if (this[zi]) throw new KM();
            return this[eL](e, r2);
          } catch (n2) {
            if (typeof r2.onError != "function") throw n2;
            return r2.onError(n2), false;
          }
        }
      };
      wB.exports = Lg;
    });
    var Hg = C2((UK, bB) => {
      "use strict";
      var DA = 0, vg = 1e3, Pg = (vg >> 1) - 1, gr, Yg = Symbol("kFastTimer"), Er = [], Gg = -2, Og = -1, RB = 0, DB = 1;
      function Vg() {
        DA += Pg;
        let t2 = 0, e = Er.length;
        for (; t2 < e; ) {
          let r2 = Er[t2];
          r2._state === RB ? (r2._idleStart = DA - Pg, r2._state = DB) : r2._state === DB && DA >= r2._idleStart + r2._idleTimeout && (r2._state = Og, r2._idleStart = -1, r2._onTimeout(r2._timerArg)), r2._state === Og ? (r2._state = Gg, --e !== 0 && (Er[t2] = Er[e])) : ++t2;
        }
        Er.length = e, Er.length !== 0 && SB();
      }
      __name(Vg, "Vg");
      function SB() {
        gr ? gr.refresh() : (clearTimeout(gr), gr = setTimeout(Vg, Pg), gr.unref && gr.unref());
      }
      __name(SB, "SB");
      var Ya = class {
        static {
          __name(this, "Ya");
        }
        [Yg] = true;
        _state = Gg;
        _idleTimeout = -1;
        _idleStart = -1;
        _onTimeout;
        _timerArg;
        constructor(e, r2, n2) {
          this._onTimeout = e, this._idleTimeout = r2, this._timerArg = n2, this.refresh();
        }
        refresh() {
          this._state === Gg && Er.push(this), (!gr || Er.length === 1) && SB(), this._state = RB;
        }
        clear() {
          this._state = Og, this._idleStart = -1;
        }
      };
      bB.exports = { setTimeout(t2, e, r2) {
        return e <= vg ? setTimeout(t2, e, r2) : new Ya(t2, e, r2);
      }, clearTimeout(t2) {
        t2[Yg] ? t2.clear() : clearTimeout(t2);
      }, setFastTimeout(t2, e, r2) {
        return new Ya(t2, e, r2);
      }, clearFastTimeout(t2) {
        t2.clear();
      }, now() {
        return DA;
      }, tick(t2 = 0) {
        DA += t2 - vg + 1, Vg(), Vg();
      }, reset() {
        DA = 0, Er.length = 0, clearTimeout(gr), gr = null;
      }, kFastTimer: Yg };
    });
    var es = C2((LK, UB) => {
      "use strict";
      var tL = __require("node:net"), NB = __require("node:assert"), xB = Y2(), { InvalidArgumentError: rL, ConnectTimeoutError: nL } = H(), Ga = Hg();
      function FB() {
      }
      __name(FB, "FB");
      var qg, Jg;
      global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG) ? Jg = class {
        static {
          __name(this, "Jg");
        }
        constructor(e) {
          this._maxCachedSessions = e, this._sessionCache = /* @__PURE__ */ new Map(), this._sessionRegistry = new global.FinalizationRegistry((r2) => {
            if (this._sessionCache.size < this._maxCachedSessions) return;
            let n2 = this._sessionCache.get(r2);
            n2 !== void 0 && n2.deref() === void 0 && this._sessionCache.delete(r2);
          });
        }
        get(e) {
          let r2 = this._sessionCache.get(e);
          return r2 ? r2.deref() : null;
        }
        set(e, r2) {
          this._maxCachedSessions !== 0 && (this._sessionCache.set(e, new WeakRef(r2)), this._sessionRegistry.register(r2, e));
        }
      } : Jg = class {
        static {
          __name(this, "Jg");
        }
        constructor(e) {
          this._maxCachedSessions = e, this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(e) {
          return this._sessionCache.get(e);
        }
        set(e, r2) {
          if (this._maxCachedSessions !== 0) {
            if (this._sessionCache.size >= this._maxCachedSessions) {
              let { value: n2 } = this._sessionCache.keys().next();
              this._sessionCache.delete(n2);
            }
            this._sessionCache.set(e, r2);
          }
        }
      };
      function AL({ allowH2: t2, maxCachedSessions: e, socketPath: r2, timeout: n2, session: A2, ...i2 }) {
        if (e != null && (!Number.isInteger(e) || e < 0)) throw new rL("maxCachedSessions must be a positive integer or zero");
        let s = { path: r2, ...i2 }, o2 = new Jg(e ?? 100);
        return n2 = n2 ?? 1e4, t2 = t2 ?? false, function({ hostname: c2, host: l2, protocol: u2, port: g, servername: E, localAddress: h, httpSocket: f2 }, p2) {
          let Q;
          if (u2 === "https:") {
            qg || (qg = __require("node:tls")), E = E || s.servername || xB.getServerName(l2) || null;
            let B = E || c2;
            NB(B);
            let w = A2 || o2.get(B) || null;
            g = g || 443, Q = qg.connect({ highWaterMark: 16384, ...s, servername: E, session: w, localAddress: h, ALPNProtocols: t2 ? ["http/1.1", "h2"] : ["http/1.1"], socket: f2, port: g, host: c2 }), Q.on("session", function(D2) {
              o2.set(B, D2);
            });
          } else NB(!f2, "httpSocket can only be sent on TLS update"), g = g || 80, Q = tL.connect({ highWaterMark: 64 * 1024, ...s, localAddress: h, port: g, host: c2 });
          if (s.keepAlive == null || s.keepAlive) {
            let B = s.keepAliveInitialDelay === void 0 ? 6e4 : s.keepAliveInitialDelay;
            Q.setKeepAlive(true, B);
          }
          let I2 = iL(new WeakRef(Q), { timeout: n2, hostname: c2, port: g });
          return Q.setNoDelay(true).once(u2 === "https:" ? "secureConnect" : "connect", function() {
            if (queueMicrotask(I2), p2) {
              let B = p2;
              p2 = null, B(null, this);
            }
          }).on("error", function(B) {
            if (queueMicrotask(I2), p2) {
              let w = p2;
              p2 = null, w(B);
            }
          }), Q;
        };
      }
      __name(AL, "AL");
      var iL = process.platform === "win32" ? (t2, e) => {
        if (!e.timeout) return FB;
        let r2 = null, n2 = null, A2 = Ga.setFastTimeout(() => {
          r2 = setImmediate(() => {
            n2 = setImmediate(() => TB(t2.deref(), e));
          });
        }, e.timeout);
        return () => {
          Ga.clearFastTimeout(A2), clearImmediate(r2), clearImmediate(n2);
        };
      } : (t2, e) => {
        if (!e.timeout) return FB;
        let r2 = null, n2 = Ga.setFastTimeout(() => {
          r2 = setImmediate(() => {
            TB(t2.deref(), e);
          });
        }, e.timeout);
        return () => {
          Ga.clearFastTimeout(n2), clearImmediate(r2);
        };
      };
      function TB(t2, e) {
        if (t2 == null) return;
        let r2 = "Connect Timeout Error";
        Array.isArray(t2.autoSelectFamilyAttemptedAddresses) ? r2 += ` (attempted addresses: ${t2.autoSelectFamilyAttemptedAddresses.join(", ")},` : r2 += ` (attempted address: ${e.hostname}:${e.port},`, r2 += ` timeout: ${e.timeout}ms)`, xB.destroy(t2, new nL(r2));
      }
      __name(TB, "TB");
      UB.exports = AL;
    });
    var kB = C2((Oa) => {
      "use strict";
      Object.defineProperty(Oa, "__esModule", { value: true });
      Oa.enumToMap = void 0;
      function sL(t2, e = [], r2 = []) {
        var n2, A2;
        let i2 = ((n2 = e?.length) !== null && n2 !== void 0 ? n2 : 0) === 0, s = ((A2 = r2?.length) !== null && A2 !== void 0 ? A2 : 0) === 0;
        return Object.fromEntries(Object.entries(t2).filter(([, o2]) => typeof o2 == "number" && (i2 || e.includes(o2)) && (s || !r2.includes(o2))));
      }
      __name(sL, "sL");
      Oa.enumToMap = sL;
    });
    var MB = C2((d2) => {
      "use strict";
      Object.defineProperty(d2, "__esModule", { value: true });
      d2.SPECIAL_HEADERS = d2.MINOR = d2.MAJOR = d2.HTAB_SP_VCHAR_OBS_TEXT = d2.QUOTED_STRING = d2.CONNECTION_TOKEN_CHARS = d2.HEADER_CHARS = d2.TOKEN = d2.HEX = d2.URL_CHAR = d2.USERINFO_CHARS = d2.MARK = d2.ALPHANUM = d2.NUM = d2.HEX_MAP = d2.NUM_MAP = d2.ALPHA = d2.STATUSES_HTTP = d2.H_METHOD_MAP = d2.METHOD_MAP = d2.METHODS_RTSP = d2.METHODS_ICE = d2.METHODS_HTTP = d2.HEADER_STATE = d2.FINISH = d2.STATUSES = d2.METHODS = d2.LENIENT_FLAGS = d2.FLAGS = d2.TYPE = d2.ERROR = void 0;
      var oL = kB();
      d2.ERROR = { OK: 0, INTERNAL: 1, STRICT: 2, CR_EXPECTED: 25, LF_EXPECTED: 3, UNEXPECTED_CONTENT_LENGTH: 4, UNEXPECTED_SPACE: 30, CLOSED_CONNECTION: 5, INVALID_METHOD: 6, INVALID_URL: 7, INVALID_CONSTANT: 8, INVALID_VERSION: 9, INVALID_HEADER_TOKEN: 10, INVALID_CONTENT_LENGTH: 11, INVALID_CHUNK_SIZE: 12, INVALID_STATUS: 13, INVALID_EOF_STATE: 14, INVALID_TRANSFER_ENCODING: 15, CB_MESSAGE_BEGIN: 16, CB_HEADERS_COMPLETE: 17, CB_MESSAGE_COMPLETE: 18, CB_CHUNK_HEADER: 19, CB_CHUNK_COMPLETE: 20, PAUSED: 21, PAUSED_UPGRADE: 22, PAUSED_H2_UPGRADE: 23, USER: 24, CB_URL_COMPLETE: 26, CB_STATUS_COMPLETE: 27, CB_METHOD_COMPLETE: 32, CB_VERSION_COMPLETE: 33, CB_HEADER_FIELD_COMPLETE: 28, CB_HEADER_VALUE_COMPLETE: 29, CB_CHUNK_EXTENSION_NAME_COMPLETE: 34, CB_CHUNK_EXTENSION_VALUE_COMPLETE: 35, CB_RESET: 31 };
      d2.TYPE = { BOTH: 0, REQUEST: 1, RESPONSE: 2 };
      d2.FLAGS = { CONNECTION_KEEP_ALIVE: 1, CONNECTION_CLOSE: 2, CONNECTION_UPGRADE: 4, CHUNKED: 8, UPGRADE: 16, CONTENT_LENGTH: 32, SKIPBODY: 64, TRAILING: 128, TRANSFER_ENCODING: 512 };
      d2.LENIENT_FLAGS = { HEADERS: 1, CHUNKED_LENGTH: 2, KEEP_ALIVE: 4, TRANSFER_ENCODING: 8, VERSION: 16, DATA_AFTER_CLOSE: 32, OPTIONAL_LF_AFTER_CR: 64, OPTIONAL_CRLF_AFTER_CHUNK: 128, OPTIONAL_CR_BEFORE_LF: 256, SPACES_AFTER_CHUNK_SIZE: 512 };
      d2.METHODS = { DELETE: 0, GET: 1, HEAD: 2, POST: 3, PUT: 4, CONNECT: 5, OPTIONS: 6, TRACE: 7, COPY: 8, LOCK: 9, MKCOL: 10, MOVE: 11, PROPFIND: 12, PROPPATCH: 13, SEARCH: 14, UNLOCK: 15, BIND: 16, REBIND: 17, UNBIND: 18, ACL: 19, REPORT: 20, MKACTIVITY: 21, CHECKOUT: 22, MERGE: 23, "M-SEARCH": 24, NOTIFY: 25, SUBSCRIBE: 26, UNSUBSCRIBE: 27, PATCH: 28, PURGE: 29, MKCALENDAR: 30, LINK: 31, UNLINK: 32, SOURCE: 33, PRI: 34, DESCRIBE: 35, ANNOUNCE: 36, SETUP: 37, PLAY: 38, PAUSE: 39, TEARDOWN: 40, GET_PARAMETER: 41, SET_PARAMETER: 42, REDIRECT: 43, RECORD: 44, FLUSH: 45, QUERY: 46 };
      d2.STATUSES = { CONTINUE: 100, SWITCHING_PROTOCOLS: 101, PROCESSING: 102, EARLY_HINTS: 103, RESPONSE_IS_STALE: 110, REVALIDATION_FAILED: 111, DISCONNECTED_OPERATION: 112, HEURISTIC_EXPIRATION: 113, MISCELLANEOUS_WARNING: 199, OK: 200, CREATED: 201, ACCEPTED: 202, NON_AUTHORITATIVE_INFORMATION: 203, NO_CONTENT: 204, RESET_CONTENT: 205, PARTIAL_CONTENT: 206, MULTI_STATUS: 207, ALREADY_REPORTED: 208, TRANSFORMATION_APPLIED: 214, IM_USED: 226, MISCELLANEOUS_PERSISTENT_WARNING: 299, MULTIPLE_CHOICES: 300, MOVED_PERMANENTLY: 301, FOUND: 302, SEE_OTHER: 303, NOT_MODIFIED: 304, USE_PROXY: 305, SWITCH_PROXY: 306, TEMPORARY_REDIRECT: 307, PERMANENT_REDIRECT: 308, BAD_REQUEST: 400, UNAUTHORIZED: 401, PAYMENT_REQUIRED: 402, FORBIDDEN: 403, NOT_FOUND: 404, METHOD_NOT_ALLOWED: 405, NOT_ACCEPTABLE: 406, PROXY_AUTHENTICATION_REQUIRED: 407, REQUEST_TIMEOUT: 408, CONFLICT: 409, GONE: 410, LENGTH_REQUIRED: 411, PRECONDITION_FAILED: 412, PAYLOAD_TOO_LARGE: 413, URI_TOO_LONG: 414, UNSUPPORTED_MEDIA_TYPE: 415, RANGE_NOT_SATISFIABLE: 416, EXPECTATION_FAILED: 417, IM_A_TEAPOT: 418, PAGE_EXPIRED: 419, ENHANCE_YOUR_CALM: 420, MISDIRECTED_REQUEST: 421, UNPROCESSABLE_ENTITY: 422, LOCKED: 423, FAILED_DEPENDENCY: 424, TOO_EARLY: 425, UPGRADE_REQUIRED: 426, PRECONDITION_REQUIRED: 428, TOO_MANY_REQUESTS: 429, REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL: 430, REQUEST_HEADER_FIELDS_TOO_LARGE: 431, LOGIN_TIMEOUT: 440, NO_RESPONSE: 444, RETRY_WITH: 449, BLOCKED_BY_PARENTAL_CONTROL: 450, UNAVAILABLE_FOR_LEGAL_REASONS: 451, CLIENT_CLOSED_LOAD_BALANCED_REQUEST: 460, INVALID_X_FORWARDED_FOR: 463, REQUEST_HEADER_TOO_LARGE: 494, SSL_CERTIFICATE_ERROR: 495, SSL_CERTIFICATE_REQUIRED: 496, HTTP_REQUEST_SENT_TO_HTTPS_PORT: 497, INVALID_TOKEN: 498, CLIENT_CLOSED_REQUEST: 499, INTERNAL_SERVER_ERROR: 500, NOT_IMPLEMENTED: 501, BAD_GATEWAY: 502, SERVICE_UNAVAILABLE: 503, GATEWAY_TIMEOUT: 504, HTTP_VERSION_NOT_SUPPORTED: 505, VARIANT_ALSO_NEGOTIATES: 506, INSUFFICIENT_STORAGE: 507, LOOP_DETECTED: 508, BANDWIDTH_LIMIT_EXCEEDED: 509, NOT_EXTENDED: 510, NETWORK_AUTHENTICATION_REQUIRED: 511, WEB_SERVER_UNKNOWN_ERROR: 520, WEB_SERVER_IS_DOWN: 521, CONNECTION_TIMEOUT: 522, ORIGIN_IS_UNREACHABLE: 523, TIMEOUT_OCCURED: 524, SSL_HANDSHAKE_FAILED: 525, INVALID_SSL_CERTIFICATE: 526, RAILGUN_ERROR: 527, SITE_IS_OVERLOADED: 529, SITE_IS_FROZEN: 530, IDENTITY_PROVIDER_AUTHENTICATION_ERROR: 561, NETWORK_READ_TIMEOUT: 598, NETWORK_CONNECT_TIMEOUT: 599 };
      d2.FINISH = { SAFE: 0, SAFE_WITH_CB: 1, UNSAFE: 2 };
      d2.HEADER_STATE = { GENERAL: 0, CONNECTION: 1, CONTENT_LENGTH: 2, TRANSFER_ENCODING: 3, UPGRADE: 4, CONNECTION_KEEP_ALIVE: 5, CONNECTION_CLOSE: 6, CONNECTION_UPGRADE: 7, TRANSFER_ENCODING_CHUNKED: 8 };
      d2.METHODS_HTTP = [d2.METHODS.DELETE, d2.METHODS.GET, d2.METHODS.HEAD, d2.METHODS.POST, d2.METHODS.PUT, d2.METHODS.CONNECT, d2.METHODS.OPTIONS, d2.METHODS.TRACE, d2.METHODS.COPY, d2.METHODS.LOCK, d2.METHODS.MKCOL, d2.METHODS.MOVE, d2.METHODS.PROPFIND, d2.METHODS.PROPPATCH, d2.METHODS.SEARCH, d2.METHODS.UNLOCK, d2.METHODS.BIND, d2.METHODS.REBIND, d2.METHODS.UNBIND, d2.METHODS.ACL, d2.METHODS.REPORT, d2.METHODS.MKACTIVITY, d2.METHODS.CHECKOUT, d2.METHODS.MERGE, d2.METHODS["M-SEARCH"], d2.METHODS.NOTIFY, d2.METHODS.SUBSCRIBE, d2.METHODS.UNSUBSCRIBE, d2.METHODS.PATCH, d2.METHODS.PURGE, d2.METHODS.MKCALENDAR, d2.METHODS.LINK, d2.METHODS.UNLINK, d2.METHODS.PRI, d2.METHODS.SOURCE, d2.METHODS.QUERY];
      d2.METHODS_ICE = [d2.METHODS.SOURCE];
      d2.METHODS_RTSP = [d2.METHODS.OPTIONS, d2.METHODS.DESCRIBE, d2.METHODS.ANNOUNCE, d2.METHODS.SETUP, d2.METHODS.PLAY, d2.METHODS.PAUSE, d2.METHODS.TEARDOWN, d2.METHODS.GET_PARAMETER, d2.METHODS.SET_PARAMETER, d2.METHODS.REDIRECT, d2.METHODS.RECORD, d2.METHODS.FLUSH, d2.METHODS.GET, d2.METHODS.POST];
      d2.METHOD_MAP = (0, oL.enumToMap)(d2.METHODS);
      d2.H_METHOD_MAP = Object.fromEntries(Object.entries(d2.METHODS).filter(([t2]) => t2.startsWith("H")));
      d2.STATUSES_HTTP = [d2.STATUSES.CONTINUE, d2.STATUSES.SWITCHING_PROTOCOLS, d2.STATUSES.PROCESSING, d2.STATUSES.EARLY_HINTS, d2.STATUSES.RESPONSE_IS_STALE, d2.STATUSES.REVALIDATION_FAILED, d2.STATUSES.DISCONNECTED_OPERATION, d2.STATUSES.HEURISTIC_EXPIRATION, d2.STATUSES.MISCELLANEOUS_WARNING, d2.STATUSES.OK, d2.STATUSES.CREATED, d2.STATUSES.ACCEPTED, d2.STATUSES.NON_AUTHORITATIVE_INFORMATION, d2.STATUSES.NO_CONTENT, d2.STATUSES.RESET_CONTENT, d2.STATUSES.PARTIAL_CONTENT, d2.STATUSES.MULTI_STATUS, d2.STATUSES.ALREADY_REPORTED, d2.STATUSES.TRANSFORMATION_APPLIED, d2.STATUSES.IM_USED, d2.STATUSES.MISCELLANEOUS_PERSISTENT_WARNING, d2.STATUSES.MULTIPLE_CHOICES, d2.STATUSES.MOVED_PERMANENTLY, d2.STATUSES.FOUND, d2.STATUSES.SEE_OTHER, d2.STATUSES.NOT_MODIFIED, d2.STATUSES.USE_PROXY, d2.STATUSES.SWITCH_PROXY, d2.STATUSES.TEMPORARY_REDIRECT, d2.STATUSES.PERMANENT_REDIRECT, d2.STATUSES.BAD_REQUEST, d2.STATUSES.UNAUTHORIZED, d2.STATUSES.PAYMENT_REQUIRED, d2.STATUSES.FORBIDDEN, d2.STATUSES.NOT_FOUND, d2.STATUSES.METHOD_NOT_ALLOWED, d2.STATUSES.NOT_ACCEPTABLE, d2.STATUSES.PROXY_AUTHENTICATION_REQUIRED, d2.STATUSES.REQUEST_TIMEOUT, d2.STATUSES.CONFLICT, d2.STATUSES.GONE, d2.STATUSES.LENGTH_REQUIRED, d2.STATUSES.PRECONDITION_FAILED, d2.STATUSES.PAYLOAD_TOO_LARGE, d2.STATUSES.URI_TOO_LONG, d2.STATUSES.UNSUPPORTED_MEDIA_TYPE, d2.STATUSES.RANGE_NOT_SATISFIABLE, d2.STATUSES.EXPECTATION_FAILED, d2.STATUSES.IM_A_TEAPOT, d2.STATUSES.PAGE_EXPIRED, d2.STATUSES.ENHANCE_YOUR_CALM, d2.STATUSES.MISDIRECTED_REQUEST, d2.STATUSES.UNPROCESSABLE_ENTITY, d2.STATUSES.LOCKED, d2.STATUSES.FAILED_DEPENDENCY, d2.STATUSES.TOO_EARLY, d2.STATUSES.UPGRADE_REQUIRED, d2.STATUSES.PRECONDITION_REQUIRED, d2.STATUSES.TOO_MANY_REQUESTS, d2.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL, d2.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE, d2.STATUSES.LOGIN_TIMEOUT, d2.STATUSES.NO_RESPONSE, d2.STATUSES.RETRY_WITH, d2.STATUSES.BLOCKED_BY_PARENTAL_CONTROL, d2.STATUSES.UNAVAILABLE_FOR_LEGAL_REASONS, d2.STATUSES.CLIENT_CLOSED_LOAD_BALANCED_REQUEST, d2.STATUSES.INVALID_X_FORWARDED_FOR, d2.STATUSES.REQUEST_HEADER_TOO_LARGE, d2.STATUSES.SSL_CERTIFICATE_ERROR, d2.STATUSES.SSL_CERTIFICATE_REQUIRED, d2.STATUSES.HTTP_REQUEST_SENT_TO_HTTPS_PORT, d2.STATUSES.INVALID_TOKEN, d2.STATUSES.CLIENT_CLOSED_REQUEST, d2.STATUSES.INTERNAL_SERVER_ERROR, d2.STATUSES.NOT_IMPLEMENTED, d2.STATUSES.BAD_GATEWAY, d2.STATUSES.SERVICE_UNAVAILABLE, d2.STATUSES.GATEWAY_TIMEOUT, d2.STATUSES.HTTP_VERSION_NOT_SUPPORTED, d2.STATUSES.VARIANT_ALSO_NEGOTIATES, d2.STATUSES.INSUFFICIENT_STORAGE, d2.STATUSES.LOOP_DETECTED, d2.STATUSES.BANDWIDTH_LIMIT_EXCEEDED, d2.STATUSES.NOT_EXTENDED, d2.STATUSES.NETWORK_AUTHENTICATION_REQUIRED, d2.STATUSES.WEB_SERVER_UNKNOWN_ERROR, d2.STATUSES.WEB_SERVER_IS_DOWN, d2.STATUSES.CONNECTION_TIMEOUT, d2.STATUSES.ORIGIN_IS_UNREACHABLE, d2.STATUSES.TIMEOUT_OCCURED, d2.STATUSES.SSL_HANDSHAKE_FAILED, d2.STATUSES.INVALID_SSL_CERTIFICATE, d2.STATUSES.RAILGUN_ERROR, d2.STATUSES.SITE_IS_OVERLOADED, d2.STATUSES.SITE_IS_FROZEN, d2.STATUSES.IDENTITY_PROVIDER_AUTHENTICATION_ERROR, d2.STATUSES.NETWORK_READ_TIMEOUT, d2.STATUSES.NETWORK_CONNECT_TIMEOUT];
      d2.ALPHA = [];
      for (let t2 = 65; t2 <= 90; t2++) d2.ALPHA.push(String.fromCharCode(t2)), d2.ALPHA.push(String.fromCharCode(t2 + 32));
      d2.NUM_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9 };
      d2.HEX_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
      d2.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
      d2.ALPHANUM = d2.ALPHA.concat(d2.NUM);
      d2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
      d2.USERINFO_CHARS = d2.ALPHANUM.concat(d2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
      d2.URL_CHAR = ["!", '"', "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~"].concat(d2.ALPHANUM);
      d2.HEX = d2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
      d2.TOKEN = ["!", "#", "$", "%", "&", "'", "*", "+", "-", ".", "^", "_", "`", "|", "~"].concat(d2.ALPHANUM);
      d2.HEADER_CHARS = ["	"];
      for (let t2 = 32; t2 <= 255; t2++) t2 !== 127 && d2.HEADER_CHARS.push(t2);
      d2.CONNECTION_TOKEN_CHARS = d2.HEADER_CHARS.filter((t2) => t2 !== 44);
      d2.QUOTED_STRING = ["	", " "];
      for (let t2 = 33; t2 <= 255; t2++) t2 !== 34 && t2 !== 92 && d2.QUOTED_STRING.push(t2);
      d2.HTAB_SP_VCHAR_OBS_TEXT = ["	", " "];
      for (let t2 = 33; t2 <= 126; t2++) d2.HTAB_SP_VCHAR_OBS_TEXT.push(t2);
      for (let t2 = 128; t2 <= 255; t2++) d2.HTAB_SP_VCHAR_OBS_TEXT.push(t2);
      d2.MAJOR = d2.NUM_MAP;
      d2.MINOR = d2.MAJOR;
      d2.SPECIAL_HEADERS = { connection: d2.HEADER_STATE.CONNECTION, "content-length": d2.HEADER_STATE.CONTENT_LENGTH, "proxy-connection": d2.HEADER_STATE.CONNECTION, "transfer-encoding": d2.HEADER_STATE.TRANSFER_ENCODING, upgrade: d2.HEADER_STATE.UPGRADE };
    });
    var _g = C2((YK, LB) => {
      "use strict";
      var { Buffer: aL } = __require("node:buffer"), cL = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAhIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAiHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACMkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACQabGxodHRwX3NldF9sZW5pZW50X3ZlcnNpb24AJSNsbGh0dHBfc2V0X2xlbmllbnRfZGF0YV9hZnRlcl9jbG9zZQAmJ2xsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9sZl9hZnRlcl9jcgAnLGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcmxmX2FmdGVyX2NodW5rACgobGxodHRwX3NldF9sZW5pZW50X29wdGlvbmFsX2NyX2JlZm9yZV9sZgApKmxsaHR0cF9zZXRfbGVuaWVudF9zcGFjZXNfYWZ0ZXJfY2h1bmtfc2l6ZQAqGGxsaHR0cF9tZXNzYWdlX25lZWRzX2VvZgA1CRcBAEEBCxEBAgMEBQoGBzEzMi0uLCsvMAq8ywIzFgBB/NMAKAIABEAAC0H80wBBATYCAAsUACAAEDcgACACNgI4IAAgAToAKAsUACAAIAAvATQgAC0AMCAAEDYQAAseAQF/QcAAEDkiARA3IAFBgAg2AjggASAAOgAoIAELjwwBB38CQCAARQ0AIABBCGsiASAAQQRrKAIAIgBBeHEiBGohBQJAIABBAXENACAAQQNxRQ0BIAEgASgCACIAayIBQZDUACgCAEkNASAAIARqIQQCQAJAQZTUACgCACABRwRAIABB/wFNBEAgAEEDdiEDIAEoAggiACABKAIMIgJGBEBBgNQAQYDUACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAEoAhghBiABIAEoAgwiAEcEQCAAIAEoAggiAjYCCCACIAA2AgwMAwsgAUEUaiIDKAIAIgJFBEAgASgCECICRQ0CIAFBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUoAgQiAEEDcUEDRw0CIAUgAEF+cTYCBEGI1AAgBDYCACAFIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAEoAhwiAkECdEGw1gBqIgMoAgAgAUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECABRhtqIAA2AgAgAEUNAQsgACAGNgIYIAEoAhAiAgRAIAAgAjYCECACIAA2AhgLIAFBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAVPDQAgBSgCBCIAQQFxRQ0AAkACQAJAAkAgAEECcUUEQEGY1AAoAgAgBUYEQEGY1AAgATYCAEGM1ABBjNQAKAIAIARqIgA2AgAgASAAQQFyNgIEIAFBlNQAKAIARw0GQYjUAEEANgIAQZTUAEEANgIADAYLQZTUACgCACAFRgRAQZTUACABNgIAQYjUAEGI1AAoAgAgBGoiADYCACABIABBAXI2AgQgACABaiAANgIADAYLIABBeHEgBGohBCAAQf8BTQRAIABBA3YhAyAFKAIIIgAgBSgCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyAFKAIYIQYgBSAFKAIMIgBHBEBBkNQAKAIAGiAAIAUoAggiAjYCCCACIAA2AgwMAwsgBUEUaiIDKAIAIgJFBEAgBSgCECICRQ0CIAVBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUgAEF+cTYCBCABIARqIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAUoAhwiAkECdEGw1gBqIgMoAgAgBUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAA2AgAgAEUNAQsgACAGNgIYIAUoAhAiAgRAIAAgAjYCECACIAA2AhgLIAVBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIARqIAQ2AgAgASAEQQFyNgIEIAFBlNQAKAIARw0AQYjUACAENgIADAELIARB/wFNBEAgBEF4cUGo1ABqIQACf0GA1AAoAgAiAkEBIARBA3Z0IgNxRQRAQYDUACACIANyNgIAIAAMAQsgACgCCAsiAiABNgIMIAAgATYCCCABIAA2AgwgASACNgIIDAELQR8hAiAEQf///wdNBEAgBEEmIARBCHZnIgBrdkEBcSAAQQF0a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygCHCICQQFrDuwB7gEB6AECAwQFBgcICQoLDA0ODxAREucBE+YBFBXlARYX5AEYGRobHB0eHyDvAe0BIeMBIiMkJSYnKCkqK+IBLC0uLzAxMuEB4AEzNN8B3gE1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk/pAVBRUlPdAdwBVNsBVdoBVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHZAdgBxgHXAccB1gHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAQDqAQtBAAzUAQtBDgzTAQtBDQzSAQtBDwzRAQtBEAzQAQtBEQzPAQtBEgzOAQtBEwzNAQtBFAzMAQtBFQzLAQtBFgzKAQtBFwzJAQtBGAzIAQtBGQzHAQtBGgzGAQtBGwzFAQtBHAzEAQtBHQzDAQtBHgzCAQtBHwzBAQtBCAzAAQtBIAy/AQtBIgy+AQtBIQy9AQtBBwy8AQtBIwy7AQtBJAy6AQtBJQy5AQtBJgy4AQtBJwy3AQtBzgEMtgELQSgMtQELQSkMtAELQSoMswELQSsMsgELQc8BDLEBC0EtDLABC0EuDK8BC0EvDK4BC0EwDK0BC0ExDKwBC0EyDKsBC0EzDKoBC0HQAQypAQtBNAyoAQtBOAynAQtBDAymAQtBNQylAQtBNgykAQtBNwyjAQtBPQyiAQtBOQyhAQtB0QEMoAELQQsMnwELQT4MngELQToMnQELQQoMnAELQTsMmwELQTwMmgELQdIBDJkBC0HAAAyYAQtBPwyXAQtBwQAMlgELQQkMlQELQSwMlAELQcIADJMBC0HDAAySAQtBxAAMkQELQcUADJABC0HGAAyPAQtBxwAMjgELQcgADI0BC0HJAAyMAQtBygAMiwELQcsADIoBC0HMAAyJAQtBzQAMiAELQc4ADIcBC0HPAAyGAQtB0AAMhQELQdEADIQBC0HSAAyDAQtB1AAMggELQdMADIEBC0HVAAyAAQtB1gAMfwtB1wAMfgtB2AAMfQtB2QAMfAtB2gAMewtB2wAMegtB0wEMeQtB3AAMeAtB3QAMdwtBBgx2C0HeAAx1C0EFDHQLQd8ADHMLQQQMcgtB4AAMcQtB4QAMcAtB4gAMbwtB4wAMbgtBAwxtC0HkAAxsC0HlAAxrC0HmAAxqC0HoAAxpC0HnAAxoC0HpAAxnC0HqAAxmC0HrAAxlC0HsAAxkC0ECDGMLQe0ADGILQe4ADGELQe8ADGALQfAADF8LQfEADF4LQfIADF0LQfMADFwLQfQADFsLQfUADFoLQfYADFkLQfcADFgLQfgADFcLQfkADFYLQfoADFULQfsADFQLQfwADFMLQf0ADFILQf4ADFELQf8ADFALQYABDE8LQYEBDE4LQYIBDE0LQYMBDEwLQYQBDEsLQYUBDEoLQYYBDEkLQYcBDEgLQYgBDEcLQYkBDEYLQYoBDEULQYsBDEQLQYwBDEMLQY0BDEILQY4BDEELQY8BDEALQZABDD8LQZEBDD4LQZIBDD0LQZMBDDwLQZQBDDsLQZUBDDoLQZYBDDkLQZcBDDgLQZgBDDcLQZkBDDYLQZoBDDULQZsBDDQLQZwBDDMLQZ0BDDILQZ4BDDELQZ8BDDALQaABDC8LQaEBDC4LQaIBDC0LQaMBDCwLQaQBDCsLQaUBDCoLQaYBDCkLQacBDCgLQagBDCcLQakBDCYLQaoBDCULQasBDCQLQawBDCMLQa0BDCILQa4BDCELQa8BDCALQbABDB8LQbEBDB4LQbIBDB0LQbMBDBwLQbQBDBsLQbUBDBoLQbYBDBkLQbcBDBgLQbgBDBcLQQEMFgtBuQEMFQtBugEMFAtBuwEMEwtBvAEMEgtBvQEMEQtBvgEMEAtBvwEMDwtBwAEMDgtBwQEMDQtBwgEMDAtBwwEMCwtBxAEMCgtBxQEMCQtBxgEMCAtB1AEMBwtBxwEMBgtByAEMBQtByQEMBAtBygEMAwtBywEMAgtBzQEMAQtBzAELIQIDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHXAdYB1QHUAdIB0QHQAc8BzgHNAcwBywHKAckByAHHAcYBxQHEAcMBwgHBAcABvwG+Ab0BvAG7AboBuQG4AbcBtgG1AbQBswGyAbEBsAGvAa4BrQGsAasBqgGpAagBpwGmAaUBpAGjAaIBoQGgAZ8BngGdAZwBmwGaAZcBlgGRAZABjwGOAY0BjAGLAYoBiQGIAYUBhAGDAX59fHt6d3Z1LFFSU1RVVgsgASAERw1zQewBIQIMqQMLIAEgBEcNkAFB0QEhAgyoAwsgASAERw3pAUGEASECDKcDCyABIARHDfQBQfoAIQIMpgMLIAEgBEcNggJB9QAhAgylAwsgASAERw2JAkHzACECDKQDCyABIARHDYwCQfEAIQIMowMLIAEgBEcNHkEeIQIMogMLIAEgBEcNGUEYIQIMoQMLIAEgBEcNuAJBzQAhAgygAwsgASAERw3DAkHGACECDJ8DCyABIARHDcQCQcMAIQIMngMLIAEgBEcNygJBOCECDJ0DCyADLQAwQQFGDZUDDPICC0EAIQACQAJAAkAgAy0AKkUNACADLQArRQ0AIAMvATIiAkECcUUNAQwCCyADLwEyIgJBAXFFDQELQQEhACADLQAoQQFGDQAgAy8BNCIGQeQAa0HkAEkNACAGQcwBRg0AIAZBsAJGDQAgAkHAAHENAEEAIQAgAkGIBHFBgARGDQAgAkEocUEARyEACyADQQA7ATIgA0EAOgAxAkAgAEUEQCADQQA6ADEgAy0ALkEEcQ0BDJwDCyADQgA3AyALIANBADoAMSADQQE6ADYMSQtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAEUNSSAAQRVHDWMgA0EENgIcIAMgATYCFCADQb0aNgIQIANBFTYCDEEAIQIMmgMLIAEgBEYEQEEGIQIMmgMLIAEtAABBCkYNGQwBCyABIARGBEBBByECDJkDCwJAIAEtAABBCmsOBAIBAQABCyABQQFqIQFBECECDP4CCyADLQAuQYABcQ0YQQAhAiADQQA2AhwgAyABNgIUIANBqR82AhAgA0ECNgIMDJcDCyABQQFqIQEgA0Evai0AAEEBcQ0XQQAhAiADQQA2AhwgAyABNgIUIANBhB82AhAgA0EZNgIMDJYDCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMWg0ZQQghAgyVAwsgASAERwRAIANBCTYCCCADIAE2AgRBEiECDPsCC0EJIQIMlAMLIAMpAyBQDZwCDEQLIAEgBEYEQEELIQIMkwMLIAEtAABBCkcNFyABQQFqIQEMGAsgA0Evai0AAEEBcUUNGgwnC0EAIQACQCADKAI4IgJFDQAgAigCSCICRQ0AIAMgAhEAACEACyAADRoMQwtBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0bDCULQQAhAAJAIAMoAjgiAkUNACACKAJIIgJFDQAgAyACEQAAIQALIAANHAwzCyADQS9qLQAAQQFxRQ0dDCMLQQAhAAJAIAMoAjgiAkUNACACKAJMIgJFDQAgAyACEQAAIQALIAANHQxDC0EAIQACQCADKAI4IgJFDQAgAigCTCICRQ0AIAMgAhEAACEACyAADR4MIQsgASAERgRAQRMhAgyLAwsCQCABLQAAIgBBCmsOBCAkJAAjCyABQQFqIQEMIAtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0jDEMLIAEgBEYEQEEWIQIMiQMLIAEtAABB8D9qLQAAQQFHDSQM7QILAkADQCABLQAAQeA5ai0AACIAQQFHBEACQCAAQQJrDgIDACgLIAFBAWohAUEfIQIM8AILIAQgAUEBaiIBRw0AC0EYIQIMiAMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABQQFqIgEQMyIADSIMQgtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0kDCsLIAEgBEYEQEEcIQIMhgMLIANBCjYCCCADIAE2AgRBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0mQSIhAgzrAgsgASAERwRAA0AgAS0AAEHgO2otAAAiAEEDRwRAIABBAWsOBRkbJ+wCJicLIAQgAUEBaiIBRw0AC0EbIQIMhQMLQRshAgyEAwsDQCABLQAAQeA9ai0AACIAQQNHBEAgAEEBaw4FEBIoFCcoCyAEIAFBAWoiAUcNAAtBHiECDIMDCyABIARHBEAgA0ELNgIIIAMgATYCBEEHIQIM6QILQR8hAgyCAwsgASAERgRAQSAhAgyCAwsCQCABLQAAQQ1rDhQvQEBAQEBAQEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDBsLIANBHDYCHCADIAA2AgwgAyABQQFqNgIUDN0CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDNICCyADQR02AhwgAyAANgIMIAMgAUEBajYCFAzcAgsgAEE7Rw0BIAFBAWohAQtBJCECDMACC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAzZAgsgASAERwRAA0AgAS0AAEEgRw3xASAEIAFBAWoiAUcNAAtBLCECDNkCC0EsIQIM2AILIAEgBEYEQEE0IQIM2AILAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0E0IQIM2QILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQ2MAiADQTI2AhwgAyABNgIUIAMgADYCDEEAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQRAIAFBAWohAQyMAgsgA0EyNgIcIAMgADYCDCADIAFBAWo2AhRBACECDNcCCyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE5IQIMwAILIAMpAyAiC0KZs+bMmbPmzBlWDQEgAyALQgp+Igo3AyAgCiAArUL/AYMiC0J/hVYNASADIAogC3w3AyAgBCABQQFqIgFHDQALQcAAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAFBAWoiARAwIgANFwzJAgtBwAAhAgzWAgsgASAERgRAQckAIQIM1gILAkADQAJAIAEtAABBCWsOGAACjwKPApMCjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CAI8CCyAEIAFBAWoiAUcNAAtByQAhAgzWAgsgAUEBaiEBIANBL2otAABBAXENjwIgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIM1QILIAEgBEcEQANAIAEtAAAiAEEgRwRAAkACQAJAIABByABrDgsAAc0BzQHNAc0BzQHNAc0BzQECzQELIAFBAWohAUHZACECDL8CCyABQQFqIQFB2gAhAgy+AgsgAUEBaiEBQdsAIQIMvQILIAQgAUEBaiIBRw0AC0HuACECDNUCC0HuACECDNQCCyADQQI6ACgMMAtBACECIANBADYCHCADQbcLNgIQIANBAjYCDCADIAFBAWo2AhQM0gILQQAhAgy3AgtBDSECDLYCC0ERIQIMtQILQRMhAgy0AgtBFCECDLMCC0EWIQIMsgILQRchAgyxAgtBGCECDLACC0EZIQIMrwILQRohAgyuAgtBGyECDK0CC0EcIQIMrAILQR0hAgyrAgtBHiECDKoCC0EgIQIMqQILQSEhAgyoAgtBIyECDKcCC0EnIQIMpgILIANBPTYCHCADIAE2AhQgAyAANgIMQQAhAgy/AgsgA0EbNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMvgILIANBIDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDL0CCyADQRM2AhwgAyABNgIUIANBnhk2AhAgA0EVNgIMQQAhAgy8AgsgA0ELNgIcIAMgATYCFCADQZ4ZNgIQIANBFTYCDEEAIQIMuwILIANBEDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDLoCCyADQSA2AhwgAyABNgIUIANBjxs2AhAgA0EVNgIMQQAhAgy5AgsgA0ELNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMuAILIANBDDYCHCADIAE2AhQgA0GPGzYCECADQRU2AgxBACECDLcCC0EAIQIgA0EANgIcIAMgATYCFCADQa8ONgIQIANBEjYCDAy2AgsCQANAAkAgAS0AAEEKaw4EAAICAAILIAQgAUEBaiIBRw0AC0HsASECDLYCCwJAAkAgAy0ANkEBRw0AQQAhAAJAIAMoAjgiAkUNACACKAJYIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB6wE2AhwgAyABNgIUIANB4hg2AhAgA0EVNgIMQQAhAgy3AgtBzAEhAgycAgsgA0EANgIcIAMgATYCFCADQfELNgIQIANBHzYCDEEAIQIMtQILAkACQCADLQAoQQFrDgIEAQALQcsBIQIMmwILQcQBIQIMmgILIANBAjoAMUEAIQACQCADKAI4IgJFDQAgAigCACICRQ0AIAMgAhEAACEACyAARQRAQc0BIQIMmgILIABBFUcEQCADQQA2AhwgAyABNgIUIANBrAw2AhAgA0EQNgIMQQAhAgy0AgsgA0HqATYCHCADIAE2AhQgA0GHGTYCECADQRU2AgxBACECDLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIMnQILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDAyeAgsgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDEEAIQIMnQILQbwBIQIMggILIAEgBEYEQEHVASECDJwCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgwMnQILIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgxBACECDJwCC0G7ASECDIECCyABIARGBEBB1AEhAgybAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMDJwCCyADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMQQAhAgybAgtBugEhAgyAAgsgASAERgRAQdMBIQIMmgILAkACQAJAAkAgAS0AAEEKaw4XAgMDAAMDAwMDAwMDAwMDAwMDAwMDAwEDCyABQQFqDAULIAFBAWohAUG5ASECDIECCyABQQFqIQEgA0Evai0AAEEBcQ0IIANBADYCHCADIAE2AhQgA0GFCzYCECADQQ02AgxBACECDJoCCyADQQA2AhwgAyABNgIUIANBhQs2AhAgA0ENNgIMQQAhAgyZAgsgASAERwRAIANBDjYCCCADIAE2AgRBASECDP8BC0HSASECDJgCCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtB0QEhAgyZAgsgAygCBCEAIANBADYCBCADIAAgARAsIgBFBEAgAUEBaiEBDAQLIANB0AE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMmAILIAMoAgQhACADQQA2AgQgAyAAIAEQLCIADQEgAUEBagshAUG3ASECDPwBCyADQc8BNgIcIAMgADYCDCADIAFBAWo2AhRBACECDJUCC0G4ASECDPoBCyADQS9qLQAAQQFxDQEgA0EANgIcIAMgATYCFCADQc8bNgIQIANBGTYCDEEAIQIMkwILIAEgBEYEQEHPASECDJMCCwJAAkACQCABLQAAQQprDgQBAgIAAgsgAUEBaiEBDAILIAFBAWohAQwBCyADLQAuQcAAcUUNAQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsgAEUNlgEgAEEVRgRAIANB2QA2AhwgAyABNgIUIANBvRk2AhAgA0EVNgIMQQAhAgySAgsgA0EANgIcIAMgATYCFCADQfgMNgIQIANBGzYCDEEAIQIMkQILIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDJACCyABIARHBEAgA0EMNgIIIAMgATYCBEG1ASECDPYBC0HOASECDI8CCyABIARGBEBBzQEhAgyPAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBwQBrDhUAAQIDWgQFBlpaWgcICQoLDA0ODxBaCyABQQFqIQFB8QAhAgyEAgsgAUEBaiEBQfIAIQIMgwILIAFBAWohAUH3ACECDIICCyABQQFqIQFB+wAhAgyBAgsgAUEBaiEBQfwAIQIMgAILIAFBAWohAUH/ACECDP8BCyABQQFqIQFBgAEhAgz+AQsgAUEBaiEBQYMBIQIM/QELIAFBAWohAUGMASECDPwBCyABQQFqIQFBjQEhAgz7AQsgAUEBaiEBQY4BIQIM+gELIAFBAWohAUGbASECDPkBCyABQQFqIQFBnAEhAgz4AQsgAUEBaiEBQaIBIQIM9wELIAFBAWohAUGqASECDPYBCyABQQFqIQFBrQEhAgz1AQsgAUEBaiEBQbQBIQIM9AELIAEgBEYEQEHMASECDI4CCyABLQAAQc4ARw1IIAFBAWohAUGzASECDPMBCyABIARGBEBBywEhAgyNAgsCQAJAAkAgAS0AAEHCAGsOEgBKSkpKSkpKSkoBSkpKSkpKAkoLIAFBAWohAUGuASECDPQBCyABQQFqIQFBsQEhAgzzAQsgAUEBaiEBQbIBIQIM8gELQcoBIQIgASAERg2LAiADKAIAIgAgBCABa2ohBSABIABrQQdqIQYCQANAIAEtAAAgAEHo0wBqLQAARw1FIABBB0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyMAgsgA0EANgIAIAZBAWohAUEbDEULIAEgBEYEQEHJASECDIsCCwJAAkAgAS0AAEHJAGsOBwBHR0dHRwFHCyABQQFqIQFBrwEhAgzxAQsgAUEBaiEBQbABIQIM8AELQcgBIQIgASAERg2JAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHm0wBqLQAARw1DIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyKAgsgA0EANgIAIAZBAWohAUEPDEMLQccBIQIgASAERg2IAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHk0wBqLQAARw1CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyJAgsgA0EANgIAIAZBAWohAUEgDEILQcYBIQIgASAERg2HAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw1BIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyIAgsgA0EANgIAIAZBAWohAUESDEELIAEgBEYEQEHFASECDIcCCwJAAkAgAS0AAEHFAGsODgBDQ0NDQ0NDQ0NDQ0MBQwsgAUEBaiEBQasBIQIM7QELIAFBAWohAUGsASECDOwBC0HEASECIAEgBEYNhQIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB3tMAai0AAEcNPyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhgILIANBADYCACAGQQFqIQFBBww/C0HDASECIAEgBEYNhAIgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABB2NMAai0AAEcNPiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhQILIANBADYCACAGQQFqIQFBKAw+CyABIARGBEBBwgEhAgyEAgsCQAJAAkAgAS0AAEHFAGsOEQBBQUFBQUFBQUEBQUFBQUECQQsgAUEBaiEBQacBIQIM6wELIAFBAWohAUGoASECDOoBCyABQQFqIQFBqQEhAgzpAQtBwQEhAiABIARGDYICIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQdHTAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIMCCyADQQA2AgAgBkEBaiEBQRoMPAtBwAEhAiABIARGDYECIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQc3TAGotAABHDTsgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIICCyADQQA2AgAgBkEBaiEBQSEMOwsgASAERgRAQb8BIQIMgQILAkACQCABLQAAQcEAaw4UAD09PT09PT09PT09PT09PT09PQE9CyABQQFqIQFBowEhAgznAQsgAUEBaiEBQaYBIQIM5gELIAEgBEYEQEG+ASECDIACCwJAAkAgAS0AAEHVAGsOCwA8PDw8PDw8PDwBPAsgAUEBaiEBQaQBIQIM5gELIAFBAWohAUGlASECDOUBC0G9ASECIAEgBEYN/gEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNOCAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/wELIANBADYCACAGQQFqIQFBKgw4CyABIARGBEBBvAEhAgz+AQsgAS0AAEHQAEcNOCABQQFqIQFBJQw3C0G7ASECIAEgBEYN/AEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBwdMAai0AAEcNNiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/QELIANBADYCACAGQQFqIQFBDgw2CyABIARGBEBBugEhAgz8AQsgAS0AAEHFAEcNNiABQQFqIQFBoQEhAgzhAQsgASAERgRAQbkBIQIM+wELAkACQAJAAkAgAS0AAEHCAGsODwABAjk5OTk5OTk5OTk5AzkLIAFBAWohAUGdASECDOMBCyABQQFqIQFBngEhAgziAQsgAUEBaiEBQZ8BIQIM4QELIAFBAWohAUGgASECDOABC0G4ASECIAEgBEYN+QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBvtMAai0AAEcNMyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+gELIANBADYCACAGQQFqIQFBFAwzC0G3ASECIAEgBEYN+AEgAygCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBudMAai0AAEcNMiAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+QELIANBADYCACAGQQFqIQFBKwwyC0G2ASECIAEgBEYN9wEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBttMAai0AAEcNMSAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+AELIANBADYCACAGQQFqIQFBLAwxC0G1ASECIAEgBEYN9gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB4dMAai0AAEcNMCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9wELIANBADYCACAGQQFqIQFBEQwwC0G0ASECIAEgBEYN9QEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBstMAai0AAEcNLyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9gELIANBADYCACAGQQFqIQFBLgwvCyABIARGBEBBswEhAgz1AQsCQAJAAkACQAJAIAEtAABBwQBrDhUANDQ0NDQ0NDQ0NAE0NAI0NAM0NAQ0CyABQQFqIQFBkQEhAgzeAQsgAUEBaiEBQZIBIQIM3QELIAFBAWohAUGTASECDNwBCyABQQFqIQFBmAEhAgzbAQsgAUEBaiEBQZoBIQIM2gELIAEgBEYEQEGyASECDPQBCwJAAkAgAS0AAEHSAGsOAwAwATALIAFBAWohAUGZASECDNoBCyABQQFqIQFBBAwtC0GxASECIAEgBEYN8gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBsNMAai0AAEcNLCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM8wELIANBADYCACAGQQFqIQFBHQwsCyABIARGBEBBsAEhAgzyAQsCQAJAIAEtAABByQBrDgcBLi4uLi4ALgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMDAAELIAFBAWohAUErIQIMYQsgAEE6Rw0BIANBADYCHCADIAE2AhQgA0G5ETYCECADQQo2AgxBACECDHoLIAFBAWohASADQS9qLQAAQQFxRQ1tIAMtADJBgAFxRQRAIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsCQAJAIAAOFkpJSAEBAQEBAQEBAQEBAQEBAQEBAQABCyADQSk2AhwgAyABNgIUIANBshg2AhAgA0EVNgIMQQAhAgx7CyADQQA2AhwgAyABNgIUIANB3Qs2AhAgA0ERNgIMQQAhAgx6C0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAARQ1VIABBFUcNASADQQU2AhwgAyABNgIUIANBhho2AhAgA0EVNgIMQQAhAgx5C0HKACECDF4LQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDHcLIAMgAy8BMkGAAXI7ATIMOAsgASAERwRAIANBEDYCCCADIAE2AgRByQAhAgxcC0HXACECDHULIAEgBEYEQEHWACECDHULAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAPT09PT09PT09PT09AT09PQIDPQsgAUEBaiEBQcUAIQIMXQsgAUEBaiEBQcYAIQIMXAsgAUEBaiEBQccAIQIMWwsgAUEBaiEBQcgAIQIMWgtB1QAhAiAEIAEiAEYNcyAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcDQCABQcDGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQhBBCABQQVGDQoaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHMLQdQAIQIgBCABIgBGDXIgBCABayADKAIAIgFqIQYgACABa0EPaiEHA0AgAUGwxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0HQQMgAUEPRg0JGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxyC0HTACECIAQgASIARg1xIAQgAWsgAygCACIBaiEGIAAgAWtBDmohBwNAIAFBksYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNBiABQQ5GDQcgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMcQtB0gAhAiAEIAEiAEYNcCAEIAFrIAMoAgAiAWohBSAAIAFrQQFqIQYDQCABQZDGAGotAAAgAC0AACIHQSByIAcgB0HBAGtB/wFxQRpJG0H/AXFHDQUgAUEBRg0CIAFBAWohASAEIABBAWoiAEcNAAsgAyAFNgIADHALIAEgBEYEQEHRACECDHALAkACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcUHuAGsOBwA2NjY2NgE2CyABQQFqIQFBwgAhAgxWCyABQQFqIQFBwwAhAgxVCyADQQA2AgAgBkEBaiEBQcQAIQIMVAtB0AAhAiAEIAEiAEYNbSAEIAFrIAMoAgAiAWohBiAAIAFrQQlqIQcDQCABQYbGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQJBAiABQQlGDQQaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADG0LQc8AIQIgBCABIgBGDWwgBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUGAxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxsCyAAIQEgA0EANgIADDALQQELOgAsIANBADYCACAHQQFqIQELQSwhAgxOCwJAA0AgAS0AAEGAxABqLQAAQQFHDQEgBCABQQFqIgFHDQALQc0AIQIMaAtBwQAhAgxNCyABIARGBEBBzAAhAgxnCyABLQAAQTpGBEAgAygCBCEAIANBADYCBCADIAAgARAvIgBFDTAgA0HLADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxnCyADQQA2AhwgAyABNgIUIANBuRE2AhAgA0EKNgIMQQAhAgxmCwJAAkAgAy0ALEECaw4CAAEkCyADQTNqLQAAQQJxRQ0jIAMtAC5BAnENIyADQQA2AhwgAyABNgIUIANB1RM2AhAgA0ELNgIMQQAhAgxmCyADLQAyQSBxRQ0iIAMtAC5BAnENIiADQQA2AhwgAyABNgIUIANB7BI2AhAgA0EPNgIMQQAhAgxlC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQRAQcAAIQIMSwsgAEEVRwRAIANBADYCHCADIAE2AhQgA0H4DjYCECADQRw2AgxBACECDGULIANBygA2AhwgAyABNgIUIANB8Bo2AhAgA0EVNgIMQQAhAgxkCyABIARHBEADQCABLQAAQfA/ai0AAEEBRw0XIAQgAUEBaiIBRw0AC0HEACECDGQLQcQAIQIMYwsgASAERwRAA0ACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcSIAQQlGDQAgAEEgRg0AAkACQAJAAkAgAEHjAGsOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBNSECDE4LIAFBAWohAUE2IQIMTQsgAUEBaiEBQTchAgxMCwwVCyAEIAFBAWoiAUcNAAtBPCECDGMLQTwhAgxiCyABIARGBEBByAAhAgxiCyADQRE2AgggAyABNgIEAkACQAJAAkACQCADLQAsQQFrDgQUAAECCQsgAy0AMkEgcQ0DQdEBIQIMSwsCQCADLwEyIgBBCHFFDQAgAy0AKEEBRw0AIAMtAC5BCHFFDQILIAMgAEH3+wNxQYAEcjsBMgwLCyADIAMvATJBEHI7ATIMBAsgA0EANgIEIAMgASABEDAiAARAIANBwQA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMYwsgAUEBaiEBDFILIANBADYCHCADIAE2AhQgA0GjEzYCECADQQQ2AgxBACECDGELQccAIQIgASAERg1gIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEHwwwBqLQAAIAEtAABBIHJHDQEgAEEGRg1GIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADGELIANBADYCAAwFCwJAIAEgBEcEQANAIAEtAABB8MEAai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBxQAhAgxhC0HFACECDGALCyADQQA6ACwMAQtBCyECDEMLQT4hAgxCCwJAAkADQCABLQAAIgBBIEcEQAJAIABBCmsOBAMFBQMACyAAQSxGDQMMBAsgBCABQQFqIgFHDQALQcYAIQIMXQsgA0EIOgAsDA4LIAMtAChBAUcNAiADLQAuQQhxDQIgAygCBCEAIANBADYCBCADIAAgARAwIgAEQCADQcIANgIcIAMgADYCDCADIAFBAWo2AhRBACECDFwLIAFBAWohAQxKC0E6IQIMQAsCQANAIAEtAAAiAEEgRyAAQQlHcQ0BIAQgAUEBaiIBRw0AC0HDACECDFoLC0E7IQIMPgsCQAJAIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBAMEBAMECyAEIAFBAWoiAUcNAAtBPyECDFoLQT8hAgxZCyADIAMvATJBIHI7ATIMCgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFDUggA0E+NgIcIAMgATYCFCADIAA2AgxBACECDFcLAkAgASAERwRAA0AgAS0AAEHwwQBqLQAAIgBBAUcEQCAAQQJGDQMMDAsgBCABQQFqIgFHDQALQTchAgxYC0E3IQIMVwsgAUEBaiEBDAQLQTshAiAEIAEiAEYNVSAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcCQANAIAFBwMYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQVGBEBBByEBDDsLIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFYLIANBADYCACAAIQEMBQtBOiECIAQgASIARg1UIAQgAWsgAygCACIBaiEGIAAgAWtBCGohBwJAA0AgAUHkP2otAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEIRgRAQQUhAQw6CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxVCyADQQA2AgAgACEBDAQLQTkhAiAEIAEiAEYNUyAEIAFrIAMoAgAiAWohBiAAIAFrQQNqIQcCQANAIAFB4D9qLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBA0YEQEEGIQEMOQsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMVAsgA0EANgIAIAAhAQwDCwJAA0AgAS0AACIAQSBHBEAgAEEKaw4EBwQEBwILIAQgAUEBaiIBRw0AC0E4IQIMUwsgAEEsRw0BIAFBAWohAEEBIQECQAJAAkACQAJAIAMtACxBBWsOBAMBAgQACyAAIQEMBAtBAiEBDAELQQQhAQsgA0EBOgAsIAMgAy8BMiABcjsBMiAAIQEMAQsgAyADLwEyQQhyOwEyIAAhAQtBPSECDDcLIANBADoALAtBOCECDDULIAEgBEYEQEE2IQIMTwsCQAJAAkACQAJAIAEtAABBCmsOBAACAgECCyADKAIEIQAgA0EANgIEIAMgACABEDAiAEUNAiADQTM2AhwgAyABNgIUIAMgADYCDEEAIQIMUgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFBEAgAUEBaiEBDAYLIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxRCyADLQAuQQFxBEBB0AEhAgw3CyADKAIEIQAgA0EANgIEIAMgACABEDAiAA0BDEMLQTMhAgw1CyADQTU2AhwgAyABNgIUIAMgADYCDEEAIQIMTgtBNCECDDMLIANBL2otAABBAXENACADQQA2AhwgAyABNgIUIANB8RU2AhAgA0EZNgIMQQAhAgxMC0EyIQIMMQsgASAERgRAQTIhAgxLCwJAIAEtAABBCkYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZgWNgIQIANBAzYCDEEAIQIMSwtBMSECDDALIAEgBEYEQEExIQIMSgsgAS0AACIAQQlHIABBIEdxDQEgAy0ALEEIRw0AIANBADoALAtBPCECDC4LQQEhAgJAAkACQAJAIAMtACxBBWsOBAMBAgAKCyADIAMvATJBCHI7ATIMCQtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgwGCyABIARGBEBBMCECDEcLIAEtAABBCkYEQCABQQFqIQEMAQsgAy0ALkEBcQ0AIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDEYLQS8hAgwrCyABQQFqIQFBMCECDCoLIAEgBEYEQEEvIQIMRAsgAS0AACIAQQlHIABBIEdxRQRAIAFBAWohASADLQAuQQFxDQEgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIMRAtBASECAkACQAJAAkACQAJAIAMtACxBAmsOBwUEBAMBAgAECyADIAMvATJBCHI7ATIMAwtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgtBLiECDCoLIANBADYCHCADIAE2AhQgA0GzEjYCECADQQs2AgxBACECDEMLQdIBIQIMKAsgASAERgRAQS4hAgxCCyADQQA2AgQgA0ERNgIIIAMgASABEDAiAA0BC0EtIQIMJgsgA0EtNgIcIAMgATYCFCADIAA2AgxBACECDD8LQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2AA2AhwgAyABNgIUIANBnho2AhAgA0EVNgIMQQAhAgw+C0HLACECDCMLIANBADYCHCADIAE2AhQgA0GFDjYCECADQR02AgxBACECDDwLIAEgBEYEQEHOACECDDwLIAEtAAAiAEEgRg0CIABBOkYNAQsgA0EAOgAsQQkhAgwgCyADKAIEIQAgA0EANgIEIAMgACABEC8iAA0BDAILIAMtAC5BAXEEQEHPASECDB8LIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ0CIANBKjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgw4CyADQcsANgIcIAMgADYCDCADIAFBAWo2AhRBACECDDcLIAFBAWohAUE/IQIMHAsgAUEBaiEBDCkLIAEgBEYEQEErIQIMNQsCQCABLQAAQQpGBEAgAUEBaiEBDAELIAMtAC5BwABxRQ0GCyADLQAyQYABcQRAQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIABFDREgAEEVRgRAIANBBTYCHCADIAE2AhQgA0GGGjYCECADQRU2AgxBACECDDYLIANBADYCHCADIAE2AhQgA0HiDTYCECADQRQ2AgxBACECDDULIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsgAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIANBAToAMAsgAiACLwEAQcAAcjsBAAtBKiECDBcLIANBKTYCHCADIAE2AhQgA0GyGDYCECADQRU2AgxBACECDDALIANBADYCHCADIAE2AhQgA0HdCzYCECADQRE2AgxBACECDC8LIANBADYCHCADIAE2AhQgA0GdCzYCECADQQI2AgxBACECDC4LQQEhByADLwEyIgVBCHFFBEAgAykDIEIAUiEHCwJAIAMtADAEQEEBIQAgAy0AKUEFRg0BIAVBwABxRSAHcUUNAQsCQCADLQAoIgJBAkYEQEEBIQAgAy8BNCIGQeUARg0CQQAhACAFQcAAcQ0CIAZB5ABGDQIgBkHmAGtBAkkNAiAGQcwBRg0CIAZBsAJGDQIMAQtBACEAIAVBwABxDQELQQIhACAFQQhxDQAgBUGABHEEQAJAIAJBAUcNACADLQAuQQpxDQBBBSEADAILQQQhAAwBCyAFQSBxRQRAIAMQNUEAR0ECdCEADAELQQBBAyADKQMgUBshAAsCQCAAQQFrDgUAAQYHAgMLQQAhAgJAIAMoAjgiAEUNACAAKAIsIgBFDQAgAyAAEQAAIQILIAJFDSYgAkEVRgRAIANBAzYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDC4LQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDC0LQc4BIQIMEgtBACECIANBADYCHCADIAE2AhQgA0HkHzYCECADQQ82AgwMKwtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAA0BC0EOIQIMDwsgAEEVRgRAIANBAjYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDCkLQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDCgLQSkhAgwNCyADQQE6ADEMJAsgASAERwRAIANBCTYCCCADIAE2AgRBKCECDAwLQSYhAgwlCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMVARAQSUhAgwlCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDQAgA0EFNgIcIAMgATYCFCADIAA2AgwMJAtBDyECDAkLIAEgBEYEQEEjIQIMIwtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsONxcWAAECAwQFBgcUFBQUFBQUCAkKCwwNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQODxAREhMUC0ICIQoMFgtCAyEKDBULQgQhCgwUC0IFIQoMEwtCBiEKDBILQgchCgwRC0IIIQoMEAtCCSEKDA8LQgohCgwOC0ILIQoMDQtCDCEKDAwLQg0hCgwLC0IOIQoMCgtCDyEKDAkLQgohCgwIC0ILIQoMBwtCDCEKDAYLQg0hCgwFC0IOIQoMBAtCDyEKDAMLQQAhAiADQQA2AhwgAyABNgIUIANBzhQ2AhAgA0EMNgIMDCILIAEgBEYEQEEiIQIMIgtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYCECAAQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAIgAEEEcUEYciICayIBQSBJDQAgACACaiEAA0AgAEIANwMYIABCADcDECAAQgA3AwggAEIANwMAIABBIGohACABQSBrIgFBH0sNAAsLC1YBAX8CQCAAKAIMDQACQAJAAkACQCAALQAxDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgAREAACIBDQMLQQAPCwALIABB0Bg2AhBBDiEBCyABCxoAIAAoAgxFBEAgAEHJHjYCECAAQRU2AgwLCxQAIAAoAgxBFUYEQCAAQQA2AgwLCxQAIAAoAgxBFkYEQCAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsXACAAQSRPBEAACyAAQQJ0QZQ3aigCAAsXACAAQS9PBEAACyAAQQJ0QaQ4aigCAAu/CQEBf0HfLCEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHkAGsO9ANjYgABYWFhYWFhAgMEBWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEGBwgJCgsMDQ4PYWFhYWEQYWFhYWFhYWFhYWERYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhEhMUFRYXGBkaG2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEcHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTZhNzg5OmFhYWFhYWFhO2FhYTxhYWFhPT4/YWFhYWFhYWFAYWFBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhQkNERUZHSElKS0xNTk9QUVJTYWFhYWFhYWFUVVZXWFlaW2FcXWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYV5hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFfYGELQdUrDwtBgyUPC0G/MA8LQfI1DwtBtCgPC0GfKA8LQYEsDwtB1ioPC0H0Mw8LQa0zDwtByygPC0HOIw8LQcAjDwtB2SMPC0HRJA8LQZwzDwtBojYPC0H8Mw8LQeArDwtB4SUPC0HtIA8LQcQyDwtBqScPC0G5Ng8LQbggDwtBqyAPC0GjJA8LQbYkDwtBgSMPC0HhMg8LQZ80DwtByCkPC0HAMg8LQe4yDwtB8C8PC0HGNA8LQdAhDwtBmiQPC0HrLw8LQYQ1DwtByzUPC0GWMQ8LQcgrDwtB1C8PC0GTMA8LQd81DwtBtCMPC0G+NQ8LQdIpDwtBsyIPC0HNIA8LQZs2DwtBkCEPC0H/IA8LQa01DwtBsDQPC0HxJA8LQacqDwtB3TAPC0GLIg8LQcgvDwtB6yoPC0H0KQ8LQY8lDwtB3SIPC0HsJg8LQf0wDwtB1iYPC0GUNQ8LQY0jDwtBuikPC0HHIg8LQfIlDwtBtjMPC0GiIQ8LQf8vDwtBwCEPC0GBMw8LQcklDwtBqDEPC0HGMw8LQdM2DwtBxjYPC0HkNA8LQYgmDwtB7ScPC0H4IQ8LQakwDwtBjzQPC0GGNg8LQaovDwtBoSYPC0HsNg8LQZIpDwtBryYPC0GZIg8LQeAhDwsAC0G1JSEBCyABCxcAIAAgAC8BLkH+/wNxIAFBAEdyOwEuCxoAIAAgAC8BLkH9/wNxIAFBAEdBAXRyOwEuCxoAIAAgAC8BLkH7/wNxIAFBAEdBAnRyOwEuCxoAIAAgAC8BLkH3/wNxIAFBAEdBA3RyOwEuCxoAIAAgAC8BLkHv/wNxIAFBAEdBBHRyOwEuCxoAIAAgAC8BLkHf/wNxIAFBAEdBBXRyOwEuCxoAIAAgAC8BLkG//wNxIAFBAEdBBnRyOwEuCxoAIAAgAC8BLkH//gNxIAFBAEdBB3RyOwEuCxoAIAAgAC8BLkH//QNxIAFBAEdBCHRyOwEuCxoAIAAgAC8BLkH/+wNxIAFBAEdBCXRyOwEuCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBzhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5Ao2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5R02AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBnRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBoh42AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7hQ2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9xs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRU2AhBBGCEECyAECzgAIAACfyAALwEyQRRxQRRGBEBBASAALQAoQQFGDQEaIAAvATRB5QBGDAELIAAtAClBBUYLOgAwC1kBAn8CQCAALQAoQQFGDQAgAC8BNCIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMiIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEyIgFBAnFFDQEMAgsgAC8BMiIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATQiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtXACAAQRhqQgA3AwAgAEIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABB7AE2AhwLBgAgABA5C5otAQt/IwBBEGsiCiQAQZjUACgCACIJRQRAQdjXACgCACIFRQRAQeTXAEJ/NwIAQdzXAEKAgISAgIDAADcCAEHY1wAgCkEIakFwcUHYqtWqBXMiBTYCAEHs1wBBADYCAEG81wBBADYCAAtBwNcAQYDYBDYCAEGQ1ABBgNgENgIAQaTUACAFNgIAQaDUAEF/NgIAQcTXAEGAqAM2AgADQCABQbzUAGogAUGw1ABqIgI2AgAgAiABQajUAGoiAzYCACABQbTUAGogAzYCACABQcTUAGogAUG41ABqIgM2AgAgAyACNgIAIAFBzNQAaiABQcDUAGoiAjYCACACIAM2AgAgAUHI1ABqIAI2AgAgAUEgaiIBQYACRw0AC0GM2ARBwacDNgIAQZzUAEHo1wAoAgA2AgBBjNQAQcCnAzYCAEGY1ABBiNgENgIAQcz/B0E4NgIAQYjYBCEJCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFNBEBBgNQAKAIAIgZBECAAQRNqQXBxIABBC0kbIgRBA3YiAHYiAUEDcQRAAkAgAUEBcSAAckEBcyICQQN0IgBBqNQAaiIBIABBsNQAaigCACIAKAIIIgNGBEBBgNQAIAZBfiACd3E2AgAMAQsgASADNgIIIAMgATYCDAsgAEEIaiEBIAAgAkEDdCICQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDBELQYjUACgCACIIIARPDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIAQQN0IgJBqNQAaiIBIAJBsNQAaigCACICKAIIIgNGBEBBgNQAIAZBfiAAd3EiBjYCAAwBCyABIAM2AgggAyABNgIMCyACIARBA3I2AgQgAEEDdCIAIARrIQUgACACaiAFNgIAIAIgBGoiBCAFQQFyNgIEIAgEQCAIQXhxQajUAGohAEGU1AAoAgAhAwJ/QQEgCEEDdnQiASAGcUUEQEGA1AAgASAGcjYCACAADAELIAAoAggLIgEgAzYCDCAAIAM2AgggAyAANgIMIAMgATYCCAsgAkEIaiEBQZTUACAENgIAQYjUACAFNgIADBELQYTUACgCACILRQ0BIAtoQQJ0QbDWAGooAgAiACgCBEF4cSAEayEFIAAhAgNAAkAgAigCECIBRQRAIAJBFGooAgAiAUUNAQsgASgCBEF4cSAEayIDIAVJIQIgAyAFIAIbIQUgASAAIAIbIQAgASECDAELCyAAKAIYIQkgACgCDCIDIABHBEBBkNQAKAIAGiADIAAoAggiATYCCCABIAM2AgwMEAsgAEEUaiICKAIAIgFFBEAgACgCECIBRQ0DIABBEGohAgsDQCACIQcgASIDQRRqIgIoAgAiAQ0AIANBEGohAiADKAIQIgENAAsgB0EANgIADA8LQX8hBCAAQb9/Sw0AIABBE2oiAUFwcSEEQYTUACgCACIIRQ0AQQAgBGshBQJAAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBsNYAaigCACICRQRAQQAhAUEAIQMMAQtBACEBIARBGSAGQQF2a0EAIAZBH0cbdCEAQQAhAwNAAkAgAigCBEF4cSAEayIHIAVPDQAgAiEDIAciBQ0AQQAhBSACIQEMAwsgASACQRRqKAIAIgcgByACIABBHXZBBHFqQRBqKAIAIgJGGyABIAcbIQEgAEEBdCEAIAINAAsLIAEgA3JFBEBBACEDQQIgBnQiAEEAIABrciAIcSIARQ0DIABoQQJ0QbDWAGooAgAhAQsgAUUNAQsDQCABKAIEQXhxIARrIgIgBUkhACACIAUgABshBSABIAMgABshAyABKAIQIgAEfyAABSABQRRqKAIACyIBDQALCyADRQ0AIAVBiNQAKAIAIARrTw0AIAMoAhghByADIAMoAgwiAEcEQEGQ1AAoAgAaIAAgAygCCCIBNgIIIAEgADYCDAwOCyADQRRqIgIoAgAiAUUEQCADKAIQIgFFDQMgA0EQaiECCwNAIAIhBiABIgBBFGoiAigCACIBDQAgAEEQaiECIAAoAhAiAQ0ACyAGQQA2AgAMDQtBiNQAKAIAIgMgBE8EQEGU1AAoAgAhAQJAIAMgBGsiAkEQTwRAIAEgBGoiACACQQFyNgIEIAEgA2ogAjYCACABIARBA3I2AgQMAQsgASADQQNyNgIEIAEgA2oiACAAKAIEQQFyNgIEQQAhAEEAIQILQYjUACACNgIAQZTUACAANgIAIAFBCGohAQwPC0GM1AAoAgAiAyAESwRAIAQgCWoiACADIARrIgFBAXI2AgRBmNQAIAA2AgBBjNQAIAE2AgAgCSAEQQNyNgIEIAlBCGohAQwPC0EAIQEgBAJ/QdjXACgCAARAQeDXACgCAAwBC0Hk1wBCfzcCAEHc1wBCgICEgICAwAA3AgBB2NcAIApBDGpBcHFB2KrVqgVzNgIAQezXAEEANgIAQbzXAEEANgIAQYCABAsiACAEQccAaiIFaiIGQQAgAGsiB3EiAk8EQEHw1wBBMDYCAAwPCwJAQbjXACgCACIBRQ0AQbDXACgCACIIIAJqIQAgACABTSAAIAhLcQ0AQQAhAUHw1wBBMDYCAAwPC0G81wAtAABBBHENBAJAAkAgCQRAQcDXACEBA0AgASgCACIAIAlNBEAgACABKAIEaiAJSw0DCyABKAIIIgENAAsLQQAQOiIAQX9GDQUgAiEGQdzXACgCACIBQQFrIgMgAHEEQCACIABrIAAgA2pBACABa3FqIQYLIAQgBk8NBSAGQf7///8HSw0FQbjXACgCACIDBEBBsNcAKAIAIgcgBmohASABIAdNDQYgASADSw0GCyAGEDoiASAARw0BDAcLIAYgA2sgB3EiBkH+////B0sNBCAGEDohACAAIAEoAgAgASgCBGpGDQMgACEBCwJAIAYgBEHIAGpPDQAgAUF/Rg0AQeDXACgCACIAIAUgBmtqQQAgAGtxIgBB/v///wdLBEAgASEADAcLIAAQOkF/RwRAIAAgBmohBiABIQAMBwtBACAGaxA6GgwECyABIgBBf0cNBQwDC0EAIQMMDAtBACEADAoLIABBf0cNAgtBvNcAQbzXACgCAEEEcjYCAAsgAkH+////B0sNASACEDohAEEAEDohASAAQX9GDQEgAUF/Rg0BIAAgAU8NASABIABrIgYgBEE4ak0NAQtBsNcAQbDXACgCACAGaiIBNgIAQbTXACgCACABSQRAQbTXACABNgIACwJAAkACQEGY1AAoAgAiAgRAQcDXACEBA0AgACABKAIAIgMgASgCBCIFakYNAiABKAIIIgENAAsMAgtBkNQAKAIAIgFBAEcgACABT3FFBEBBkNQAIAA2AgALQQAhAUHE1wAgBjYCAEHA1wAgADYCAEGg1ABBfzYCAEGk1ABB2NcAKAIANgIAQczXAEEANgIAA0AgAUG81ABqIAFBsNQAaiICNgIAIAIgAUGo1ABqIgM2AgAgAUG01ABqIAM2AgAgAUHE1ABqIAFBuNQAaiIDNgIAIAMgAjYCACABQczUAGogAUHA1ABqIgI2AgAgAiADNgIAIAFByNQAaiACNgIAIAFBIGoiAUGAAkcNAAtBeCAAa0EPcSIBIABqIgIgBkE4ayIDIAFrIgFBAXI2AgRBnNQAQejXACgCADYCAEGM1AAgATYCAEGY1AAgAjYCACAAIANqQTg2AgQMAgsgACACTQ0AIAIgA0kNACABKAIMQQhxDQBBeCACa0EPcSIAIAJqIgNBjNQAKAIAIAZqIgcgAGsiAEEBcjYCBCABIAUgBmo2AgRBnNQAQejXACgCADYCAEGM1AAgADYCAEGY1AAgAzYCACACIAdqQTg2AgQMAQsgAEGQ1AAoAgBJBEBBkNQAIAA2AgALIAAgBmohA0HA1wAhAQJAAkACQANAIAMgASgCAEcEQCABKAIIIgENAQwCCwsgAS0ADEEIcUUNAQtBwNcAIQEDQCABKAIAIgMgAk0EQCADIAEoAgRqIgUgAksNAwsgASgCCCEBDAALAAsgASAANgIAIAEgASgCBCAGajYCBCAAQXggAGtBD3FqIgkgBEEDcjYCBCADQXggA2tBD3FqIgYgBCAJaiIEayEBIAIgBkYEQEGY1AAgBDYCAEGM1ABBjNQAKAIAIAFqIgA2AgAgBCAAQQFyNgIEDAgLQZTUACgCACAGRgRAQZTUACAENgIAQYjUAEGI1AAoAgAgAWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAgLIAYoAgQiBUEDcUEBRw0GIAVBeHEhCCAFQf8BTQRAIAVBA3YhAyAGKAIIIgAgBigCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBwsgAiAANgIIIAAgAjYCDAwGCyAGKAIYIQcgBiAGKAIMIgBHBEAgACAGKAIIIgI2AgggAiAANgIMDAULIAZBFGoiAigCACIFRQRAIAYoAhAiBUUNBCAGQRBqIQILA0AgAiEDIAUiAEEUaiICKAIAIgUNACAAQRBqIQIgACgCECIFDQALIANBADYCAAwEC0F4IABrQQ9xIgEgAGoiByAGQThrIgMgAWsiAUEBcjYCBCAAIANqQTg2AgQgAiAFQTcgBWtBD3FqQT9rIgMgAyACQRBqSRsiA0EjNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAE2AgBBmNQAIAc2AgAgA0EQakHI1wApAgA3AgAgA0HA1wApAgA3AghByNcAIANBCGo2AgBBxNcAIAY2AgBBwNcAIAA2AgBBzNcAQQA2AgAgA0EkaiEBA0AgAUEHNgIAIAUgAUEEaiIBSw0ACyACIANGDQAgAyADKAIEQX5xNgIEIAMgAyACayIFNgIAIAIgBUEBcjYCBCAFQf8BTQRAIAVBeHFBqNQAaiEAAn9BgNQAKAIAIgFBASAFQQN2dCIDcUUEQEGA1AAgASADcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbDWAGohAEGE1AAoAgAiA0EBIAF0IgZxRQRAIAAgAjYCAEGE1AAgAyAGcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQMCQANAIAMiACgCBEF4cSAFRg0BIAFBHXYhAyABQQF0IQEgACADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAtBjNQAKAIAIgEgBE0NAEGY1AAoAgAiACAEaiICIAEgBGsiAUEBcjYCBEGM1AAgATYCAEGY1AAgAjYCACAAIARBA3I2AgQgAEEIaiEBDAgLQQAhAUHw1wBBMDYCAAwHC0EAIQALIAdFDQACQCAGKAIcIgJBAnRBsNYAaiIDKAIAIAZGBEAgAyAANgIAIAANAUGE1ABBhNQAKAIAQX4gAndxNgIADAILIAdBEEEUIAcoAhAgBkYbaiAANgIAIABFDQELIAAgBzYCGCAGKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAGQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAIaiEBIAYgCGoiBigCBCEFCyAGIAVBfnE2AgQgASAEaiABNgIAIAQgAUEBcjYCBCABQf8BTQRAIAFBeHFBqNQAaiEAAn9BgNQAKAIAIgJBASABQQN2dCIBcUUEQEGA1AAgASACcjYCACAADAELIAAoAggLIgEgBDYCDCAAIAQ2AgggBCAANgIMIAQgATYCCAwBC0EfIQUgAUH///8HTQRAIAFBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBQsgBCAFNgIcIARCADcCECAFQQJ0QbDWAGohAEGE1AAoAgAiAkEBIAV0IgNxRQRAIAAgBDYCAEGE1AAgAiADcjYCACAEIAA2AhggBCAENgIIIAQgBDYCDAwBCyABQRkgBUEBdmtBACAFQR9HG3QhBSAAKAIAIQACQANAIAAiAigCBEF4cSABRg0BIAVBHXYhACAFQQF0IQUgAiAAQQRxakEQaiIDKAIAIgANAAsgAyAENgIAIAQgAjYCGCAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgCUEIaiEBDAILAkAgB0UNAAJAIAMoAhwiAUECdEGw1gBqIgIoAgAgA0YEQCACIAA2AgAgAA0BQYTUACAIQX4gAXdxIgg2AgAMAgsgB0EQQRQgBygCECADRhtqIAA2AgAgAEUNAQsgACAHNgIYIAMoAhAiAQRAIAAgATYCECABIAA2AhgLIANBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAIAVBD00EQCADIAQgBWoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARqIgIgBUEBcjYCBCADIARBA3I2AgQgAiAFaiAFNgIAIAVB/wFNBEAgBUF4cUGo1ABqIQACf0GA1AAoAgAiAUEBIAVBA3Z0IgVxRQRAQYDUACABIAVyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRBsNYAaiEAQQEgAXQiBCAIcUUEQCAAIAI2AgBBhNQAIAQgCHI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEEAkADQCAEIgAoAgRBeHEgBUYNASABQR12IQQgAUEBdCEBIAAgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLIANBCGohAQwBCwJAIAlFDQACQCAAKAIcIgFBAnRBsNYAaiICKAIAIABGBEAgAiADNgIAIAMNAUGE1AAgC0F+IAF3cTYCAAwCCyAJQRBBFCAJKAIQIABGG2ogAzYCACADRQ0BCyADIAk2AhggACgCECIBBEAgAyABNgIQIAEgAzYCGAsgAEEUaigCACIBRQ0AIANBFGogATYCACABIAM2AhgLAkAgBUEPTQRAIAAgBCAFaiIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELIAAgBGoiByAFQQFyNgIEIAAgBEEDcjYCBCAFIAdqIAU2AgAgCARAIAhBeHFBqNQAaiEBQZTUACgCACEDAn9BASAIQQN2dCICIAZxRQRAQYDUACACIAZyNgIAIAEMAQsgASgCCAsiAiADNgIMIAEgAzYCCCADIAE2AgwgAyACNgIIC0GU1AAgBzYCAEGI1AAgBTYCAAsgAEEIaiEBCyAKQRBqJAAgAQtDACAARQRAPwBBEHQPCwJAIABB//8DcQ0AIABBAEgNACAAQRB2QAAiAEF/RgRAQfDXAEEwNgIAQX8PCyAAQRB0DwsACwvbQCIAQYAICwkBAAAAAgAAAAMAQZQICwUEAAAABQBBpAgLCQYAAAAHAAAACABB3AgLgjFJbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABUcmFuc2Zlci1FbmNvZGluZyBjYW4ndCBiZSBwcmVzZW50IHdpdGggQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBzaXplAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIHNpemUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAUhUAABoVAAAPEgAA5BkAAJEVAAAJFAAALRkAAOQUAADpEQAAaRQAAKEUAAB2FQAAQxYAAF4SAACUFwAAFxYAAH0UAAB/FgAAQRcAALMTAADDFgAABBoAAL0YAADQGAAAoBMAANQZAACvFgAAaBYAAHAXAADZFgAA/BgAAP4RAABZFwAAlxYAABwXAAD2FgAAjRcAAAsSAAB/GwAALhEAALMQAABJEgAArRIAAPYYAABoEAAAYhUAABAVAABaFgAAShkAALUVAADBFQAAYBUAAFwZAABaGQAAUxkAABYVAACtEQAAQhAAALcQAABXGAAAvxUAAIkQAAAcGQAAGhkAALkVAABRGAAA3BMAAFsVAABZFQAA5hgAAGcVAAARGQAA7RgAAOcTAACuEAAAwhcAAAAUAACSEwAAhBMAAEASAAAmGQAArxUAAGIQAEHpOQsBAQBBgDoL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB6jsLBAEAAAIAQYE8C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHqPQsEAQAAAgBBgT4LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQeA/Cw1sb3NlZWVwLWFsaXZlAEH5PwsBAQBBkMAAC+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnBAAsBAQBBkMIAC+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGhxAALXgEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAQYDGAAshZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAEGwxgALK3JhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KU00NCg0KVFRQL0NFL1RTUC8AQenGAAsFAQIAAQMAQYDHAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenIAAsFAQIAAQMAQYDJAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenKAAsEAQAAAQBBgcsAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEHpzAALBQECAAEDAEGAzQALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEHpzgALBQEBAAEBAEGAzwALAQEAQZrPAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQenQAAsFAQEAAQEAQYDRAAsBAQBBitEACwYCAAAAAAIAQaHRAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB4NIAC5oBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", Wg;
      Object.defineProperty(LB, "exports", { get: /* @__PURE__ */ __name(() => Wg || (Wg = aL.from(cL, "base64")), "get") });
    });
    var PB = C2((GK, vB) => {
      "use strict";
      var { Buffer: lL } = __require("node:buffer"), uL = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAhIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAiHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACMkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACQabGxodHRwX3NldF9sZW5pZW50X3ZlcnNpb24AJSNsbGh0dHBfc2V0X2xlbmllbnRfZGF0YV9hZnRlcl9jbG9zZQAmJ2xsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9sZl9hZnRlcl9jcgAnLGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcmxmX2FmdGVyX2NodW5rACgobGxodHRwX3NldF9sZW5pZW50X29wdGlvbmFsX2NyX2JlZm9yZV9sZgApKmxsaHR0cF9zZXRfbGVuaWVudF9zcGFjZXNfYWZ0ZXJfY2h1bmtfc2l6ZQAqGGxsaHR0cF9tZXNzYWdlX25lZWRzX2VvZgA1CRcBAEEBCxEBAgMEBQoGBzEzMi0uLCsvMArYywIzFgBB/NMAKAIABEAAC0H80wBBATYCAAsUACAAEDcgACACNgI4IAAgAToAKAsUACAAIAAvATQgAC0AMCAAEDYQAAseAQF/QcAAEDkiARA3IAFBgAg2AjggASAAOgAoIAELjwwBB38CQCAARQ0AIABBCGsiASAAQQRrKAIAIgBBeHEiBGohBQJAIABBAXENACAAQQNxRQ0BIAEgASgCACIAayIBQZDUACgCAEkNASAAIARqIQQCQAJAQZTUACgCACABRwRAIABB/wFNBEAgAEEDdiEDIAEoAggiACABKAIMIgJGBEBBgNQAQYDUACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAEoAhghBiABIAEoAgwiAEcEQCAAIAEoAggiAjYCCCACIAA2AgwMAwsgAUEUaiIDKAIAIgJFBEAgASgCECICRQ0CIAFBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUoAgQiAEEDcUEDRw0CIAUgAEF+cTYCBEGI1AAgBDYCACAFIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAEoAhwiAkECdEGw1gBqIgMoAgAgAUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECABRhtqIAA2AgAgAEUNAQsgACAGNgIYIAEoAhAiAgRAIAAgAjYCECACIAA2AhgLIAFBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAVPDQAgBSgCBCIAQQFxRQ0AAkACQAJAAkAgAEECcUUEQEGY1AAoAgAgBUYEQEGY1AAgATYCAEGM1ABBjNQAKAIAIARqIgA2AgAgASAAQQFyNgIEIAFBlNQAKAIARw0GQYjUAEEANgIAQZTUAEEANgIADAYLQZTUACgCACAFRgRAQZTUACABNgIAQYjUAEGI1AAoAgAgBGoiADYCACABIABBAXI2AgQgACABaiAANgIADAYLIABBeHEgBGohBCAAQf8BTQRAIABBA3YhAyAFKAIIIgAgBSgCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyAFKAIYIQYgBSAFKAIMIgBHBEBBkNQAKAIAGiAAIAUoAggiAjYCCCACIAA2AgwMAwsgBUEUaiIDKAIAIgJFBEAgBSgCECICRQ0CIAVBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUgAEF+cTYCBCABIARqIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAUoAhwiAkECdEGw1gBqIgMoAgAgBUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAA2AgAgAEUNAQsgACAGNgIYIAUoAhAiAgRAIAAgAjYCECACIAA2AhgLIAVBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIARqIAQ2AgAgASAEQQFyNgIEIAFBlNQAKAIARw0AQYjUACAENgIADAELIARB/wFNBEAgBEF4cUGo1ABqIQACf0GA1AAoAgAiAkEBIARBA3Z0IgNxRQRAQYDUACACIANyNgIAIAAMAQsgACgCCAsiAiABNgIMIAAgATYCCCABIAA2AgwgASACNgIIDAELQR8hAiAEQf///wdNBEAgBEEmIARBCHZnIgBrdkEBcSAAQQF0a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygCHCICQQFrDuwB7gEB6AECAwQFBgcICQoLDA0ODxAREucBE+YBFBXlARYX5AEYGRobHB0eHyDvAe0BIeMBIiMkJSYnKCkqK+IBLC0uLzAxMuEB4AEzNN8B3gE1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk/pAVBRUlPdAdwBVNsBVdoBVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHZAdgBxgHXAccB1gHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAQDqAQtBAAzUAQtBDgzTAQtBDQzSAQtBDwzRAQtBEAzQAQtBEQzPAQtBEgzOAQtBEwzNAQtBFAzMAQtBFQzLAQtBFgzKAQtBFwzJAQtBGAzIAQtBGQzHAQtBGgzGAQtBGwzFAQtBHAzEAQtBHQzDAQtBHgzCAQtBHwzBAQtBCAzAAQtBIAy/AQtBIgy+AQtBIQy9AQtBBwy8AQtBIwy7AQtBJAy6AQtBJQy5AQtBJgy4AQtBJwy3AQtBzgEMtgELQSgMtQELQSkMtAELQSoMswELQSsMsgELQc8BDLEBC0EtDLABC0EuDK8BC0EvDK4BC0EwDK0BC0ExDKwBC0EyDKsBC0EzDKoBC0HQAQypAQtBNAyoAQtBOAynAQtBDAymAQtBNQylAQtBNgykAQtBNwyjAQtBPQyiAQtBOQyhAQtB0QEMoAELQQsMnwELQT4MngELQToMnQELQQoMnAELQTsMmwELQTwMmgELQdIBDJkBC0HAAAyYAQtBPwyXAQtBwQAMlgELQQkMlQELQSwMlAELQcIADJMBC0HDAAySAQtBxAAMkQELQcUADJABC0HGAAyPAQtBxwAMjgELQcgADI0BC0HJAAyMAQtBygAMiwELQcsADIoBC0HMAAyJAQtBzQAMiAELQc4ADIcBC0HPAAyGAQtB0AAMhQELQdEADIQBC0HSAAyDAQtB1AAMggELQdMADIEBC0HVAAyAAQtB1gAMfwtB1wAMfgtB2AAMfQtB2QAMfAtB2gAMewtB2wAMegtB0wEMeQtB3AAMeAtB3QAMdwtBBgx2C0HeAAx1C0EFDHQLQd8ADHMLQQQMcgtB4AAMcQtB4QAMcAtB4gAMbwtB4wAMbgtBAwxtC0HkAAxsC0HlAAxrC0HmAAxqC0HoAAxpC0HnAAxoC0HpAAxnC0HqAAxmC0HrAAxlC0HsAAxkC0ECDGMLQe0ADGILQe4ADGELQe8ADGALQfAADF8LQfEADF4LQfIADF0LQfMADFwLQfQADFsLQfUADFoLQfYADFkLQfcADFgLQfgADFcLQfkADFYLQfoADFULQfsADFQLQfwADFMLQf0ADFILQf4ADFELQf8ADFALQYABDE8LQYEBDE4LQYIBDE0LQYMBDEwLQYQBDEsLQYUBDEoLQYYBDEkLQYcBDEgLQYgBDEcLQYkBDEYLQYoBDEULQYsBDEQLQYwBDEMLQY0BDEILQY4BDEELQY8BDEALQZABDD8LQZEBDD4LQZIBDD0LQZMBDDwLQZQBDDsLQZUBDDoLQZYBDDkLQZcBDDgLQZgBDDcLQZkBDDYLQZoBDDULQZsBDDQLQZwBDDMLQZ0BDDILQZ4BDDELQZ8BDDALQaABDC8LQaEBDC4LQaIBDC0LQaMBDCwLQaQBDCsLQaUBDCoLQaYBDCkLQacBDCgLQagBDCcLQakBDCYLQaoBDCULQasBDCQLQawBDCMLQa0BDCILQa4BDCELQa8BDCALQbABDB8LQbEBDB4LQbIBDB0LQbMBDBwLQbQBDBsLQbUBDBoLQbYBDBkLQbcBDBgLQbgBDBcLQQEMFgtBuQEMFQtBugEMFAtBuwEMEwtBvAEMEgtBvQEMEQtBvgEMEAtBvwEMDwtBwAEMDgtBwQEMDQtBwgEMDAtBwwEMCwtBxAEMCgtBxQEMCQtBxgEMCAtB1AEMBwtBxwEMBgtByAEMBQtByQEMBAtBygEMAwtBywEMAgtBzQEMAQtBzAELIQIDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHXAdYB1QHUAdIB0QHQAc8BzgHNAcwBywHKAckByAHHAcYBxQHEAcMBwgHBAcABvwG+Ab0BvAG7AboBuQG4AbcBtgG1AbQBswGyAbEBsAGvAa4BrQGsAasBqgGpAagBpwGmAaUBpAGjAaIBoQGgAZ8BngGdAZwBmwGaAZcBlgGRAZABjwGOAY0BjAGLAYoBiQGIAYUBhAGDAX59fHt6d3Z1LFFSU1RVVgsgASAERw1zQewBIQIMqQMLIAEgBEcNkAFB0QEhAgyoAwsgASAERw3pAUGEASECDKcDCyABIARHDfQBQfoAIQIMpgMLIAEgBEcNggJB9QAhAgylAwsgASAERw2JAkHzACECDKQDCyABIARHDYwCQfEAIQIMowMLIAEgBEcNHkEeIQIMogMLIAEgBEcNGUEYIQIMoQMLIAEgBEcNuAJBzQAhAgygAwsgASAERw3DAkHGACECDJ8DCyABIARHDcQCQcMAIQIMngMLIAEgBEcNygJBOCECDJ0DCyADLQAwQQFGDZUDDPICC0EAIQACQAJAAkAgAy0AKkUNACADLQArRQ0AIAMvATIiAkECcUUNAQwCCyADLwEyIgJBAXFFDQELQQEhACADLQAoQQFGDQAgAy8BNCIGQeQAa0HkAEkNACAGQcwBRg0AIAZBsAJGDQAgAkHAAHENAEEAIQAgAkGIBHFBgARGDQAgAkEocUEARyEACyADQQA7ATIgA0EAOgAxAkAgAEUEQCADQQA6ADEgAy0ALkEEcQ0BDJwDCyADQgA3AyALIANBADoAMSADQQE6ADYMSQtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAEUNSSAAQRVHDWMgA0EENgIcIAMgATYCFCADQb0aNgIQIANBFTYCDEEAIQIMmgMLIAEgBEYEQEEGIQIMmgMLIAEtAABBCkYNGQwBCyABIARGBEBBByECDJkDCwJAIAEtAABBCmsOBAIBAQABCyABQQFqIQFBECECDP4CCyADLQAuQYABcQ0YQQAhAiADQQA2AhwgAyABNgIUIANBqR82AhAgA0ECNgIMDJcDCyABQQFqIQEgA0Evai0AAEEBcQ0XQQAhAiADQQA2AhwgAyABNgIUIANBhB82AhAgA0EZNgIMDJYDCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMWg0ZQQghAgyVAwsgASAERwRAIANBCTYCCCADIAE2AgRBEiECDPsCC0EJIQIMlAMLIAMpAyBQDZwCDEQLIAEgBEYEQEELIQIMkwMLIAEtAABBCkcNFyABQQFqIQEMGAsgA0Evai0AAEEBcUUNGgwnC0EAIQACQCADKAI4IgJFDQAgAigCSCICRQ0AIAMgAhEAACEACyAADRoMQwtBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0bDCULQQAhAAJAIAMoAjgiAkUNACACKAJIIgJFDQAgAyACEQAAIQALIAANHAwzCyADQS9qLQAAQQFxRQ0dDCMLQQAhAAJAIAMoAjgiAkUNACACKAJMIgJFDQAgAyACEQAAIQALIAANHQxDC0EAIQACQCADKAI4IgJFDQAgAigCTCICRQ0AIAMgAhEAACEACyAADR4MIQsgASAERgRAQRMhAgyLAwsCQCABLQAAIgBBCmsOBCAkJAAjCyABQQFqIQEMIAtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0jDEMLIAEgBEYEQEEWIQIMiQMLIAEtAABB8D9qLQAAQQFHDSQM7QILAkADQCABLQAAQeA5ai0AACIAQQFHBEACQCAAQQJrDgIDACgLIAFBAWohAUEfIQIM8AILIAQgAUEBaiIBRw0AC0EYIQIMiAMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABQQFqIgEQMyIADSIMQgtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0kDCsLIAEgBEYEQEEcIQIMhgMLIANBCjYCCCADIAE2AgRBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0mQSIhAgzrAgsgASAERwRAA0AgAS0AAEHgO2otAAAiAEEDRwRAIABBAWsOBRkbJ+wCJicLIAQgAUEBaiIBRw0AC0EbIQIMhQMLQRshAgyEAwsDQCABLQAAQeA9ai0AACIAQQNHBEAgAEEBaw4FEBIoFCcoCyAEIAFBAWoiAUcNAAtBHiECDIMDCyABIARHBEAgA0ELNgIIIAMgATYCBEEHIQIM6QILQR8hAgyCAwsgASAERgRAQSAhAgyCAwsCQCABLQAAQQ1rDhQvQEBAQEBAQEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDBsLIANBHDYCHCADIAA2AgwgAyABQQFqNgIUDN0CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDNICCyADQR02AhwgAyAANgIMIAMgAUEBajYCFAzcAgsgAEE7Rw0BIAFBAWohAQtBJCECDMACC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAzZAgsgASAERwRAA0AgAS0AAEEgRw3xASAEIAFBAWoiAUcNAAtBLCECDNkCC0EsIQIM2AILIAEgBEYEQEE0IQIM2AILAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0E0IQIM2QILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQ2MAiADQTI2AhwgAyABNgIUIAMgADYCDEEAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQRAIAFBAWohAQyMAgsgA0EyNgIcIAMgADYCDCADIAFBAWo2AhRBACECDNcCCyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE5IQIMwAILIAMpAyAiC0KZs+bMmbPmzBlWDQEgAyALQgp+Igo3AyAgCiAArUL/AYMiC0J/hVYNASADIAogC3w3AyAgBCABQQFqIgFHDQALQcAAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAFBAWoiARAwIgANFwzJAgtBwAAhAgzWAgsgASAERgRAQckAIQIM1gILAkADQAJAIAEtAABBCWsOGAACjwKPApMCjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CAI8CCyAEIAFBAWoiAUcNAAtByQAhAgzWAgsgAUEBaiEBIANBL2otAABBAXENjwIgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIM1QILIAEgBEcEQANAIAEtAAAiAEEgRwRAAkACQAJAIABByABrDgsAAc0BzQHNAc0BzQHNAc0BzQECzQELIAFBAWohAUHZACECDL8CCyABQQFqIQFB2gAhAgy+AgsgAUEBaiEBQdsAIQIMvQILIAQgAUEBaiIBRw0AC0HuACECDNUCC0HuACECDNQCCyADQQI6ACgMMAtBACECIANBADYCHCADQbcLNgIQIANBAjYCDCADIAFBAWo2AhQM0gILQQAhAgy3AgtBDSECDLYCC0ERIQIMtQILQRMhAgy0AgtBFCECDLMCC0EWIQIMsgILQRchAgyxAgtBGCECDLACC0EZIQIMrwILQRohAgyuAgtBGyECDK0CC0EcIQIMrAILQR0hAgyrAgtBHiECDKoCC0EgIQIMqQILQSEhAgyoAgtBIyECDKcCC0EnIQIMpgILIANBPTYCHCADIAE2AhQgAyAANgIMQQAhAgy/AgsgA0EbNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMvgILIANBIDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDL0CCyADQRM2AhwgAyABNgIUIANBnhk2AhAgA0EVNgIMQQAhAgy8AgsgA0ELNgIcIAMgATYCFCADQZ4ZNgIQIANBFTYCDEEAIQIMuwILIANBEDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDLoCCyADQSA2AhwgAyABNgIUIANBjxs2AhAgA0EVNgIMQQAhAgy5AgsgA0ELNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMuAILIANBDDYCHCADIAE2AhQgA0GPGzYCECADQRU2AgxBACECDLcCC0EAIQIgA0EANgIcIAMgATYCFCADQa8ONgIQIANBEjYCDAy2AgsCQANAAkAgAS0AAEEKaw4EAAICAAILIAQgAUEBaiIBRw0AC0HsASECDLYCCwJAAkAgAy0ANkEBRw0AQQAhAAJAIAMoAjgiAkUNACACKAJYIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB6wE2AhwgAyABNgIUIANB4hg2AhAgA0EVNgIMQQAhAgy3AgtBzAEhAgycAgsgA0EANgIcIAMgATYCFCADQfELNgIQIANBHzYCDEEAIQIMtQILAkACQCADLQAoQQFrDgIEAQALQcsBIQIMmwILQcQBIQIMmgILIANBAjoAMUEAIQACQCADKAI4IgJFDQAgAigCACICRQ0AIAMgAhEAACEACyAARQRAQc0BIQIMmgILIABBFUcEQCADQQA2AhwgAyABNgIUIANBrAw2AhAgA0EQNgIMQQAhAgy0AgsgA0HqATYCHCADIAE2AhQgA0GHGTYCECADQRU2AgxBACECDLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIMnQILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDAyeAgsgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDEEAIQIMnQILQbwBIQIMggILIAEgBEYEQEHVASECDJwCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgwMnQILIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgxBACECDJwCC0G7ASECDIECCyABIARGBEBB1AEhAgybAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMDJwCCyADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMQQAhAgybAgtBugEhAgyAAgsgASAERgRAQdMBIQIMmgILAkACQAJAAkAgAS0AAEEKaw4XAgMDAAMDAwMDAwMDAwMDAwMDAwMDAwEDCyABQQFqDAULIAFBAWohAUG5ASECDIECCyABQQFqIQEgA0Evai0AAEEBcQ0IIANBADYCHCADIAE2AhQgA0GFCzYCECADQQ02AgxBACECDJoCCyADQQA2AhwgAyABNgIUIANBhQs2AhAgA0ENNgIMQQAhAgyZAgsgASAERwRAIANBDjYCCCADIAE2AgRBASECDP8BC0HSASECDJgCCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtB0QEhAgyZAgsgAygCBCEAIANBADYCBCADIAAgARAsIgBFBEAgAUEBaiEBDAQLIANB0AE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMmAILIAMoAgQhACADQQA2AgQgAyAAIAEQLCIADQEgAUEBagshAUG3ASECDPwBCyADQc8BNgIcIAMgADYCDCADIAFBAWo2AhRBACECDJUCC0G4ASECDPoBCyADQS9qLQAAQQFxDQEgA0EANgIcIAMgATYCFCADQc8bNgIQIANBGTYCDEEAIQIMkwILIAEgBEYEQEHPASECDJMCCwJAAkACQCABLQAAQQprDgQBAgIAAgsgAUEBaiEBDAILIAFBAWohAQwBCyADLQAuQcAAcUUNAQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsgAEUNlgEgAEEVRgRAIANB2QA2AhwgAyABNgIUIANBvRk2AhAgA0EVNgIMQQAhAgySAgsgA0EANgIcIAMgATYCFCADQfgMNgIQIANBGzYCDEEAIQIMkQILIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDJACCyABIARHBEAgA0EMNgIIIAMgATYCBEG1ASECDPYBC0HOASECDI8CCyABIARGBEBBzQEhAgyPAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBwQBrDhUAAQIDWgQFBlpaWgcICQoLDA0ODxBaCyABQQFqIQFB8QAhAgyEAgsgAUEBaiEBQfIAIQIMgwILIAFBAWohAUH3ACECDIICCyABQQFqIQFB+wAhAgyBAgsgAUEBaiEBQfwAIQIMgAILIAFBAWohAUH/ACECDP8BCyABQQFqIQFBgAEhAgz+AQsgAUEBaiEBQYMBIQIM/QELIAFBAWohAUGMASECDPwBCyABQQFqIQFBjQEhAgz7AQsgAUEBaiEBQY4BIQIM+gELIAFBAWohAUGbASECDPkBCyABQQFqIQFBnAEhAgz4AQsgAUEBaiEBQaIBIQIM9wELIAFBAWohAUGqASECDPYBCyABQQFqIQFBrQEhAgz1AQsgAUEBaiEBQbQBIQIM9AELIAEgBEYEQEHMASECDI4CCyABLQAAQc4ARw1IIAFBAWohAUGzASECDPMBCyABIARGBEBBywEhAgyNAgsCQAJAAkAgAS0AAEHCAGsOEgBKSkpKSkpKSkoBSkpKSkpKAkoLIAFBAWohAUGuASECDPQBCyABQQFqIQFBsQEhAgzzAQsgAUEBaiEBQbIBIQIM8gELQcoBIQIgASAERg2LAiADKAIAIgAgBCABa2ohBSABIABrQQdqIQYCQANAIAEtAAAgAEHo0wBqLQAARw1FIABBB0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyMAgsgA0EANgIAIAZBAWohAUEbDEULIAEgBEYEQEHJASECDIsCCwJAAkAgAS0AAEHJAGsOBwBHR0dHRwFHCyABQQFqIQFBrwEhAgzxAQsgAUEBaiEBQbABIQIM8AELQcgBIQIgASAERg2JAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHm0wBqLQAARw1DIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyKAgsgA0EANgIAIAZBAWohAUEPDEMLQccBIQIgASAERg2IAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHk0wBqLQAARw1CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyJAgsgA0EANgIAIAZBAWohAUEgDEILQcYBIQIgASAERg2HAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw1BIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyIAgsgA0EANgIAIAZBAWohAUESDEELIAEgBEYEQEHFASECDIcCCwJAAkAgAS0AAEHFAGsODgBDQ0NDQ0NDQ0NDQ0MBQwsgAUEBaiEBQasBIQIM7QELIAFBAWohAUGsASECDOwBC0HEASECIAEgBEYNhQIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB3tMAai0AAEcNPyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhgILIANBADYCACAGQQFqIQFBBww/C0HDASECIAEgBEYNhAIgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABB2NMAai0AAEcNPiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhQILIANBADYCACAGQQFqIQFBKAw+CyABIARGBEBBwgEhAgyEAgsCQAJAAkAgAS0AAEHFAGsOEQBBQUFBQUFBQUEBQUFBQUECQQsgAUEBaiEBQacBIQIM6wELIAFBAWohAUGoASECDOoBCyABQQFqIQFBqQEhAgzpAQtBwQEhAiABIARGDYICIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQdHTAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIMCCyADQQA2AgAgBkEBaiEBQRoMPAtBwAEhAiABIARGDYECIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQc3TAGotAABHDTsgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIICCyADQQA2AgAgBkEBaiEBQSEMOwsgASAERgRAQb8BIQIMgQILAkACQCABLQAAQcEAaw4UAD09PT09PT09PT09PT09PT09PQE9CyABQQFqIQFBowEhAgznAQsgAUEBaiEBQaYBIQIM5gELIAEgBEYEQEG+ASECDIACCwJAAkAgAS0AAEHVAGsOCwA8PDw8PDw8PDwBPAsgAUEBaiEBQaQBIQIM5gELIAFBAWohAUGlASECDOUBC0G9ASECIAEgBEYN/gEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNOCAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/wELIANBADYCACAGQQFqIQFBKgw4CyABIARGBEBBvAEhAgz+AQsgAS0AAEHQAEcNOCABQQFqIQFBJQw3C0G7ASECIAEgBEYN/AEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBwdMAai0AAEcNNiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/QELIANBADYCACAGQQFqIQFBDgw2CyABIARGBEBBugEhAgz8AQsgAS0AAEHFAEcNNiABQQFqIQFBoQEhAgzhAQsgASAERgRAQbkBIQIM+wELAkACQAJAAkAgAS0AAEHCAGsODwABAjk5OTk5OTk5OTk5AzkLIAFBAWohAUGdASECDOMBCyABQQFqIQFBngEhAgziAQsgAUEBaiEBQZ8BIQIM4QELIAFBAWohAUGgASECDOABC0G4ASECIAEgBEYN+QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBvtMAai0AAEcNMyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+gELIANBADYCACAGQQFqIQFBFAwzC0G3ASECIAEgBEYN+AEgAygCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBudMAai0AAEcNMiAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+QELIANBADYCACAGQQFqIQFBKwwyC0G2ASECIAEgBEYN9wEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBttMAai0AAEcNMSAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+AELIANBADYCACAGQQFqIQFBLAwxC0G1ASECIAEgBEYN9gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB4dMAai0AAEcNMCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9wELIANBADYCACAGQQFqIQFBEQwwC0G0ASECIAEgBEYN9QEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBstMAai0AAEcNLyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9gELIANBADYCACAGQQFqIQFBLgwvCyABIARGBEBBswEhAgz1AQsCQAJAAkACQAJAIAEtAABBwQBrDhUANDQ0NDQ0NDQ0NAE0NAI0NAM0NAQ0CyABQQFqIQFBkQEhAgzeAQsgAUEBaiEBQZIBIQIM3QELIAFBAWohAUGTASECDNwBCyABQQFqIQFBmAEhAgzbAQsgAUEBaiEBQZoBIQIM2gELIAEgBEYEQEGyASECDPQBCwJAAkAgAS0AAEHSAGsOAwAwATALIAFBAWohAUGZASECDNoBCyABQQFqIQFBBAwtC0GxASECIAEgBEYN8gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBsNMAai0AAEcNLCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM8wELIANBADYCACAGQQFqIQFBHQwsCyABIARGBEBBsAEhAgzyAQsCQAJAIAEtAABByQBrDgcBLi4uLi4ALgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMDAAELIAFBAWohAUErIQIMYQsgAEE6Rw0BIANBADYCHCADIAE2AhQgA0G5ETYCECADQQo2AgxBACECDHoLIAFBAWohASADQS9qLQAAQQFxRQ1tIAMtADJBgAFxRQRAIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsCQAJAIAAOFkpJSAEBAQEBAQEBAQEBAQEBAQEBAQABCyADQSk2AhwgAyABNgIUIANBshg2AhAgA0EVNgIMQQAhAgx7CyADQQA2AhwgAyABNgIUIANB3Qs2AhAgA0ERNgIMQQAhAgx6C0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAARQ1VIABBFUcNASADQQU2AhwgAyABNgIUIANBhho2AhAgA0EVNgIMQQAhAgx5C0HKACECDF4LQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDHcLIAMgAy8BMkGAAXI7ATIMOAsgASAERwRAIANBEDYCCCADIAE2AgRByQAhAgxcC0HXACECDHULIAEgBEYEQEHWACECDHULAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAPT09PT09PT09PT09AT09PQIDPQsgAUEBaiEBQcUAIQIMXQsgAUEBaiEBQcYAIQIMXAsgAUEBaiEBQccAIQIMWwsgAUEBaiEBQcgAIQIMWgtB1QAhAiAEIAEiAEYNcyAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcDQCABQcDGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQhBBCABQQVGDQoaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHMLQdQAIQIgBCABIgBGDXIgBCABayADKAIAIgFqIQYgACABa0EPaiEHA0AgAUGwxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0HQQMgAUEPRg0JGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxyC0HTACECIAQgASIARg1xIAQgAWsgAygCACIBaiEGIAAgAWtBDmohBwNAIAFBksYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNBiABQQ5GDQcgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMcQtB0gAhAiAEIAEiAEYNcCAEIAFrIAMoAgAiAWohBSAAIAFrQQFqIQYDQCABQZDGAGotAAAgAC0AACIHQSByIAcgB0HBAGtB/wFxQRpJG0H/AXFHDQUgAUEBRg0CIAFBAWohASAEIABBAWoiAEcNAAsgAyAFNgIADHALIAEgBEYEQEHRACECDHALAkACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcUHuAGsOBwA2NjY2NgE2CyABQQFqIQFBwgAhAgxWCyABQQFqIQFBwwAhAgxVCyADQQA2AgAgBkEBaiEBQcQAIQIMVAtB0AAhAiAEIAEiAEYNbSAEIAFrIAMoAgAiAWohBiAAIAFrQQlqIQcDQCABQYbGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQJBAiABQQlGDQQaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADG0LQc8AIQIgBCABIgBGDWwgBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUGAxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxsCyAAIQEgA0EANgIADDALQQELOgAsIANBADYCACAHQQFqIQELQSwhAgxOCwJAA0AgAS0AAEGAxABqLQAAQQFHDQEgBCABQQFqIgFHDQALQc0AIQIMaAtBwQAhAgxNCyABIARGBEBBzAAhAgxnCyABLQAAQTpGBEAgAygCBCEAIANBADYCBCADIAAgARAvIgBFDTAgA0HLADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxnCyADQQA2AhwgAyABNgIUIANBuRE2AhAgA0EKNgIMQQAhAgxmCwJAAkAgAy0ALEECaw4CAAEkCyADQTNqLQAAQQJxRQ0jIAMtAC5BAnENIyADQQA2AhwgAyABNgIUIANB1RM2AhAgA0ELNgIMQQAhAgxmCyADLQAyQSBxRQ0iIAMtAC5BAnENIiADQQA2AhwgAyABNgIUIANB7BI2AhAgA0EPNgIMQQAhAgxlC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQRAQcAAIQIMSwsgAEEVRwRAIANBADYCHCADIAE2AhQgA0H4DjYCECADQRw2AgxBACECDGULIANBygA2AhwgAyABNgIUIANB8Bo2AhAgA0EVNgIMQQAhAgxkCyABIARHBEADQCABLQAAQfA/ai0AAEEBRw0XIAQgAUEBaiIBRw0AC0HEACECDGQLQcQAIQIMYwsgASAERwRAA0ACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcSIAQQlGDQAgAEEgRg0AAkACQAJAAkAgAEHjAGsOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBNSECDE4LIAFBAWohAUE2IQIMTQsgAUEBaiEBQTchAgxMCwwVCyAEIAFBAWoiAUcNAAtBPCECDGMLQTwhAgxiCyABIARGBEBByAAhAgxiCyADQRE2AgggAyABNgIEAkACQAJAAkACQCADLQAsQQFrDgQUAAECCQsgAy0AMkEgcQ0DQdEBIQIMSwsCQCADLwEyIgBBCHFFDQAgAy0AKEEBRw0AIAMtAC5BCHFFDQILIAMgAEH3+wNxQYAEcjsBMgwLCyADIAMvATJBEHI7ATIMBAsgA0EANgIEIAMgASABEDAiAARAIANBwQA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMYwsgAUEBaiEBDFILIANBADYCHCADIAE2AhQgA0GjEzYCECADQQQ2AgxBACECDGELQccAIQIgASAERg1gIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEHwwwBqLQAAIAEtAABBIHJHDQEgAEEGRg1GIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADGELIANBADYCAAwFCwJAIAEgBEcEQANAIAEtAABB8MEAai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBxQAhAgxhC0HFACECDGALCyADQQA6ACwMAQtBCyECDEMLQT4hAgxCCwJAAkADQCABLQAAIgBBIEcEQAJAIABBCmsOBAMFBQMACyAAQSxGDQMMBAsgBCABQQFqIgFHDQALQcYAIQIMXQsgA0EIOgAsDA4LIAMtAChBAUcNAiADLQAuQQhxDQIgAygCBCEAIANBADYCBCADIAAgARAwIgAEQCADQcIANgIcIAMgADYCDCADIAFBAWo2AhRBACECDFwLIAFBAWohAQxKC0E6IQIMQAsCQANAIAEtAAAiAEEgRyAAQQlHcQ0BIAQgAUEBaiIBRw0AC0HDACECDFoLC0E7IQIMPgsCQAJAIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBAMEBAMECyAEIAFBAWoiAUcNAAtBPyECDFoLQT8hAgxZCyADIAMvATJBIHI7ATIMCgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFDUggA0E+NgIcIAMgATYCFCADIAA2AgxBACECDFcLAkAgASAERwRAA0AgAS0AAEHwwQBqLQAAIgBBAUcEQCAAQQJGDQMMDAsgBCABQQFqIgFHDQALQTchAgxYC0E3IQIMVwsgAUEBaiEBDAQLQTshAiAEIAEiAEYNVSAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcCQANAIAFBwMYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQVGBEBBByEBDDsLIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFYLIANBADYCACAAIQEMBQtBOiECIAQgASIARg1UIAQgAWsgAygCACIBaiEGIAAgAWtBCGohBwJAA0AgAUHkP2otAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEIRgRAQQUhAQw6CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxVCyADQQA2AgAgACEBDAQLQTkhAiAEIAEiAEYNUyAEIAFrIAMoAgAiAWohBiAAIAFrQQNqIQcCQANAIAFB4D9qLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBA0YEQEEGIQEMOQsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMVAsgA0EANgIAIAAhAQwDCwJAA0AgAS0AACIAQSBHBEAgAEEKaw4EBwQEBwILIAQgAUEBaiIBRw0AC0E4IQIMUwsgAEEsRw0BIAFBAWohAEEBIQECQAJAAkACQAJAIAMtACxBBWsOBAMBAgQACyAAIQEMBAtBAiEBDAELQQQhAQsgA0EBOgAsIAMgAy8BMiABcjsBMiAAIQEMAQsgAyADLwEyQQhyOwEyIAAhAQtBPSECDDcLIANBADoALAtBOCECDDULIAEgBEYEQEE2IQIMTwsCQAJAAkACQAJAIAEtAABBCmsOBAACAgECCyADKAIEIQAgA0EANgIEIAMgACABEDAiAEUNAiADQTM2AhwgAyABNgIUIAMgADYCDEEAIQIMUgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFBEAgAUEBaiEBDAYLIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxRCyADLQAuQQFxBEBB0AEhAgw3CyADKAIEIQAgA0EANgIEIAMgACABEDAiAA0BDEMLQTMhAgw1CyADQTU2AhwgAyABNgIUIAMgADYCDEEAIQIMTgtBNCECDDMLIANBL2otAABBAXENACADQQA2AhwgAyABNgIUIANB8RU2AhAgA0EZNgIMQQAhAgxMC0EyIQIMMQsgASAERgRAQTIhAgxLCwJAIAEtAABBCkYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZgWNgIQIANBAzYCDEEAIQIMSwtBMSECDDALIAEgBEYEQEExIQIMSgsgAS0AACIAQQlHIABBIEdxDQEgAy0ALEEIRw0AIANBADoALAtBPCECDC4LQQEhAgJAAkACQAJAIAMtACxBBWsOBAMBAgAKCyADIAMvATJBCHI7ATIMCQtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgwGCyABIARGBEBBMCECDEcLIAEtAABBCkYEQCABQQFqIQEMAQsgAy0ALkEBcQ0AIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDEYLQS8hAgwrCyABQQFqIQFBMCECDCoLIAEgBEYEQEEvIQIMRAsgAS0AACIAQQlHIABBIEdxRQRAIAFBAWohASADLQAuQQFxDQEgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIMRAtBASECAkACQAJAAkACQAJAIAMtACxBAmsOBwUEBAMBAgAECyADIAMvATJBCHI7ATIMAwtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgtBLiECDCoLIANBADYCHCADIAE2AhQgA0GzEjYCECADQQs2AgxBACECDEMLQdIBIQIMKAsgASAERgRAQS4hAgxCCyADQQA2AgQgA0ERNgIIIAMgASABEDAiAA0BC0EtIQIMJgsgA0EtNgIcIAMgATYCFCADIAA2AgxBACECDD8LQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2AA2AhwgAyABNgIUIANBnho2AhAgA0EVNgIMQQAhAgw+C0HLACECDCMLIANBADYCHCADIAE2AhQgA0GFDjYCECADQR02AgxBACECDDwLIAEgBEYEQEHOACECDDwLIAEtAAAiAEEgRg0CIABBOkYNAQsgA0EAOgAsQQkhAgwgCyADKAIEIQAgA0EANgIEIAMgACABEC8iAA0BDAILIAMtAC5BAXEEQEHPASECDB8LIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ0CIANBKjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgw4CyADQcsANgIcIAMgADYCDCADIAFBAWo2AhRBACECDDcLIAFBAWohAUE/IQIMHAsgAUEBaiEBDCkLIAEgBEYEQEErIQIMNQsCQCABLQAAQQpGBEAgAUEBaiEBDAELIAMtAC5BwABxRQ0GCyADLQAyQYABcQRAQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIABFDREgAEEVRgRAIANBBTYCHCADIAE2AhQgA0GGGjYCECADQRU2AgxBACECDDYLIANBADYCHCADIAE2AhQgA0HiDTYCECADQRQ2AgxBACECDDULIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsgAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIANBAToAMAsgAiACLwEAQcAAcjsBAAtBKiECDBcLIANBKTYCHCADIAE2AhQgA0GyGDYCECADQRU2AgxBACECDDALIANBADYCHCADIAE2AhQgA0HdCzYCECADQRE2AgxBACECDC8LIANBADYCHCADIAE2AhQgA0GdCzYCECADQQI2AgxBACECDC4LQQEhByADLwEyIgVBCHFFBEAgAykDIEIAUiEHCwJAIAMtADAEQEEBIQAgAy0AKUEFRg0BIAVBwABxRSAHcUUNAQsCQCADLQAoIgJBAkYEQEEBIQAgAy8BNCIGQeUARg0CQQAhACAFQcAAcQ0CIAZB5ABGDQIgBkHmAGtBAkkNAiAGQcwBRg0CIAZBsAJGDQIMAQtBACEAIAVBwABxDQELQQIhACAFQQhxDQAgBUGABHEEQAJAIAJBAUcNACADLQAuQQpxDQBBBSEADAILQQQhAAwBCyAFQSBxRQRAIAMQNUEAR0ECdCEADAELQQBBAyADKQMgUBshAAsCQCAAQQFrDgUAAQYHAgMLQQAhAgJAIAMoAjgiAEUNACAAKAIsIgBFDQAgAyAAEQAAIQILIAJFDSYgAkEVRgRAIANBAzYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDC4LQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDC0LQc4BIQIMEgtBACECIANBADYCHCADIAE2AhQgA0HkHzYCECADQQ82AgwMKwtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAA0BC0EOIQIMDwsgAEEVRgRAIANBAjYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDCkLQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDCgLQSkhAgwNCyADQQE6ADEMJAsgASAERwRAIANBCTYCCCADIAE2AgRBKCECDAwLQSYhAgwlCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMVARAQSUhAgwlCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDQAgA0EFNgIcIAMgATYCFCADIAA2AgwMJAtBDyECDAkLIAEgBEYEQEEjIQIMIwtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsONxcWAAECAwQFBgcUFBQUFBQUCAkKCwwNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQODxAREhMUC0ICIQoMFgtCAyEKDBULQgQhCgwUC0IFIQoMEwtCBiEKDBILQgchCgwRC0IIIQoMEAtCCSEKDA8LQgohCgwOC0ILIQoMDQtCDCEKDAwLQg0hCgwLC0IOIQoMCgtCDyEKDAkLQgohCgwIC0ILIQoMBwtCDCEKDAYLQg0hCgwFC0IOIQoMBAtCDyEKDAMLQQAhAiADQQA2AhwgAyABNgIUIANBzhQ2AhAgA0EMNgIMDCILIAEgBEYEQEEiIQIMIgtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYCECAAQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAIgAEEEcUEYciICayIBQSBJDQAgACACaiEAA0AgAEIANwMYIABCADcDECAAQgA3AwggAEIANwMAIABBIGohACABQSBrIgFBH0sNAAsLC1YBAX8CQCAAKAIMDQACQAJAAkACQCAALQAxDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgAREAACIBDQMLQQAPCwALIABB0Bg2AhBBDiEBCyABCxoAIAAoAgxFBEAgAEHJHjYCECAAQRU2AgwLCxQAIAAoAgxBFUYEQCAAQQA2AgwLCxQAIAAoAgxBFkYEQCAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsXACAAQSRPBEAACyAAQQJ0QZQ3aigCAAsXACAAQS9PBEAACyAAQQJ0QaQ4aigCAAu/CQEBf0HfLCEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHkAGsO9ANjYgABYWFhYWFhAgMEBWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEGBwgJCgsMDQ4PYWFhYWEQYWFhYWFhYWFhYWERYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhEhMUFRYXGBkaG2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEcHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTZhNzg5OmFhYWFhYWFhO2FhYTxhYWFhPT4/YWFhYWFhYWFAYWFBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhQkNERUZHSElKS0xNTk9QUVJTYWFhYWFhYWFUVVZXWFlaW2FcXWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYV5hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFfYGELQdUrDwtBgyUPC0G/MA8LQfI1DwtBtCgPC0GfKA8LQYEsDwtB1ioPC0H0Mw8LQa0zDwtByygPC0HOIw8LQcAjDwtB2SMPC0HRJA8LQZwzDwtBojYPC0H8Mw8LQeArDwtB4SUPC0HtIA8LQcQyDwtBqScPC0G5Ng8LQbggDwtBqyAPC0GjJA8LQbYkDwtBgSMPC0HhMg8LQZ80DwtByCkPC0HAMg8LQe4yDwtB8C8PC0HGNA8LQdAhDwtBmiQPC0HrLw8LQYQ1DwtByzUPC0GWMQ8LQcgrDwtB1C8PC0GTMA8LQd81DwtBtCMPC0G+NQ8LQdIpDwtBsyIPC0HNIA8LQZs2DwtBkCEPC0H/IA8LQa01DwtBsDQPC0HxJA8LQacqDwtB3TAPC0GLIg8LQcgvDwtB6yoPC0H0KQ8LQY8lDwtB3SIPC0HsJg8LQf0wDwtB1iYPC0GUNQ8LQY0jDwtBuikPC0HHIg8LQfIlDwtBtjMPC0GiIQ8LQf8vDwtBwCEPC0GBMw8LQcklDwtBqDEPC0HGMw8LQdM2DwtBxjYPC0HkNA8LQYgmDwtB7ScPC0H4IQ8LQakwDwtBjzQPC0GGNg8LQaovDwtBoSYPC0HsNg8LQZIpDwtBryYPC0GZIg8LQeAhDwsAC0G1JSEBCyABCxcAIAAgAC8BLkH+/wNxIAFBAEdyOwEuCxoAIAAgAC8BLkH9/wNxIAFBAEdBAXRyOwEuCxoAIAAgAC8BLkH7/wNxIAFBAEdBAnRyOwEuCxoAIAAgAC8BLkH3/wNxIAFBAEdBA3RyOwEuCxoAIAAgAC8BLkHv/wNxIAFBAEdBBHRyOwEuCxoAIAAgAC8BLkHf/wNxIAFBAEdBBXRyOwEuCxoAIAAgAC8BLkG//wNxIAFBAEdBBnRyOwEuCxoAIAAgAC8BLkH//gNxIAFBAEdBB3RyOwEuCxoAIAAgAC8BLkH//QNxIAFBAEdBCHRyOwEuCxoAIAAgAC8BLkH/+wNxIAFBAEdBCXRyOwEuCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBzhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5Ao2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5R02AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBnRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBoh42AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7hQ2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9xs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRU2AhBBGCEECyAECzgAIAACfyAALwEyQRRxQRRGBEBBASAALQAoQQFGDQEaIAAvATRB5QBGDAELIAAtAClBBUYLOgAwC1kBAn8CQCAALQAoQQFGDQAgAC8BNCIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMiIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEyIgFBAnFFDQEMAgsgAC8BMiIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATQiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtzACAAQRBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAA/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQTBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQSBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQewBNgIcCwYAIAAQOQuaLQELfyMAQRBrIgokAEGY1AAoAgAiCUUEQEHY1wAoAgAiBUUEQEHk1wBCfzcCAEHc1wBCgICEgICAwAA3AgBB2NcAIApBCGpBcHFB2KrVqgVzIgU2AgBB7NcAQQA2AgBBvNcAQQA2AgALQcDXAEGA2AQ2AgBBkNQAQYDYBDYCAEGk1AAgBTYCAEGg1ABBfzYCAEHE1wBBgKgDNgIAA0AgAUG81ABqIAFBsNQAaiICNgIAIAIgAUGo1ABqIgM2AgAgAUG01ABqIAM2AgAgAUHE1ABqIAFBuNQAaiIDNgIAIAMgAjYCACABQczUAGogAUHA1ABqIgI2AgAgAiADNgIAIAFByNQAaiACNgIAIAFBIGoiAUGAAkcNAAtBjNgEQcGnAzYCAEGc1ABB6NcAKAIANgIAQYzUAEHApwM2AgBBmNQAQYjYBDYCAEHM/wdBODYCAEGI2AQhCQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQewBTQRAQYDUACgCACIGQRAgAEETakFwcSAAQQtJGyIEQQN2IgB2IgFBA3EEQAJAIAFBAXEgAHJBAXMiAkEDdCIAQajUAGoiASAAQbDUAGooAgAiACgCCCIDRgRAQYDUACAGQX4gAndxNgIADAELIAEgAzYCCCADIAE2AgwLIABBCGohASAAIAJBA3QiAkEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwRC0GI1AAoAgAiCCAETw0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cWgiAEEDdCICQajUAGoiASACQbDUAGooAgAiAigCCCIDRgRAQYDUACAGQX4gAHdxIgY2AgAMAQsgASADNgIIIAMgATYCDAsgAiAEQQNyNgIEIABBA3QiACAEayEFIAAgAmogBTYCACACIARqIgQgBUEBcjYCBCAIBEAgCEF4cUGo1ABqIQBBlNQAKAIAIQMCf0EBIAhBA3Z0IgEgBnFFBEBBgNQAIAEgBnI2AgAgAAwBCyAAKAIICyIBIAM2AgwgACADNgIIIAMgADYCDCADIAE2AggLIAJBCGohAUGU1AAgBDYCAEGI1AAgBTYCAAwRC0GE1AAoAgAiC0UNASALaEECdEGw1gBqKAIAIgAoAgRBeHEgBGshBSAAIQIDQAJAIAIoAhAiAUUEQCACQRRqKAIAIgFFDQELIAEoAgRBeHEgBGsiAyAFSSECIAMgBSACGyEFIAEgACACGyEAIAEhAgwBCwsgACgCGCEJIAAoAgwiAyAARwRAQZDUACgCABogAyAAKAIIIgE2AgggASADNgIMDBALIABBFGoiAigCACIBRQRAIAAoAhAiAUUNAyAAQRBqIQILA0AgAiEHIAEiA0EUaiICKAIAIgENACADQRBqIQIgAygCECIBDQALIAdBADYCAAwPC0F/IQQgAEG/f0sNACAAQRNqIgFBcHEhBEGE1AAoAgAiCEUNAEEAIARrIQUCQAJAAkACf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QbDWAGooAgAiAkUEQEEAIQFBACEDDAELQQAhASAEQRkgBkEBdmtBACAGQR9HG3QhAEEAIQMDQAJAIAIoAgRBeHEgBGsiByAFTw0AIAIhAyAHIgUNAEEAIQUgAiEBDAMLIAEgAkEUaigCACIHIAcgAiAAQR12QQRxakEQaigCACICRhsgASAHGyEBIABBAXQhACACDQALCyABIANyRQRAQQAhA0ECIAZ0IgBBACAAa3IgCHEiAEUNAyAAaEECdEGw1gBqKAIAIQELIAFFDQELA0AgASgCBEF4cSAEayICIAVJIQAgAiAFIAAbIQUgASADIAAbIQMgASgCECIABH8gAAUgAUEUaigCAAsiAQ0ACwsgA0UNACAFQYjUACgCACAEa08NACADKAIYIQcgAyADKAIMIgBHBEBBkNQAKAIAGiAAIAMoAggiATYCCCABIAA2AgwMDgsgA0EUaiICKAIAIgFFBEAgAygCECIBRQ0DIANBEGohAgsDQCACIQYgASIAQRRqIgIoAgAiAQ0AIABBEGohAiAAKAIQIgENAAsgBkEANgIADA0LQYjUACgCACIDIARPBEBBlNQAKAIAIQECQCADIARrIgJBEE8EQCABIARqIgAgAkEBcjYCBCABIANqIAI2AgAgASAEQQNyNgIEDAELIAEgA0EDcjYCBCABIANqIgAgACgCBEEBcjYCBEEAIQBBACECC0GI1AAgAjYCAEGU1AAgADYCACABQQhqIQEMDwtBjNQAKAIAIgMgBEsEQCAEIAlqIgAgAyAEayIBQQFyNgIEQZjUACAANgIAQYzUACABNgIAIAkgBEEDcjYCBCAJQQhqIQEMDwtBACEBIAQCf0HY1wAoAgAEQEHg1wAoAgAMAQtB5NcAQn83AgBB3NcAQoCAhICAgMAANwIAQdjXACAKQQxqQXBxQdiq1aoFczYCAEHs1wBBADYCAEG81wBBADYCAEGAgAQLIgAgBEHHAGoiBWoiBkEAIABrIgdxIgJPBEBB8NcAQTA2AgAMDwsCQEG41wAoAgAiAUUNAEGw1wAoAgAiCCACaiEAIAAgAU0gACAIS3ENAEEAIQFB8NcAQTA2AgAMDwtBvNcALQAAQQRxDQQCQAJAIAkEQEHA1wAhAQNAIAEoAgAiACAJTQRAIAAgASgCBGogCUsNAwsgASgCCCIBDQALC0EAEDoiAEF/Rg0FIAIhBkHc1wAoAgAiAUEBayIDIABxBEAgAiAAayAAIANqQQAgAWtxaiEGCyAEIAZPDQUgBkH+////B0sNBUG41wAoAgAiAwRAQbDXACgCACIHIAZqIQEgASAHTQ0GIAEgA0sNBgsgBhA6IgEgAEcNAQwHCyAGIANrIAdxIgZB/v///wdLDQQgBhA6IQAgACABKAIAIAEoAgRqRg0DIAAhAQsCQCAGIARByABqTw0AIAFBf0YNAEHg1wAoAgAiACAFIAZrakEAIABrcSIAQf7///8HSwRAIAEhAAwHCyAAEDpBf0cEQCAAIAZqIQYgASEADAcLQQAgBmsQOhoMBAsgASIAQX9HDQUMAwtBACEDDAwLQQAhAAwKCyAAQX9HDQILQbzXAEG81wAoAgBBBHI2AgALIAJB/v///wdLDQEgAhA6IQBBABA6IQEgAEF/Rg0BIAFBf0YNASAAIAFPDQEgASAAayIGIARBOGpNDQELQbDXAEGw1wAoAgAgBmoiATYCAEG01wAoAgAgAUkEQEG01wAgATYCAAsCQAJAAkBBmNQAKAIAIgIEQEHA1wAhAQNAIAAgASgCACIDIAEoAgQiBWpGDQIgASgCCCIBDQALDAILQZDUACgCACIBQQBHIAAgAU9xRQRAQZDUACAANgIAC0EAIQFBxNcAIAY2AgBBwNcAIAA2AgBBoNQAQX82AgBBpNQAQdjXACgCADYCAEHM1wBBADYCAANAIAFBvNQAaiABQbDUAGoiAjYCACACIAFBqNQAaiIDNgIAIAFBtNQAaiADNgIAIAFBxNQAaiABQbjUAGoiAzYCACADIAI2AgAgAUHM1ABqIAFBwNQAaiICNgIAIAIgAzYCACABQcjUAGogAjYCACABQSBqIgFBgAJHDQALQXggAGtBD3EiASAAaiICIAZBOGsiAyABayIBQQFyNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAE2AgBBmNQAIAI2AgAgACADakE4NgIEDAILIAAgAk0NACACIANJDQAgASgCDEEIcQ0AQXggAmtBD3EiACACaiIDQYzUACgCACAGaiIHIABrIgBBAXI2AgQgASAFIAZqNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAA2AgBBmNQAIAM2AgAgAiAHakE4NgIEDAELIABBkNQAKAIASQRAQZDUACAANgIACyAAIAZqIQNBwNcAIQECQAJAAkADQCADIAEoAgBHBEAgASgCCCIBDQEMAgsLIAEtAAxBCHFFDQELQcDXACEBA0AgASgCACIDIAJNBEAgAyABKAIEaiIFIAJLDQMLIAEoAgghAQwACwALIAEgADYCACABIAEoAgQgBmo2AgQgAEF4IABrQQ9xaiIJIARBA3I2AgQgA0F4IANrQQ9xaiIGIAQgCWoiBGshASACIAZGBEBBmNQAIAQ2AgBBjNQAQYzUACgCACABaiIANgIAIAQgAEEBcjYCBAwIC0GU1AAoAgAgBkYEQEGU1AAgBDYCAEGI1ABBiNQAKAIAIAFqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwICyAGKAIEIgVBA3FBAUcNBiAFQXhxIQggBUH/AU0EQCAFQQN2IQMgBigCCCIAIAYoAgwiAkYEQEGA1ABBgNQAKAIAQX4gA3dxNgIADAcLIAIgADYCCCAAIAI2AgwMBgsgBigCGCEHIAYgBigCDCIARwRAIAAgBigCCCICNgIIIAIgADYCDAwFCyAGQRRqIgIoAgAiBUUEQCAGKAIQIgVFDQQgBkEQaiECCwNAIAIhAyAFIgBBFGoiAigCACIFDQAgAEEQaiECIAAoAhAiBQ0ACyADQQA2AgAMBAtBeCAAa0EPcSIBIABqIgcgBkE4ayIDIAFrIgFBAXI2AgQgACADakE4NgIEIAIgBUE3IAVrQQ9xakE/ayIDIAMgAkEQakkbIgNBIzYCBEGc1ABB6NcAKAIANgIAQYzUACABNgIAQZjUACAHNgIAIANBEGpByNcAKQIANwIAIANBwNcAKQIANwIIQcjXACADQQhqNgIAQcTXACAGNgIAQcDXACAANgIAQczXAEEANgIAIANBJGohAQNAIAFBBzYCACAFIAFBBGoiAUsNAAsgAiADRg0AIAMgAygCBEF+cTYCBCADIAMgAmsiBTYCACACIAVBAXI2AgQgBUH/AU0EQCAFQXhxQajUAGohAAJ/QYDUACgCACIBQQEgBUEDdnQiA3FFBEBBgNQAIAEgA3I2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEGw1gBqIQBBhNQAKAIAIgNBASABdCIGcUUEQCAAIAI2AgBBhNQAIAMgBnI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEDAkADQCADIgAoAgRBeHEgBUYNASABQR12IQMgAUEBdCEBIAAgA0EEcWpBEGoiBigCACIDDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLQYzUACgCACIBIARNDQBBmNQAKAIAIgAgBGoiAiABIARrIgFBAXI2AgRBjNQAIAE2AgBBmNQAIAI2AgAgACAEQQNyNgIEIABBCGohAQwIC0EAIQFB8NcAQTA2AgAMBwtBACEACyAHRQ0AAkAgBigCHCICQQJ0QbDWAGoiAygCACAGRgRAIAMgADYCACAADQFBhNQAQYTUACgCAEF+IAJ3cTYCAAwCCyAHQRBBFCAHKAIQIAZGG2ogADYCACAARQ0BCyAAIAc2AhggBigCECICBEAgACACNgIQIAIgADYCGAsgBkEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgCGohASAGIAhqIgYoAgQhBQsgBiAFQX5xNgIEIAEgBGogATYCACAEIAFBAXI2AgQgAUH/AU0EQCABQXhxQajUAGohAAJ/QYDUACgCACICQQEgAUEDdnQiAXFFBEBBgNQAIAEgAnI2AgAgAAwBCyAAKAIICyIBIAQ2AgwgACAENgIIIAQgADYCDCAEIAE2AggMAQtBHyEFIAFB////B00EQCABQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQULIAQgBTYCHCAEQgA3AhAgBUECdEGw1gBqIQBBhNQAKAIAIgJBASAFdCIDcUUEQCAAIAQ2AgBBhNQAIAIgA3I2AgAgBCAANgIYIAQgBDYCCCAEIAQ2AgwMAQsgAUEZIAVBAXZrQQAgBUEfRxt0IQUgACgCACEAAkADQCAAIgIoAgRBeHEgAUYNASAFQR12IQAgBUEBdCEFIAIgAEEEcWpBEGoiAygCACIADQALIAMgBDYCACAEIAI2AhggBCAENgIMIAQgBDYCCAwBCyACKAIIIgAgBDYCDCACIAQ2AgggBEEANgIYIAQgAjYCDCAEIAA2AggLIAlBCGohAQwCCwJAIAdFDQACQCADKAIcIgFBAnRBsNYAaiICKAIAIANGBEAgAiAANgIAIAANAUGE1AAgCEF+IAF3cSIINgIADAILIAdBEEEUIAcoAhAgA0YbaiAANgIAIABFDQELIAAgBzYCGCADKAIQIgEEQCAAIAE2AhAgASAANgIYCyADQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAFQQ9NBEAgAyAEIAVqIgBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQMAQsgAyAEaiICIAVBAXI2AgQgAyAEQQNyNgIEIAIgBWogBTYCACAFQf8BTQRAIAVBeHFBqNQAaiEAAn9BgNQAKAIAIgFBASAFQQN2dCIFcUUEQEGA1AAgASAFcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbDWAGohAEEBIAF0IgQgCHFFBEAgACACNgIAQYTUACAEIAhyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhBAJAA0AgBCIAKAIEQXhxIAVGDQEgAUEddiEEIAFBAXQhASAAIARBBHFqQRBqIgYoAgAiBA0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIICyADQQhqIQEMAQsCQCAJRQ0AAkAgACgCHCIBQQJ0QbDWAGoiAigCACAARgRAIAIgAzYCACADDQFBhNQAIAtBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAARhtqIAM2AgAgA0UNAQsgAyAJNgIYIAAoAhAiAQRAIAMgATYCECABIAM2AhgLIABBFGooAgAiAUUNACADQRRqIAE2AgAgASADNgIYCwJAIAVBD00EQCAAIAQgBWoiAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBCyAAIARqIgcgBUEBcjYCBCAAIARBA3I2AgQgBSAHaiAFNgIAIAgEQCAIQXhxQajUAGohAUGU1AAoAgAhAwJ/QQEgCEEDdnQiAiAGcUUEQEGA1AAgAiAGcjYCACABDAELIAEoAggLIgIgAzYCDCABIAM2AgggAyABNgIMIAMgAjYCCAtBlNQAIAc2AgBBiNQAIAU2AgALIABBCGohAQsgCkEQaiQAIAELQwAgAEUEQD8AQRB0DwsCQCAAQf//A3ENACAAQQBIDQAgAEEQdkAAIgBBf0YEQEHw1wBBMDYCAEF/DwsgAEEQdA8LAAsL20AiAEGACAsJAQAAAAIAAAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4IxSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMARXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVycwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGhlYWRlciB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBxdW90ZWQtcGFpciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgcmVzcG9uc2UgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGV4dGVuc2lvbiBuYW1lAEludmFsaWQgc3RhdHVzIGNvZGUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBkYXRhAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIGRhdGEAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAERhdGEgYWZ0ZXIgYENvbm5lY3Rpb246IGNsb3NlYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAUVVFUlkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBFeHBlY3RlZCBMRiBhZnRlciBDUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAFIVAAAaFQAADxIAAOQZAACRFQAACRQAAC0ZAADkFAAA6REAAGkUAAChFAAAdhUAAEMWAABeEgAAlBcAABcWAAB9FAAAfxYAAEEXAACzEwAAwxYAAAQaAAC9GAAA0BgAAKATAADUGQAArxYAAGgWAABwFwAA2RYAAPwYAAD+EQAAWRcAAJcWAAAcFwAA9hYAAI0XAAALEgAAfxsAAC4RAACzEAAASRIAAK0SAAD2GAAAaBAAAGIVAAAQFQAAWhYAAEoZAAC1FQAAwRUAAGAVAABcGQAAWhkAAFMZAAAWFQAArREAAEIQAAC3EAAAVxgAAL8VAACJEAAAHBkAABoZAAC5FQAAURgAANwTAABbFQAAWRUAAOYYAABnFQAAERkAAO0YAADnEwAArhAAAMIXAAAAFAAAkhMAAIQTAABAEgAAJhkAAK8VAABiEABB6TkLAQEAQYA6C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQeo7CwQBAAACAEGBPAteAwQDAwMDAwAAAwMAAwMAAwMDAwMDAwMDAwAFAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMAAwBB6j0LBAEAAAIAQYE+C14DAAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAQABQAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHgPwsNbG9zZWVlcC1hbGl2ZQBB+T8LAQEAQZDAAAvgAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5wQALAQEAQZDCAAvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBocQAC14BAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGAxgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBsMYACytyYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNClNNDQoNClRUUC9DRS9UU1AvAEHpxgALBQECAAEDAEGAxwALXwQFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpyAALBQECAAEDAEGAyQALXwQFBQYFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpygALBAEAAAEAQYHLAAteAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgBB6cwACwUBAgABAwBBgM0AC18EBQAABQUFBQUFBQUFBQUGBQUFBQUFBQUFBQUFAAUABwgFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUABQAFAAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAAABQBB6c4ACwUBAQABAQBBgM8ACwEBAEGazwALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEHp0AALBQEBAAEBAEGA0QALAQEAQYrRAAsGAgAAAAACAEGh0QALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQeDSAAuaAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VVRVJZT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=", jg;
      Object.defineProperty(vB, "exports", { get: /* @__PURE__ */ __name(() => jg || (jg = lL.from(uL, "base64")), "get") });
    });
    var ts = C2((OK2, WB) => {
      "use strict";
      var YB = ["GET", "HEAD", "POST"], gL = new Set(YB), EL = [101, 204, 205, 304], GB = [301, 302, 303, 307, 308], dL = new Set(GB), OB = ["1", "7", "9", "11", "13", "15", "17", "19", "20", "21", "22", "23", "25", "37", "42", "43", "53", "69", "77", "79", "87", "95", "101", "102", "103", "104", "109", "110", "111", "113", "115", "117", "119", "123", "135", "137", "139", "143", "161", "179", "389", "427", "465", "512", "513", "514", "515", "526", "530", "531", "532", "540", "548", "554", "556", "563", "587", "601", "636", "989", "990", "993", "995", "1719", "1720", "1723", "2049", "3659", "4045", "4190", "5060", "5061", "6000", "6566", "6665", "6666", "6667", "6668", "6669", "6679", "6697", "10080"], hL = new Set(OB), VB = ["no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"], fL = ["", ...VB], QL = new Set(VB), CL = ["follow", "manual", "error"], HB = ["GET", "HEAD", "OPTIONS", "TRACE"], IL = new Set(HB), pL = ["navigate", "same-origin", "no-cors", "cors"], BL = ["omit", "same-origin", "include"], mL = ["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"], yL = ["content-encoding", "content-language", "content-location", "content-type", "content-length"], wL = ["half"], qB = ["CONNECT", "TRACE", "TRACK"], DL = new Set(qB), JB = ["audio", "audioworklet", "font", "image", "manifest", "paintworklet", "script", "style", "track", "video", "xslt", ""], RL = new Set(JB);
      WB.exports = { subresource: JB, forbiddenMethods: qB, requestBodyHeader: yL, referrerPolicy: fL, requestRedirect: CL, requestMode: pL, requestCredentials: BL, requestCache: mL, redirectStatus: GB, corsSafeListedMethods: YB, nullBodyStatus: EL, safeMethods: HB, badPorts: OB, requestDuplex: wL, subresourceSet: RL, badPortsSet: hL, redirectStatusSet: dL, corsSafeListedMethodsSet: gL, safeMethodsSet: IL, forbiddenMethodsSet: DL, referrerPolicyTokens: QL };
    });
    var Xg = C2((VK, _B) => {
      "use strict";
      var Zg = Symbol.for("undici.globalOrigin.1");
      function SL() {
        return globalThis[Zg];
      }
      __name(SL, "SL");
      function bL(t2) {
        if (t2 === void 0) {
          Object.defineProperty(globalThis, Zg, { value: void 0, writable: true, enumerable: false, configurable: false });
          return;
        }
        let e = new URL(t2);
        if (e.protocol !== "http:" && e.protocol !== "https:") throw new TypeError(`Only http & https urls are allowed, received ${e.protocol}`);
        Object.defineProperty(globalThis, Zg, { value: e, writable: true, enumerable: false, configurable: false });
      }
      __name(bL, "bL");
      _B.exports = { getGlobalOrigin: SL, setGlobalOrigin: bL };
    });
    var tt = C2((HK, em) => {
      "use strict";
      var Ha = __require("node:assert"), NL = new TextEncoder(), rs = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/, FL = /[\u000A\u000D\u0009\u0020]/, TL = /[\u0009\u000A\u000C\u000D\u0020]/g, xL = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
      function UL(t2) {
        Ha(t2.protocol === "data:");
        let e = XB(t2, true);
        e = e.slice(5);
        let r2 = { position: 0 }, n2 = RA(",", e, r2), A2 = n2.length;
        if (n2 = YL(n2, true, true), r2.position >= e.length) return "failure";
        r2.position++;
        let i2 = e.slice(A2 + 1), s = KB(i2);
        if (/;(\u0020){0,}base64$/i.test(n2)) {
          let a2 = zB(s);
          if (s = ML(a2), s === "failure") return "failure";
          n2 = n2.slice(0, -6), n2 = n2.replace(/(\u0020)+$/, ""), n2 = n2.slice(0, -1);
        }
        n2.startsWith(";") && (n2 = "text/plain" + n2);
        let o2 = Kg(n2);
        return o2 === "failure" && (o2 = Kg("text/plain;charset=US-ASCII")), { mimeType: o2, body: s };
      }
      __name(UL, "UL");
      function XB(t2, e = false) {
        if (!e) return t2.href;
        let r2 = t2.href, n2 = t2.hash.length, A2 = n2 === 0 ? r2 : r2.substring(0, r2.length - n2);
        return !n2 && r2.endsWith("#") ? A2.slice(0, -1) : A2;
      }
      __name(XB, "XB");
      function qa(t2, e, r2) {
        let n2 = "";
        for (; r2.position < e.length && t2(e[r2.position]); ) n2 += e[r2.position], r2.position++;
        return n2;
      }
      __name(qa, "qa");
      function RA(t2, e, r2) {
        let n2 = e.indexOf(t2, r2.position), A2 = r2.position;
        return n2 === -1 ? (r2.position = e.length, e.slice(A2)) : (r2.position = n2, e.slice(A2, r2.position));
      }
      __name(RA, "RA");
      function KB(t2) {
        let e = NL.encode(t2);
        return kL(e);
      }
      __name(KB, "KB");
      function jB(t2) {
        return t2 >= 48 && t2 <= 57 || t2 >= 65 && t2 <= 70 || t2 >= 97 && t2 <= 102;
      }
      __name(jB, "jB");
      function ZB(t2) {
        return t2 >= 48 && t2 <= 57 ? t2 - 48 : (t2 & 223) - 55;
      }
      __name(ZB, "ZB");
      function kL(t2) {
        let e = t2.length, r2 = new Uint8Array(e), n2 = 0;
        for (let A2 = 0; A2 < e; ++A2) {
          let i2 = t2[A2];
          i2 !== 37 ? r2[n2++] = i2 : i2 === 37 && !(jB(t2[A2 + 1]) && jB(t2[A2 + 2])) ? r2[n2++] = 37 : (r2[n2++] = ZB(t2[A2 + 1]) << 4 | ZB(t2[A2 + 2]), A2 += 2);
        }
        return e === n2 ? r2 : r2.subarray(0, n2);
      }
      __name(kL, "kL");
      function Kg(t2) {
        t2 = Va(t2, true, true);
        let e = { position: 0 }, r2 = RA("/", t2, e);
        if (r2.length === 0 || !rs.test(r2) || e.position >= t2.length) return "failure";
        e.position++;
        let n2 = RA(";", t2, e);
        if (n2 = Va(n2, false, true), n2.length === 0 || !rs.test(n2)) return "failure";
        let A2 = r2.toLowerCase(), i2 = n2.toLowerCase(), s = { type: A2, subtype: i2, parameters: /* @__PURE__ */ new Map(), essence: `${A2}/${i2}` };
        for (; e.position < t2.length; ) {
          e.position++, qa((c2) => FL.test(c2), t2, e);
          let o2 = qa((c2) => c2 !== ";" && c2 !== "=", t2, e);
          if (o2 = o2.toLowerCase(), e.position < t2.length) {
            if (t2[e.position] === ";") continue;
            e.position++;
          }
          if (e.position >= t2.length) break;
          let a2 = null;
          if (t2[e.position] === '"') a2 = $B(t2, e, true), RA(";", t2, e);
          else if (a2 = RA(";", t2, e), a2 = Va(a2, false, true), a2.length === 0) continue;
          o2.length !== 0 && rs.test(o2) && (a2.length === 0 || xL.test(a2)) && !s.parameters.has(o2) && s.parameters.set(o2, a2);
        }
        return s;
      }
      __name(Kg, "Kg");
      function ML(t2) {
        t2 = t2.replace(TL, "");
        let e = t2.length;
        if (e % 4 === 0 && t2.charCodeAt(e - 1) === 61 && (--e, t2.charCodeAt(e - 1) === 61 && --e), e % 4 === 1 || /[^+/0-9A-Za-z]/.test(t2.length === e ? t2 : t2.substring(0, e))) return "failure";
        let r2 = Buffer.from(t2, "base64");
        return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
      }
      __name(ML, "ML");
      function $B(t2, e, r2 = false) {
        let n2 = e.position, A2 = "";
        for (Ha(t2[e.position] === '"'), e.position++; A2 += qa((s) => s !== '"' && s !== "\\", t2, e), !(e.position >= t2.length); ) {
          let i2 = t2[e.position];
          if (e.position++, i2 === "\\") {
            if (e.position >= t2.length) {
              A2 += "\\";
              break;
            }
            A2 += t2[e.position], e.position++;
          } else {
            Ha(i2 === '"');
            break;
          }
        }
        return r2 ? A2 : t2.slice(n2, e.position);
      }
      __name($B, "$B");
      function LL(t2) {
        Ha(t2 !== "failure");
        let { parameters: e, essence: r2 } = t2, n2 = r2;
        for (let [A2, i2] of e.entries()) n2 += ";", n2 += A2, n2 += "=", rs.test(i2) || (i2 = i2.replace(/(\\|")/g, "\\$1"), i2 = '"' + i2, i2 += '"'), n2 += i2;
        return n2;
      }
      __name(LL, "LL");
      function vL(t2) {
        return t2 === 13 || t2 === 10 || t2 === 9 || t2 === 32;
      }
      __name(vL, "vL");
      function Va(t2, e = true, r2 = true) {
        return $g(t2, e, r2, vL);
      }
      __name(Va, "Va");
      function PL(t2) {
        return t2 === 13 || t2 === 10 || t2 === 9 || t2 === 12 || t2 === 32;
      }
      __name(PL, "PL");
      function YL(t2, e = true, r2 = true) {
        return $g(t2, e, r2, PL);
      }
      __name(YL, "YL");
      function $g(t2, e, r2, n2) {
        let A2 = 0, i2 = t2.length - 1;
        if (e) for (; A2 < t2.length && n2(t2.charCodeAt(A2)); ) A2++;
        if (r2) for (; i2 > 0 && n2(t2.charCodeAt(i2)); ) i2--;
        return A2 === 0 && i2 === t2.length - 1 ? t2 : t2.slice(A2, i2 + 1);
      }
      __name($g, "$g");
      function zB(t2) {
        let e = t2.length;
        if (65535 > e) return String.fromCharCode.apply(null, t2);
        let r2 = "", n2 = 0, A2 = 65535;
        for (; n2 < e; ) n2 + A2 > e && (A2 = e - n2), r2 += String.fromCharCode.apply(null, t2.subarray(n2, n2 += A2));
        return r2;
      }
      __name(zB, "zB");
      function GL(t2) {
        switch (t2.essence) {
          case "application/ecmascript":
          case "application/javascript":
          case "application/x-ecmascript":
          case "application/x-javascript":
          case "text/ecmascript":
          case "text/javascript":
          case "text/javascript1.0":
          case "text/javascript1.1":
          case "text/javascript1.2":
          case "text/javascript1.3":
          case "text/javascript1.4":
          case "text/javascript1.5":
          case "text/jscript":
          case "text/livescript":
          case "text/x-ecmascript":
          case "text/x-javascript":
            return "text/javascript";
          case "application/json":
          case "text/json":
            return "application/json";
          case "image/svg+xml":
            return "image/svg+xml";
          case "text/xml":
          case "application/xml":
            return "application/xml";
        }
        return t2.subtype.endsWith("+json") ? "application/json" : t2.subtype.endsWith("+xml") ? "application/xml" : "";
      }
      __name(GL, "GL");
      em.exports = { dataURLProcessor: UL, URLSerializer: XB, collectASequenceOfCodePoints: qa, collectASequenceOfCodePointsFast: RA, stringPercentDecode: KB, parseMIMEType: Kg, collectAnHTTPQuotedString: $B, serializeAMimeType: LL, removeChars: $g, removeHTTPWhitespace: Va, minimizeSupportedMimeType: GL, HTTP_TOKEN_CODEPOINTS: rs, isomorphicDecode: zB };
    });
    var Te = C2((qK, rm) => {
      "use strict";
      var { types: dn, inspect: OL } = __require("node:util"), { markAsUncloneable: VL } = __require("node:worker_threads"), { toUSVString: HL } = Y2(), zg = 1, eE = 2, Ja = 3, Wa = 4, tE = 5, rE = 6, nE = 7, Vt = 8, tm = Function.call.bind(Function.prototype[Symbol.hasInstance]), m2 = { converters: {}, util: {}, errors: {}, is: {} };
      m2.errors.exception = function(t2) {
        return new TypeError(`${t2.header}: ${t2.message}`);
      };
      m2.errors.conversionFailed = function(t2) {
        let e = t2.types.length === 1 ? "" : " one of", r2 = `${t2.argument} could not be converted to${e}: ${t2.types.join(", ")}.`;
        return m2.errors.exception({ header: t2.prefix, message: r2 });
      };
      m2.errors.invalidArgument = function(t2) {
        return m2.errors.exception({ header: t2.prefix, message: `"${t2.value}" is an invalid ${t2.type}.` });
      };
      m2.brandCheck = function(t2, e) {
        if (!tm(e, t2)) {
          let r2 = new TypeError("Illegal invocation");
          throw r2.code = "ERR_INVALID_THIS", r2;
        }
      };
      m2.brandCheckMultiple = function(t2) {
        let e = t2.map((r2) => m2.util.MakeTypeAssertion(r2));
        return (r2) => {
          if (e.every((n2) => !n2(r2))) {
            let n2 = new TypeError("Illegal invocation");
            throw n2.code = "ERR_INVALID_THIS", n2;
          }
        };
      };
      m2.argumentLengthCheck = function({ length: t2 }, e, r2) {
        if (t2 < e) throw m2.errors.exception({ message: `${e} argument${e !== 1 ? "s" : ""} required, but${t2 ? " only" : ""} ${t2} found.`, header: r2 });
      };
      m2.illegalConstructor = function() {
        throw m2.errors.exception({ header: "TypeError", message: "Illegal constructor" });
      };
      m2.util.MakeTypeAssertion = function(t2) {
        return (e) => tm(t2, e);
      };
      m2.util.Type = function(t2) {
        switch (typeof t2) {
          case "undefined":
            return zg;
          case "boolean":
            return eE;
          case "string":
            return Ja;
          case "symbol":
            return Wa;
          case "number":
            return tE;
          case "bigint":
            return rE;
          case "function":
          case "object":
            return t2 === null ? nE : Vt;
        }
      };
      m2.util.Types = { UNDEFINED: zg, BOOLEAN: eE, STRING: Ja, SYMBOL: Wa, NUMBER: tE, BIGINT: rE, NULL: nE, OBJECT: Vt };
      m2.util.TypeValueToString = function(t2) {
        switch (m2.util.Type(t2)) {
          case zg:
            return "Undefined";
          case eE:
            return "Boolean";
          case Ja:
            return "String";
          case Wa:
            return "Symbol";
          case tE:
            return "Number";
          case rE:
            return "BigInt";
          case nE:
            return "Null";
          case Vt:
            return "Object";
        }
      };
      m2.util.markAsUncloneable = VL || (() => {
      });
      m2.util.ConvertToInt = function(t2, e, r2, n2) {
        let A2, i2;
        e === 64 ? (A2 = Math.pow(2, 53) - 1, r2 === "unsigned" ? i2 = 0 : i2 = Math.pow(-2, 53) + 1) : r2 === "unsigned" ? (i2 = 0, A2 = Math.pow(2, e) - 1) : (i2 = Math.pow(-2, e) - 1, A2 = Math.pow(2, e - 1) - 1);
        let s = Number(t2);
        if (s === 0 && (s = 0), n2?.enforceRange === true) {
          if (Number.isNaN(s) || s === Number.POSITIVE_INFINITY || s === Number.NEGATIVE_INFINITY) throw m2.errors.exception({ header: "Integer conversion", message: `Could not convert ${m2.util.Stringify(t2)} to an integer.` });
          if (s = m2.util.IntegerPart(s), s < i2 || s > A2) throw m2.errors.exception({ header: "Integer conversion", message: `Value must be between ${i2}-${A2}, got ${s}.` });
          return s;
        }
        return !Number.isNaN(s) && n2?.clamp === true ? (s = Math.min(Math.max(s, i2), A2), Math.floor(s) % 2 === 0 ? s = Math.floor(s) : s = Math.ceil(s), s) : Number.isNaN(s) || s === 0 && Object.is(0, s) || s === Number.POSITIVE_INFINITY || s === Number.NEGATIVE_INFINITY ? 0 : (s = m2.util.IntegerPart(s), s = s % Math.pow(2, e), r2 === "signed" && s >= Math.pow(2, e) - 1 ? s - Math.pow(2, e) : s);
      };
      m2.util.IntegerPart = function(t2) {
        let e = Math.floor(Math.abs(t2));
        return t2 < 0 ? -1 * e : e;
      };
      m2.util.Stringify = function(t2) {
        switch (m2.util.Type(t2)) {
          case Wa:
            return `Symbol(${t2.description})`;
          case Vt:
            return OL(t2);
          case Ja:
            return `"${t2}"`;
          default:
            return `${t2}`;
        }
      };
      m2.sequenceConverter = function(t2) {
        return (e, r2, n2, A2) => {
          if (m2.util.Type(e) !== Vt) throw m2.errors.exception({ header: r2, message: `${n2} (${m2.util.Stringify(e)}) is not iterable.` });
          let i2 = typeof A2 == "function" ? A2() : e?.[Symbol.iterator]?.(), s = [], o2 = 0;
          if (i2 === void 0 || typeof i2.next != "function") throw m2.errors.exception({ header: r2, message: `${n2} is not iterable.` });
          for (; ; ) {
            let { done: a2, value: c2 } = i2.next();
            if (a2) break;
            s.push(t2(c2, r2, `${n2}[${o2++}]`));
          }
          return s;
        };
      };
      m2.recordConverter = function(t2, e) {
        return (r2, n2, A2) => {
          if (m2.util.Type(r2) !== Vt) throw m2.errors.exception({ header: n2, message: `${A2} ("${m2.util.TypeValueToString(r2)}") is not an Object.` });
          let i2 = {};
          if (!dn.isProxy(r2)) {
            let o2 = [...Object.getOwnPropertyNames(r2), ...Object.getOwnPropertySymbols(r2)];
            for (let a2 of o2) {
              let c2 = m2.util.Stringify(a2), l2 = t2(a2, n2, `Key ${c2} in ${A2}`), u2 = e(r2[a2], n2, `${A2}[${c2}]`);
              i2[l2] = u2;
            }
            return i2;
          }
          let s = Reflect.ownKeys(r2);
          for (let o2 of s) if (Reflect.getOwnPropertyDescriptor(r2, o2)?.enumerable) {
            let c2 = t2(o2, n2, A2), l2 = e(r2[o2], n2, A2);
            i2[c2] = l2;
          }
          return i2;
        };
      };
      m2.interfaceConverter = function(t2, e) {
        return (r2, n2, A2) => {
          if (!t2(r2)) throw m2.errors.exception({ header: n2, message: `Expected ${A2} ("${m2.util.Stringify(r2)}") to be an instance of ${e}.` });
          return r2;
        };
      };
      m2.dictionaryConverter = function(t2) {
        return (e, r2, n2) => {
          let A2 = {};
          if (e != null && m2.util.Type(e) !== Vt) throw m2.errors.exception({ header: r2, message: `Expected ${e} to be one of: Null, Undefined, Object.` });
          for (let i2 of t2) {
            let { key: s, defaultValue: o2, required: a2, converter: c2 } = i2;
            if (a2 === true && (e == null || !Object.hasOwn(e, s))) throw m2.errors.exception({ header: r2, message: `Missing required key "${s}".` });
            let l2 = e?.[s], u2 = o2 !== void 0;
            if (u2 && l2 === void 0 && (l2 = o2()), a2 || u2 || l2 !== void 0) {
              if (l2 = c2(l2, r2, `${n2}.${s}`), i2.allowedValues && !i2.allowedValues.includes(l2)) throw m2.errors.exception({ header: r2, message: `${l2} is not an accepted type. Expected one of ${i2.allowedValues.join(", ")}.` });
              A2[s] = l2;
            }
          }
          return A2;
        };
      };
      m2.nullableConverter = function(t2) {
        return (e, r2, n2) => e === null ? e : t2(e, r2, n2);
      };
      m2.is.ReadableStream = m2.util.MakeTypeAssertion(ReadableStream);
      m2.is.Blob = m2.util.MakeTypeAssertion(Blob);
      m2.is.URLSearchParams = m2.util.MakeTypeAssertion(URLSearchParams);
      m2.is.File = m2.util.MakeTypeAssertion(globalThis.File ?? __require("node:buffer").File);
      m2.is.URL = m2.util.MakeTypeAssertion(URL);
      m2.is.AbortSignal = m2.util.MakeTypeAssertion(AbortSignal);
      m2.is.MessagePort = m2.util.MakeTypeAssertion(MessagePort);
      m2.converters.DOMString = function(t2, e, r2, n2) {
        if (t2 === null && n2?.legacyNullToEmptyString) return "";
        if (typeof t2 == "symbol") throw m2.errors.exception({ header: e, message: `${r2} is a symbol, which cannot be converted to a DOMString.` });
        return String(t2);
      };
      m2.converters.ByteString = function(t2, e, r2) {
        if (typeof t2 == "symbol") throw m2.errors.exception({ header: e, message: `${r2} is a symbol, which cannot be converted to a ByteString.` });
        let n2 = String(t2);
        for (let A2 = 0; A2 < n2.length; A2++) if (n2.charCodeAt(A2) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${A2} has a value of ${n2.charCodeAt(A2)} which is greater than 255.`);
        return n2;
      };
      m2.converters.USVString = HL;
      m2.converters.boolean = function(t2) {
        return !!t2;
      };
      m2.converters.any = function(t2) {
        return t2;
      };
      m2.converters["long long"] = function(t2, e, r2) {
        return m2.util.ConvertToInt(t2, 64, "signed", void 0, e, r2);
      };
      m2.converters["unsigned long long"] = function(t2, e, r2) {
        return m2.util.ConvertToInt(t2, 64, "unsigned", void 0, e, r2);
      };
      m2.converters["unsigned long"] = function(t2, e, r2) {
        return m2.util.ConvertToInt(t2, 32, "unsigned", void 0, e, r2);
      };
      m2.converters["unsigned short"] = function(t2, e, r2, n2) {
        return m2.util.ConvertToInt(t2, 16, "unsigned", n2, e, r2);
      };
      m2.converters.ArrayBuffer = function(t2, e, r2, n2) {
        if (m2.util.Type(t2) !== Vt || !dn.isAnyArrayBuffer(t2)) throw m2.errors.conversionFailed({ prefix: e, argument: `${r2} ("${m2.util.Stringify(t2)}")`, types: ["ArrayBuffer"] });
        if (n2?.allowShared === false && dn.isSharedArrayBuffer(t2)) throw m2.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (t2.resizable || t2.growable) throw m2.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return t2;
      };
      m2.converters.TypedArray = function(t2, e, r2, n2, A2) {
        if (m2.util.Type(t2) !== Vt || !dn.isTypedArray(t2) || t2.constructor.name !== e.name) throw m2.errors.conversionFailed({ prefix: r2, argument: `${n2} ("${m2.util.Stringify(t2)}")`, types: [e.name] });
        if (A2?.allowShared === false && dn.isSharedArrayBuffer(t2.buffer)) throw m2.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (t2.buffer.resizable || t2.buffer.growable) throw m2.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return t2;
      };
      m2.converters.DataView = function(t2, e, r2, n2) {
        if (m2.util.Type(t2) !== Vt || !dn.isDataView(t2)) throw m2.errors.exception({ header: e, message: `${r2} is not a DataView.` });
        if (n2?.allowShared === false && dn.isSharedArrayBuffer(t2.buffer)) throw m2.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (t2.buffer.resizable || t2.buffer.growable) throw m2.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return t2;
      };
      m2.converters["sequence<ByteString>"] = m2.sequenceConverter(m2.converters.ByteString);
      m2.converters["sequence<sequence<ByteString>>"] = m2.sequenceConverter(m2.converters["sequence<ByteString>"]);
      m2.converters["record<ByteString, ByteString>"] = m2.recordConverter(m2.converters.ByteString, m2.converters.ByteString);
      m2.converters.Blob = m2.interfaceConverter(m2.is.Blob, "Blob");
      m2.converters.AbortSignal = m2.interfaceConverter(m2.is.AbortSignal, "AbortSignal");
      rm.exports = { webidl: m2 };
    });
    var Ve = C2((JK, Cm) => {
      "use strict";
      var { Transform: qL } = __require("node:stream"), nm = __require("node:zlib"), { redirectStatusSet: JL, referrerPolicyTokens: WL, badPortsSet: _L } = ts(), { getGlobalOrigin: Am } = Xg(), { collectASequenceOfCodePoints: hn, collectAnHTTPQuotedString: jL, removeChars: ZL, parseMIMEType: XL } = tt(), { performance: KL } = __require("node:perf_hooks"), { ReadableStreamFrom: $L, isValidHTTPToken: im, normalizedMethodRecordsBase: zL } = Y2(), Cn = __require("node:assert"), { isUint8Array: ev } = __require("node:util/types"), { webidl: Hr } = Te(), sm = [], ja;
      try {
        ja = __require("node:crypto");
        let t2 = ["sha256", "sha384", "sha512"];
        sm = ja.getHashes().filter((e) => t2.includes(e));
      } catch {
      }
      function om(t2) {
        let e = t2.urlList, r2 = e.length;
        return r2 === 0 ? null : e[r2 - 1].toString();
      }
      __name(om, "om");
      function tv(t2, e) {
        if (!JL.has(t2.status)) return null;
        let r2 = t2.headersList.get("location", true);
        return r2 !== null && cm(r2) && (am(r2) || (r2 = rv(r2)), r2 = new URL(r2, om(t2))), r2 && !r2.hash && (r2.hash = e), r2;
      }
      __name(tv, "tv");
      function am(t2) {
        for (let e = 0; e < t2.length; ++e) {
          let r2 = t2.charCodeAt(e);
          if (r2 > 126 || r2 < 32) return false;
        }
        return true;
      }
      __name(am, "am");
      function rv(t2) {
        return Buffer.from(t2, "binary").toString("utf8");
      }
      __name(rv, "rv");
      function Qn(t2) {
        return t2.urlList[t2.urlList.length - 1];
      }
      __name(Qn, "Qn");
      function nv(t2) {
        let e = Qn(t2);
        return fm(e) && _L.has(e.port) ? "blocked" : "allowed";
      }
      __name(nv, "nv");
      function Av(t2) {
        return t2 instanceof Error || t2?.constructor?.name === "Error" || t2?.constructor?.name === "DOMException";
      }
      __name(Av, "Av");
      function iv(t2) {
        for (let e = 0; e < t2.length; ++e) {
          let r2 = t2.charCodeAt(e);
          if (!(r2 === 9 || r2 >= 32 && r2 <= 126 || r2 >= 128 && r2 <= 255)) return false;
        }
        return true;
      }
      __name(iv, "iv");
      var sv = im;
      function cm(t2) {
        return (t2[0] === "	" || t2[0] === " " || t2[t2.length - 1] === "	" || t2[t2.length - 1] === " " || t2.includes(`
`) || t2.includes("\r") || t2.includes("\0")) === false;
      }
      __name(cm, "cm");
      function ov(t2) {
        let e = (t2.headersList.get("referrer-policy", true) ?? "").split(","), r2 = "";
        if (e.length) for (let n2 = e.length; n2 !== 0; n2--) {
          let A2 = e[n2 - 1].trim();
          if (WL.has(A2)) {
            r2 = A2;
            break;
          }
        }
        return r2;
      }
      __name(ov, "ov");
      function av(t2, e) {
        let r2 = ov(e);
        r2 !== "" && (t2.referrerPolicy = r2);
      }
      __name(av, "av");
      function cv() {
        return "allowed";
      }
      __name(cv, "cv");
      function lv() {
        return "success";
      }
      __name(lv, "lv");
      function uv() {
        return "success";
      }
      __name(uv, "uv");
      function gv(t2) {
        let e = null;
        e = t2.mode, t2.headersList.set("sec-fetch-mode", e, true);
      }
      __name(gv, "gv");
      function Ev(t2) {
        let e = t2.origin;
        if (!(e === "client" || e === void 0)) {
          if (t2.responseTainting === "cors" || t2.mode === "websocket") t2.headersList.append("origin", e, true);
          else if (t2.method !== "GET" && t2.method !== "HEAD") {
            switch (t2.referrerPolicy) {
              case "no-referrer":
                e = null;
                break;
              case "no-referrer-when-downgrade":
              case "strict-origin":
              case "strict-origin-when-cross-origin":
                t2.origin && iE(t2.origin) && !iE(Qn(t2)) && (e = null);
                break;
              case "same-origin":
                ns(t2, Qn(t2)) || (e = null);
                break;
              default:
            }
            t2.headersList.append("origin", e, true);
          }
        }
      }
      __name(Ev, "Ev");
      function SA(t2, e) {
        return t2;
      }
      __name(SA, "SA");
      function dv(t2, e, r2) {
        return !t2?.startTime || t2.startTime < e ? { domainLookupStartTime: e, domainLookupEndTime: e, connectionStartTime: e, connectionEndTime: e, secureConnectionStartTime: e, ALPNNegotiatedProtocol: t2?.ALPNNegotiatedProtocol } : { domainLookupStartTime: SA(t2.domainLookupStartTime, r2), domainLookupEndTime: SA(t2.domainLookupEndTime, r2), connectionStartTime: SA(t2.connectionStartTime, r2), connectionEndTime: SA(t2.connectionEndTime, r2), secureConnectionStartTime: SA(t2.secureConnectionStartTime, r2), ALPNNegotiatedProtocol: t2.ALPNNegotiatedProtocol };
      }
      __name(dv, "dv");
      function hv(t2) {
        return SA(KL.now(), t2);
      }
      __name(hv, "hv");
      function fv(t2) {
        return { startTime: t2.startTime ?? 0, redirectStartTime: 0, redirectEndTime: 0, postRedirectStartTime: t2.startTime ?? 0, finalServiceWorkerStartTime: 0, finalNetworkResponseStartTime: 0, finalNetworkRequestStartTime: 0, endTime: 0, encodedBodySize: 0, decodedBodySize: 0, finalConnectionTimingInfo: null };
      }
      __name(fv, "fv");
      function lm() {
        return { referrerPolicy: "strict-origin-when-cross-origin" };
      }
      __name(lm, "lm");
      function Qv(t2) {
        return { referrerPolicy: t2.referrerPolicy };
      }
      __name(Qv, "Qv");
      function Cv(t2) {
        let e = t2.referrerPolicy;
        Cn(e);
        let r2 = null;
        if (t2.referrer === "client") {
          let i2 = Am();
          if (!i2 || i2.origin === "null") return "no-referrer";
          r2 = new URL(i2);
        } else Hr.is.URL(t2.referrer) && (r2 = t2.referrer);
        let n2 = AE(r2), A2 = AE(r2, true);
        switch (n2.toString().length > 4096 && (n2 = A2), e) {
          case "no-referrer":
            return "no-referrer";
          case "origin":
            return A2 ?? AE(r2, true);
          case "unsafe-url":
            return n2;
          case "strict-origin": {
            let i2 = Qn(t2);
            return fn(n2) && !fn(i2) ? "no-referrer" : A2;
          }
          case "strict-origin-when-cross-origin": {
            let i2 = Qn(t2);
            return ns(n2, i2) ? n2 : fn(n2) && !fn(i2) ? "no-referrer" : A2;
          }
          case "same-origin":
            return ns(t2, n2) ? n2 : "no-referrer";
          case "origin-when-cross-origin":
            return ns(t2, n2) ? n2 : A2;
          case "no-referrer-when-downgrade": {
            let i2 = Qn(t2);
            return fn(n2) && !fn(i2) ? "no-referrer" : A2;
          }
        }
      }
      __name(Cv, "Cv");
      function AE(t2, e = false) {
        return Cn(Hr.is.URL(t2)), t2 = new URL(t2), hm(t2) ? "no-referrer" : (t2.username = "", t2.password = "", t2.hash = "", e === true && (t2.pathname = "", t2.search = ""), t2);
      }
      __name(AE, "AE");
      var Iv = new RegExp("^(?:(?:127\\.)(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){2}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9]))$"), pv = new RegExp("^(?:(?:(?:0{1,4}):){7}(?:(?:0{0,3}1))|(?:(?:0{1,4}):){1,6}(?::(?:0{0,3}1))|(?:::(?:0{0,3}1))|)$");
      function um(t2) {
        return t2.includes(":") ? (t2[0] === "[" && t2[t2.length - 1] === "]" && (t2 = t2.slice(1, -1)), pv.test(t2)) : Iv.test(t2);
      }
      __name(um, "um");
      function Bv(t2) {
        return t2 == null || t2 === "null" ? false : (t2 = new URL(t2), !!(t2.protocol === "https:" || t2.protocol === "wss:" || um(t2.hostname) || t2.hostname === "localhost" || t2.hostname === "localhost." || t2.hostname.endsWith(".localhost") || t2.hostname.endsWith(".localhost.") || t2.protocol === "file:"));
      }
      __name(Bv, "Bv");
      function fn(t2) {
        return Hr.is.URL(t2) ? t2.href === "about:blank" || t2.href === "about:srcdoc" || t2.protocol === "data:" || t2.protocol === "blob:" ? true : Bv(t2.origin) : false;
      }
      __name(fn, "fn");
      function mv(t2, e) {
        if (ja === void 0) return true;
        let r2 = gm(e);
        if (r2 === "no metadata" || r2.length === 0) return true;
        let n2 = wv(r2), A2 = Dv(r2, n2);
        for (let i2 of A2) {
          let s = i2.algo, o2 = i2.hash, a2 = ja.createHash(s).update(t2).digest("base64");
          if (a2[a2.length - 1] === "=" && (a2[a2.length - 2] === "=" ? a2 = a2.slice(0, -2) : a2 = a2.slice(0, -1)), Rv(a2, o2)) return true;
        }
        return false;
      }
      __name(mv, "mv");
      var yv = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
      function gm(t2) {
        let e = [], r2 = true;
        for (let n2 of t2.split(" ")) {
          r2 = false;
          let A2 = yv.exec(n2);
          if (A2 === null || A2.groups === void 0 || A2.groups.algo === void 0) continue;
          let i2 = A2.groups.algo.toLowerCase();
          sm.includes(i2) && e.push(A2.groups);
        }
        return r2 === true ? "no metadata" : e;
      }
      __name(gm, "gm");
      function wv(t2) {
        let e = t2[0].algo;
        if (e[3] === "5") return e;
        for (let r2 = 1; r2 < t2.length; ++r2) {
          let n2 = t2[r2];
          if (n2.algo[3] === "5") {
            e = "sha512";
            break;
          } else {
            if (e[3] === "3") continue;
            n2.algo[3] === "3" && (e = "sha384");
          }
        }
        return e;
      }
      __name(wv, "wv");
      function Dv(t2, e) {
        if (t2.length === 1) return t2;
        let r2 = 0;
        for (let n2 = 0; n2 < t2.length; ++n2) t2[n2].algo === e && (t2[r2++] = t2[n2]);
        return t2.length = r2, t2;
      }
      __name(Dv, "Dv");
      function Rv(t2, e) {
        if (t2.length !== e.length) return false;
        for (let r2 = 0; r2 < t2.length; ++r2) if (t2[r2] !== e[r2]) {
          if (t2[r2] === "+" && e[r2] === "-" || t2[r2] === "/" && e[r2] === "_") continue;
          return false;
        }
        return true;
      }
      __name(Rv, "Rv");
      function Sv(t2) {
      }
      __name(Sv, "Sv");
      function ns(t2, e) {
        return t2.origin === e.origin && t2.origin === "null" || t2.protocol === e.protocol && t2.hostname === e.hostname && t2.port === e.port;
      }
      __name(ns, "ns");
      function bv() {
        let t2, e;
        return { promise: new Promise((n2, A2) => {
          t2 = n2, e = A2;
        }), resolve: t2, reject: e };
      }
      __name(bv, "bv");
      function Nv(t2) {
        return t2.controller.state === "aborted";
      }
      __name(Nv, "Nv");
      function Fv(t2) {
        return t2.controller.state === "aborted" || t2.controller.state === "terminated";
      }
      __name(Fv, "Fv");
      function Tv(t2) {
        return zL[t2.toLowerCase()] ?? t2;
      }
      __name(Tv, "Tv");
      function xv(t2) {
        let e = JSON.stringify(t2);
        if (e === void 0) throw new TypeError("Value is not JSON serializable");
        return Cn(typeof e == "string"), e;
      }
      __name(xv, "xv");
      var Uv = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
      function Em(t2, e, r2 = 0, n2 = 1) {
        class A2 {
          static {
            __name(this, "A");
          }
          #e;
          #t;
          #r;
          constructor(s, o2) {
            this.#e = s, this.#t = o2, this.#r = 0;
          }
          next() {
            if (typeof this != "object" || this === null || !(#e in this)) throw new TypeError(`'next' called on an object that does not implement interface ${t2} Iterator.`);
            let s = this.#r, o2 = e(this.#e), a2 = o2.length;
            if (s >= a2) return { value: void 0, done: true };
            let { [r2]: c2, [n2]: l2 } = o2[s];
            this.#r = s + 1;
            let u2;
            switch (this.#t) {
              case "key":
                u2 = c2;
                break;
              case "value":
                u2 = l2;
                break;
              case "key+value":
                u2 = [c2, l2];
                break;
            }
            return { value: u2, done: false };
          }
        }
        return delete A2.prototype.constructor, Object.setPrototypeOf(A2.prototype, Uv), Object.defineProperties(A2.prototype, { [Symbol.toStringTag]: { writable: false, enumerable: false, configurable: true, value: `${t2} Iterator` }, next: { writable: true, enumerable: true, configurable: true } }), function(i2, s) {
          return new A2(i2, s);
        };
      }
      __name(Em, "Em");
      function kv(t2, e, r2, n2 = 0, A2 = 1) {
        let i2 = Em(t2, r2, n2, A2), s = { keys: { writable: true, enumerable: true, configurable: true, value: /* @__PURE__ */ __name(function() {
          return Hr.brandCheck(this, e), i2(this, "key");
        }, "value") }, values: { writable: true, enumerable: true, configurable: true, value: /* @__PURE__ */ __name(function() {
          return Hr.brandCheck(this, e), i2(this, "value");
        }, "value") }, entries: { writable: true, enumerable: true, configurable: true, value: /* @__PURE__ */ __name(function() {
          return Hr.brandCheck(this, e), i2(this, "key+value");
        }, "value") }, forEach: { writable: true, enumerable: true, configurable: true, value: /* @__PURE__ */ __name(function(a2, c2 = globalThis) {
          if (Hr.brandCheck(this, e), Hr.argumentLengthCheck(arguments, 1, `${t2}.forEach`), typeof a2 != "function") throw new TypeError(`Failed to execute 'forEach' on '${t2}': parameter 1 is not of type 'Function'.`);
          for (let { 0: l2, 1: u2 } of i2(this, "key+value")) a2.call(c2, u2, l2, this);
        }, "value") } };
        return Object.defineProperties(e.prototype, { ...s, [Symbol.iterator]: { writable: true, enumerable: false, configurable: true, value: s.entries.value } });
      }
      __name(kv, "kv");
      function Mv(t2, e, r2) {
        let n2 = e, A2 = r2, i2;
        try {
          i2 = t2.stream.getReader();
        } catch (s) {
          A2(s);
          return;
        }
        dm(i2, n2, A2);
      }
      __name(Mv, "Mv");
      function Lv(t2) {
        try {
          t2.close(), t2.byobRequest?.respond(0);
        } catch (e) {
          if (!e.message.includes("Controller is already closed") && !e.message.includes("ReadableStream is already closed")) throw e;
        }
      }
      __name(Lv, "Lv");
      var vv = /[^\x00-\xFF]/;
      function _a(t2) {
        return Cn(!vv.test(t2)), t2;
      }
      __name(_a, "_a");
      async function dm(t2, e, r2) {
        let n2 = [], A2 = 0;
        try {
          do {
            let { done: i2, value: s } = await t2.read();
            if (i2) {
              e(Buffer.concat(n2, A2));
              return;
            }
            if (!ev(s)) {
              r2(TypeError("Received non-Uint8Array chunk"));
              return;
            }
            n2.push(s), A2 += s.length;
          } while (true);
        } catch (i2) {
          r2(i2);
        }
      }
      __name(dm, "dm");
      function hm(t2) {
        Cn("protocol" in t2);
        let e = t2.protocol;
        return e === "about:" || e === "blob:" || e === "data:";
      }
      __name(hm, "hm");
      function iE(t2) {
        return typeof t2 == "string" && t2[5] === ":" && t2[0] === "h" && t2[1] === "t" && t2[2] === "t" && t2[3] === "p" && t2[4] === "s" || t2.protocol === "https:";
      }
      __name(iE, "iE");
      function fm(t2) {
        Cn("protocol" in t2);
        let e = t2.protocol;
        return e === "http:" || e === "https:";
      }
      __name(fm, "fm");
      function Pv(t2, e) {
        let r2 = t2;
        if (!r2.startsWith("bytes")) return "failure";
        let n2 = { position: 5 };
        if (e && hn((a2) => a2 === "	" || a2 === " ", r2, n2), r2.charCodeAt(n2.position) !== 61) return "failure";
        n2.position++, e && hn((a2) => a2 === "	" || a2 === " ", r2, n2);
        let A2 = hn((a2) => {
          let c2 = a2.charCodeAt(0);
          return c2 >= 48 && c2 <= 57;
        }, r2, n2), i2 = A2.length ? Number(A2) : null;
        if (e && hn((a2) => a2 === "	" || a2 === " ", r2, n2), r2.charCodeAt(n2.position) !== 45) return "failure";
        n2.position++, e && hn((a2) => a2 === "	" || a2 === " ", r2, n2);
        let s = hn((a2) => {
          let c2 = a2.charCodeAt(0);
          return c2 >= 48 && c2 <= 57;
        }, r2, n2), o2 = s.length ? Number(s) : null;
        return n2.position < r2.length || o2 === null && i2 === null || i2 > o2 ? "failure" : { rangeStartValue: i2, rangeEndValue: o2 };
      }
      __name(Pv, "Pv");
      function Yv(t2, e, r2) {
        let n2 = "bytes ";
        return n2 += _a(`${t2}`), n2 += "-", n2 += _a(`${e}`), n2 += "/", n2 += _a(`${r2}`), n2;
      }
      __name(Yv, "Yv");
      var sE = class extends qL {
        static {
          __name(this, "sE");
        }
        #e;
        constructor(e) {
          super(), this.#e = e;
        }
        _transform(e, r2, n2) {
          if (!this._inflateStream) {
            if (e.length === 0) {
              n2();
              return;
            }
            this._inflateStream = (e[0] & 15) === 8 ? nm.createInflate(this.#e) : nm.createInflateRaw(this.#e), this._inflateStream.on("data", this.push.bind(this)), this._inflateStream.on("end", () => this.push(null)), this._inflateStream.on("error", (A2) => this.destroy(A2));
          }
          this._inflateStream.write(e, r2, n2);
        }
        _final(e) {
          this._inflateStream && (this._inflateStream.end(), this._inflateStream = null), e();
        }
      };
      function Gv(t2) {
        return new sE(t2);
      }
      __name(Gv, "Gv");
      function Ov(t2) {
        let e = null, r2 = null, n2 = null, A2 = Qm("content-type", t2);
        if (A2 === null) return "failure";
        for (let i2 of A2) {
          let s = XL(i2);
          s === "failure" || s.essence === "*/*" || (n2 = s, n2.essence !== r2 ? (e = null, n2.parameters.has("charset") && (e = n2.parameters.get("charset")), r2 = n2.essence) : !n2.parameters.has("charset") && e !== null && n2.parameters.set("charset", e));
        }
        return n2 ?? "failure";
      }
      __name(Ov, "Ov");
      function Vv(t2) {
        let e = t2, r2 = { position: 0 }, n2 = [], A2 = "";
        for (; r2.position < e.length; ) {
          if (A2 += hn((i2) => i2 !== '"' && i2 !== ",", e, r2), r2.position < e.length) if (e.charCodeAt(r2.position) === 34) {
            if (A2 += jL(e, r2), r2.position < e.length) continue;
          } else Cn(e.charCodeAt(r2.position) === 44), r2.position++;
          A2 = ZL(A2, true, true, (i2) => i2 === 9 || i2 === 32), n2.push(A2), A2 = "";
        }
        return n2;
      }
      __name(Vv, "Vv");
      function Qm(t2, e) {
        let r2 = e.get(t2, true);
        return r2 === null ? null : Vv(r2);
      }
      __name(Qm, "Qm");
      var Hv = new TextDecoder();
      function qv(t2) {
        return t2.length === 0 ? "" : (t2[0] === 239 && t2[1] === 187 && t2[2] === 191 && (t2 = t2.subarray(3)), Hv.decode(t2));
      }
      __name(qv, "qv");
      var oE = class {
        static {
          __name(this, "oE");
        }
        get baseUrl() {
          return Am();
        }
        get origin() {
          return this.baseUrl?.origin;
        }
        policyContainer = lm();
      }, aE = class {
        static {
          __name(this, "aE");
        }
        settingsObject = new oE();
      }, Jv = new aE();
      Cm.exports = { isAborted: Nv, isCancelled: Fv, isValidEncodedURL: am, createDeferredPromise: bv, ReadableStreamFrom: $L, tryUpgradeRequestToAPotentiallyTrustworthyURL: Sv, clampAndCoarsenConnectionTimingInfo: dv, coarsenedSharedCurrentTime: hv, determineRequestsReferrer: Cv, makePolicyContainer: lm, clonePolicyContainer: Qv, appendFetchMetadata: gv, appendRequestOriginHeader: Ev, TAOCheck: uv, corsCheck: lv, crossOriginResourcePolicyCheck: cv, createOpaqueTimingInfo: fv, setRequestReferrerPolicyOnRedirect: av, isValidHTTPToken: im, requestBadPort: nv, requestCurrentURL: Qn, responseURL: om, responseLocationURL: tv, isURLPotentiallyTrustworthy: fn, isValidReasonPhrase: iv, sameOrigin: ns, normalizeMethod: Tv, serializeJavascriptValueToJSONString: xv, iteratorMixin: kv, createIterator: Em, isValidHeaderName: sv, isValidHeaderValue: cm, isErrorLike: Av, fullyReadBody: Mv, bytesMatch: mv, readableStreamClose: Lv, isomorphicEncode: _a, urlIsLocal: hm, urlHasHttpsScheme: iE, urlIsHttpHttpsScheme: fm, readAllBytes: dm, simpleRangeHeaderValue: Pv, buildContentRange: Yv, parseMetadata: gm, createInflate: Gv, extractMimeType: Ov, getDecodeSplit: Qm, utf8DecodeBytes: qv, environmentSettingsObject: Jv, isOriginIPPotentiallyTrustworthy: um };
    });
    var Za = C2((WK, Bm) => {
      "use strict";
      var { iteratorMixin: Wv } = Ve(), { kEnumerableProperty: bA } = Y2(), { webidl: X } = Te(), { File: _v } = __require("node:buffer"), Im = __require("node:util"), pm = globalThis.File ?? _v, dr = class t2 {
        static {
          __name(this, "t");
        }
        #e = [];
        constructor(e) {
          if (X.util.markAsUncloneable(this), e !== void 0) throw X.errors.conversionFailed({ prefix: "FormData constructor", argument: "Argument 1", types: ["undefined"] });
        }
        append(e, r2, n2 = void 0) {
          X.brandCheck(this, t2);
          let A2 = "FormData.append";
          X.argumentLengthCheck(arguments, 2, A2), e = X.converters.USVString(e), arguments.length === 3 || X.is.Blob(r2) ? (r2 = X.converters.Blob(r2, A2, "value"), n2 !== void 0 && (n2 = X.converters.USVString(n2))) : r2 = X.converters.USVString(r2);
          let i2 = cE(e, r2, n2);
          this.#e.push(i2);
        }
        delete(e) {
          X.brandCheck(this, t2), X.argumentLengthCheck(arguments, 1, "FormData.delete"), e = X.converters.USVString(e), this.#e = this.#e.filter((n2) => n2.name !== e);
        }
        get(e) {
          X.brandCheck(this, t2), X.argumentLengthCheck(arguments, 1, "FormData.get"), e = X.converters.USVString(e);
          let n2 = this.#e.findIndex((A2) => A2.name === e);
          return n2 === -1 ? null : this.#e[n2].value;
        }
        getAll(e) {
          return X.brandCheck(this, t2), X.argumentLengthCheck(arguments, 1, "FormData.getAll"), e = X.converters.USVString(e), this.#e.filter((n2) => n2.name === e).map((n2) => n2.value);
        }
        has(e) {
          return X.brandCheck(this, t2), X.argumentLengthCheck(arguments, 1, "FormData.has"), e = X.converters.USVString(e), this.#e.findIndex((n2) => n2.name === e) !== -1;
        }
        set(e, r2, n2 = void 0) {
          X.brandCheck(this, t2);
          let A2 = "FormData.set";
          X.argumentLengthCheck(arguments, 2, A2), e = X.converters.USVString(e), arguments.length === 3 || X.is.Blob(r2) ? (r2 = X.converters.Blob(r2, A2, "value"), n2 !== void 0 && (n2 = X.converters.USVString(n2))) : r2 = X.converters.USVString(r2);
          let i2 = cE(e, r2, n2), s = this.#e.findIndex((o2) => o2.name === e);
          s !== -1 ? this.#e = [...this.#e.slice(0, s), i2, ...this.#e.slice(s + 1).filter((o2) => o2.name !== e)] : this.#e.push(i2);
        }
        [Im.inspect.custom](e, r2) {
          let n2 = this.#e.reduce((i2, s) => (i2[s.name] ? Array.isArray(i2[s.name]) ? i2[s.name].push(s.value) : i2[s.name] = [i2[s.name], s.value] : i2[s.name] = s.value, i2), { __proto__: null });
          r2.depth ??= e, r2.colors ??= true;
          let A2 = Im.formatWithOptions(r2, n2);
          return `FormData ${A2.slice(A2.indexOf("]") + 2)}`;
        }
        static getFormDataState(e) {
          return e.#e;
        }
        static setFormDataState(e, r2) {
          e.#e = r2;
        }
      }, { getFormDataState: jv, setFormDataState: Zv } = dr;
      Reflect.deleteProperty(dr, "getFormDataState");
      Reflect.deleteProperty(dr, "setFormDataState");
      Wv("FormData", dr, jv, "name", "value");
      Object.defineProperties(dr.prototype, { append: bA, delete: bA, get: bA, getAll: bA, has: bA, set: bA, [Symbol.toStringTag]: { value: "FormData", configurable: true } });
      function cE(t2, e, r2) {
        if (typeof e != "string") {
          if (X.is.File(e) || (e = new pm([e], "blob", { type: e.type })), r2 !== void 0) {
            let n2 = { type: e.type, lastModified: e.lastModified };
            e = new pm([e], r2, n2);
          }
        }
        return { name: t2, value: e };
      }
      __name(cE, "cE");
      X.is.FormData = X.util.MakeTypeAssertion(dr);
      Bm.exports = { FormData: dr, makeEntry: cE, setFormDataState: Zv };
    });
    var Rm = C2((_K, Dm) => {
      "use strict";
      var { isUSVString: mm, bufferToLowerCasedHeaderName: Xv } = Y2(), { utf8DecodeBytes: Kv } = Ve(), { HTTP_TOKEN_CODEPOINTS: $v, isomorphicDecode: ym } = tt(), { makeEntry: zv } = Za(), { webidl: eP } = Te(), Xa = __require("node:assert"), { File: tP } = __require("node:buffer"), rP = globalThis.File ?? tP, nP = Buffer.from('form-data; name="'), AP = Buffer.from("filename"), iP = Buffer.from("--"), sP = Buffer.from(`--\r
`);
      function oP(t2) {
        for (let e = 0; e < t2.length; ++e) if ((t2.charCodeAt(e) & -128) !== 0) return false;
        return true;
      }
      __name(oP, "oP");
      function aP(t2) {
        let e = t2.length;
        if (e < 27 || e > 70) return false;
        for (let r2 = 0; r2 < e; ++r2) {
          let n2 = t2.charCodeAt(r2);
          if (!(n2 >= 48 && n2 <= 57 || n2 >= 65 && n2 <= 90 || n2 >= 97 && n2 <= 122 || n2 === 39 || n2 === 45 || n2 === 95)) return false;
        }
        return true;
      }
      __name(aP, "aP");
      function cP(t2, e) {
        Xa(e !== "failure" && e.essence === "multipart/form-data");
        let r2 = e.parameters.get("boundary");
        if (r2 === void 0) throw Et("missing boundary in content-type header");
        let n2 = Buffer.from(`--${r2}`, "utf8"), A2 = [], i2 = { position: 0 };
        for (; t2[i2.position] === 13 && t2[i2.position + 1] === 10; ) i2.position += 2;
        let s = t2.length;
        for (; t2[s - 1] === 10 && t2[s - 2] === 13; ) s -= 2;
        for (s !== t2.length && (t2 = t2.subarray(0, s)); ; ) {
          if (t2.subarray(i2.position, i2.position + n2.length).equals(n2)) i2.position += n2.length;
          else throw Et("expected a value starting with -- and the boundary");
          if (i2.position === t2.length - 2 && Ka(t2, iP, i2) || i2.position === t2.length - 4 && Ka(t2, sP, i2)) return A2;
          if (t2[i2.position] !== 13 || t2[i2.position + 1] !== 10) throw Et("expected CRLF");
          i2.position += 2;
          let o2 = lP(t2, i2), { name: a2, filename: c2, contentType: l2, encoding: u2 } = o2;
          i2.position += 2;
          let g;
          {
            let h = t2.indexOf(n2.subarray(2), i2.position);
            if (h === -1) throw Et("expected boundary after body");
            g = t2.subarray(i2.position, h - 4), i2.position += g.length, u2 === "base64" && (g = Buffer.from(g.toString(), "base64"));
          }
          if (t2[i2.position] !== 13 || t2[i2.position + 1] !== 10) throw Et("expected CRLF");
          i2.position += 2;
          let E;
          c2 !== null ? (l2 ??= "text/plain", oP(l2) || (l2 = ""), E = new rP([g], c2, { type: l2 })) : E = Kv(Buffer.from(g)), Xa(mm(a2)), Xa(typeof E == "string" && mm(E) || eP.is.File(E)), A2.push(zv(a2, E, c2));
        }
      }
      __name(cP, "cP");
      function lP(t2, e) {
        let r2 = null, n2 = null, A2 = null, i2 = null;
        for (; ; ) {
          if (t2[e.position] === 13 && t2[e.position + 1] === 10) {
            if (r2 === null) throw Et("header name is null");
            return { name: r2, filename: n2, contentType: A2, encoding: i2 };
          }
          let s = hr((o2) => o2 !== 10 && o2 !== 13 && o2 !== 58, t2, e);
          if (s = lE(s, true, true, (o2) => o2 === 9 || o2 === 32), !$v.test(s.toString())) throw Et("header name does not match the field-name token production");
          if (t2[e.position] !== 58) throw Et("expected :");
          switch (e.position++, hr((o2) => o2 === 32 || o2 === 9, t2, e), Xv(s)) {
            case "content-disposition": {
              if (r2 = n2 = null, !Ka(t2, nP, e)) throw Et('expected form-data; name=" for content-disposition header');
              if (e.position += 17, r2 = wm(t2, e), t2[e.position] === 59 && t2[e.position + 1] === 32) {
                let o2 = { position: e.position + 2 };
                if (Ka(t2, AP, o2)) if (t2[o2.position + 8] === 42) {
                  o2.position += 10, hr((c2) => c2 === 32 || c2 === 9, t2, o2);
                  let a2 = hr((c2) => c2 !== 32 && c2 !== 13 && c2 !== 10, t2, o2);
                  if (a2[0] !== 117 && a2[0] !== 85 || a2[1] !== 116 && a2[1] !== 84 || a2[2] !== 102 && a2[2] !== 70 || a2[3] !== 45 || a2[4] !== 56) throw Et("unknown encoding, expected utf-8''");
                  n2 = decodeURIComponent(new TextDecoder().decode(a2.subarray(7))), e.position = o2.position;
                } else e.position += 11, hr((a2) => a2 === 32 || a2 === 9, t2, e), e.position++, n2 = wm(t2, e);
              }
              break;
            }
            case "content-type": {
              let o2 = hr((a2) => a2 !== 10 && a2 !== 13, t2, e);
              o2 = lE(o2, false, true, (a2) => a2 === 9 || a2 === 32), A2 = ym(o2);
              break;
            }
            case "content-transfer-encoding": {
              let o2 = hr((a2) => a2 !== 10 && a2 !== 13, t2, e);
              o2 = lE(o2, false, true, (a2) => a2 === 9 || a2 === 32), i2 = ym(o2);
              break;
            }
            default:
              hr((o2) => o2 !== 10 && o2 !== 13, t2, e);
          }
          if (t2[e.position] !== 13 && t2[e.position + 1] !== 10) throw Et("expected CRLF");
          e.position += 2;
        }
      }
      __name(lP, "lP");
      function wm(t2, e) {
        Xa(t2[e.position - 1] === 34);
        let r2 = hr((n2) => n2 !== 10 && n2 !== 13 && n2 !== 34, t2, e);
        if (t2[e.position] !== 34) throw Et('expected "');
        return e.position++, r2 = new TextDecoder().decode(r2).replace(/%0A/ig, `
`).replace(/%0D/ig, "\r").replace(/%22/g, '"'), r2;
      }
      __name(wm, "wm");
      function hr(t2, e, r2) {
        let n2 = r2.position;
        for (; n2 < e.length && t2(e[n2]); ) ++n2;
        return e.subarray(r2.position, r2.position = n2);
      }
      __name(hr, "hr");
      function lE(t2, e, r2, n2) {
        let A2 = 0, i2 = t2.length - 1;
        if (e) for (; A2 < t2.length && n2(t2[A2]); ) A2++;
        if (r2) for (; i2 > 0 && n2(t2[i2]); ) i2--;
        return A2 === 0 && i2 === t2.length - 1 ? t2 : t2.subarray(A2, i2 + 1);
      }
      __name(lE, "lE");
      function Ka(t2, e, r2) {
        if (t2.length < e.length) return false;
        for (let n2 = 0; n2 < e.length; n2++) if (e[n2] !== t2[r2.position + n2]) return false;
        return true;
      }
      __name(Ka, "Ka");
      function Et(t2) {
        return new TypeError("Failed to parse body as FormData.", { cause: new TypeError(t2) });
      }
      __name(Et, "Et");
      Dm.exports = { multipartFormDataParser: cP, validateBoundary: aP };
    });
    var FA = C2((jK, Um) => {
      "use strict";
      var za = Y2(), { ReadableStreamFrom: uP, readableStreamClose: gP, createDeferredPromise: EP, fullyReadBody: dP, extractMimeType: hP, utf8DecodeBytes: Nm } = Ve(), { FormData: Sm, setFormDataState: fP } = Za(), { webidl: fr } = Te(), { Blob: QP } = __require("node:buffer"), uE = __require("node:assert"), { isErrored: Fm, isDisturbed: CP } = __require("node:stream"), { isArrayBuffer: IP } = __require("node:util/types"), { serializeAMimeType: pP } = tt(), { multipartFormDataParser: BP } = Rm(), gE;
      try {
        let t2 = __require("node:crypto");
        gE = /* @__PURE__ */ __name((e) => t2.randomInt(0, e), "gE");
      } catch {
        gE = /* @__PURE__ */ __name((t2) => Math.floor(Math.random() * t2), "gE");
      }
      var $a = new TextEncoder();
      function mP() {
      }
      __name(mP, "mP");
      var EE = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0, dE;
      EE && (dE = new FinalizationRegistry((t2) => {
        let e = t2.deref();
        e && !e.locked && !CP(e) && !Fm(e) && e.cancel("Response object has been garbage collected").catch(mP);
      }));
      function Tm(t2, e = false) {
        let r2 = null;
        fr.is.ReadableStream(t2) ? r2 = t2 : fr.is.Blob(t2) ? r2 = t2.stream() : r2 = new ReadableStream({ async pull(a2) {
          let c2 = typeof A2 == "string" ? $a.encode(A2) : A2;
          c2.byteLength && a2.enqueue(c2), queueMicrotask(() => gP(a2));
        }, start() {
        }, type: "bytes" }), uE(fr.is.ReadableStream(r2));
        let n2 = null, A2 = null, i2 = null, s = null;
        if (typeof t2 == "string") A2 = t2, s = "text/plain;charset=UTF-8";
        else if (fr.is.URLSearchParams(t2)) A2 = t2.toString(), s = "application/x-www-form-urlencoded;charset=UTF-8";
        else if (IP(t2)) A2 = new Uint8Array(t2.slice());
        else if (ArrayBuffer.isView(t2)) A2 = new Uint8Array(t2.buffer.slice(t2.byteOffset, t2.byteOffset + t2.byteLength));
        else if (fr.is.FormData(t2)) {
          let a2 = `----formdata-undici-0${`${gE(1e11)}`.padStart(11, "0")}`, c2 = `--${a2}\r
Content-Disposition: form-data`;
          let l2 = /* @__PURE__ */ __name((p2) => p2.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), "l"), u2 = /* @__PURE__ */ __name((p2) => p2.replace(/\r?\n|\r/g, `\r
`), "u"), g = [], E = new Uint8Array([13, 10]);
          i2 = 0;
          let h = false;
          for (let [p2, Q] of t2) if (typeof Q == "string") {
            let I2 = $a.encode(c2 + `; name="${l2(u2(p2))}"\r
\r
${u2(Q)}\r
`);
            g.push(I2), i2 += I2.byteLength;
          } else {
            let I2 = $a.encode(`${c2}; name="${l2(u2(p2))}"` + (Q.name ? `; filename="${l2(Q.name)}"` : "") + `\r
Content-Type: ${Q.type || "application/octet-stream"}\r
\r
`);
            g.push(I2, Q, E), typeof Q.size == "number" ? i2 += I2.byteLength + Q.size + E.byteLength : h = true;
          }
          let f2 = $a.encode(`--${a2}--\r
`);
          g.push(f2), i2 += f2.byteLength, h && (i2 = null), A2 = t2, n2 = /* @__PURE__ */ __name(async function* () {
            for (let p2 of g) p2.stream ? yield* p2.stream() : yield p2;
          }, "n"), s = `multipart/form-data; boundary=${a2}`;
        } else if (fr.is.Blob(t2)) A2 = t2, i2 = t2.size, t2.type && (s = t2.type);
        else if (typeof t2[Symbol.asyncIterator] == "function") {
          if (e) throw new TypeError("keepalive");
          if (za.isDisturbed(t2) || t2.locked) throw new TypeError("Response body object should not be disturbed or locked");
          r2 = fr.is.ReadableStream(t2) ? t2 : uP(t2);
        }
        if ((typeof A2 == "string" || za.isBuffer(A2)) && (i2 = Buffer.byteLength(A2)), n2 != null) {
          let a2;
          r2 = new ReadableStream({ async start() {
            a2 = n2(t2)[Symbol.asyncIterator]();
          }, async pull(c2) {
            let { value: l2, done: u2 } = await a2.next();
            if (u2) queueMicrotask(() => {
              c2.close(), c2.byobRequest?.respond(0);
            });
            else if (!Fm(r2)) {
              let g = new Uint8Array(l2);
              g.byteLength && c2.enqueue(g);
            }
            return c2.desiredSize > 0;
          }, async cancel(c2) {
            await a2.return();
          }, type: "bytes" });
        }
        return [{ stream: r2, source: A2, length: i2 }, s];
      }
      __name(Tm, "Tm");
      function yP(t2, e = false) {
        return fr.is.ReadableStream(t2) && (uE(!za.isDisturbed(t2), "The body has already been consumed."), uE(!t2.locked, "The stream is locked.")), Tm(t2, e);
      }
      __name(yP, "yP");
      function wP(t2, e) {
        let [r2, n2] = e.stream.tee();
        return EE && dE.register(t2, new WeakRef(r2)), e.stream = r2, { stream: n2, length: e.length, source: e.source };
      }
      __name(wP, "wP");
      function DP(t2) {
        if (t2.aborted) throw new DOMException("The operation was aborted.", "AbortError");
      }
      __name(DP, "DP");
      function RP(t2, e) {
        return { blob() {
          return NA(this, (n2) => {
            let A2 = bm(e(this));
            return A2 === null ? A2 = "" : A2 && (A2 = pP(A2)), new QP([n2], { type: A2 });
          }, t2, e);
        }, arrayBuffer() {
          return NA(this, (n2) => new Uint8Array(n2).buffer, t2, e);
        }, text() {
          return NA(this, Nm, t2, e);
        }, json() {
          return NA(this, bP, t2, e);
        }, formData() {
          return NA(this, (n2) => {
            let A2 = bm(e(this));
            if (A2 !== null) switch (A2.essence) {
              case "multipart/form-data": {
                let i2 = BP(n2, A2), s = new Sm();
                return fP(s, i2), s;
              }
              case "application/x-www-form-urlencoded": {
                let i2 = new URLSearchParams(n2.toString()), s = new Sm();
                for (let [o2, a2] of i2) s.append(o2, a2);
                return s;
              }
            }
            throw new TypeError('Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".');
          }, t2, e);
        }, bytes() {
          return NA(this, (n2) => new Uint8Array(n2), t2, e);
        } };
      }
      __name(RP, "RP");
      function SP(t2, e) {
        Object.assign(t2.prototype, RP(t2, e));
      }
      __name(SP, "SP");
      async function NA(t2, e, r2, n2) {
        fr.brandCheck(t2, r2);
        let A2 = n2(t2);
        if (xm(A2)) throw new TypeError("Body is unusable: Body has already been read");
        DP(A2);
        let i2 = EP(), s = /* @__PURE__ */ __name((a2) => i2.reject(a2), "s"), o2 = /* @__PURE__ */ __name((a2) => {
          try {
            i2.resolve(e(a2));
          } catch (c2) {
            s(c2);
          }
        }, "o");
        return A2.body == null ? (o2(Buffer.allocUnsafe(0)), i2.promise) : (dP(A2.body, o2, s), i2.promise);
      }
      __name(NA, "NA");
      function xm(t2) {
        let e = t2.body;
        return e != null && (e.stream.locked || za.isDisturbed(e.stream));
      }
      __name(xm, "xm");
      function bP(t2) {
        return JSON.parse(Nm(t2));
      }
      __name(bP, "bP");
      function bm(t2) {
        let e = t2.headersList, r2 = hP(e);
        return r2 === "failure" ? null : r2;
      }
      __name(bm, "bm");
      Um.exports = { extractBody: Tm, safelyExtractBody: yP, cloneBody: wP, mixinBody: SP, streamRegistry: dE, hasFinalizationRegistry: EE, bodyUnusable: xm };
    });
    var qm = C2((ZK, Hm) => {
      "use strict";
      var U = __require("node:assert"), k = Y2(), { channels: km } = lr(), hE = Hg(), { RequestContentLengthMismatchError: In, ResponseContentLengthMismatchError: NP, RequestAbortedError: Gm, HeadersTimeoutError: FP, HeadersOverflowError: TP, SocketError: ss, InformationalError: TA, BodyTimeoutError: xP, HTTPParserError: UP, ResponseExceededMaxSizeError: kP } = H(), { kUrl: Om, kReset: je, kClient: yE, kParser: de, kBlocking: os, kRunning: Me, kPending: MP, kSize: Mm, kWriting: Jr, kQueue: yt, kNoRef: As, kKeepAliveDefaultTimeout: LP, kHostHeader: vP, kPendingIdx: PP, kRunningIdx: dt, kError: ht, kPipelining: rc, kSocket: xA, kKeepAliveTimeoutValue: Ac, kMaxHeadersSize: YP, kKeepAliveMaxTimeout: GP, kKeepAliveTimeoutThreshold: OP, kHeadersTimeout: VP, kBodyTimeout: HP, kStrictContentLength: CE, kMaxRequests: Lm, kCounter: qP, kMaxResponseSize: JP, kOnError: WP, kResume: qr, kHTTPContext: Vm, kClosed: IE } = ne(), Ht = MB(), _P = Buffer.alloc(0), ec = Buffer[Symbol.species], jP = k.removeAllListeners, fE;
      async function ZP() {
        let t2 = process.env.JEST_WORKER_ID ? _g() : void 0, e;
        try {
          e = await WebAssembly.compile(PB());
        } catch {
          e = await WebAssembly.compile(t2 || _g());
        }
        return await WebAssembly.instantiate(e, { env: { wasm_on_url: /* @__PURE__ */ __name((r2, n2, A2) => 0, "wasm_on_url"), wasm_on_status: /* @__PURE__ */ __name((r2, n2, A2) => {
          U(ye.ptr === r2);
          let i2 = n2 - Jt + qt.byteOffset;
          return ye.onStatus(new ec(qt.buffer, i2, A2));
        }, "wasm_on_status"), wasm_on_message_begin: /* @__PURE__ */ __name((r2) => (U(ye.ptr === r2), ye.onMessageBegin()), "wasm_on_message_begin"), wasm_on_header_field: /* @__PURE__ */ __name((r2, n2, A2) => {
          U(ye.ptr === r2);
          let i2 = n2 - Jt + qt.byteOffset;
          return ye.onHeaderField(new ec(qt.buffer, i2, A2));
        }, "wasm_on_header_field"), wasm_on_header_value: /* @__PURE__ */ __name((r2, n2, A2) => {
          U(ye.ptr === r2);
          let i2 = n2 - Jt + qt.byteOffset;
          return ye.onHeaderValue(new ec(qt.buffer, i2, A2));
        }, "wasm_on_header_value"), wasm_on_headers_complete: /* @__PURE__ */ __name((r2, n2, A2, i2) => (U(ye.ptr === r2), ye.onHeadersComplete(n2, A2 === 1, i2 === 1)), "wasm_on_headers_complete"), wasm_on_body: /* @__PURE__ */ __name((r2, n2, A2) => {
          U(ye.ptr === r2);
          let i2 = n2 - Jt + qt.byteOffset;
          return ye.onBody(new ec(qt.buffer, i2, A2));
        }, "wasm_on_body"), wasm_on_message_complete: /* @__PURE__ */ __name((r2) => (U(ye.ptr === r2), ye.onMessageComplete()), "wasm_on_message_complete") } });
      }
      __name(ZP, "ZP");
      var QE = null, pE = ZP();
      pE.catch();
      var ye = null, qt = null, tc = 0, Jt = null, XP = 0, is = 1, UA = 2 | is, nc = 4 | is, BE = 8 | XP, mE = class {
        static {
          __name(this, "mE");
        }
        constructor(e, r2, { exports: n2 }) {
          this.llhttp = n2, this.ptr = this.llhttp.llhttp_alloc(Ht.TYPE.RESPONSE), this.client = e, this.socket = r2, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = 0, this.statusText = "", this.upgrade = false, this.headers = [], this.headersSize = 0, this.headersMaxSize = e[YP], this.shouldKeepAlive = false, this.paused = false, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = e[JP];
        }
        setTimeout(e, r2) {
          e !== this.timeoutValue || r2 & is ^ this.timeoutType & is ? (this.timeout && (hE.clearTimeout(this.timeout), this.timeout = null), e && (r2 & is ? this.timeout = hE.setFastTimeout(vm, e, new WeakRef(this)) : (this.timeout = setTimeout(vm, e, new WeakRef(this)), this.timeout.unref())), this.timeoutValue = e) : this.timeout && this.timeout.refresh && this.timeout.refresh(), this.timeoutType = r2;
        }
        resume() {
          this.socket.destroyed || !this.paused || (U(this.ptr != null), U(ye === null), this.llhttp.llhttp_resume(this.ptr), U(this.timeoutType === nc), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = false, this.execute(this.socket.read() || _P), this.readMore());
        }
        readMore() {
          for (; !this.paused && this.ptr; ) {
            let e = this.socket.read();
            if (e === null) break;
            this.execute(e);
          }
        }
        execute(e) {
          U(ye === null), U(this.ptr != null), U(!this.paused);
          let { socket: r2, llhttp: n2 } = this;
          e.length > tc && (Jt && n2.free(Jt), tc = Math.ceil(e.length / 4096) * 4096, Jt = n2.malloc(tc)), new Uint8Array(n2.memory.buffer, Jt, tc).set(e);
          try {
            let A2;
            try {
              qt = e, ye = this, A2 = n2.llhttp_execute(this.ptr, Jt, e.length);
            } catch (i2) {
              throw i2;
            } finally {
              ye = null, qt = null;
            }
            if (A2 !== Ht.ERROR.OK) {
              let i2 = e.subarray(n2.llhttp_get_error_pos(this.ptr) - Jt);
              if (A2 === Ht.ERROR.PAUSED_UPGRADE) this.onUpgrade(i2);
              else if (A2 === Ht.ERROR.PAUSED) this.paused = true, r2.unshift(i2);
              else {
                let s = n2.llhttp_get_error_reason(this.ptr), o2 = "";
                if (s) {
                  let a2 = new Uint8Array(n2.memory.buffer, s).indexOf(0);
                  o2 = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(n2.memory.buffer, s, a2).toString() + ")";
                }
                throw new UP(o2, Ht.ERROR[A2], i2);
              }
            }
          } catch (A2) {
            k.destroy(r2, A2);
          }
        }
        destroy() {
          U(ye === null), U(this.ptr != null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, this.timeout && hE.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = false;
        }
        onStatus(e) {
          return this.statusText = e.toString(), 0;
        }
        onMessageBegin() {
          let { socket: e, client: r2 } = this;
          if (e.destroyed) return -1;
          let n2 = r2[yt][r2[dt]];
          return n2 ? (n2.onResponseStarted(), 0) : -1;
        }
        onHeaderField(e) {
          let r2 = this.headers.length;
          return (r2 & 1) === 0 ? this.headers.push(e) : this.headers[r2 - 1] = Buffer.concat([this.headers[r2 - 1], e]), this.trackHeader(e.length), 0;
        }
        onHeaderValue(e) {
          let r2 = this.headers.length;
          (r2 & 1) === 1 ? (this.headers.push(e), r2 += 1) : this.headers[r2 - 1] = Buffer.concat([this.headers[r2 - 1], e]);
          let n2 = this.headers[r2 - 2];
          if (n2.length === 10) {
            let A2 = k.bufferToLowerCasedHeaderName(n2);
            A2 === "keep-alive" ? this.keepAlive += e.toString() : A2 === "connection" && (this.connection += e.toString());
          } else n2.length === 14 && k.bufferToLowerCasedHeaderName(n2) === "content-length" && (this.contentLength += e.toString());
          return this.trackHeader(e.length), 0;
        }
        trackHeader(e) {
          this.headersSize += e, this.headersSize >= this.headersMaxSize && k.destroy(this.socket, new TP());
        }
        onUpgrade(e) {
          let { upgrade: r2, client: n2, socket: A2, headers: i2, statusCode: s } = this;
          U(r2), U(n2[xA] === A2), U(!A2.destroyed), U(!this.paused), U((i2.length & 1) === 0);
          let o2 = n2[yt][n2[dt]];
          U(o2), U(o2.upgrade || o2.method === "CONNECT"), this.statusCode = 0, this.statusText = "", this.shouldKeepAlive = false, this.headers = [], this.headersSize = 0, A2.unshift(e), A2[de].destroy(), A2[de] = null, A2[yE] = null, A2[ht] = null, jP(A2), n2[xA] = null, n2[Vm] = null, n2[yt][n2[dt]++] = null, n2.emit("disconnect", n2[Om], [n2], new TA("upgrade"));
          try {
            o2.onUpgrade(s, i2, A2);
          } catch (a2) {
            k.destroy(A2, a2);
          }
          n2[qr]();
        }
        onHeadersComplete(e, r2, n2) {
          let { client: A2, socket: i2, headers: s, statusText: o2 } = this;
          if (i2.destroyed) return -1;
          let a2 = A2[yt][A2[dt]];
          if (!a2) return -1;
          if (U(!this.upgrade), U(this.statusCode < 200), e === 100) return k.destroy(i2, new ss("bad response", k.getSocketInfo(i2))), -1;
          if (r2 && !a2.upgrade) return k.destroy(i2, new ss("bad upgrade", k.getSocketInfo(i2))), -1;
          if (U(this.timeoutType === UA), this.statusCode = e, this.shouldKeepAlive = n2 || a2.method === "HEAD" && !i2[je] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
            let l2 = a2.bodyTimeout != null ? a2.bodyTimeout : A2[HP];
            this.setTimeout(l2, nc);
          } else this.timeout && this.timeout.refresh && this.timeout.refresh();
          if (a2.method === "CONNECT") return U(A2[Me] === 1), this.upgrade = true, 2;
          if (r2) return U(A2[Me] === 1), this.upgrade = true, 2;
          if (U((this.headers.length & 1) === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && A2[rc]) {
            let l2 = this.keepAlive ? k.parseKeepAliveTimeout(this.keepAlive) : null;
            if (l2 != null) {
              let u2 = Math.min(l2 - A2[OP], A2[GP]);
              u2 <= 0 ? i2[je] = true : A2[Ac] = u2;
            } else A2[Ac] = A2[LP];
          } else i2[je] = true;
          let c2 = a2.onHeaders(e, s, this.resume, o2) === false;
          return a2.aborted ? -1 : a2.method === "HEAD" || e < 200 ? 1 : (i2[os] && (i2[os] = false, A2[qr]()), c2 ? Ht.ERROR.PAUSED : 0);
        }
        onBody(e) {
          let { client: r2, socket: n2, statusCode: A2, maxResponseSize: i2 } = this;
          if (n2.destroyed) return -1;
          let s = r2[yt][r2[dt]];
          return U(s), U(this.timeoutType === nc), this.timeout && this.timeout.refresh && this.timeout.refresh(), U(A2 >= 200), i2 > -1 && this.bytesRead + e.length > i2 ? (k.destroy(n2, new kP()), -1) : (this.bytesRead += e.length, s.onData(e) === false ? Ht.ERROR.PAUSED : 0);
        }
        onMessageComplete() {
          let { client: e, socket: r2, statusCode: n2, upgrade: A2, headers: i2, contentLength: s, bytesRead: o2, shouldKeepAlive: a2 } = this;
          if (r2.destroyed && (!n2 || a2)) return -1;
          if (A2) return 0;
          U(n2 >= 100), U((this.headers.length & 1) === 0);
          let c2 = e[yt][e[dt]];
          if (U(c2), this.statusCode = 0, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", this.headers = [], this.headersSize = 0, n2 < 200) return 0;
          if (c2.method !== "HEAD" && s && o2 !== parseInt(s, 10)) return k.destroy(r2, new NP()), -1;
          if (c2.onComplete(i2), e[yt][e[dt]++] = null, r2[Jr]) return U(e[Me] === 0), k.destroy(r2, new TA("reset")), Ht.ERROR.PAUSED;
          if (a2) {
            if (r2[je] && e[Me] === 0) return k.destroy(r2, new TA("reset")), Ht.ERROR.PAUSED;
            e[rc] == null || e[rc] === 1 ? setImmediate(() => e[qr]()) : e[qr]();
          } else return k.destroy(r2, new TA("reset")), Ht.ERROR.PAUSED;
          return 0;
        }
      };
      function vm(t2) {
        let { socket: e, timeoutType: r2, client: n2, paused: A2 } = t2.deref();
        r2 === UA ? (!e[Jr] || e.writableNeedDrain || n2[Me] > 1) && (U(!A2, "cannot be paused while waiting for headers"), k.destroy(e, new FP())) : r2 === nc ? A2 || k.destroy(e, new xP()) : r2 === BE && (U(n2[Me] === 0 && n2[Ac]), k.destroy(e, new TA("socket idle timeout")));
      }
      __name(vm, "vm");
      async function KP(t2, e) {
        if (t2[xA] = e, !QE) {
          let r2 = /* @__PURE__ */ __name(() => {
          }, "r");
          e.on("error", r2), QE = await pE, pE = null, e.off("error", r2);
        }
        if (e.errored) throw e.errored;
        if (e.destroyed) throw new ss("destroyed");
        return e[As] = false, e[Jr] = false, e[je] = false, e[os] = false, e[de] = new mE(t2, e, QE), k.addListener(e, "error", $P), k.addListener(e, "readable", zP), k.addListener(e, "end", e1), k.addListener(e, "close", t1), e[IE] = false, e.on("close", r1), { version: "h1", defaultPipelining: 1, write(r2) {
          return i1(t2, r2);
        }, resume() {
          n1(t2);
        }, destroy(r2, n2) {
          e[IE] ? queueMicrotask(n2) : (e.on("close", n2), e.destroy(r2));
        }, get destroyed() {
          return e.destroyed;
        }, busy(r2) {
          return !!(e[Jr] || e[je] || e[os] || r2 && (t2[Me] > 0 && !r2.idempotent || t2[Me] > 0 && (r2.upgrade || r2.method === "CONNECT") || t2[Me] > 0 && k.bodyLength(r2.body) !== 0 && (k.isStream(r2.body) || k.isAsyncIterable(r2.body) || k.isFormDataLike(r2.body))));
        } };
      }
      __name(KP, "KP");
      function $P(t2) {
        U(t2.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
        let e = this[de];
        if (t2.code === "ECONNRESET" && e.statusCode && !e.shouldKeepAlive) {
          e.onMessageComplete();
          return;
        }
        this[ht] = t2, this[yE][WP](t2);
      }
      __name($P, "$P");
      function zP() {
        this[de]?.readMore();
      }
      __name(zP, "zP");
      function e1() {
        let t2 = this[de];
        if (t2.statusCode && !t2.shouldKeepAlive) {
          t2.onMessageComplete();
          return;
        }
        k.destroy(this, new ss("other side closed", k.getSocketInfo(this)));
      }
      __name(e1, "e1");
      function t1() {
        let t2 = this[de];
        t2 && (!this[ht] && t2.statusCode && !t2.shouldKeepAlive && t2.onMessageComplete(), this[de].destroy(), this[de] = null);
        let e = this[ht] || new ss("closed", k.getSocketInfo(this)), r2 = this[yE];
        if (r2[xA] = null, r2[Vm] = null, r2.destroyed) {
          U(r2[MP] === 0);
          let n2 = r2[yt].splice(r2[dt]);
          for (let A2 = 0; A2 < n2.length; A2++) {
            let i2 = n2[A2];
            k.errorRequest(r2, i2, e);
          }
        } else if (r2[Me] > 0 && e.code !== "UND_ERR_INFO") {
          let n2 = r2[yt][r2[dt]];
          r2[yt][r2[dt]++] = null, k.errorRequest(r2, n2, e);
        }
        r2[PP] = r2[dt], U(r2[Me] === 0), r2.emit("disconnect", r2[Om], [r2], e), r2[qr]();
      }
      __name(t1, "t1");
      function r1() {
        this[IE] = true;
      }
      __name(r1, "r1");
      function n1(t2) {
        let e = t2[xA];
        if (e && !e.destroyed) {
          if (t2[Mm] === 0 ? !e[As] && e.unref && (e.unref(), e[As] = true) : e[As] && e.ref && (e.ref(), e[As] = false), t2[Mm] === 0) e[de].timeoutType !== BE && e[de].setTimeout(t2[Ac], BE);
          else if (t2[Me] > 0 && e[de].statusCode < 200 && e[de].timeoutType !== UA) {
            let r2 = t2[yt][t2[dt]], n2 = r2.headersTimeout != null ? r2.headersTimeout : t2[VP];
            e[de].setTimeout(n2, UA);
          }
        }
      }
      __name(n1, "n1");
      function A1(t2) {
        return t2 !== "GET" && t2 !== "HEAD" && t2 !== "OPTIONS" && t2 !== "TRACE" && t2 !== "CONNECT";
      }
      __name(A1, "A1");
      function i1(t2, e) {
        let { method: r2, path: n2, host: A2, upgrade: i2, blocking: s, reset: o2 } = e, { body: a2, headers: c2, contentLength: l2 } = e, u2 = r2 === "PUT" || r2 === "POST" || r2 === "PATCH" || r2 === "QUERY" || r2 === "PROPFIND" || r2 === "PROPPATCH";
        if (k.isFormDataLike(a2)) {
          fE || (fE = FA().extractBody);
          let [p2, Q] = fE(a2);
          e.contentType == null && c2.push("content-type", Q), a2 = p2.stream, l2 = p2.length;
        } else k.isBlobLike(a2) && e.contentType == null && a2.type && c2.push("content-type", a2.type);
        a2 && typeof a2.read == "function" && a2.read(0);
        let g = k.bodyLength(a2);
        if (l2 = g ?? l2, l2 === null && (l2 = e.contentLength), l2 === 0 && !u2 && (l2 = null), A1(r2) && l2 > 0 && e.contentLength !== null && e.contentLength !== l2) {
          if (t2[CE]) return k.errorRequest(t2, e, new In()), false;
          process.emitWarning(new In());
        }
        let E = t2[xA], h = /* @__PURE__ */ __name((p2) => {
          e.aborted || e.completed || (k.errorRequest(t2, e, p2 || new Gm()), k.destroy(a2), k.destroy(E, new TA("aborted")));
        }, "h");
        try {
          e.onConnect(h);
        } catch (p2) {
          k.errorRequest(t2, e, p2);
        }
        if (e.aborted) return false;
        r2 === "HEAD" && (E[je] = true), (i2 || r2 === "CONNECT") && (E[je] = true), o2 != null && (E[je] = o2), t2[Lm] && E[qP]++ >= t2[Lm] && (E[je] = true), s && (E[os] = true);
        let f2 = `${r2} ${n2} HTTP/1.1\r
`;
        if (typeof A2 == "string" ? f2 += `host: ${A2}\r
` : f2 += t2[vP], i2 ? f2 += `connection: upgrade\r
upgrade: ${i2}\r
` : t2[rc] && !E[je] ? f2 += `connection: keep-alive\r
` : f2 += `connection: close\r
`, Array.isArray(c2)) for (let p2 = 0; p2 < c2.length; p2 += 2) {
          let Q = c2[p2 + 0], I2 = c2[p2 + 1];
          if (Array.isArray(I2)) for (let B = 0; B < I2.length; B++) f2 += `${Q}: ${I2[B]}\r
`;
          else f2 += `${Q}: ${I2}\r
`;
        }
        return km.sendHeaders.hasSubscribers && km.sendHeaders.publish({ request: e, headers: f2, socket: E }), !a2 || g === 0 ? Pm(h, null, t2, e, E, l2, f2, u2) : k.isBuffer(a2) ? Pm(h, a2, t2, e, E, l2, f2, u2) : k.isBlobLike(a2) ? typeof a2.stream == "function" ? Ym(h, a2.stream(), t2, e, E, l2, f2, u2) : o1(h, a2, t2, e, E, l2, f2, u2) : k.isStream(a2) ? s1(h, a2, t2, e, E, l2, f2, u2) : k.isIterable(a2) ? Ym(h, a2, t2, e, E, l2, f2, u2) : U(false), true;
      }
      __name(i1, "i1");
      function s1(t2, e, r2, n2, A2, i2, s, o2) {
        U(i2 !== 0 || r2[Me] === 0, "stream body cannot be pipelined");
        let a2 = false, c2 = new ic({ abort: t2, socket: A2, request: n2, contentLength: i2, client: r2, expectsPayload: o2, header: s }), l2 = /* @__PURE__ */ __name(function(h) {
          if (!a2) try {
            !c2.write(h) && this.pause && this.pause();
          } catch (f2) {
            k.destroy(this, f2);
          }
        }, "l"), u2 = /* @__PURE__ */ __name(function() {
          a2 || e.resume && e.resume();
        }, "u"), g = /* @__PURE__ */ __name(function() {
          if (queueMicrotask(() => {
            e.removeListener("error", E);
          }), !a2) {
            let h = new Gm();
            queueMicrotask(() => E(h));
          }
        }, "g"), E = /* @__PURE__ */ __name(function(h) {
          if (!a2) {
            if (a2 = true, U(A2.destroyed || A2[Jr] && r2[Me] <= 1), A2.off("drain", u2).off("error", E), e.removeListener("data", l2).removeListener("end", E).removeListener("close", g), !h) try {
              c2.end();
            } catch (f2) {
              h = f2;
            }
            c2.destroy(h), h && (h.code !== "UND_ERR_INFO" || h.message !== "reset") ? k.destroy(e, h) : k.destroy(e);
          }
        }, "E");
        e.on("data", l2).on("end", E).on("error", E).on("close", g), e.resume && e.resume(), A2.on("drain", u2).on("error", E), e.errorEmitted ?? e.errored ? setImmediate(() => E(e.errored)) : (e.endEmitted ?? e.readableEnded) && setImmediate(() => E(null)), (e.closeEmitted ?? e.closed) && setImmediate(g);
      }
      __name(s1, "s1");
      function Pm(t2, e, r2, n2, A2, i2, s, o2) {
        try {
          e ? k.isBuffer(e) && (U(i2 === e.byteLength, "buffer body must have content length"), A2.cork(), A2.write(`${s}content-length: ${i2}\r
\r
`, "latin1"), A2.write(e), A2.uncork(), n2.onBodySent(e), !o2 && n2.reset !== false && (A2[je] = true)) : i2 === 0 ? A2.write(`${s}content-length: 0\r
\r
`, "latin1") : (U(i2 === null, "no body must not have content length"), A2.write(`${s}\r
`, "latin1")), n2.onRequestSent(), r2[qr]();
        } catch (a2) {
          t2(a2);
        }
      }
      __name(Pm, "Pm");
      async function o1(t2, e, r2, n2, A2, i2, s, o2) {
        U(i2 === e.size, "blob body must have content length");
        try {
          if (i2 != null && i2 !== e.size) throw new In();
          let a2 = Buffer.from(await e.arrayBuffer());
          A2.cork(), A2.write(`${s}content-length: ${i2}\r
\r
`, "latin1"), A2.write(a2), A2.uncork(), n2.onBodySent(a2), n2.onRequestSent(), !o2 && n2.reset !== false && (A2[je] = true), r2[qr]();
        } catch (a2) {
          t2(a2);
        }
      }
      __name(o1, "o1");
      async function Ym(t2, e, r2, n2, A2, i2, s, o2) {
        U(i2 !== 0 || r2[Me] === 0, "iterator body cannot be pipelined");
        let a2 = null;
        function c2() {
          if (a2) {
            let g = a2;
            a2 = null, g();
          }
        }
        __name(c2, "c");
        let l2 = /* @__PURE__ */ __name(() => new Promise((g, E) => {
          U(a2 === null), A2[ht] ? E(A2[ht]) : a2 = g;
        }), "l");
        A2.on("close", c2).on("drain", c2);
        let u2 = new ic({ abort: t2, socket: A2, request: n2, contentLength: i2, client: r2, expectsPayload: o2, header: s });
        try {
          for await (let g of e) {
            if (A2[ht]) throw A2[ht];
            u2.write(g) || await l2();
          }
          u2.end();
        } catch (g) {
          u2.destroy(g);
        } finally {
          A2.off("close", c2).off("drain", c2);
        }
      }
      __name(Ym, "Ym");
      var ic = class {
        static {
          __name(this, "ic");
        }
        constructor({ abort: e, socket: r2, request: n2, contentLength: A2, client: i2, expectsPayload: s, header: o2 }) {
          this.socket = r2, this.request = n2, this.contentLength = A2, this.client = i2, this.bytesWritten = 0, this.expectsPayload = s, this.header = o2, this.abort = e, r2[Jr] = true;
        }
        write(e) {
          let { socket: r2, request: n2, contentLength: A2, client: i2, bytesWritten: s, expectsPayload: o2, header: a2 } = this;
          if (r2[ht]) throw r2[ht];
          if (r2.destroyed) return false;
          let c2 = Buffer.byteLength(e);
          if (!c2) return true;
          if (A2 !== null && s + c2 > A2) {
            if (i2[CE]) throw new In();
            process.emitWarning(new In());
          }
          r2.cork(), s === 0 && (!o2 && n2.reset !== false && (r2[je] = true), A2 === null ? r2.write(`${a2}transfer-encoding: chunked\r
`, "latin1") : r2.write(`${a2}content-length: ${A2}\r
\r
`, "latin1")), A2 === null && r2.write(`\r
${c2.toString(16)}\r
`, "latin1"), this.bytesWritten += c2;
          let l2 = r2.write(e);
          return r2.uncork(), n2.onBodySent(e), l2 || r2[de].timeout && r2[de].timeoutType === UA && r2[de].timeout.refresh && r2[de].timeout.refresh(), l2;
        }
        end() {
          let { socket: e, contentLength: r2, client: n2, bytesWritten: A2, expectsPayload: i2, header: s, request: o2 } = this;
          if (o2.onRequestSent(), e[Jr] = false, e[ht]) throw e[ht];
          if (!e.destroyed) {
            if (A2 === 0 ? i2 ? e.write(`${s}content-length: 0\r
\r
`, "latin1") : e.write(`${s}\r
`, "latin1") : r2 === null && e.write(`\r
0\r
\r
`, "latin1"), r2 !== null && A2 !== r2) {
              if (n2[CE]) throw new In();
              process.emitWarning(new In());
            }
            e[de].timeout && e[de].timeoutType === UA && e[de].timeout.refresh && e[de].timeout.refresh(), n2[qr]();
          }
        }
        destroy(e) {
          let { socket: r2, client: n2, abort: A2 } = this;
          r2[Jr] = false, e && (U(n2[Me] <= 1, "pipeline should only contain this request"), A2(e));
        }
      };
      Hm.exports = KP;
    });
    var Km = C2((XK, Xm) => {
      "use strict";
      var Qt = __require("node:assert"), { pipeline: a1 } = __require("node:stream"), J = Y2(), { RequestContentLengthMismatchError: wE, RequestAbortedError: c1, SocketError: as, InformationalError: sc } = H(), { kUrl: ac, kReset: cc, kClient: pn, kRunning: lc, kPending: l1, kQueue: Wr, kPendingIdx: RE, kRunningIdx: wt, kError: Dt, kSocket: fe, kStrictContentLength: u1, kOnError: uc, kMaxConcurrentStreams: Zm, kHTTP2Session: Wt, kResume: Qr, kSize: g1, kHTTPContext: SE, kClosed: DE, kBodyTimeout: E1 } = ne(), { channels: Jm } = lr(), ft = Symbol("open streams"), Wm, oc;
      try {
        oc = __require("node:http2");
      } catch {
        oc = { constants: {} };
      }
      var { constants: { HTTP2_HEADER_AUTHORITY: d1, HTTP2_HEADER_METHOD: h1, HTTP2_HEADER_PATH: f1, HTTP2_HEADER_SCHEME: Q1, HTTP2_HEADER_CONTENT_LENGTH: C1, HTTP2_HEADER_EXPECT: I1, HTTP2_HEADER_STATUS: p1 } } = oc;
      function B1(t2) {
        let e = [];
        for (let [r2, n2] of Object.entries(t2)) if (Array.isArray(n2)) for (let A2 of n2) e.push(Buffer.from(r2), Buffer.from(A2));
        else e.push(Buffer.from(r2), Buffer.from(n2));
        return e;
      }
      __name(B1, "B1");
      async function m1(t2, e) {
        t2[fe] = e;
        let r2 = oc.connect(t2[ac], { createConnection: /* @__PURE__ */ __name(() => e, "createConnection"), peerMaxConcurrentStreams: t2[Zm], settings: { enablePush: false } });
        return r2[ft] = 0, r2[pn] = t2, r2[fe] = e, r2[Wt] = null, J.addListener(r2, "error", w1), J.addListener(r2, "frameError", D1), J.addListener(r2, "end", R1), J.addListener(r2, "goaway", S1), J.addListener(r2, "close", b1), r2.unref(), t2[Wt] = r2, e[Wt] = r2, J.addListener(e, "error", F1), J.addListener(e, "end", T1), J.addListener(e, "close", N1), e[DE] = false, e.on("close", x1), { version: "h2", defaultPipelining: 1 / 0, write(n2) {
          return k1(t2, n2);
        }, resume() {
          y1(t2);
        }, destroy(n2, A2) {
          e[DE] ? queueMicrotask(A2) : e.destroy(n2).on("close", A2);
        }, get destroyed() {
          return e.destroyed;
        }, busy() {
          return false;
        } };
      }
      __name(m1, "m1");
      function y1(t2) {
        let e = t2[fe];
        e?.destroyed === false && (t2[g1] === 0 || t2[Zm] === 0 ? (e.unref(), t2[Wt].unref()) : (e.ref(), t2[Wt].ref()));
      }
      __name(y1, "y1");
      function w1(t2) {
        Qt(t2.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[fe][Dt] = t2, this[pn][uc](t2);
      }
      __name(w1, "w1");
      function D1(t2, e, r2) {
        if (r2 === 0) {
          let n2 = new sc(`HTTP/2: "frameError" received - type ${t2}, code ${e}`);
          this[fe][Dt] = n2, this[pn][uc](n2);
        }
      }
      __name(D1, "D1");
      function R1() {
        let t2 = new as("other side closed", J.getSocketInfo(this[fe]));
        this.destroy(t2), J.destroy(this[fe], t2);
      }
      __name(R1, "R1");
      function S1(t2) {
        let e = this[Dt] || new as(`HTTP/2: "GOAWAY" frame received with code ${t2}`, J.getSocketInfo(this[fe])), r2 = this[pn];
        if (r2[fe] = null, r2[SE] = null, this.close(), this[Wt] = null, J.destroy(this[fe], e), r2[wt] < r2[Wr].length) {
          let n2 = r2[Wr][r2[wt]];
          r2[Wr][r2[wt]++] = null, J.errorRequest(r2, n2, e), r2[RE] = r2[wt];
        }
        Qt(r2[lc] === 0), r2.emit("disconnect", r2[ac], [r2], e), r2[Qr]();
      }
      __name(S1, "S1");
      function b1() {
        let { [pn]: t2 } = this, { [fe]: e } = t2, r2 = this[fe][Dt] || this[Dt] || new as("closed", J.getSocketInfo(e));
        if (t2[fe] = null, t2[SE] = null, t2.destroyed) {
          Qt(t2[l1] === 0);
          let n2 = t2[Wr].splice(t2[wt]);
          for (let A2 = 0; A2 < n2.length; A2++) {
            let i2 = n2[A2];
            J.errorRequest(t2, i2, r2);
          }
        }
      }
      __name(b1, "b1");
      function N1() {
        let t2 = this[Dt] || new as("closed", J.getSocketInfo(this)), e = this[Wt][pn];
        e[fe] = null, e[SE] = null, this[Wt] !== null && this[Wt].destroy(t2), e[RE] = e[wt], Qt(e[lc] === 0), e.emit("disconnect", e[ac], [e], t2), e[Qr]();
      }
      __name(N1, "N1");
      function F1(t2) {
        Qt(t2.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[Dt] = t2, this[pn][uc](t2);
      }
      __name(F1, "F1");
      function T1() {
        J.destroy(this, new as("other side closed", J.getSocketInfo(this)));
      }
      __name(T1, "T1");
      function x1() {
        this[DE] = true;
      }
      __name(x1, "x1");
      function U1(t2) {
        return t2 !== "GET" && t2 !== "HEAD" && t2 !== "OPTIONS" && t2 !== "TRACE" && t2 !== "CONNECT";
      }
      __name(U1, "U1");
      function k1(t2, e) {
        let r2 = e.bodyTimeout ?? t2[E1], n2 = t2[Wt], { method: A2, path: i2, host: s, upgrade: o2, expectContinue: a2, signal: c2, headers: l2 } = e, { body: u2 } = e;
        if (o2) return J.errorRequest(t2, e, new Error("Upgrade not supported for H2")), false;
        let g = {};
        for (let D2 = 0; D2 < l2.length; D2 += 2) {
          let v2 = l2[D2 + 0], K2 = l2[D2 + 1];
          if (Array.isArray(K2)) for (let W2 = 0; W2 < K2.length; W2++) g[v2] ? g[v2] += `,${K2[W2]}` : g[v2] = K2[W2];
          else g[v2] = K2;
        }
        let E = null, { hostname: h, port: f2 } = t2[ac];
        g[d1] = s || `${h}${f2 ? `:${f2}` : ""}`, g[h1] = A2;
        let p2 = /* @__PURE__ */ __name((D2) => {
          e.aborted || e.completed || (D2 = D2 || new c1(), J.errorRequest(t2, e, D2), E != null && (E.removeAllListeners("data"), E.close(), t2[uc](D2), t2[Qr]()), J.destroy(u2, D2));
        }, "p");
        try {
          e.onConnect(p2);
        } catch (D2) {
          J.errorRequest(t2, e, D2);
        }
        if (e.aborted) return false;
        if (A2 === "CONNECT") return n2.ref(), E = n2.request(g, { endStream: false, signal: c2 }), E.pending ? E.once("ready", () => {
          e.onUpgrade(null, null, E), ++n2[ft], t2[Wr][t2[wt]++] = null;
        }) : (e.onUpgrade(null, null, E), ++n2[ft], t2[Wr][t2[wt]++] = null), E.once("close", () => {
          n2[ft] -= 1, n2[ft] === 0 && n2.unref();
        }), E.setTimeout(r2), true;
        g[f1] = i2, g[Q1] = "https";
        let Q = A2 === "PUT" || A2 === "POST" || A2 === "PATCH";
        u2 && typeof u2.read == "function" && u2.read(0);
        let I2 = J.bodyLength(u2);
        if (J.isFormDataLike(u2)) {
          Wm ??= FA().extractBody;
          let [D2, v2] = Wm(u2);
          g["content-type"] = v2, u2 = D2.stream, I2 = D2.length;
        }
        if (I2 == null && (I2 = e.contentLength), (I2 === 0 || !Q) && (I2 = null), U1(A2) && I2 > 0 && e.contentLength != null && e.contentLength !== I2) {
          if (t2[u1]) return J.errorRequest(t2, e, new wE()), false;
          process.emitWarning(new wE());
        }
        if (I2 != null && (Qt(u2, "no body must not have content length"), g[C1] = `${I2}`), n2.ref(), Jm.sendHeaders.hasSubscribers) {
          let D2 = "";
          for (let v2 in g) D2 += `${v2}: ${g[v2]}\r
`;
          Jm.sendHeaders.publish({ request: e, headers: D2, socket: n2[fe] });
        }
        let B = A2 === "GET" || A2 === "HEAD" || u2 === null;
        return a2 ? (g[I1] = "100-continue", E = n2.request(g, { endStream: B, signal: c2 }), E.once("continue", w)) : (E = n2.request(g, { endStream: B, signal: c2 }), w()), ++n2[ft], E.setTimeout(r2), E.once("response", (D2) => {
          let { [p1]: v2, ...K2 } = D2;
          if (e.onResponseStarted(), e.aborted) {
            E.removeAllListeners("data");
            return;
          }
          e.onHeaders(Number(v2), B1(K2), E.resume.bind(E), "") === false && E.pause();
        }), E.on("data", (D2) => {
          e.onData(D2) === false && E.pause();
        }), E.once("end", (D2) => {
          E.removeAllListeners("data"), E.state?.state == null || E.state.state < 6 ? (!e.aborted && !e.completed && e.onComplete({}), t2[Wr][t2[wt]++] = null, t2[Qr]()) : (--n2[ft], n2[ft] === 0 && n2.unref(), p2(D2 ?? new sc("HTTP/2: stream half-closed (remote)")), t2[Wr][t2[wt]++] = null, t2[RE] = t2[wt], t2[Qr]());
        }), E.once("close", () => {
          E.removeAllListeners("data"), n2[ft] -= 1, n2[ft] === 0 && n2.unref();
        }), E.once("error", function(D2) {
          E.removeAllListeners("data"), p2(D2);
        }), E.once("frameError", (D2, v2) => {
          E.removeAllListeners("data"), p2(new sc(`HTTP/2: "frameError" received - type ${D2}, code ${v2}`));
        }), E.on("aborted", () => {
          E.removeAllListeners("data");
        }), E.on("timeout", () => {
          let D2 = new sc(`HTTP/2: "stream timeout after ${r2}"`);
          E.removeAllListeners("data"), n2[ft] -= 1, n2[ft] === 0 && n2.unref(), p2(D2);
        }), E.once("trailers", (D2) => {
          e.aborted || e.completed || e.onComplete(D2);
        }), true;
        function w() {
          !u2 || I2 === 0 ? _m(p2, E, null, t2, e, t2[fe], I2, Q) : J.isBuffer(u2) ? _m(p2, E, u2, t2, e, t2[fe], I2, Q) : J.isBlobLike(u2) ? typeof u2.stream == "function" ? jm(p2, E, u2.stream(), t2, e, t2[fe], I2, Q) : L1(p2, E, u2, t2, e, t2[fe], I2, Q) : J.isStream(u2) ? M1(p2, t2[fe], Q, E, u2, t2, e, I2) : J.isIterable(u2) ? jm(p2, E, u2, t2, e, t2[fe], I2, Q) : Qt(false);
        }
        __name(w, "w");
      }
      __name(k1, "k1");
      function _m(t2, e, r2, n2, A2, i2, s, o2) {
        try {
          r2 != null && J.isBuffer(r2) && (Qt(s === r2.byteLength, "buffer body must have content length"), e.cork(), e.write(r2), e.uncork(), e.end(), A2.onBodySent(r2)), o2 || (i2[cc] = true), A2.onRequestSent(), n2[Qr]();
        } catch (a2) {
          t2(a2);
        }
      }
      __name(_m, "_m");
      function M1(t2, e, r2, n2, A2, i2, s, o2) {
        Qt(o2 !== 0 || i2[lc] === 0, "stream body cannot be pipelined");
        let a2 = a1(A2, n2, (l2) => {
          l2 ? (J.destroy(a2, l2), t2(l2)) : (J.removeAllListeners(a2), s.onRequestSent(), r2 || (e[cc] = true), i2[Qr]());
        });
        J.addListener(a2, "data", c2);
        function c2(l2) {
          s.onBodySent(l2);
        }
        __name(c2, "c");
      }
      __name(M1, "M1");
      async function L1(t2, e, r2, n2, A2, i2, s, o2) {
        Qt(s === r2.size, "blob body must have content length");
        try {
          if (s != null && s !== r2.size) throw new wE();
          let a2 = Buffer.from(await r2.arrayBuffer());
          e.cork(), e.write(a2), e.uncork(), e.end(), A2.onBodySent(a2), A2.onRequestSent(), o2 || (i2[cc] = true), n2[Qr]();
        } catch (a2) {
          t2(a2);
        }
      }
      __name(L1, "L1");
      async function jm(t2, e, r2, n2, A2, i2, s, o2) {
        Qt(s !== 0 || n2[lc] === 0, "iterator body cannot be pipelined");
        let a2 = null;
        function c2() {
          if (a2) {
            let u2 = a2;
            a2 = null, u2();
          }
        }
        __name(c2, "c");
        let l2 = /* @__PURE__ */ __name(() => new Promise((u2, g) => {
          Qt(a2 === null), i2[Dt] ? g(i2[Dt]) : a2 = u2;
        }), "l");
        e.on("close", c2).on("drain", c2);
        try {
          for await (let u2 of r2) {
            if (i2[Dt]) throw i2[Dt];
            let g = e.write(u2);
            A2.onBodySent(u2), g || await l2();
          }
          e.end(), A2.onRequestSent(), o2 || (i2[cc] = true), n2[Qr]();
        } catch (u2) {
          t2(u2);
        } finally {
          e.off("close", c2).off("drain", c2);
        }
      }
      __name(jm, "jm");
      Xm.exports = m1;
    });
    var fs = C2((KK, iy) => {
      "use strict";
      var Cr = __require("node:assert"), ty = __require("node:net"), cs = __require("node:http"), Bn = Y2(), { channels: kA } = lr(), v1 = QB(), P1 = wA(), { InvalidArgumentError: Qe, InformationalError: Y1, ClientDestroyedError: G1 } = H(), O1 = es(), { kUrl: _t, kServerName: _r, kClient: V1, kBusy: bE, kConnect: H1, kResuming: mn, kRunning: ds, kPending: hs, kSize: Es, kQueue: Rt, kConnected: q1, kConnecting: MA, kNeedDrain: Zr, kKeepAliveDefaultTimeout: $m, kHostHeader: J1, kPendingIdx: St, kRunningIdx: Ir, kError: W1, kPipelining: gc, kKeepAliveTimeoutValue: _1, kMaxHeadersSize: j1, kKeepAliveMaxTimeout: Z1, kKeepAliveTimeoutThreshold: X1, kHeadersTimeout: K1, kBodyTimeout: $1, kStrictContentLength: z1, kConnector: ls, kMaxRequests: NE, kCounter: eY, kClose: tY, kDestroy: rY, kDispatch: nY, kLocalAddress: us, kMaxResponseSize: AY, kOnError: iY, kHTTPContext: Ce, kMaxConcurrentStreams: sY, kResume: gs } = ne(), oY = qm(), aY = Km(), jr = Symbol("kClosedResolve"), cY = cs && cs.maxHeaderSize && Number.isInteger(cs.maxHeaderSize) && cs.maxHeaderSize > 0 ? () => cs.maxHeaderSize : () => {
        throw new Qe("http module not available or http.maxHeaderSize invalid");
      }, zm = /* @__PURE__ */ __name(() => {
      }, "zm");
      function ry(t2) {
        return t2[gc] ?? t2[Ce]?.defaultPipelining ?? 1;
      }
      __name(ry, "ry");
      var FE = class extends P1 {
        static {
          __name(this, "FE");
        }
        constructor(e, { maxHeaderSize: r2, headersTimeout: n2, socketTimeout: A2, requestTimeout: i2, connectTimeout: s, bodyTimeout: o2, idleTimeout: a2, keepAlive: c2, keepAliveTimeout: l2, maxKeepAliveTimeout: u2, keepAliveMaxTimeout: g, keepAliveTimeoutThreshold: E, socketPath: h, pipelining: f2, tls: p2, strictContentLength: Q, maxCachedSessions: I2, connect: B, maxRequestsPerClient: w, localAddress: D2, maxResponseSize: v2, autoSelectFamily: K2, autoSelectFamilyAttemptTimeout: W2, maxConcurrentStreams: ae, allowH2: xe } = {}) {
          if (c2 !== void 0) throw new Qe("unsupported keepAlive, use pipelining=0 instead");
          if (A2 !== void 0) throw new Qe("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
          if (i2 !== void 0) throw new Qe("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
          if (a2 !== void 0) throw new Qe("unsupported idleTimeout, use keepAliveTimeout instead");
          if (u2 !== void 0) throw new Qe("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
          if (r2 != null) {
            if (!Number.isInteger(r2) || r2 < 1) throw new Qe("invalid maxHeaderSize");
          } else r2 = cY();
          if (h != null && typeof h != "string") throw new Qe("invalid socketPath");
          if (s != null && (!Number.isFinite(s) || s < 0)) throw new Qe("invalid connectTimeout");
          if (l2 != null && (!Number.isFinite(l2) || l2 <= 0)) throw new Qe("invalid keepAliveTimeout");
          if (g != null && (!Number.isFinite(g) || g <= 0)) throw new Qe("invalid keepAliveMaxTimeout");
          if (E != null && !Number.isFinite(E)) throw new Qe("invalid keepAliveTimeoutThreshold");
          if (n2 != null && (!Number.isInteger(n2) || n2 < 0)) throw new Qe("headersTimeout must be a positive integer or zero");
          if (o2 != null && (!Number.isInteger(o2) || o2 < 0)) throw new Qe("bodyTimeout must be a positive integer or zero");
          if (B != null && typeof B != "function" && typeof B != "object") throw new Qe("connect must be a function or an object");
          if (w != null && (!Number.isInteger(w) || w < 0)) throw new Qe("maxRequestsPerClient must be a positive number");
          if (D2 != null && (typeof D2 != "string" || ty.isIP(D2) === 0)) throw new Qe("localAddress must be valid string IP address");
          if (v2 != null && (!Number.isInteger(v2) || v2 < -1)) throw new Qe("maxResponseSize must be a positive number");
          if (W2 != null && (!Number.isInteger(W2) || W2 < -1)) throw new Qe("autoSelectFamilyAttemptTimeout must be a positive number");
          if (xe != null && typeof xe != "boolean") throw new Qe("allowH2 must be a valid boolean value");
          if (ae != null && (typeof ae != "number" || ae < 1)) throw new Qe("maxConcurrentStreams must be a positive integer, greater than 0");
          super(), typeof B != "function" && (B = O1({ ...p2, maxCachedSessions: I2, allowH2: xe, socketPath: h, timeout: s, ...K2 ? { autoSelectFamily: K2, autoSelectFamilyAttemptTimeout: W2 } : void 0, ...B })), this[_t] = Bn.parseOrigin(e), this[ls] = B, this[gc] = f2 ?? 1, this[j1] = r2, this[$m] = l2 ?? 4e3, this[Z1] = g ?? 6e5, this[X1] = E ?? 2e3, this[_1] = this[$m], this[_r] = null, this[us] = D2 ?? null, this[mn] = 0, this[Zr] = 0, this[J1] = `host: ${this[_t].hostname}${this[_t].port ? `:${this[_t].port}` : ""}\r
`, this[$1] = o2 ?? 3e5, this[K1] = n2 ?? 3e5, this[z1] = Q ?? true, this[NE] = w, this[jr] = null, this[AY] = v2 > -1 ? v2 : -1, this[sY] = ae ?? 100, this[Ce] = null, this[Rt] = [], this[Ir] = 0, this[St] = 0, this[gs] = (te) => TE(this, te), this[iY] = (te) => ny(this, te);
        }
        get pipelining() {
          return this[gc];
        }
        set pipelining(e) {
          this[gc] = e, this[gs](true);
        }
        get [hs]() {
          return this[Rt].length - this[St];
        }
        get [ds]() {
          return this[St] - this[Ir];
        }
        get [Es]() {
          return this[Rt].length - this[Ir];
        }
        get [q1]() {
          return !!this[Ce] && !this[MA] && !this[Ce].destroyed;
        }
        get [bE]() {
          return !!(this[Ce]?.busy(null) || this[Es] >= (ry(this) || 1) || this[hs] > 0);
        }
        [H1](e) {
          Ay(this), this.once("connect", e);
        }
        [nY](e, r2) {
          let n2 = e.origin || this[_t].origin, A2 = new v1(n2, e, r2);
          return this[Rt].push(A2), this[mn] || (Bn.bodyLength(A2.body) == null && Bn.isIterable(A2.body) ? (this[mn] = 1, queueMicrotask(() => TE(this))) : this[gs](true)), this[mn] && this[Zr] !== 2 && this[bE] && (this[Zr] = 2), this[Zr] < 2;
        }
        async [tY]() {
          return new Promise((e) => {
            this[Es] ? this[jr] = e : e(null);
          });
        }
        async [rY](e) {
          return new Promise((r2) => {
            let n2 = this[Rt].splice(this[St]);
            for (let i2 = 0; i2 < n2.length; i2++) {
              let s = n2[i2];
              Bn.errorRequest(this, s, e);
            }
            let A2 = /* @__PURE__ */ __name(() => {
              this[jr] && (this[jr](), this[jr] = null), r2(null);
            }, "A");
            this[Ce] ? (this[Ce].destroy(e, A2), this[Ce] = null) : queueMicrotask(A2), this[gs]();
          });
        }
      };
      function ny(t2, e) {
        if (t2[ds] === 0 && e.code !== "UND_ERR_INFO" && e.code !== "UND_ERR_SOCKET") {
          Cr(t2[St] === t2[Ir]);
          let r2 = t2[Rt].splice(t2[Ir]);
          for (let n2 = 0; n2 < r2.length; n2++) {
            let A2 = r2[n2];
            Bn.errorRequest(t2, A2, e);
          }
          Cr(t2[Es] === 0);
        }
      }
      __name(ny, "ny");
      async function Ay(t2) {
        Cr(!t2[MA]), Cr(!t2[Ce]);
        let { host: e, hostname: r2, protocol: n2, port: A2 } = t2[_t];
        if (r2[0] === "[") {
          let i2 = r2.indexOf("]");
          Cr(i2 !== -1);
          let s = r2.substring(1, i2);
          Cr(ty.isIPv6(s)), r2 = s;
        }
        t2[MA] = true, kA.beforeConnect.hasSubscribers && kA.beforeConnect.publish({ connectParams: { host: e, hostname: r2, protocol: n2, port: A2, version: t2[Ce]?.version, servername: t2[_r], localAddress: t2[us] }, connector: t2[ls] });
        try {
          let i2 = await new Promise((s, o2) => {
            t2[ls]({ host: e, hostname: r2, protocol: n2, port: A2, servername: t2[_r], localAddress: t2[us] }, (a2, c2) => {
              a2 ? o2(a2) : s(c2);
            });
          });
          if (t2.destroyed) {
            Bn.destroy(i2.on("error", zm), new G1());
            return;
          }
          Cr(i2);
          try {
            t2[Ce] = i2.alpnProtocol === "h2" ? await aY(t2, i2) : await oY(t2, i2);
          } catch (s) {
            throw i2.destroy().on("error", zm), s;
          }
          t2[MA] = false, i2[eY] = 0, i2[NE] = t2[NE], i2[V1] = t2, i2[W1] = null, kA.connected.hasSubscribers && kA.connected.publish({ connectParams: { host: e, hostname: r2, protocol: n2, port: A2, version: t2[Ce]?.version, servername: t2[_r], localAddress: t2[us] }, connector: t2[ls], socket: i2 }), t2.emit("connect", t2[_t], [t2]);
        } catch (i2) {
          if (t2.destroyed) return;
          if (t2[MA] = false, kA.connectError.hasSubscribers && kA.connectError.publish({ connectParams: { host: e, hostname: r2, protocol: n2, port: A2, version: t2[Ce]?.version, servername: t2[_r], localAddress: t2[us] }, connector: t2[ls], error: i2 }), i2.code === "ERR_TLS_CERT_ALTNAME_INVALID") for (Cr(t2[ds] === 0); t2[hs] > 0 && t2[Rt][t2[St]].servername === t2[_r]; ) {
            let s = t2[Rt][t2[St]++];
            Bn.errorRequest(t2, s, i2);
          }
          else ny(t2, i2);
          t2.emit("connectionError", t2[_t], [t2], i2);
        }
        t2[gs]();
      }
      __name(Ay, "Ay");
      function ey(t2) {
        t2[Zr] = 0, t2.emit("drain", t2[_t], [t2]);
      }
      __name(ey, "ey");
      function TE(t2, e) {
        t2[mn] !== 2 && (t2[mn] = 2, lY(t2, e), t2[mn] = 0, t2[Ir] > 256 && (t2[Rt].splice(0, t2[Ir]), t2[St] -= t2[Ir], t2[Ir] = 0));
      }
      __name(TE, "TE");
      function lY(t2, e) {
        for (; ; ) {
          if (t2.destroyed) {
            Cr(t2[hs] === 0);
            return;
          }
          if (t2[jr] && !t2[Es]) {
            t2[jr](), t2[jr] = null;
            return;
          }
          if (t2[Ce] && t2[Ce].resume(), t2[bE]) t2[Zr] = 2;
          else if (t2[Zr] === 2) {
            e ? (t2[Zr] = 1, queueMicrotask(() => ey(t2))) : ey(t2);
            continue;
          }
          if (t2[hs] === 0 || t2[ds] >= (ry(t2) || 1)) return;
          let r2 = t2[Rt][t2[St]];
          if (t2[_t].protocol === "https:" && t2[_r] !== r2.servername) {
            if (t2[ds] > 0) return;
            t2[_r] = r2.servername, t2[Ce]?.destroy(new Y1("servername changed"), () => {
              t2[Ce] = null, TE(t2);
            });
          }
          if (t2[MA]) return;
          if (!t2[Ce]) {
            Ay(t2);
            return;
          }
          if (t2[Ce].destroyed || t2[Ce].busy(r2)) return;
          !r2.aborted && t2[Ce].write(r2) ? t2[St]++ : t2[Rt].splice(t2[St], 1);
        }
      }
      __name(lY, "lY");
      iy.exports = FE;
    });
    var xE = C2((zK, sy) => {
      "use strict";
      var Ec = class {
        static {
          __name(this, "Ec");
        }
        constructor() {
          this.bottom = 0, this.top = 0, this.list = new Array(2048).fill(void 0), this.next = null;
        }
        isEmpty() {
          return this.top === this.bottom;
        }
        isFull() {
          return (this.top + 1 & 2047) === this.bottom;
        }
        push(e) {
          this.list[this.top] = e, this.top = this.top + 1 & 2047;
        }
        shift() {
          let e = this.list[this.bottom];
          return e === void 0 ? null : (this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & 2047, e);
        }
      };
      sy.exports = class {
        constructor() {
          this.head = this.tail = new Ec();
        }
        isEmpty() {
          return this.head.isEmpty();
        }
        push(e) {
          this.head.isFull() && (this.head = this.head.next = new Ec()), this.head.push(e);
        }
        shift() {
          let e = this.tail, r2 = e.shift();
          return e.isEmpty() && e.next !== null && (this.tail = e.next, e.next = null), r2;
        }
      };
    });
    var ay = C2((e$, oy) => {
      "use strict";
      var { kFree: uY, kConnected: gY, kPending: EY, kQueued: dY, kRunning: hY, kSize: fY } = ne(), yn = Symbol("pool"), UE = class {
        static {
          __name(this, "UE");
        }
        constructor(e) {
          this[yn] = e;
        }
        get connected() {
          return this[yn][gY];
        }
        get free() {
          return this[yn][uY];
        }
        get pending() {
          return this[yn][EY];
        }
        get queued() {
          return this[yn][dY];
        }
        get running() {
          return this[yn][hY];
        }
        get size() {
          return this[yn][fY];
        }
      };
      oy.exports = UE;
    });
    var YE = C2((t$, Cy) => {
      "use strict";
      var QY = wA(), CY = xE(), { kConnected: kE, kSize: cy, kRunning: ly, kPending: uy, kQueued: Qs, kBusy: IY, kFree: pY, kUrl: BY, kClose: mY, kDestroy: yY, kDispatch: wY } = ne(), DY = ay(), Ze = Symbol("clients"), He = Symbol("needDrain"), Cs = Symbol("queue"), ME = Symbol("closed resolve"), LE = Symbol("onDrain"), gy = Symbol("onConnect"), Ey = Symbol("onDisconnect"), dy = Symbol("onConnectionError"), vE = Symbol("get dispatcher"), fy = Symbol("add client"), Qy = Symbol("remove client"), hy = Symbol("stats"), PE = class extends QY {
        static {
          __name(this, "PE");
        }
        constructor() {
          super(), this[Cs] = new CY(), this[Ze] = [], this[Qs] = 0;
          let e = this;
          this[LE] = function(n2, A2) {
            let i2 = e[Cs], s = false;
            for (; !s; ) {
              let o2 = i2.shift();
              if (!o2) break;
              e[Qs]--, s = !this.dispatch(o2.opts, o2.handler);
            }
            this[He] = s, !this[He] && e[He] && (e[He] = false, e.emit("drain", n2, [e, ...A2])), e[ME] && i2.isEmpty() && Promise.all(e[Ze].map((o2) => o2.close())).then(e[ME]);
          }, this[gy] = (r2, n2) => {
            e.emit("connect", r2, [e, ...n2]);
          }, this[Ey] = (r2, n2, A2) => {
            e.emit("disconnect", r2, [e, ...n2], A2);
          }, this[dy] = (r2, n2, A2) => {
            e.emit("connectionError", r2, [e, ...n2], A2);
          }, this[hy] = new DY(this);
        }
        get [IY]() {
          return this[He];
        }
        get [kE]() {
          return this[Ze].filter((e) => e[kE]).length;
        }
        get [pY]() {
          return this[Ze].filter((e) => e[kE] && !e[He]).length;
        }
        get [uy]() {
          let e = this[Qs];
          for (let { [uy]: r2 } of this[Ze]) e += r2;
          return e;
        }
        get [ly]() {
          let e = 0;
          for (let { [ly]: r2 } of this[Ze]) e += r2;
          return e;
        }
        get [cy]() {
          let e = this[Qs];
          for (let { [cy]: r2 } of this[Ze]) e += r2;
          return e;
        }
        get stats() {
          return this[hy];
        }
        async [mY]() {
          this[Cs].isEmpty() ? await Promise.all(this[Ze].map((e) => e.close())) : await new Promise((e) => {
            this[ME] = e;
          });
        }
        async [yY](e) {
          for (; ; ) {
            let r2 = this[Cs].shift();
            if (!r2) break;
            r2.handler.onError(e);
          }
          await Promise.all(this[Ze].map((r2) => r2.destroy(e)));
        }
        [wY](e, r2) {
          let n2 = this[vE]();
          return n2 ? n2.dispatch(e, r2) || (n2[He] = true, this[He] = !this[vE]()) : (this[He] = true, this[Cs].push({ opts: e, handler: r2 }), this[Qs]++), !this[He];
        }
        [fy](e) {
          return e.on("drain", this[LE]).on("connect", this[gy]).on("disconnect", this[Ey]).on("connectionError", this[dy]), this[Ze].push(e), this[He] && queueMicrotask(() => {
            this[He] && this[LE](e[BY], [this, e]);
          }), this;
        }
        [Qy](e) {
          e.close(() => {
            let r2 = this[Ze].indexOf(e);
            r2 !== -1 && this[Ze].splice(r2, 1);
          }), this[He] = this[Ze].some((r2) => !r2[He] && r2.closed !== true && r2.destroyed !== true);
        }
      };
      Cy.exports = { PoolBase: PE, kClients: Ze, kNeedDrain: He, kAddClient: fy, kRemoveClient: Qy, kGetDispatcher: vE };
    });
    var LA = C2((r$, yy) => {
      "use strict";
      var { PoolBase: RY, kClients: Iy, kNeedDrain: SY, kAddClient: bY, kGetDispatcher: NY } = YE(), FY = fs(), { InvalidArgumentError: GE } = H(), py = Y2(), { kUrl: By } = ne(), TY = es(), OE = Symbol("options"), VE = Symbol("connections"), my = Symbol("factory");
      function xY(t2, e) {
        return new FY(t2, e);
      }
      __name(xY, "xY");
      var HE = class extends RY {
        static {
          __name(this, "HE");
        }
        constructor(e, { connections: r2, factory: n2 = xY, connect: A2, connectTimeout: i2, tls: s, maxCachedSessions: o2, socketPath: a2, autoSelectFamily: c2, autoSelectFamilyAttemptTimeout: l2, allowH2: u2, ...g } = {}) {
          if (r2 != null && (!Number.isFinite(r2) || r2 < 0)) throw new GE("invalid connections");
          if (typeof n2 != "function") throw new GE("factory must be a function.");
          if (A2 != null && typeof A2 != "function" && typeof A2 != "object") throw new GE("connect must be a function or an object");
          super(), typeof A2 != "function" && (A2 = TY({ ...s, maxCachedSessions: o2, allowH2: u2, socketPath: a2, timeout: i2, ...c2 ? { autoSelectFamily: c2, autoSelectFamilyAttemptTimeout: l2 } : void 0, ...A2 })), this[VE] = r2 || null, this[By] = py.parseOrigin(e), this[OE] = { ...py.deepClone(g), connect: A2, allowH2: u2 }, this[OE].interceptors = g.interceptors ? { ...g.interceptors } : void 0, this[my] = n2;
        }
        [NY]() {
          for (let e of this[Iy]) if (!e[SY]) return e;
          if (!this[VE] || this[Iy].length < this[VE]) {
            let e = this[my](this[By], this[OE]);
            return this[bY](e), e;
          }
        }
      };
      yy.exports = HE;
    });
    var by = C2((n$, Sy) => {
      "use strict";
      var { BalancedPoolMissingUpstreamError: UY, InvalidArgumentError: kY } = H(), { PoolBase: MY, kClients: Le, kNeedDrain: Is, kAddClient: LY, kRemoveClient: vY, kGetDispatcher: PY } = YE(), YY = LA(), { kUrl: qE } = ne(), { parseOrigin: wy } = Y2(), Dy = Symbol("factory"), dc = Symbol("options"), Ry = Symbol("kGreatestCommonDivisor"), wn = Symbol("kCurrentWeight"), Dn = Symbol("kIndex"), Ct = Symbol("kWeight"), hc = Symbol("kMaxWeightPerServer"), fc = Symbol("kErrorPenalty");
      function GY(t2, e) {
        if (t2 === 0) return e;
        for (; e !== 0; ) {
          let r2 = e;
          e = t2 % e, t2 = r2;
        }
        return t2;
      }
      __name(GY, "GY");
      function OY(t2, e) {
        return new YY(t2, e);
      }
      __name(OY, "OY");
      var JE = class extends MY {
        static {
          __name(this, "JE");
        }
        constructor(e = [], { factory: r2 = OY, ...n2 } = {}) {
          if (typeof r2 != "function") throw new kY("factory must be a function.");
          super(), this[dc] = n2, this[Dn] = -1, this[wn] = 0, this[hc] = this[dc].maxWeightPerServer || 100, this[fc] = this[dc].errorPenalty || 15, Array.isArray(e) || (e = [e]), this[Dy] = r2;
          for (let A2 of e) this.addUpstream(A2);
          this._updateBalancedPoolStats();
        }
        addUpstream(e) {
          let r2 = wy(e).origin;
          if (this[Le].find((A2) => A2[qE].origin === r2 && A2.closed !== true && A2.destroyed !== true)) return this;
          let n2 = this[Dy](r2, Object.assign({}, this[dc]));
          this[LY](n2), n2.on("connect", () => {
            n2[Ct] = Math.min(this[hc], n2[Ct] + this[fc]);
          }), n2.on("connectionError", () => {
            n2[Ct] = Math.max(1, n2[Ct] - this[fc]), this._updateBalancedPoolStats();
          }), n2.on("disconnect", (...A2) => {
            let i2 = A2[2];
            i2 && i2.code === "UND_ERR_SOCKET" && (n2[Ct] = Math.max(1, n2[Ct] - this[fc]), this._updateBalancedPoolStats());
          });
          for (let A2 of this[Le]) A2[Ct] = this[hc];
          return this._updateBalancedPoolStats(), this;
        }
        _updateBalancedPoolStats() {
          let e = 0;
          for (let r2 = 0; r2 < this[Le].length; r2++) e = GY(this[Le][r2][Ct], e);
          this[Ry] = e;
        }
        removeUpstream(e) {
          let r2 = wy(e).origin, n2 = this[Le].find((A2) => A2[qE].origin === r2 && A2.closed !== true && A2.destroyed !== true);
          return n2 && this[vY](n2), this;
        }
        get upstreams() {
          return this[Le].filter((e) => e.closed !== true && e.destroyed !== true).map((e) => e[qE].origin);
        }
        [PY]() {
          if (this[Le].length === 0) throw new UY();
          if (!this[Le].find((i2) => !i2[Is] && i2.closed !== true && i2.destroyed !== true) || this[Le].map((i2) => i2[Is]).reduce((i2, s) => i2 && s, true)) return;
          let n2 = 0, A2 = this[Le].findIndex((i2) => !i2[Is]);
          for (; n2++ < this[Le].length; ) {
            this[Dn] = (this[Dn] + 1) % this[Le].length;
            let i2 = this[Le][this[Dn]];
            if (i2[Ct] > this[Le][A2][Ct] && !i2[Is] && (A2 = this[Dn]), this[Dn] === 0 && (this[wn] = this[wn] - this[Ry], this[wn] <= 0 && (this[wn] = this[hc])), i2[Ct] >= this[wn] && !i2[Is]) return i2;
          }
          return this[wn] = this[Le][A2][Ct], this[Dn] = A2, this[Le][A2];
        }
      };
      Sy.exports = JE;
    });
    var vA = C2((A$, Ly) => {
      "use strict";
      var { InvalidArgumentError: WE } = H(), { kClients: Xr, kRunning: Ny, kClose: VY, kDestroy: HY, kDispatch: qY } = ne(), JY = wA(), WY = LA(), _Y = fs(), jY = Y2(), Fy = Symbol("onConnect"), Ty = Symbol("onDisconnect"), xy = Symbol("onConnectionError"), Uy = Symbol("onDrain"), ky = Symbol("factory"), My = Symbol("options");
      function ZY(t2, e) {
        return e && e.connections === 1 ? new _Y(t2, e) : new WY(t2, e);
      }
      __name(ZY, "ZY");
      var _E = class extends JY {
        static {
          __name(this, "_E");
        }
        constructor({ factory: e = ZY, connect: r2, ...n2 } = {}) {
          if (typeof e != "function") throw new WE("factory must be a function.");
          if (r2 != null && typeof r2 != "function" && typeof r2 != "object") throw new WE("connect must be a function or an object");
          super(), r2 && typeof r2 != "function" && (r2 = { ...r2 }), this[My] = { ...jY.deepClone(n2), connect: r2 }, this[ky] = e, this[Xr] = /* @__PURE__ */ new Map(), this[Uy] = (A2, i2) => {
            this.emit("drain", A2, [this, ...i2]);
          }, this[Fy] = (A2, i2) => {
            this.emit("connect", A2, [this, ...i2]);
          }, this[Ty] = (A2, i2, s) => {
            this.emit("disconnect", A2, [this, ...i2], s);
          }, this[xy] = (A2, i2, s) => {
            this.emit("connectionError", A2, [this, ...i2], s);
          };
        }
        get [Ny]() {
          let e = 0;
          for (let r2 of this[Xr].values()) e += r2[Ny];
          return e;
        }
        [qY](e, r2) {
          let n2;
          if (e.origin && (typeof e.origin == "string" || e.origin instanceof URL)) n2 = String(e.origin);
          else throw new WE("opts.origin must be a non-empty string or URL.");
          let A2 = this[Xr].get(n2);
          return A2 || (A2 = this[ky](e.origin, this[My]).on("drain", this[Uy]).on("connect", this[Fy]).on("disconnect", this[Ty]).on("connectionError", this[xy]), this[Xr].set(n2, A2)), A2.dispatch(e, r2);
        }
        async [VY]() {
          let e = [];
          for (let r2 of this[Xr].values()) e.push(r2.close());
          this[Xr].clear(), await Promise.all(e);
        }
        async [HY](e) {
          let r2 = [];
          for (let n2 of this[Xr].values()) r2.push(n2.destroy(e));
          this[Xr].clear(), await Promise.all(r2);
        }
      };
      Ly.exports = _E;
    });
    var XE = C2((i$, Gy) => {
      "use strict";
      var { kProxy: XY, kClose: KY, kDestroy: $Y } = ne(), { URL: ps } = __require("node:url"), zY = vA(), e2 = LA(), t2 = wA(), { InvalidArgumentError: Ic, RequestAbortedError: r2, SecureProxyConnectionError: n2 } = H(), vy = es(), Qc = Symbol("proxy agent"), Cc = Symbol("proxy client"), Bs = Symbol("proxy headers"), jE = Symbol("request tls settings"), Py = Symbol("proxy tls settings"), Yy = Symbol("connect endpoint function");
      function A2(t3) {
        return t3 === "https:" ? 443 : 80;
      }
      __name(A2, "A2");
      function i2(t3, e) {
        return new e2(t3, e);
      }
      __name(i2, "i2");
      var s2 = /* @__PURE__ */ __name(() => {
      }, "s2"), ZE = class extends t2 {
        static {
          __name(this, "ZE");
        }
        constructor(e) {
          if (!e || typeof e == "object" && !(e instanceof ps) && !e.uri) throw new Ic("Proxy uri is mandatory");
          let { clientFactory: r3 = i2 } = e;
          if (typeof r3 != "function") throw new Ic("Proxy opts.clientFactory must be a function.");
          super();
          let n3 = this.#e(e), { href: A3, origin: i3, port: s, protocol: o3, username: a3, password: c2, hostname: l2 } = n3;
          if (this[XY] = { uri: A3, protocol: o3 }, this[jE] = e.requestTls, this[Py] = e.proxyTls, this[Bs] = e.headers || {}, e.auth && e.token) throw new Ic("opts.auth cannot be used in combination with opts.token");
          e.auth ? this[Bs]["proxy-authorization"] = `Basic ${e.auth}` : e.token ? this[Bs]["proxy-authorization"] = e.token : a3 && c2 && (this[Bs]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(a3)}:${decodeURIComponent(c2)}`).toString("base64")}`);
          let u2 = vy({ ...e.proxyTls });
          this[Yy] = vy({ ...e.requestTls }), this[Cc] = r3(n3, { connect: u2 }), this[Qc] = new zY({ ...e, connect: /* @__PURE__ */ __name(async (g, E) => {
            let h = g.host;
            g.port || (h += `:${A2(g.protocol)}`);
            try {
              let { socket: f2, statusCode: p2 } = await this[Cc].connect({ origin: i3, port: s, path: h, signal: g.signal, headers: { ...this[Bs], host: g.host }, servername: this[Py]?.servername || l2 });
              if (p2 !== 200 && (f2.on("error", s2).destroy(), E(new r2(`Proxy response (${p2}) !== 200 when HTTP Tunneling`))), g.protocol !== "https:") {
                E(null, f2);
                return;
              }
              let Q;
              this[jE] ? Q = this[jE].servername : Q = g.servername, this[Yy]({ ...g, servername: Q, httpSocket: f2 }, E);
            } catch (f2) {
              f2.code === "ERR_TLS_CERT_ALTNAME_INVALID" ? E(new n2(f2)) : E(f2);
            }
          }, "connect") });
        }
        dispatch(e, r3) {
          let n3 = o2(e.headers);
          if (a2(n3), n3 && !("host" in n3) && !("Host" in n3)) {
            let { host: A3 } = new ps(e.origin);
            n3.host = A3;
          }
          return this[Qc].dispatch({ ...e, headers: n3 }, r3);
        }
        #e(e) {
          return typeof e == "string" ? new ps(e) : e instanceof ps ? e : new ps(e.uri);
        }
        async [KY]() {
          await this[Qc].close(), await this[Cc].close();
        }
        async [$Y]() {
          await this[Qc].destroy(), await this[Cc].destroy();
        }
      };
      function o2(t3) {
        if (Array.isArray(t3)) {
          let e = {};
          for (let r3 = 0; r3 < t3.length; r3 += 2) e[t3[r3]] = t3[r3 + 1];
          return e;
        }
        return t3;
      }
      __name(o2, "o2");
      function a2(t3) {
        if (t3 && Object.keys(t3).find((r3) => r3.toLowerCase() === "proxy-authorization")) throw new Ic("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
      __name(a2, "a2");
      Gy.exports = ZE;
    });
    var Jy = C2((s$, qy) => {
      "use strict";
      var c2 = wA(), { kClose: l2, kDestroy: u2, kClosed: Oy, kDestroyed: Vy, kDispatch: g2, kNoProxyAgent: ms, kHttpProxyAgent: Kr, kHttpsProxyAgent: Rn } = ne(), Hy = XE(), E2 = vA(), d2 = { "http:": 80, "https:": 443 }, KE = class extends c2 {
        static {
          __name(this, "KE");
        }
        #e = null;
        #t = null;
        #r = null;
        constructor(e = {}) {
          super(), this.#r = e;
          let { httpProxy: r2, httpsProxy: n2, noProxy: A2, ...i2 } = e;
          this[ms] = new E2(i2);
          let s = r2 ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
          s ? this[Kr] = new Hy({ ...i2, uri: s }) : this[Kr] = this[ms];
          let o2 = n2 ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
          o2 ? this[Rn] = new Hy({ ...i2, uri: o2 }) : this[Rn] = this[Kr], this.#A();
        }
        [g2](e, r2) {
          let n2 = new URL(e.origin);
          return this.#n(n2).dispatch(e, r2);
        }
        async [l2]() {
          await this[ms].close(), this[Kr][Oy] || await this[Kr].close(), this[Rn][Oy] || await this[Rn].close();
        }
        async [u2](e) {
          await this[ms].destroy(e), this[Kr][Vy] || await this[Kr].destroy(e), this[Rn][Vy] || await this[Rn].destroy(e);
        }
        #n(e) {
          let { protocol: r2, host: n2, port: A2 } = e;
          return n2 = n2.replace(/:\d*$/, "").toLowerCase(), A2 = Number.parseInt(A2, 10) || d2[r2] || 0, this.#i(n2, A2) ? r2 === "https:" ? this[Rn] : this[Kr] : this[ms];
        }
        #i(e, r2) {
          if (this.#a && this.#A(), this.#t.length === 0) return true;
          if (this.#e === "*") return false;
          for (let n2 = 0; n2 < this.#t.length; n2++) {
            let A2 = this.#t[n2];
            if (!(A2.port && A2.port !== r2)) {
              if (/^[.*]/.test(A2.hostname)) {
                if (e.endsWith(A2.hostname.replace(/^\*/, ""))) return false;
              } else if (e === A2.hostname) return false;
            }
          }
          return true;
        }
        #A() {
          let e = this.#r.noProxy ?? this.#s, r2 = e.split(/[,\s]/), n2 = [];
          for (let A2 = 0; A2 < r2.length; A2++) {
            let i2 = r2[A2];
            if (!i2) continue;
            let s = i2.match(/^(.+):(\d+)$/);
            n2.push({ hostname: (s ? s[1] : i2).toLowerCase(), port: s ? Number.parseInt(s[2], 10) : 0 });
          }
          this.#e = e, this.#t = n2;
        }
        get #a() {
          return this.#r.noProxy !== void 0 ? false : this.#e !== this.#s;
        }
        get #s() {
          return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
        }
      };
      qy.exports = KE;
    });
    var pc = C2((o$, Zy) => {
      "use strict";
      var PA = __require("node:assert"), { kRetryHandlerDefaultRetry: Wy } = ne(), { RequestRetryError: ys } = H(), h2 = va(), { isDisturbed: _y, parseRangeHeader: jy, wrapRequestBody: f2 } = Y2();
      function Q2(t2) {
        let e = Date.now();
        return new Date(t2).getTime() - e;
      }
      __name(Q2, "Q2");
      var $E = class t2 {
        static {
          __name(this, "t");
        }
        constructor(e, { dispatch: r2, handler: n2 }) {
          let { retryOptions: A2, ...i2 } = e, { retry: s, maxRetries: o2, maxTimeout: a2, minTimeout: c2, timeoutFactor: l2, methods: u2, errorCodes: g, retryAfter: E, statusCodes: h } = A2 ?? {};
          this.dispatch = r2, this.handler = h2.wrap(n2), this.opts = { ...i2, body: f2(e.body) }, this.retryOpts = { retry: s ?? t2[Wy], retryAfter: E ?? true, maxTimeout: a2 ?? 30 * 1e3, minTimeout: c2 ?? 500, timeoutFactor: l2 ?? 2, maxRetries: o2 ?? 5, methods: u2 ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"], statusCodes: h ?? [500, 502, 503, 504, 429], errorCodes: g ?? ["ECONNRESET", "ECONNREFUSED", "ENOTFOUND", "ENETDOWN", "ENETUNREACH", "EHOSTDOWN", "EHOSTUNREACH", "EPIPE", "UND_ERR_SOCKET"] }, this.retryCount = 0, this.retryCountCheckpoint = 0, this.headersSent = false, this.start = 0, this.end = null, this.etag = null;
        }
        onRequestStart(e, r2) {
          this.headersSent || this.handler.onRequestStart?.(e, r2);
        }
        onRequestUpgrade(e, r2, n2, A2) {
          this.handler.onRequestUpgrade?.(e, r2, n2, A2);
        }
        static [Wy](e, { state: r2, opts: n2 }, A2) {
          let { statusCode: i2, code: s, headers: o2 } = e, { method: a2, retryOptions: c2 } = n2, { maxRetries: l2, minTimeout: u2, maxTimeout: g, timeoutFactor: E, statusCodes: h, errorCodes: f3, methods: p2 } = c2, { counter: Q } = r2;
          if (s && s !== "UND_ERR_REQ_RETRY" && !f3.includes(s)) {
            A2(e);
            return;
          }
          if (Array.isArray(p2) && !p2.includes(a2)) {
            A2(e);
            return;
          }
          if (i2 != null && Array.isArray(h) && !h.includes(i2)) {
            A2(e);
            return;
          }
          if (Q > l2) {
            A2(e);
            return;
          }
          let I2 = o2?.["retry-after"];
          I2 && (I2 = Number(I2), I2 = Number.isNaN(I2) ? Q2(I2) : I2 * 1e3);
          let B = I2 > 0 ? Math.min(I2, g) : Math.min(u2 * E ** (Q - 1), g);
          setTimeout(() => A2(null), B);
        }
        onResponseStart(e, r2, n2, A2) {
          if (this.retryCount += 1, r2 >= 300) if (this.retryOpts.statusCodes.includes(r2) === false) {
            this.headersSent = true, this.handler.onResponseStart?.(e, r2, n2, A2);
            return;
          } else throw new ys("Request failed", r2, { headers: n2, data: { count: this.retryCount } });
          if (this.headersSent) {
            if (r2 !== 206 && (this.start > 0 || r2 !== 200)) throw new ys("server does not support the range header and the payload was partially consumed", r2, { headers: n2, data: { count: this.retryCount } });
            let i2 = jy(n2["content-range"]);
            if (!i2) throw new ys("Content-Range mismatch", r2, { headers: n2, data: { count: this.retryCount } });
            if (this.etag != null && this.etag !== n2.etag) throw new ys("ETag mismatch", r2, { headers: n2, data: { count: this.retryCount } });
            let { start: s, size: o2, end: a2 = o2 ? o2 - 1 : null } = i2;
            PA(this.start === s, "content-range mismatch"), PA(this.end == null || this.end === a2, "content-range mismatch");
            return;
          }
          if (this.end == null) {
            if (r2 === 206) {
              let i2 = jy(n2["content-range"]);
              if (i2 == null) {
                this.headersSent = true, this.handler.onResponseStart?.(e, r2, n2, A2);
                return;
              }
              let { start: s, size: o2, end: a2 = o2 ? o2 - 1 : null } = i2;
              PA(s != null && Number.isFinite(s), "content-range mismatch"), PA(a2 != null && Number.isFinite(a2), "invalid content-length"), this.start = s, this.end = a2;
            }
            if (this.end == null) {
              let i2 = n2["content-length"];
              this.end = i2 != null ? Number(i2) - 1 : null;
            }
            PA(Number.isFinite(this.start)), PA(this.end == null || Number.isFinite(this.end), "invalid content-length"), this.resume = true, this.etag = n2.etag != null ? n2.etag : null, this.etag != null && this.etag[0] === "W" && this.etag[1] === "/" && (this.etag = null), this.headersSent = true, this.handler.onResponseStart?.(e, r2, n2, A2);
          } else throw new ys("Request failed", r2, { headers: n2, data: { count: this.retryCount } });
        }
        onResponseData(e, r2) {
          this.start += r2.length, this.handler.onResponseData?.(e, r2);
        }
        onResponseEnd(e, r2) {
          return this.retryCount = 0, this.handler.onResponseEnd?.(e, r2);
        }
        onResponseError(e, r2) {
          if (e?.aborted || _y(this.opts.body)) {
            this.handler.onResponseError?.(e, r2);
            return;
          }
          this.retryCount - this.retryCountCheckpoint > 0 ? this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint) : this.retryCount += 1, this.retryOpts.retry(r2, { state: { counter: this.retryCount }, opts: { retryOptions: this.retryOpts, ...this.opts } }, n2.bind(this));
          function n2(A2) {
            if (A2 != null || e?.aborted || _y(this.opts.body)) return this.handler.onResponseError?.(e, A2);
            if (this.start !== 0) {
              let i2 = { range: `bytes=${this.start}-${this.end ?? ""}` };
              this.etag != null && (i2["if-match"] = this.etag), this.opts = { ...this.opts, headers: { ...this.opts.headers, ...i2 } };
            }
            try {
              this.retryCountCheckpoint = this.retryCount, this.dispatch(this.opts, this);
            } catch (i2) {
              this.handler.onResponseError?.(e, i2);
            }
          }
          __name(n2, "n");
        }
      };
      Zy.exports = $E;
    });
    var Ky = C2((a$, Xy) => {
      "use strict";
      var C22 = $i(), I2 = pc(), zE = class extends C22 {
        static {
          __name(this, "zE");
        }
        #e = null;
        #t = null;
        constructor(e, r2 = {}) {
          super(r2), this.#e = e, this.#t = r2;
        }
        dispatch(e, r2) {
          let n2 = new I2({ ...e, retryOptions: this.#t }, { dispatch: this.#e.dispatch.bind(this.#e), handler: r2 });
          return this.#e.dispatch(e, n2);
        }
        close() {
          return this.#e.close();
        }
        destroy() {
          return this.#e.destroy();
        }
      };
      Xy.exports = zE;
    });
    var sw = C2((c$, iw) => {
      "use strict";
      var tw = __require("node:assert"), { Readable: p2 } = __require("node:stream"), { RequestAbortedError: rw, NotSupportedError: B2, InvalidArgumentError: m2, AbortError: ed } = H(), nw = Y2(), { ReadableStreamFrom: y22 } = Y2(), rt = Symbol("kConsume"), Bc = Symbol("kReading"), Sn = Symbol("kBody"), $y = Symbol("kAbort"), Aw = Symbol("kContentType"), td = Symbol("kContentLength"), rd = Symbol("kUsed"), mc = Symbol("kBytesRead"), w2 = /* @__PURE__ */ __name(() => {
      }, "w2"), nd = class extends p2 {
        static {
          __name(this, "nd");
        }
        constructor({ resume: e, abort: r2, contentType: n2 = "", contentLength: A2, highWaterMark: i2 = 64 * 1024 }) {
          super({ autoDestroy: true, read: e, highWaterMark: i2 }), this._readableState.dataEmitted = false, this[$y] = r2, this[rt] = null, this[mc] = 0, this[Sn] = null, this[rd] = false, this[Aw] = n2, this[td] = Number.isFinite(A2) ? A2 : null, this[Bc] = false;
        }
        _destroy(e, r2) {
          !e && !this._readableState.endEmitted && (e = new rw()), e && this[$y](), this[rd] ? r2(e) : setImmediate(() => {
            r2(e);
          });
        }
        on(e, r2) {
          return (e === "data" || e === "readable") && (this[Bc] = true, this[rd] = true), super.on(e, r2);
        }
        addListener(e, r2) {
          return this.on(e, r2);
        }
        off(e, r2) {
          let n2 = super.off(e, r2);
          return (e === "data" || e === "readable") && (this[Bc] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0), n2;
        }
        removeListener(e, r2) {
          return this.off(e, r2);
        }
        push(e) {
          return this[mc] += e ? e.length : 0, this[rt] && e !== null ? (id(this[rt], e), this[Bc] ? super.push(e) : true) : super.push(e);
        }
        text() {
          return ws(this, "text");
        }
        json() {
          return ws(this, "json");
        }
        blob() {
          return ws(this, "blob");
        }
        bytes() {
          return ws(this, "bytes");
        }
        arrayBuffer() {
          return ws(this, "arrayBuffer");
        }
        async formData() {
          throw new B2();
        }
        get bodyUsed() {
          return nw.isDisturbed(this);
        }
        get body() {
          return this[Sn] || (this[Sn] = y22(this), this[rt] && (this[Sn].getReader(), tw(this[Sn].locked))), this[Sn];
        }
        async dump(e) {
          let r2 = e?.signal;
          if (r2 != null && (typeof r2 != "object" || !("aborted" in r2))) throw new m2("signal must be an AbortSignal");
          let n2 = e?.limit && Number.isFinite(e.limit) ? e.limit : 128 * 1024;
          return r2?.throwIfAborted(), this._readableState.closeEmitted ? null : await new Promise((A2, i2) => {
            if ((this[td] && this[td] > n2 || this[mc] > n2) && this.destroy(new ed()), r2) {
              let s = /* @__PURE__ */ __name(() => {
                this.destroy(r2.reason ?? new ed());
              }, "s");
              r2.addEventListener("abort", s), this.on("close", function() {
                r2.removeEventListener("abort", s), r2.aborted ? i2(r2.reason ?? new ed()) : A2(null);
              });
            } else this.on("close", A2);
            this.on("error", w2).on("data", () => {
              this[mc] > n2 && this.destroy();
            }).resume();
          });
        }
        setEncoding(e) {
          return Buffer.isEncoding(e) && (this._readableState.encoding = e), this;
        }
      };
      function D2(t2) {
        return t2[Sn]?.locked === true || t2[rt] !== null;
      }
      __name(D2, "D2");
      function R2(t2) {
        return nw.isDisturbed(t2) || D2(t2);
      }
      __name(R2, "R2");
      function ws(t2, e) {
        return tw(!t2[rt]), new Promise((r2, n2) => {
          if (R2(t2)) {
            let A2 = t2._readableState;
            A2.destroyed && A2.closeEmitted === false ? t2.on("error", (i2) => {
              n2(i2);
            }).on("close", () => {
              n2(new TypeError("unusable"));
            }) : n2(A2.errored ?? new TypeError("unusable"));
          } else queueMicrotask(() => {
            t2[rt] = { type: e, stream: t2, resolve: r2, reject: n2, length: 0, body: [] }, t2.on("error", function(A2) {
              sd(this[rt], A2);
            }).on("close", function() {
              this[rt].body !== null && sd(this[rt], new rw());
            }), S2(t2[rt]);
          });
        });
      }
      __name(ws, "ws");
      function S2(t2) {
        if (t2.body === null) return;
        let { _readableState: e } = t2.stream;
        if (e.bufferIndex) {
          let r2 = e.bufferIndex, n2 = e.buffer.length;
          for (let A2 = r2; A2 < n2; A2++) id(t2, e.buffer[A2]);
        } else for (let r2 of e.buffer) id(t2, r2);
        for (e.endEmitted ? ew(this[rt], this._readableState.encoding) : t2.stream.on("end", function() {
          ew(this[rt], this._readableState.encoding);
        }), t2.stream.resume(); t2.stream.read() != null; ) ;
      }
      __name(S2, "S2");
      function Ad(t2, e, r2) {
        if (t2.length === 0 || e === 0) return "";
        let n2 = t2.length === 1 ? t2[0] : Buffer.concat(t2, e), A2 = n2.length, i2 = A2 > 2 && n2[0] === 239 && n2[1] === 187 && n2[2] === 191 ? 3 : 0;
        return !r2 || r2 === "utf8" || r2 === "utf-8" ? n2.utf8Slice(i2, A2) : n2.subarray(i2, A2).toString(r2);
      }
      __name(Ad, "Ad");
      function zy(t2, e) {
        if (t2.length === 0 || e === 0) return new Uint8Array(0);
        if (t2.length === 1) return new Uint8Array(t2[0]);
        let r2 = new Uint8Array(Buffer.allocUnsafeSlow(e).buffer), n2 = 0;
        for (let A2 = 0; A2 < t2.length; ++A2) {
          let i2 = t2[A2];
          r2.set(i2, n2), n2 += i2.length;
        }
        return r2;
      }
      __name(zy, "zy");
      function ew(t2, e) {
        let { type: r2, body: n2, resolve: A2, stream: i2, length: s } = t2;
        try {
          r2 === "text" ? A2(Ad(n2, s, e)) : r2 === "json" ? A2(JSON.parse(Ad(n2, s, e))) : r2 === "arrayBuffer" ? A2(zy(n2, s).buffer) : r2 === "blob" ? A2(new Blob(n2, { type: i2[Aw] })) : r2 === "bytes" && A2(zy(n2, s)), sd(t2);
        } catch (o2) {
          i2.destroy(o2);
        }
      }
      __name(ew, "ew");
      function id(t2, e) {
        t2.length += e.length, t2.body.push(e);
      }
      __name(id, "id");
      function sd(t2, e) {
        t2.body !== null && (e ? t2.reject(e) : t2.resolve(), t2.type = null, t2.stream = null, t2.resolve = null, t2.reject = null, t2.length = 0, t2.body = null);
      }
      __name(sd, "sd");
      iw.exports = { Readable: nd, chunksDecode: Ad };
    });
    var cw = C2((l$, od) => {
      "use strict";
      var b22 = __require("node:assert"), { AsyncResource: N22 } = __require("node:async_hooks"), { Readable: F2 } = sw(), { InvalidArgumentError: YA, RequestAbortedError: ow } = H(), bt = Y2();
      function yc() {
      }
      __name(yc, "yc");
      var wc = class extends N22 {
        static {
          __name(this, "wc");
        }
        constructor(e, r2) {
          if (!e || typeof e != "object") throw new YA("invalid opts");
          let { signal: n2, method: A2, opaque: i2, body: s, onInfo: o2, responseHeaders: a2, highWaterMark: c2 } = e;
          try {
            if (typeof r2 != "function") throw new YA("invalid callback");
            if (c2 && (typeof c2 != "number" || c2 < 0)) throw new YA("invalid highWaterMark");
            if (n2 && typeof n2.on != "function" && typeof n2.addEventListener != "function") throw new YA("signal must be an EventEmitter or EventTarget");
            if (A2 === "CONNECT") throw new YA("invalid method");
            if (o2 && typeof o2 != "function") throw new YA("invalid onInfo callback");
            super("UNDICI_REQUEST");
          } catch (l2) {
            throw bt.isStream(s) && bt.destroy(s.on("error", yc), l2), l2;
          }
          this.method = A2, this.responseHeaders = a2 || null, this.opaque = i2 || null, this.callback = r2, this.res = null, this.abort = null, this.body = s, this.trailers = {}, this.context = null, this.onInfo = o2 || null, this.highWaterMark = c2, this.reason = null, this.removeAbortListener = null, n2?.aborted ? this.reason = n2.reason ?? new ow() : n2 && (this.removeAbortListener = bt.addAbortListener(n2, () => {
            this.reason = n2.reason ?? new ow(), this.res ? bt.destroy(this.res.on("error", yc), this.reason) : this.abort && this.abort(this.reason);
          }));
        }
        onConnect(e, r2) {
          if (this.reason) {
            e(this.reason);
            return;
          }
          b22(this.callback), this.abort = e, this.context = r2;
        }
        onHeaders(e, r2, n2, A2) {
          let { callback: i2, opaque: s, abort: o2, context: a2, responseHeaders: c2, highWaterMark: l2 } = this, u2 = c2 === "raw" ? bt.parseRawHeaders(r2) : bt.parseHeaders(r2);
          if (e < 200) {
            this.onInfo && this.onInfo({ statusCode: e, headers: u2 });
            return;
          }
          let g = c2 === "raw" ? bt.parseHeaders(r2) : u2, E = g["content-type"], h = g["content-length"], f2 = new F2({ resume: n2, abort: o2, contentType: E, contentLength: this.method !== "HEAD" && h ? Number(h) : null, highWaterMark: l2 });
          this.removeAbortListener && (f2.on("close", this.removeAbortListener), this.removeAbortListener = null), this.callback = null, this.res = f2, i2 !== null && this.runInAsyncScope(i2, null, null, { statusCode: e, headers: u2, trailers: this.trailers, opaque: s, body: f2, context: a2 });
        }
        onData(e) {
          return this.res.push(e);
        }
        onComplete(e) {
          bt.parseHeaders(e, this.trailers), this.res.push(null);
        }
        onError(e) {
          let { res: r2, callback: n2, body: A2, opaque: i2 } = this;
          n2 && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(n2, null, e, { opaque: i2 });
          })), r2 && (this.res = null, queueMicrotask(() => {
            bt.destroy(r2.on("error", yc), e);
          })), A2 && (this.body = null, bt.isStream(A2) && (A2.on("error", yc), bt.destroy(A2, e))), this.removeAbortListener && (this.removeAbortListener(), this.removeAbortListener = null);
        }
      };
      function aw(t2, e) {
        if (e === void 0) return new Promise((r2, n2) => {
          aw.call(this, t2, (A2, i2) => A2 ? n2(A2) : r2(i2));
        });
        try {
          let r2 = new wc(t2, e);
          this.dispatch(t2, r2);
        } catch (r2) {
          if (typeof e != "function") throw r2;
          let n2 = t2?.opaque;
          queueMicrotask(() => e(r2, { opaque: n2 }));
        }
      }
      __name(aw, "aw");
      od.exports = aw;
      od.exports.RequestHandler = wc;
    });
    var Ds = C2((u$, gw) => {
      "use strict";
      var { addAbortListener: T2 } = Y2(), { RequestAbortedError: x2 } = H(), GA = Symbol("kListener"), jt = Symbol("kSignal");
      function lw(t2) {
        t2.abort ? t2.abort(t2[jt]?.reason) : t2.reason = t2[jt]?.reason ?? new x2(), uw(t2);
      }
      __name(lw, "lw");
      function U2(t2, e) {
        if (t2.reason = null, t2[jt] = null, t2[GA] = null, !!e) {
          if (e.aborted) {
            lw(t2);
            return;
          }
          t2[jt] = e, t2[GA] = () => {
            lw(t2);
          }, T2(t2[jt], t2[GA]);
        }
      }
      __name(U2, "U2");
      function uw(t2) {
        t2[jt] && ("removeEventListener" in t2[jt] ? t2[jt].removeEventListener("abort", t2[GA]) : t2[jt].removeListener("abort", t2[GA]), t2[jt] = null, t2[GA] = null);
      }
      __name(uw, "uw");
      gw.exports = { addSignal: U2, removeSignal: uw };
    });
    var fw = C2((g$, hw) => {
      "use strict";
      var k2 = __require("node:assert"), { finished: M22 } = __require("node:stream"), { AsyncResource: L22 } = __require("node:async_hooks"), { InvalidArgumentError: OA, InvalidReturnValueError: v2 } = H(), pr = Y2(), { addSignal: P22, removeSignal: Ew } = Ds();
      function Y22() {
      }
      __name(Y22, "Y2");
      var ad = class extends L22 {
        static {
          __name(this, "ad");
        }
        constructor(e, r2, n2) {
          if (!e || typeof e != "object") throw new OA("invalid opts");
          let { signal: A2, method: i2, opaque: s, body: o2, onInfo: a2, responseHeaders: c2 } = e;
          try {
            if (typeof n2 != "function") throw new OA("invalid callback");
            if (typeof r2 != "function") throw new OA("invalid factory");
            if (A2 && typeof A2.on != "function" && typeof A2.addEventListener != "function") throw new OA("signal must be an EventEmitter or EventTarget");
            if (i2 === "CONNECT") throw new OA("invalid method");
            if (a2 && typeof a2 != "function") throw new OA("invalid onInfo callback");
            super("UNDICI_STREAM");
          } catch (l2) {
            throw pr.isStream(o2) && pr.destroy(o2.on("error", Y22), l2), l2;
          }
          this.responseHeaders = c2 || null, this.opaque = s || null, this.factory = r2, this.callback = n2, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = o2, this.onInfo = a2 || null, pr.isStream(o2) && o2.on("error", (l2) => {
            this.onError(l2);
          }), P22(this, A2);
        }
        onConnect(e, r2) {
          if (this.reason) {
            e(this.reason);
            return;
          }
          k2(this.callback), this.abort = e, this.context = r2;
        }
        onHeaders(e, r2, n2, A2) {
          let { factory: i2, opaque: s, context: o2, responseHeaders: a2 } = this, c2 = a2 === "raw" ? pr.parseRawHeaders(r2) : pr.parseHeaders(r2);
          if (e < 200) {
            this.onInfo && this.onInfo({ statusCode: e, headers: c2 });
            return;
          }
          if (this.factory = null, i2 === null) return;
          let l2 = this.runInAsyncScope(i2, null, { statusCode: e, headers: c2, opaque: s, context: o2 });
          if (!l2 || typeof l2.write != "function" || typeof l2.end != "function" || typeof l2.on != "function") throw new v2("expected Writable");
          return M22(l2, { readable: false }, (g) => {
            let { callback: E, res: h, opaque: f2, trailers: p2, abort: Q } = this;
            this.res = null, (g || !h.readable) && pr.destroy(h, g), this.callback = null, this.runInAsyncScope(E, null, g || null, { opaque: f2, trailers: p2 }), g && Q();
          }), l2.on("drain", n2), this.res = l2, (l2.writableNeedDrain !== void 0 ? l2.writableNeedDrain : l2._writableState?.needDrain) !== true;
        }
        onData(e) {
          let { res: r2 } = this;
          return r2 ? r2.write(e) : true;
        }
        onComplete(e) {
          let { res: r2 } = this;
          Ew(this), r2 && (this.trailers = pr.parseHeaders(e), r2.end());
        }
        onError(e) {
          let { res: r2, callback: n2, opaque: A2, body: i2 } = this;
          Ew(this), this.factory = null, r2 ? (this.res = null, pr.destroy(r2, e)) : n2 && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(n2, null, e, { opaque: A2 });
          })), i2 && (this.body = null, pr.destroy(i2, e));
        }
      };
      function dw(t2, e, r2) {
        if (r2 === void 0) return new Promise((n2, A2) => {
          dw.call(this, t2, e, (i2, s) => i2 ? A2(i2) : n2(s));
        });
        try {
          let n2 = new ad(t2, e, r2);
          this.dispatch(t2, n2);
        } catch (n2) {
          if (typeof r2 != "function") throw n2;
          let A2 = t2?.opaque;
          queueMicrotask(() => r2(n2, { opaque: A2 }));
        }
      }
      __name(dw, "dw");
      hw.exports = dw;
    });
    var pw = C2((E$, Iw) => {
      "use strict";
      var { Readable: Cw, Duplex: G22, PassThrough: O2 } = __require("node:stream"), V2 = __require("node:assert"), { AsyncResource: H2 } = __require("node:async_hooks"), { InvalidArgumentError: Rs, InvalidReturnValueError: q2, RequestAbortedError: cd } = H(), Zt = Y2(), { addSignal: J2, removeSignal: W2 } = Ds();
      function Qw() {
      }
      __name(Qw, "Qw");
      var VA = Symbol("resume"), ld = class extends Cw {
        static {
          __name(this, "ld");
        }
        constructor() {
          super({ autoDestroy: true }), this[VA] = null;
        }
        _read() {
          let { [VA]: e } = this;
          e && (this[VA] = null, e());
        }
        _destroy(e, r2) {
          this._read(), r2(e);
        }
      }, ud = class extends Cw {
        static {
          __name(this, "ud");
        }
        constructor(e) {
          super({ autoDestroy: true }), this[VA] = e;
        }
        _read() {
          this[VA]();
        }
        _destroy(e, r2) {
          !e && !this._readableState.endEmitted && (e = new cd()), r2(e);
        }
      }, gd = class extends H2 {
        static {
          __name(this, "gd");
        }
        constructor(e, r2) {
          if (!e || typeof e != "object") throw new Rs("invalid opts");
          if (typeof r2 != "function") throw new Rs("invalid handler");
          let { signal: n2, method: A2, opaque: i2, onInfo: s, responseHeaders: o2 } = e;
          if (n2 && typeof n2.on != "function" && typeof n2.addEventListener != "function") throw new Rs("signal must be an EventEmitter or EventTarget");
          if (A2 === "CONNECT") throw new Rs("invalid method");
          if (s && typeof s != "function") throw new Rs("invalid onInfo callback");
          super("UNDICI_PIPELINE"), this.opaque = i2 || null, this.responseHeaders = o2 || null, this.handler = r2, this.abort = null, this.context = null, this.onInfo = s || null, this.req = new ld().on("error", Qw), this.ret = new G22({ readableObjectMode: e.objectMode, autoDestroy: true, read: /* @__PURE__ */ __name(() => {
            let { body: a2 } = this;
            a2?.resume && a2.resume();
          }, "read"), write: /* @__PURE__ */ __name((a2, c2, l2) => {
            let { req: u2 } = this;
            u2.push(a2, c2) || u2._readableState.destroyed ? l2() : u2[VA] = l2;
          }, "write"), destroy: /* @__PURE__ */ __name((a2, c2) => {
            let { body: l2, req: u2, res: g, ret: E, abort: h } = this;
            !a2 && !E._readableState.endEmitted && (a2 = new cd()), h && a2 && h(), Zt.destroy(l2, a2), Zt.destroy(u2, a2), Zt.destroy(g, a2), W2(this), c2(a2);
          }, "destroy") }).on("prefinish", () => {
            let { req: a2 } = this;
            a2.push(null);
          }), this.res = null, J2(this, n2);
        }
        onConnect(e, r2) {
          let { res: n2 } = this;
          if (this.reason) {
            e(this.reason);
            return;
          }
          V2(!n2, "pipeline cannot be retried"), this.abort = e, this.context = r2;
        }
        onHeaders(e, r2, n2) {
          let { opaque: A2, handler: i2, context: s } = this;
          if (e < 200) {
            if (this.onInfo) {
              let a2 = this.responseHeaders === "raw" ? Zt.parseRawHeaders(r2) : Zt.parseHeaders(r2);
              this.onInfo({ statusCode: e, headers: a2 });
            }
            return;
          }
          this.res = new ud(n2);
          let o2;
          try {
            this.handler = null;
            let a2 = this.responseHeaders === "raw" ? Zt.parseRawHeaders(r2) : Zt.parseHeaders(r2);
            o2 = this.runInAsyncScope(i2, null, { statusCode: e, headers: a2, opaque: A2, body: this.res, context: s });
          } catch (a2) {
            throw this.res.on("error", Qw), a2;
          }
          if (!o2 || typeof o2.on != "function") throw new q2("expected Readable");
          o2.on("data", (a2) => {
            let { ret: c2, body: l2 } = this;
            !c2.push(a2) && l2.pause && l2.pause();
          }).on("error", (a2) => {
            let { ret: c2 } = this;
            Zt.destroy(c2, a2);
          }).on("end", () => {
            let { ret: a2 } = this;
            a2.push(null);
          }).on("close", () => {
            let { ret: a2 } = this;
            a2._readableState.ended || Zt.destroy(a2, new cd());
          }), this.body = o2;
        }
        onData(e) {
          let { res: r2 } = this;
          return r2.push(e);
        }
        onComplete(e) {
          let { res: r2 } = this;
          r2.push(null);
        }
        onError(e) {
          let { ret: r2 } = this;
          this.handler = null, Zt.destroy(r2, e);
        }
      };
      function _22(t2, e) {
        try {
          let r2 = new gd(t2, e);
          return this.dispatch({ ...t2, body: r2.req }, r2), r2.ret;
        } catch (r2) {
          return new O2().destroy(r2);
        }
      }
      __name(_22, "_2");
      Iw.exports = _22;
    });
    var Rw = C2((d$, Dw) => {
      "use strict";
      var { InvalidArgumentError: Ed, SocketError: j2 } = H(), { AsyncResource: Z2 } = __require("node:async_hooks"), Bw = __require("node:assert"), mw = Y2(), { addSignal: X2, removeSignal: yw } = Ds(), dd = class extends Z2 {
        static {
          __name(this, "dd");
        }
        constructor(e, r2) {
          if (!e || typeof e != "object") throw new Ed("invalid opts");
          if (typeof r2 != "function") throw new Ed("invalid callback");
          let { signal: n2, opaque: A2, responseHeaders: i2 } = e;
          if (n2 && typeof n2.on != "function" && typeof n2.addEventListener != "function") throw new Ed("signal must be an EventEmitter or EventTarget");
          super("UNDICI_UPGRADE"), this.responseHeaders = i2 || null, this.opaque = A2 || null, this.callback = r2, this.abort = null, this.context = null, X2(this, n2);
        }
        onConnect(e, r2) {
          if (this.reason) {
            e(this.reason);
            return;
          }
          Bw(this.callback), this.abort = e, this.context = null;
        }
        onHeaders() {
          throw new j2("bad upgrade", null);
        }
        onUpgrade(e, r2, n2) {
          Bw(e === 101);
          let { callback: A2, opaque: i2, context: s } = this;
          yw(this), this.callback = null;
          let o2 = this.responseHeaders === "raw" ? mw.parseRawHeaders(r2) : mw.parseHeaders(r2);
          this.runInAsyncScope(A2, null, null, { headers: o2, socket: n2, opaque: i2, context: s });
        }
        onError(e) {
          let { callback: r2, opaque: n2 } = this;
          yw(this), r2 && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(r2, null, e, { opaque: n2 });
          }));
        }
      };
      function ww(t2, e) {
        if (e === void 0) return new Promise((r2, n2) => {
          ww.call(this, t2, (A2, i2) => A2 ? n2(A2) : r2(i2));
        });
        try {
          let r2 = new dd(t2, e), n2 = { ...t2, method: t2.method || "GET", upgrade: t2.protocol || "Websocket" };
          this.dispatch(n2, r2);
        } catch (r2) {
          if (typeof e != "function") throw r2;
          let n2 = t2?.opaque;
          queueMicrotask(() => e(r2, { opaque: n2 }));
        }
      }
      __name(ww, "ww");
      Dw.exports = ww;
    });
    var Tw = C2((h$, Fw) => {
      "use strict";
      var K2 = __require("node:assert"), { AsyncResource: $2 } = __require("node:async_hooks"), { InvalidArgumentError: hd, SocketError: z2 } = H(), Sw = Y2(), { addSignal: eG, removeSignal: bw } = Ds(), fd = class extends $2 {
        static {
          __name(this, "fd");
        }
        constructor(e, r2) {
          if (!e || typeof e != "object") throw new hd("invalid opts");
          if (typeof r2 != "function") throw new hd("invalid callback");
          let { signal: n2, opaque: A2, responseHeaders: i2 } = e;
          if (n2 && typeof n2.on != "function" && typeof n2.addEventListener != "function") throw new hd("signal must be an EventEmitter or EventTarget");
          super("UNDICI_CONNECT"), this.opaque = A2 || null, this.responseHeaders = i2 || null, this.callback = r2, this.abort = null, eG(this, n2);
        }
        onConnect(e, r2) {
          if (this.reason) {
            e(this.reason);
            return;
          }
          K2(this.callback), this.abort = e, this.context = r2;
        }
        onHeaders() {
          throw new z2("bad connect", null);
        }
        onUpgrade(e, r2, n2) {
          let { callback: A2, opaque: i2, context: s } = this;
          bw(this), this.callback = null;
          let o2 = r2;
          o2 != null && (o2 = this.responseHeaders === "raw" ? Sw.parseRawHeaders(r2) : Sw.parseHeaders(r2)), this.runInAsyncScope(A2, null, null, { statusCode: e, headers: o2, socket: n2, opaque: i2, context: s });
        }
        onError(e) {
          let { callback: r2, opaque: n2 } = this;
          bw(this), r2 && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(r2, null, e, { opaque: n2 });
          }));
        }
      };
      function Nw(t2, e) {
        if (e === void 0) return new Promise((r2, n2) => {
          Nw.call(this, t2, (A2, i2) => A2 ? n2(A2) : r2(i2));
        });
        try {
          let r2 = new fd(t2, e), n2 = { ...t2, method: "CONNECT" };
          this.dispatch(n2, r2);
        } catch (r2) {
          if (typeof e != "function") throw r2;
          let n2 = t2?.opaque;
          queueMicrotask(() => e(r2, { opaque: n2 }));
        }
      }
      __name(Nw, "Nw");
      Fw.exports = Nw;
    });
    var xw = C2((f$, HA) => {
      "use strict";
      HA.exports.request = cw();
      HA.exports.stream = fw();
      HA.exports.pipeline = pw();
      HA.exports.upgrade = Rw();
      HA.exports.connect = Tw();
    });
    var Cd = C2((Q$, Uw) => {
      "use strict";
      var { UndiciError: tG } = H(), Qd = class extends tG {
        static {
          __name(this, "Qd");
        }
        constructor(e) {
          super(e), this.name = "MockNotMatchedError", this.message = e || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
        }
      };
      Uw.exports = { MockNotMatchedError: Qd };
    });
    var qA = C2((C$, kw) => {
      "use strict";
      kw.exports = { kAgent: Symbol("agent"), kOptions: Symbol("options"), kFactory: Symbol("factory"), kDispatches: Symbol("dispatches"), kDispatchKey: Symbol("dispatch key"), kDefaultHeaders: Symbol("default headers"), kDefaultTrailers: Symbol("default trailers"), kContentLength: Symbol("content length"), kMockAgent: Symbol("mock agent"), kMockAgentSet: Symbol("mock agent set"), kMockAgentGet: Symbol("mock agent get"), kMockDispatch: Symbol("mock dispatch"), kClose: Symbol("close"), kOriginalClose: Symbol("original agent close"), kOriginalDispatch: Symbol("original dispatch"), kOrigin: Symbol("origin"), kIsMockActive: Symbol("is mock active"), kNetConnect: Symbol("net connect"), kGetNetConnect: Symbol("get net connect"), kConnected: Symbol("connected"), kIgnoreTrailingSlash: Symbol("ignore trailing slash") };
    });
    var Ss = C2((I$, Jw) => {
      "use strict";
      var { MockNotMatchedError: bn } = Cd(), { kDispatches: Dc, kMockAgent: rG, kOriginalDispatch: nG, kOrigin: AG, kGetNetConnect: iG } = qA(), { serializePathWithQuery: sG } = Y2(), { STATUS_CODES: oG } = __require("node:http"), { types: { isPromise: aG } } = __require("node:util");
      function Xt(t2, e) {
        return typeof t2 == "string" ? t2 === e : t2 instanceof RegExp ? t2.test(e) : typeof t2 == "function" ? t2(e) === true : false;
      }
      __name(Xt, "Xt");
      function Lw(t2) {
        return Object.fromEntries(Object.entries(t2).map(([e, r2]) => [e.toLocaleLowerCase(), r2]));
      }
      __name(Lw, "Lw");
      function vw(t2, e) {
        if (Array.isArray(t2)) {
          for (let r2 = 0; r2 < t2.length; r2 += 2) if (t2[r2].toLocaleLowerCase() === e.toLocaleLowerCase()) return t2[r2 + 1];
          return;
        } else return typeof t2.get == "function" ? t2.get(e) : Lw(t2)[e.toLocaleLowerCase()];
      }
      __name(vw, "vw");
      function md(t2) {
        let e = t2.slice(), r2 = [];
        for (let n2 = 0; n2 < e.length; n2 += 2) r2.push([e[n2], e[n2 + 1]]);
        return Object.fromEntries(r2);
      }
      __name(md, "md");
      function Pw(t2, e) {
        if (typeof t2.headers == "function") return Array.isArray(e) && (e = md(e)), t2.headers(e ? Lw(e) : {});
        if (typeof t2.headers > "u") return true;
        if (typeof e != "object" || typeof t2.headers != "object") return false;
        for (let [r2, n2] of Object.entries(t2.headers)) {
          let A2 = vw(e, r2);
          if (!Xt(n2, A2)) return false;
        }
        return true;
      }
      __name(Pw, "Pw");
      function Id(t2) {
        if (typeof t2 != "string") return t2;
        let e = t2.split("?");
        if (e.length !== 2) return t2;
        let r2 = new URLSearchParams(e.pop());
        return r2.sort(), [...e, r2.toString()].join("?");
      }
      __name(Id, "Id");
      function cG(t2, { path: e, method: r2, body: n2, headers: A2 }) {
        let i2 = Xt(t2.path, e), s = Xt(t2.method, r2), o2 = typeof t2.body < "u" ? Xt(t2.body, n2) : true, a2 = Pw(t2, A2);
        return i2 && s && o2 && a2;
      }
      __name(cG, "cG");
      function Yw(t2) {
        return Buffer.isBuffer(t2) || t2 instanceof Uint8Array || t2 instanceof ArrayBuffer ? t2 : typeof t2 == "object" ? JSON.stringify(t2) : t2 ? t2.toString() : "";
      }
      __name(Yw, "Yw");
      function Gw(t2, e) {
        let r2 = e.query ? sG(e.path, e.query) : e.path, n2 = typeof r2 == "string" ? Id(r2) : r2, A2 = Mw(n2), i2 = t2.filter(({ consumed: s }) => !s).filter(({ path: s, ignoreTrailingSlash: o2 }) => o2 ? Xt(Mw(Id(s)), A2) : Xt(Id(s), n2));
        if (i2.length === 0) throw new bn(`Mock dispatch not matched for path '${n2}'`);
        if (i2 = i2.filter(({ method: s }) => Xt(s, e.method)), i2.length === 0) throw new bn(`Mock dispatch not matched for method '${e.method}' on path '${n2}'`);
        if (i2 = i2.filter(({ body: s }) => typeof s < "u" ? Xt(s, e.body) : true), i2.length === 0) throw new bn(`Mock dispatch not matched for body '${e.body}' on path '${n2}'`);
        if (i2 = i2.filter((s) => Pw(s, e.headers)), i2.length === 0) {
          let s = typeof e.headers == "object" ? JSON.stringify(e.headers) : e.headers;
          throw new bn(`Mock dispatch not matched for headers '${s}' on path '${n2}'`);
        }
        return i2[0];
      }
      __name(Gw, "Gw");
      function lG(t2, e, r2, n2) {
        let A2 = { timesInvoked: 0, times: 1, persist: false, consumed: false, ...n2 }, i2 = typeof r2 == "function" ? { callback: r2 } : { ...r2 }, s = { ...A2, ...e, pending: true, data: { error: null, ...i2 } };
        return t2.push(s), s;
      }
      __name(lG, "lG");
      function pd(t2, e) {
        let r2 = t2.findIndex((n2) => n2.consumed ? cG(n2, e) : false);
        r2 !== -1 && t2.splice(r2, 1);
      }
      __name(pd, "pd");
      function Mw(t2) {
        for (; t2.endsWith("/"); ) t2 = t2.slice(0, -1);
        return t2.length === 0 && (t2 = "/"), t2;
      }
      __name(Mw, "Mw");
      function Ow(t2) {
        let { path: e, method: r2, body: n2, headers: A2, query: i2 } = t2;
        return { path: e, method: r2, body: n2, headers: A2, query: i2 };
      }
      __name(Ow, "Ow");
      function Bd(t2) {
        let e = Object.keys(t2), r2 = [];
        for (let n2 = 0; n2 < e.length; ++n2) {
          let A2 = e[n2], i2 = t2[A2], s = Buffer.from(`${A2}`);
          if (Array.isArray(i2)) for (let o2 = 0; o2 < i2.length; ++o2) r2.push(s, Buffer.from(`${i2[o2]}`));
          else r2.push(s, Buffer.from(`${i2}`));
        }
        return r2;
      }
      __name(Bd, "Bd");
      function Vw(t2) {
        return oG[t2] || "unknown";
      }
      __name(Vw, "Vw");
      async function uG(t2) {
        let e = [];
        for await (let r2 of t2) e.push(r2);
        return Buffer.concat(e).toString("utf8");
      }
      __name(uG, "uG");
      function Hw(t2, e) {
        let r2 = Ow(t2), n2 = Gw(this[Dc], r2);
        n2.timesInvoked++, n2.data.callback && (n2.data = { ...n2.data, ...n2.data.callback(t2) });
        let { data: { statusCode: A2, data: i2, headers: s, trailers: o2, error: a2 }, delay: c2, persist: l2 } = n2, { timesInvoked: u2, times: g } = n2;
        if (n2.consumed = !l2 && u2 >= g, n2.pending = u2 < g, a2 !== null) return pd(this[Dc], r2), e.onError(a2), true;
        typeof c2 == "number" && c2 > 0 ? setTimeout(() => {
          E(this[Dc]);
        }, c2) : E(this[Dc]);
        function E(f2, p2 = i2) {
          let Q = Array.isArray(t2.headers) ? md(t2.headers) : t2.headers, I2 = typeof p2 == "function" ? p2({ ...t2, headers: Q }) : p2;
          if (aG(I2)) {
            I2.then((v2) => E(f2, v2));
            return;
          }
          let B = Yw(I2), w = Bd(s), D2 = Bd(o2);
          e.onConnect?.((v2) => e.onError(v2), null), e.onHeaders?.(A2, w, h, Vw(A2)), e.onData?.(Buffer.from(B)), e.onComplete?.(D2), pd(f2, r2);
        }
        __name(E, "E");
        function h() {
        }
        __name(h, "h");
        return true;
      }
      __name(Hw, "Hw");
      function gG() {
        let t2 = this[rG], e = this[AG], r2 = this[nG];
        return function(A2, i2) {
          if (t2.isMockActive) try {
            Hw.call(this, A2, i2);
          } catch (s) {
            if (s instanceof bn) {
              let o2 = t2[iG]();
              if (o2 === false) throw new bn(`${s.message}: subsequent request to origin ${e} was not allowed (net.connect disabled)`);
              if (qw(o2, e)) r2.call(this, A2, i2);
              else throw new bn(`${s.message}: subsequent request to origin ${e} was not allowed (net.connect is not enabled for this origin)`);
            } else throw s;
          }
          else r2.call(this, A2, i2);
        };
      }
      __name(gG, "gG");
      function qw(t2, e) {
        let r2 = new URL(e);
        return t2 === true ? true : !!(Array.isArray(t2) && t2.some((n2) => Xt(n2, r2.host)));
      }
      __name(qw, "qw");
      function EG(t2) {
        if (t2) {
          let { agent: e, ...r2 } = t2;
          return r2;
        }
      }
      __name(EG, "EG");
      Jw.exports = { getResponseData: Yw, getMockDispatch: Gw, addMockDispatch: lG, deleteMockDispatch: pd, buildKey: Ow, generateKeyValues: Bd, matchValue: Xt, getResponse: uG, getStatusText: Vw, mockDispatch: Hw, buildMockDispatch: gG, checkNetConnect: qw, buildMockOptions: EG, getHeaderByName: vw, buildHeadersFromArray: md };
    });
    var Nd = C2((p$, bd) => {
      "use strict";
      var { getResponseData: dG, buildKey: hG, addMockDispatch: yd } = Ss(), { kDispatches: Rc, kDispatchKey: Sc, kDefaultHeaders: wd, kDefaultTrailers: Dd, kContentLength: Rd, kMockDispatch: bc, kIgnoreTrailingSlash: Nc } = qA(), { InvalidArgumentError: Kt } = H(), { serializePathWithQuery: fG } = Y2(), JA = class {
        static {
          __name(this, "JA");
        }
        constructor(e) {
          this[bc] = e;
        }
        delay(e) {
          if (typeof e != "number" || !Number.isInteger(e) || e <= 0) throw new Kt("waitInMs must be a valid integer > 0");
          return this[bc].delay = e, this;
        }
        persist() {
          return this[bc].persist = true, this;
        }
        times(e) {
          if (typeof e != "number" || !Number.isInteger(e) || e <= 0) throw new Kt("repeatTimes must be a valid integer > 0");
          return this[bc].times = e, this;
        }
      }, Sd = class {
        static {
          __name(this, "Sd");
        }
        constructor(e, r2) {
          if (typeof e != "object") throw new Kt("opts must be an object");
          if (typeof e.path > "u") throw new Kt("opts.path must be defined");
          if (typeof e.method > "u" && (e.method = "GET"), typeof e.path == "string") if (e.query) e.path = fG(e.path, e.query);
          else {
            let n2 = new URL(e.path, "data://");
            e.path = n2.pathname + n2.search;
          }
          typeof e.method == "string" && (e.method = e.method.toUpperCase()), this[Sc] = hG(e), this[Rc] = r2, this[Nc] = e.ignoreTrailingSlash ?? false, this[wd] = {}, this[Dd] = {}, this[Rd] = false;
        }
        createMockScopeDispatchData({ statusCode: e, data: r2, responseOptions: n2 }) {
          let A2 = dG(r2), i2 = this[Rd] ? { "content-length": A2.length } : {}, s = { ...this[wd], ...i2, ...n2.headers }, o2 = { ...this[Dd], ...n2.trailers };
          return { statusCode: e, data: r2, headers: s, trailers: o2 };
        }
        validateReplyParameters(e) {
          if (typeof e.statusCode > "u") throw new Kt("statusCode must be defined");
          if (typeof e.responseOptions != "object" || e.responseOptions === null) throw new Kt("responseOptions must be an object");
        }
        reply(e) {
          if (typeof e == "function") {
            let i2 = /* @__PURE__ */ __name((o2) => {
              let a2 = e(o2);
              if (typeof a2 != "object" || a2 === null) throw new Kt("reply options callback must return an object");
              let c2 = { data: "", responseOptions: {}, ...a2 };
              return this.validateReplyParameters(c2), { ...this.createMockScopeDispatchData(c2) };
            }, "i"), s = yd(this[Rc], this[Sc], i2, { ignoreTrailingSlash: this[Nc] });
            return new JA(s);
          }
          let r2 = { statusCode: e, data: arguments[1] === void 0 ? "" : arguments[1], responseOptions: arguments[2] === void 0 ? {} : arguments[2] };
          this.validateReplyParameters(r2);
          let n2 = this.createMockScopeDispatchData(r2), A2 = yd(this[Rc], this[Sc], n2, { ignoreTrailingSlash: this[Nc] });
          return new JA(A2);
        }
        replyWithError(e) {
          if (typeof e > "u") throw new Kt("error must be defined");
          let r2 = yd(this[Rc], this[Sc], { error: e }, { ignoreTrailingSlash: this[Nc] });
          return new JA(r2);
        }
        defaultReplyHeaders(e) {
          if (typeof e > "u") throw new Kt("headers must be defined");
          return this[wd] = e, this;
        }
        defaultReplyTrailers(e) {
          if (typeof e > "u") throw new Kt("trailers must be defined");
          return this[Dd] = e, this;
        }
        replyContentLength() {
          return this[Rd] = true, this;
        }
      };
      bd.exports.MockInterceptor = Sd;
      bd.exports.MockScope = JA;
    });
    var xd = C2((B$, zw) => {
      "use strict";
      var { promisify: QG } = __require("node:util"), CG = fs(), { buildMockDispatch: IG } = Ss(), { kDispatches: Ww, kMockAgent: _w, kClose: jw, kOriginalClose: Zw, kOrigin: Xw, kOriginalDispatch: pG, kConnected: Fd, kIgnoreTrailingSlash: Kw } = qA(), { MockInterceptor: BG } = Nd(), $w = ne(), { InvalidArgumentError: mG } = H(), Td = class extends CG {
        static {
          __name(this, "Td");
        }
        constructor(e, r2) {
          if (!r2 || !r2.agent || typeof r2.agent.dispatch != "function") throw new mG("Argument opts.agent must implement Agent");
          super(e, r2), this[_w] = r2.agent, this[Xw] = e, this[Kw] = r2.ignoreTrailingSlash ?? false, this[Ww] = [], this[Fd] = 1, this[pG] = this.dispatch, this[Zw] = this.close.bind(this), this.dispatch = IG.call(this), this.close = this[jw];
        }
        get [$w.kConnected]() {
          return this[Fd];
        }
        intercept(e) {
          return new BG(e && { ignoreTrailingSlash: this[Kw], ...e }, this[Ww]);
        }
        async [jw]() {
          await QG(this[Zw])(), this[Fd] = 0, this[_w][$w.kClients].delete(this[Xw]);
        }
      };
      zw.exports = Td;
    });
    var Md = C2((m$, oD) => {
      "use strict";
      var { promisify: yG } = __require("node:util"), wG = LA(), { buildMockDispatch: DG } = Ss(), { kDispatches: eD, kMockAgent: tD, kClose: rD, kOriginalClose: nD, kOrigin: AD, kOriginalDispatch: RG, kConnected: Ud, kIgnoreTrailingSlash: iD } = qA(), { MockInterceptor: SG } = Nd(), sD = ne(), { InvalidArgumentError: bG } = H(), kd = class extends wG {
        static {
          __name(this, "kd");
        }
        constructor(e, r2) {
          if (!r2 || !r2.agent || typeof r2.agent.dispatch != "function") throw new bG("Argument opts.agent must implement Agent");
          super(e, r2), this[tD] = r2.agent, this[AD] = e, this[iD] = r2.ignoreTrailingSlash ?? false, this[eD] = [], this[Ud] = 1, this[RG] = this.dispatch, this[nD] = this.close.bind(this), this.dispatch = DG.call(this), this.close = this[rD];
        }
        get [sD.kConnected]() {
          return this[Ud];
        }
        intercept(e) {
          return new SG(e && { ignoreTrailingSlash: this[iD], ...e }, this[eD]);
        }
        async [rD]() {
          await yG(this[nD])(), this[Ud] = 0, this[tD][sD.kClients].delete(this[AD]);
        }
      };
      oD.exports = kd;
    });
    var cD = C2((w$, aD) => {
      "use strict";
      var { Transform: NG } = __require("node:stream"), { Console: FG } = __require("node:console"), TG = process.versions.icu ? "" : "Y ", xG = process.versions.icu ? "" : "N ";
      aD.exports = class {
        constructor({ disableColors: e } = {}) {
          this.transform = new NG({ transform(r2, n2, A2) {
            A2(null, r2);
          } }), this.logger = new FG({ stdout: this.transform, inspectOptions: { colors: !e && !process.env.CI } });
        }
        format(e) {
          let r2 = e.map(({ method: n2, path: A2, data: { statusCode: i2 }, persist: s, times: o2, timesInvoked: a2, origin: c2 }) => ({ Method: n2, Origin: c2, Path: A2, "Status code": i2, Persistent: s ? TG : xG, Invocations: a2, Remaining: s ? 1 / 0 : o2 - a2 }));
          return this.logger.table(r2), this.transform.read().toString();
        }
      };
    });
    var ED = C2((D$, gD) => {
      "use strict";
      var { kClients: Nn } = ne(), UG = vA(), { kAgent: Ld, kMockAgentSet: Fc, kMockAgentGet: lD, kDispatches: vd, kIsMockActive: Tc, kNetConnect: Fn, kGetNetConnect: kG, kOptions: xc, kFactory: Uc } = qA(), MG = xd(), LG = Md(), { matchValue: vG, buildMockOptions: PG } = Ss(), { InvalidArgumentError: uD, UndiciError: YG } = H(), GG = $i(), OG = cD(), Pd = class extends GG {
        static {
          __name(this, "Pd");
        }
        constructor(e) {
          if (super(e), this[Fn] = true, this[Tc] = true, e?.agent && typeof e.agent.dispatch != "function") throw new uD("Argument opts.agent must implement Agent");
          let r2 = e?.agent ? e.agent : new UG(e);
          this[Ld] = r2, this[Nn] = r2[Nn], this[xc] = PG(e);
        }
        get(e) {
          let r2 = this[lD](e);
          return r2 || (r2 = this[Uc](e), this[Fc](e, r2)), r2;
        }
        dispatch(e, r2) {
          return this.get(e.origin), this[Ld].dispatch(e, r2);
        }
        async close() {
          await this[Ld].close(), this[Nn].clear();
        }
        deactivate() {
          this[Tc] = false;
        }
        activate() {
          this[Tc] = true;
        }
        enableNetConnect(e) {
          if (typeof e == "string" || typeof e == "function" || e instanceof RegExp) Array.isArray(this[Fn]) ? this[Fn].push(e) : this[Fn] = [e];
          else if (typeof e > "u") this[Fn] = true;
          else throw new uD("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
        disableNetConnect() {
          this[Fn] = false;
        }
        get isMockActive() {
          return this[Tc];
        }
        [Fc](e, r2) {
          this[Nn].set(e, r2);
        }
        [Uc](e) {
          let r2 = Object.assign({ agent: this }, this[xc]);
          return this[xc] && this[xc].connections === 1 ? new MG(e, r2) : new LG(e, r2);
        }
        [lD](e) {
          let r2 = this[Nn].get(e);
          if (r2) return r2;
          if (typeof e != "string") {
            let n2 = this[Uc]("http://localhost:9999");
            return this[Fc](e, n2), n2;
          }
          for (let [n2, A2] of Array.from(this[Nn])) if (A2 && typeof n2 != "string" && vG(n2, e)) {
            let i2 = this[Uc](e);
            return this[Fc](e, i2), i2[vd] = A2[vd], i2;
          }
        }
        [kG]() {
          return this[Fn];
        }
        pendingInterceptors() {
          let e = this[Nn];
          return Array.from(e.entries()).flatMap(([r2, n2]) => n2[vd].map((A2) => ({ ...A2, origin: r2 }))).filter(({ pending: r2 }) => r2);
        }
        assertNoPendingInterceptors({ pendingInterceptorsFormatter: e = new OG() } = {}) {
          let r2 = this.pendingInterceptors();
          if (r2.length !== 0) throw new YG(r2.length === 1 ? `1 interceptor is pending:

${e.format(r2)}`.trim() : `${r2.length} interceptors are pending:

${e.format(r2)}`.trim());
        }
      };
      gD.exports = Pd;
    });
    var kc = C2((R$, QD) => {
      "use strict";
      var dD = Symbol.for("undici.globalDispatcher.1"), { InvalidArgumentError: VG } = H(), HG = vA();
      fD() === void 0 && hD(new HG());
      function hD(t2) {
        if (!t2 || typeof t2.dispatch != "function") throw new VG("Argument agent must implement Agent");
        Object.defineProperty(globalThis, dD, { value: t2, writable: true, enumerable: false, configurable: false });
      }
      __name(hD, "hD");
      function fD() {
        return globalThis[dD];
      }
      __name(fD, "fD");
      QD.exports = { setGlobalDispatcher: hD, getGlobalDispatcher: fD };
    });
    var bs = C2((b$, CD) => {
      "use strict";
      var Br = __require("node:assert"), qG = va();
      CD.exports = class {
        #e;
        #t = false;
        #r = false;
        #n = false;
        constructor(e) {
          if (typeof e != "object" || e === null) throw new TypeError("handler must be an object");
          this.#e = qG.wrap(e);
        }
        onRequestStart(...e) {
          this.#e.onRequestStart?.(...e);
        }
        onRequestUpgrade(...e) {
          return Br(!this.#t), Br(!this.#r), this.#e.onRequestUpgrade?.(...e);
        }
        onResponseStart(...e) {
          return Br(!this.#t), Br(!this.#r), Br(!this.#n), this.#n = true, this.#e.onResponseStart?.(...e);
        }
        onResponseData(...e) {
          return Br(!this.#t), Br(!this.#r), this.#e.onResponseData?.(...e);
        }
        onResponseEnd(...e) {
          return Br(!this.#t), Br(!this.#r), this.#t = true, this.#e.onResponseEnd?.(...e);
        }
        onResponseError(...e) {
          return this.#r = true, this.#e.onResponseError?.(...e);
        }
        onBodySent() {
        }
      };
    });
    var Od = C2((N$, yD) => {
      "use strict";
      var nt = Y2(), { kBodyUsed: Ns } = ne(), Gd = __require("node:assert"), { InvalidArgumentError: ID } = H(), JG = __require("node:events"), WG = [300, 301, 302, 303, 307, 308], pD = Symbol("body"), BD = /* @__PURE__ */ __name(() => {
      }, "BD"), Mc = class {
        static {
          __name(this, "Mc");
        }
        constructor(e) {
          this[pD] = e, this[Ns] = false;
        }
        async *[Symbol.asyncIterator]() {
          Gd(!this[Ns], "disturbed"), this[Ns] = true, yield* this[pD];
        }
      }, Yd = class t2 {
        static {
          __name(this, "t");
        }
        static buildDispatch(e, r2) {
          if (r2 != null && (!Number.isInteger(r2) || r2 < 0)) throw new ID("maxRedirections must be a positive number");
          let n2 = e.dispatch.bind(e);
          return (A2, i2) => n2(A2, new t2(n2, r2, A2, i2));
        }
        constructor(e, r2, n2, A2) {
          if (r2 != null && (!Number.isInteger(r2) || r2 < 0)) throw new ID("maxRedirections must be a positive number");
          this.dispatch = e, this.location = null, this.opts = { ...n2, maxRedirections: 0 }, this.maxRedirections = r2, this.handler = A2, this.history = [], nt.isStream(this.opts.body) ? (nt.bodyLength(this.opts.body) === 0 && this.opts.body.on("data", function() {
            Gd(false);
          }), typeof this.opts.body.readableDidRead != "boolean" && (this.opts.body[Ns] = false, JG.prototype.on.call(this.opts.body, "data", function() {
            this[Ns] = true;
          }))) : this.opts.body && typeof this.opts.body.pipeTo == "function" ? this.opts.body = new Mc(this.opts.body) : this.opts.body && typeof this.opts.body != "string" && !ArrayBuffer.isView(this.opts.body) && nt.isIterable(this.opts.body) && !nt.isFormDataLike(this.opts.body) && (this.opts.body = new Mc(this.opts.body));
        }
        onRequestStart(e, r2) {
          this.handler.onRequestStart?.(e, { ...r2, history: this.history });
        }
        onRequestUpgrade(e, r2, n2, A2) {
          this.handler.onRequestUpgrade?.(e, r2, n2, A2);
        }
        onResponseStart(e, r2, n2, A2) {
          if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) throw new Error("max redirects");
          if ((r2 === 301 || r2 === 302) && this.opts.method === "POST" && (this.opts.method = "GET", nt.isStream(this.opts.body) && nt.destroy(this.opts.body.on("error", BD)), this.opts.body = null), r2 === 303 && this.opts.method !== "HEAD" && (this.opts.method = "GET", nt.isStream(this.opts.body) && nt.destroy(this.opts.body.on("error", BD)), this.opts.body = null), this.location = this.history.length >= this.maxRedirections || nt.isDisturbed(this.opts.body) || WG.indexOf(r2) === -1 ? null : n2.location, this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location) {
            this.handler.onResponseStart?.(e, r2, n2, A2);
            return;
          }
          let { origin: i2, pathname: s, search: o2 } = nt.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), a2 = o2 ? `${s}${o2}` : s;
          this.opts.headers = _G(this.opts.headers, r2 === 303, this.opts.origin !== i2), this.opts.path = a2, this.opts.origin = i2, this.opts.maxRedirections = 0, this.opts.query = null;
        }
        onResponseData(e, r2) {
          this.location || this.handler.onResponseData?.(e, r2);
        }
        onResponseEnd(e, r2) {
          this.location ? this.dispatch(this.opts, this) : this.handler.onResponseEnd(e, r2);
        }
        onResponseError(e, r2) {
          this.handler.onResponseError?.(e, r2);
        }
      };
      function mD(t2, e, r2) {
        if (t2.length === 4) return nt.headerNameToString(t2) === "host";
        if (e && nt.headerNameToString(t2).startsWith("content-")) return true;
        if (r2 && (t2.length === 13 || t2.length === 6 || t2.length === 19)) {
          let n2 = nt.headerNameToString(t2);
          return n2 === "authorization" || n2 === "cookie" || n2 === "proxy-authorization";
        }
        return false;
      }
      __name(mD, "mD");
      function _G(t2, e, r2) {
        let n2 = [];
        if (Array.isArray(t2)) for (let A2 = 0; A2 < t2.length; A2 += 2) mD(t2[A2], e, r2) || n2.push(t2[A2], t2[A2 + 1]);
        else if (t2 && typeof t2 == "object") {
          let A2 = typeof t2[Symbol.iterator] == "function" ? t2 : Object.entries(t2);
          for (let [i2, s] of A2) mD(i2, e, r2) || n2.push(i2, s);
        } else Gd(t2 == null, "headers must be an object or an array");
        return n2;
      }
      __name(_G, "_G");
      yD.exports = Yd;
    });
    var DD = C2((F$, wD) => {
      "use strict";
      var jG = Od();
      function ZG({ maxRedirections: t2 } = {}) {
        return (e) => function(n2, A2) {
          let { maxRedirections: i2 = t2, ...s } = n2;
          if (i2 == null || i2 === 0) return e(n2, A2);
          let o2 = { ...s, maxRedirections: 0 }, a2 = new jG(e, i2, o2, A2);
          return e(o2, a2);
        };
      }
      __name(ZG, "ZG");
      wD.exports = ZG;
    });
    var SD = C2((T$, RD) => {
      "use strict";
      var XG = bs(), { ResponseError: KG } = H(), Vd = class extends XG {
        static {
          __name(this, "Vd");
        }
        #e;
        #t;
        #r;
        #n;
        #i;
        constructor(e, { handler: r2 }) {
          super(r2);
        }
        #A(e) {
          return (this.#t ?? "").indexOf(e) === 0;
        }
        onRequestStart(e, r2) {
          return this.#e = 0, this.#t = null, this.#r = null, this.#n = null, this.#i = "", super.onRequestStart(e, r2);
        }
        onResponseStart(e, r2, n2, A2) {
          if (this.#e = r2, this.#n = n2, this.#t = n2["content-type"], this.#e < 400) return super.onResponseStart(e, r2, n2, A2);
          (this.#A("application/json") || this.#A("text/plain")) && (this.#r = new TextDecoder("utf-8"));
        }
        onResponseData(e, r2) {
          if (this.#e < 400) return super.onResponseData(e, r2);
          this.#i += this.#r?.decode(r2, { stream: true }) ?? "";
        }
        onResponseEnd(e, r2) {
          if (this.#e >= 400) {
            if (this.#i += this.#r?.decode(void 0, { stream: false }) ?? "", this.#A("application/json")) try {
              this.#i = JSON.parse(this.#i);
            } catch {
            }
            let n2, A2 = Error.stackTraceLimit;
            Error.stackTraceLimit = 0;
            try {
              n2 = new KG("Response Error", this.#e, { body: this.#i, headers: this.#n });
            } finally {
              Error.stackTraceLimit = A2;
            }
            super.onResponseError(e, n2);
          } else super.onResponseEnd(e, r2);
        }
        onResponseError(e, r2) {
          super.onResponseError(e, r2);
        }
      };
      RD.exports = () => (t2) => function(r2, n2) {
        return t2(r2, new Vd(r2, { handler: n2 }));
      };
    });
    var ND = C2((x$, bD) => {
      "use strict";
      var $G = pc();
      bD.exports = (t2) => (e) => function(n2, A2) {
        return e(n2, new $G({ ...n2, retryOptions: { ...t2, ...n2.retryOptions } }, { handler: A2, dispatch: e }));
      };
    });
    var TD = C2((U$, FD) => {
      "use strict";
      var { InvalidArgumentError: zG, RequestAbortedError: eO } = H(), tO = bs(), Hd = class extends tO {
        static {
          __name(this, "Hd");
        }
        #e = 1024 * 1024;
        #t = false;
        #r = 0;
        #n = null;
        aborted = false;
        reason = false;
        constructor({ maxSize: e, signal: r2 }, n2) {
          if (e != null && (!Number.isFinite(e) || e < 1)) throw new zG("maxSize must be a number greater than 0");
          super(n2), this.#e = e ?? this.#e;
        }
        #i(e) {
          this.aborted = true, this.reason = e;
        }
        onRequestStart(e, r2) {
          return e.abort = this.#i.bind(this), this.#n = e, super.onRequestStart(e, r2);
        }
        onResponseStart(e, r2, n2, A2) {
          let i2 = n2["content-length"];
          if (i2 != null && i2 > this.#e) throw new eO(`Response size (${i2}) larger than maxSize (${this.#e})`);
          return this.aborted === true ? true : super.onResponseStart(e, r2, n2, A2);
        }
        onResponseError(e, r2) {
          this.#t || (r2 = this.#n.reason ?? r2, super.onResponseError(e, r2));
        }
        onResponseData(e, r2) {
          return this.#r = this.#r + r2.length, this.#r >= this.#e && (this.#t = true, this.aborted === true ? super.onResponseError(e, this.reason) : super.onResponseEnd(e, {})), true;
        }
        onResponseEnd(e, r2) {
          if (!this.#t) {
            if (this.#n.aborted === true) {
              super.onResponseError(e, this.reason);
              return;
            }
            super.onResponseEnd(e, r2);
          }
        }
      };
      function rO({ maxSize: t2 } = { maxSize: 1024 * 1024 }) {
        return (e) => function(n2, A2) {
          let { dumpMaxSize: i2 = t2 } = n2, s = new Hd({ maxSize: i2, signal: n2.signal }, A2);
          return e(n2, s);
        };
      }
      __name(rO, "rO");
      FD.exports = rO;
    });
    var UD = C2((k$, xD) => {
      "use strict";
      var { isIP: nO } = __require("node:net"), { lookup: AO } = __require("node:dns"), iO = bs(), { InvalidArgumentError: WA, InformationalError: sO } = H(), qd = Math.pow(2, 31) - 1, Jd = class {
        static {
          __name(this, "Jd");
        }
        #e = 0;
        #t = 0;
        #r = /* @__PURE__ */ new Map();
        dualStack = true;
        affinity = null;
        lookup = null;
        pick = null;
        constructor(e) {
          this.#e = e.maxTTL, this.#t = e.maxItems, this.dualStack = e.dualStack, this.affinity = e.affinity, this.lookup = e.lookup ?? this.#n, this.pick = e.pick ?? this.#i;
        }
        get full() {
          return this.#r.size === this.#t;
        }
        runLookup(e, r2, n2) {
          let A2 = this.#r.get(e.hostname);
          if (A2 == null && this.full) {
            n2(null, e);
            return;
          }
          let i2 = { affinity: this.affinity, dualStack: this.dualStack, lookup: this.lookup, pick: this.pick, ...r2.dns, maxTTL: this.#e, maxItems: this.#t };
          if (A2 == null) this.lookup(e, i2, (s, o2) => {
            if (s || o2 == null || o2.length === 0) {
              n2(s ?? new sO("No DNS entries found"));
              return;
            }
            this.setRecords(e, o2);
            let a2 = this.#r.get(e.hostname), c2 = this.pick(e, a2, i2.affinity), l2;
            typeof c2.port == "number" ? l2 = `:${c2.port}` : e.port !== "" ? l2 = `:${e.port}` : l2 = "", n2(null, new URL(`${e.protocol}//${c2.family === 6 ? `[${c2.address}]` : c2.address}${l2}`));
          });
          else {
            let s = this.pick(e, A2, i2.affinity);
            if (s == null) {
              this.#r.delete(e.hostname), this.runLookup(e, r2, n2);
              return;
            }
            let o2;
            typeof s.port == "number" ? o2 = `:${s.port}` : e.port !== "" ? o2 = `:${e.port}` : o2 = "", n2(null, new URL(`${e.protocol}//${s.family === 6 ? `[${s.address}]` : s.address}${o2}`));
          }
        }
        #n(e, r2, n2) {
          AO(e.hostname, { all: true, family: this.dualStack === false ? this.affinity : 0, order: "ipv4first" }, (A2, i2) => {
            if (A2) return n2(A2);
            let s = /* @__PURE__ */ new Map();
            for (let o2 of i2) s.set(`${o2.address}:${o2.family}`, o2);
            n2(null, s.values());
          });
        }
        #i(e, r2, n2) {
          let A2 = null, { records: i2, offset: s } = r2, o2;
          if (this.dualStack ? (n2 == null && (s == null || s === qd ? (r2.offset = 0, n2 = 4) : (r2.offset++, n2 = (r2.offset & 1) === 1 ? 6 : 4)), i2[n2] != null && i2[n2].ips.length > 0 ? o2 = i2[n2] : o2 = i2[n2 === 4 ? 6 : 4]) : o2 = i2[n2], o2 == null || o2.ips.length === 0) return A2;
          o2.offset == null || o2.offset === qd ? o2.offset = 0 : o2.offset++;
          let a2 = o2.offset % o2.ips.length;
          return A2 = o2.ips[a2] ?? null, A2 == null ? A2 : Date.now() - A2.timestamp > A2.ttl ? (o2.ips.splice(a2, 1), this.pick(e, r2, n2)) : A2;
        }
        pickFamily(e, r2) {
          let n2 = this.#r.get(e.hostname)?.records;
          if (!n2) return null;
          let A2 = n2[r2];
          if (!A2) return null;
          A2.offset == null || A2.offset === qd ? A2.offset = 0 : A2.offset++;
          let i2 = A2.offset % A2.ips.length, s = A2.ips[i2] ?? null;
          return s == null || Date.now() - s.timestamp > s.ttl && A2.ips.splice(i2, 1), s;
        }
        setRecords(e, r2) {
          let n2 = Date.now(), A2 = { records: { 4: null, 6: null } };
          for (let i2 of r2) {
            i2.timestamp = n2, typeof i2.ttl == "number" ? i2.ttl = Math.min(i2.ttl, this.#e) : i2.ttl = this.#e;
            let s = A2.records[i2.family] ?? { ips: [] };
            s.ips.push(i2), A2.records[i2.family] = s;
          }
          this.#r.set(e.hostname, A2);
        }
        deleteRecords(e) {
          this.#r.delete(e.hostname);
        }
        getHandler(e, r2) {
          return new Wd(this, e, r2);
        }
      }, Wd = class extends iO {
        static {
          __name(this, "Wd");
        }
        #e = null;
        #t = null;
        #r = null;
        #n = null;
        #i = null;
        #A = null;
        #a = true;
        constructor(e, { origin: r2, handler: n2, dispatch: A2, newOrigin: i2 }, s) {
          super(n2), this.#n = r2, this.#A = i2, this.#t = { ...s }, this.#e = e, this.#r = A2;
        }
        onResponseError(e, r2) {
          switch (r2.code) {
            case "ETIMEDOUT":
            case "ECONNREFUSED": {
              if (this.#e.dualStack) {
                if (!this.#a) {
                  super.onResponseError(e, r2);
                  return;
                }
                this.#a = false;
                let n2 = this.#A.hostname[0] === "[" ? 4 : 6, A2 = this.#e.pickFamily(this.#n, n2);
                if (A2 == null) {
                  super.onResponseError(e, r2);
                  return;
                }
                let i2;
                typeof A2.port == "number" ? i2 = `:${A2.port}` : this.#n.port !== "" ? i2 = `:${this.#n.port}` : i2 = "";
                let s = { ...this.#t, origin: `${this.#n.protocol}//${A2.family === 6 ? `[${A2.address}]` : A2.address}${i2}` };
                this.#r(s, this);
                return;
              }
              super.onResponseError(e, r2);
              break;
            }
            case "ENOTFOUND":
              this.#e.deleteRecords(this.#n), super.onResponseError(e, r2);
              break;
            default:
              super.onResponseError(e, r2);
              break;
          }
        }
      };
      xD.exports = (t2) => {
        if (t2?.maxTTL != null && (typeof t2?.maxTTL != "number" || t2?.maxTTL < 0)) throw new WA("Invalid maxTTL. Must be a positive number");
        if (t2?.maxItems != null && (typeof t2?.maxItems != "number" || t2?.maxItems < 1)) throw new WA("Invalid maxItems. Must be a positive number and greater than zero");
        if (t2?.affinity != null && t2?.affinity !== 4 && t2?.affinity !== 6) throw new WA("Invalid affinity. Must be either 4 or 6");
        if (t2?.dualStack != null && typeof t2?.dualStack != "boolean") throw new WA("Invalid dualStack. Must be a boolean");
        if (t2?.lookup != null && typeof t2?.lookup != "function") throw new WA("Invalid lookup. Must be a function");
        if (t2?.pick != null && typeof t2?.pick != "function") throw new WA("Invalid pick. Must be a function");
        let e = t2?.dualStack ?? true, r2;
        e ? r2 = t2?.affinity ?? null : r2 = t2?.affinity ?? 4;
        let n2 = { maxTTL: t2?.maxTTL ?? 1e4, lookup: t2?.lookup ?? null, pick: t2?.pick ?? null, dualStack: e, affinity: r2, maxItems: t2?.maxItems ?? 1 / 0 }, A2 = new Jd(n2);
        return (i2) => function(o2, a2) {
          let c2 = o2.origin.constructor === URL ? o2.origin : new URL(o2.origin);
          return nO(c2.hostname) !== 0 ? i2(o2, a2) : (A2.runLookup(c2, o2, (l2, u2) => {
            if (l2) return a2.onResponseError(null, l2);
            let g = { ...o2, servername: c2.hostname, origin: u2.origin, headers: { host: c2.host, ...o2.headers } };
            i2(g, A2.getHandler({ origin: c2, dispatch: i2, handler: a2, newOrigin: u2 }, o2));
          }), true);
        };
      };
    });
    var Fs = C2((M$, MD) => {
      "use strict";
      var { safeHTTPMethods: kD } = Y2();
      function oO(t2) {
        if (!t2.origin) throw new Error("opts.origin is undefined");
        let e;
        if (t2.headers == null) e = {};
        else if (typeof t2.headers[Symbol.iterator] == "function") {
          e = {};
          for (let r2 of t2.headers) {
            if (!Array.isArray(r2)) throw new Error("opts.headers is not a valid header map");
            let [n2, A2] = r2;
            if (typeof n2 != "string" || typeof A2 != "string") throw new Error("opts.headers is not a valid header map");
            e[n2.toLowerCase()] = A2;
          }
        } else if (typeof t2.headers == "object") {
          e = {};
          for (let r2 of Object.keys(t2.headers)) e[r2.toLowerCase()] = t2.headers[r2];
        } else throw new Error("opts.headers is not an object");
        return { origin: t2.origin.toString(), method: t2.method, path: t2.path, headers: e };
      }
      __name(oO, "oO");
      function aO(t2) {
        if (typeof t2 != "object") throw new TypeError(`expected key to be object, got ${typeof t2}`);
        for (let e of ["origin", "method", "path"]) if (typeof t2[e] != "string") throw new TypeError(`expected key.${e} to be string, got ${typeof t2[e]}`);
        if (t2.headers !== void 0 && typeof t2.headers != "object") throw new TypeError(`expected headers to be object, got ${typeof t2}`);
      }
      __name(aO, "aO");
      function cO(t2) {
        if (typeof t2 != "object") throw new TypeError(`expected value to be object, got ${typeof t2}`);
        for (let e of ["statusCode", "cachedAt", "staleAt", "deleteAt"]) if (typeof t2[e] != "number") throw new TypeError(`expected value.${e} to be number, got ${typeof t2[e]}`);
        if (typeof t2.statusMessage != "string") throw new TypeError(`expected value.statusMessage to be string, got ${typeof t2.statusMessage}`);
        if (t2.headers != null && typeof t2.headers != "object") throw new TypeError(`expected value.rawHeaders to be object, got ${typeof t2.headers}`);
        if (t2.vary !== void 0 && typeof t2.vary != "object") throw new TypeError(`expected value.vary to be object, got ${typeof t2.vary}`);
        if (t2.etag !== void 0 && typeof t2.etag != "string") throw new TypeError(`expected value.etag to be string, got ${typeof t2.etag}`);
      }
      __name(cO, "cO");
      function lO(t2) {
        let e = {}, r2;
        if (Array.isArray(t2)) {
          r2 = [];
          for (let n2 of t2) r2.push(...n2.split(","));
        } else r2 = t2.split(",");
        for (let n2 = 0; n2 < r2.length; n2++) {
          let A2 = r2[n2].toLowerCase(), i2 = A2.indexOf("="), s, o2;
          switch (i2 !== -1 ? (s = A2.substring(0, i2).trimStart(), o2 = A2.substring(i2 + 1)) : s = A2.trim(), s) {
            case "min-fresh":
            case "max-stale":
            case "max-age":
            case "s-maxage":
            case "stale-while-revalidate":
            case "stale-if-error": {
              if (o2 === void 0 || o2[0] === " ") continue;
              o2.length >= 2 && o2[0] === '"' && o2[o2.length - 1] === '"' && (o2 = o2.substring(1, o2.length - 1));
              let a2 = parseInt(o2, 10);
              if (a2 !== a2 || s === "max-age" && s in e && e[s] >= a2) continue;
              e[s] = a2;
              break;
            }
            case "private":
            case "no-cache":
              if (o2) {
                if (o2[0] === '"') {
                  let a2 = [o2.substring(1)], c2 = o2[o2.length - 1] === '"';
                  if (!c2) for (let l2 = n2 + 1; l2 < r2.length; l2++) {
                    let u2 = r2[l2], g = u2.length;
                    if (a2.push(u2.trim()), g !== 0 && u2[g - 1] === '"') {
                      c2 = true;
                      break;
                    }
                  }
                  if (c2) {
                    let l2 = a2[a2.length - 1];
                    l2[l2.length - 1] === '"' && (l2 = l2.substring(0, l2.length - 1), a2[a2.length - 1] = l2), s in e ? e[s] = e[s].concat(a2) : e[s] = a2;
                  }
                } else s in e ? e[s] = e[s].concat(o2) : e[s] = [o2];
                break;
              }
            case "public":
            case "no-store":
            case "must-revalidate":
            case "proxy-revalidate":
            case "immutable":
            case "no-transform":
            case "must-understand":
            case "only-if-cached":
              if (o2) continue;
              e[s] = true;
              break;
            default:
              continue;
          }
        }
        return e;
      }
      __name(lO, "lO");
      function uO(t2, e) {
        if (typeof t2 == "string" && t2.includes("*")) return e;
        let r2 = {}, n2 = typeof t2 == "string" ? t2.split(",") : t2;
        for (let A2 of n2) {
          let i2 = A2.trim().toLowerCase();
          r2[i2] = e[i2] ?? null;
        }
        return r2;
      }
      __name(uO, "uO");
      function gO(t2) {
        return t2.length <= 2 ? false : t2[0] === '"' && t2[t2.length - 1] === '"' ? !(t2[1] === '"' || t2.startsWith('"W/')) : t2.startsWith('W/"') && t2[t2.length - 1] === '"' ? t2.length !== 4 : false;
      }
      __name(gO, "gO");
      function EO(t2, e = "CacheStore") {
        if (typeof t2 != "object" || t2 === null) throw new TypeError(`expected type of ${e} to be a CacheStore, got ${t2 === null ? "null" : typeof t2}`);
        for (let r2 of ["get", "createWriteStream", "delete"]) if (typeof t2[r2] != "function") throw new TypeError(`${e} needs to have a \`${r2}()\` function`);
      }
      __name(EO, "EO");
      function dO(t2, e = "CacheMethods") {
        if (!Array.isArray(t2)) throw new TypeError(`expected type of ${e} needs to be an array, got ${t2 === null ? "null" : typeof t2}`);
        if (t2.length === 0) throw new TypeError(`${e} needs to have at least one method`);
        for (let r2 of t2) if (!kD.includes(r2)) throw new TypeError(`element of ${e}-array needs to be one of following values: ${kD.join(", ")}, got ${r2}`);
      }
      __name(dO, "dO");
      MD.exports = { makeCacheKey: oO, assertCacheKey: aO, assertCacheValue: cO, parseCacheControlHeader: lO, parseVaryHeader: uO, isEtagUsable: gO, assertCacheMethods: dO, assertCacheStore: EO };
    });
    var PD = C2((L$, vD) => {
      "use strict";
      var LD = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"], hO = [4, 7, 11, 16, 25], _d = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"], fO = [19, 22], QO = [3, 7, 10, 19], CO = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
      function IO(t2, e) {
        switch (t2 = t2.toLowerCase(), t2[3]) {
          case ",":
            return pO(t2);
          case " ":
            return BO(t2);
          default:
            return mO(t2, e);
        }
      }
      __name(IO, "IO");
      function pO(t2) {
        if (t2.length !== 29 || !t2.endsWith("gmt")) return;
        for (let E of hO) if (t2[E] !== " ") return;
        for (let E of fO) if (t2[E] !== ":") return;
        let e = t2.substring(0, 3);
        if (!LD.includes(e)) return;
        let r2 = t2.substring(5, 7), n2 = Number.parseInt(r2);
        if (isNaN(n2) || n2 < 10 && r2[0] !== "0") return;
        let A2 = t2.substring(8, 11), i2 = _d.indexOf(A2);
        if (i2 === -1) return;
        let s = Number.parseInt(t2.substring(12, 16));
        if (isNaN(s)) return;
        let o2 = t2.substring(17, 19), a2 = Number.parseInt(o2);
        if (isNaN(a2) || a2 < 10 && o2[0] !== "0") return;
        let c2 = t2.substring(20, 22), l2 = Number.parseInt(c2);
        if (isNaN(l2) || l2 < 10 && c2[0] !== "0") return;
        let u2 = t2.substring(23, 25), g = Number.parseInt(u2);
        if (!(isNaN(g) || g < 10 && u2[0] !== "0")) return new Date(Date.UTC(s, i2, n2, a2, l2, g));
      }
      __name(pO, "pO");
      function BO(t2) {
        if (t2.length !== 24) return;
        for (let E of QO) if (t2[E] !== " ") return;
        let e = t2.substring(0, 3);
        if (!LD.includes(e)) return;
        let r2 = t2.substring(4, 7), n2 = _d.indexOf(r2);
        if (n2 === -1) return;
        let A2 = t2.substring(8, 10), i2 = Number.parseInt(A2);
        if (isNaN(i2) || i2 < 10 && A2[0] !== " ") return;
        let s = t2.substring(11, 13), o2 = Number.parseInt(s);
        if (isNaN(o2) || o2 < 10 && s[0] !== "0") return;
        let a2 = t2.substring(14, 16), c2 = Number.parseInt(a2);
        if (isNaN(c2) || c2 < 10 && a2[0] !== "0") return;
        let l2 = t2.substring(17, 19), u2 = Number.parseInt(l2);
        if (isNaN(u2) || u2 < 10 && l2[0] !== "0") return;
        let g = Number.parseInt(t2.substring(20, 24));
        if (!isNaN(g)) return new Date(Date.UTC(g, n2, i2, o2, c2, u2));
      }
      __name(BO, "BO");
      function mO(t2, e = /* @__PURE__ */ new Date()) {
        if (!t2.endsWith("gmt")) return;
        let r2 = t2.indexOf(",");
        if (r2 === -1 || t2.length - r2 - 1 !== 23) return;
        let n2 = t2.substring(0, r2);
        if (!CO.includes(n2) || t2[r2 + 1] !== " " || t2[r2 + 4] !== "-" || t2[r2 + 8] !== "-" || t2[r2 + 11] !== " " || t2[r2 + 14] !== ":" || t2[r2 + 17] !== ":" || t2[r2 + 20] !== " ") return;
        let A2 = t2.substring(r2 + 2, r2 + 4), i2 = Number.parseInt(A2);
        if (isNaN(i2) || i2 < 10 && A2[0] !== "0") return;
        let s = t2.substring(r2 + 5, r2 + 8), o2 = _d.indexOf(s);
        if (o2 === -1) return;
        let a2 = Number.parseInt(t2.substring(r2 + 9, r2 + 11));
        if (isNaN(a2)) return;
        let c2 = e.getUTCFullYear(), l2 = c2 % 100, u2 = Math.floor(c2 / 100);
        a2 > l2 && a2 - l2 >= 50 ? a2 += (u2 - 1) * 100 : a2 += u2 * 100;
        let g = t2.substring(r2 + 12, r2 + 14), E = Number.parseInt(g);
        if (isNaN(E) || E < 10 && g[0] !== "0") return;
        let h = t2.substring(r2 + 15, r2 + 17), f2 = Number.parseInt(h);
        if (isNaN(f2) || f2 < 10 && h[0] !== "0") return;
        let p2 = t2.substring(r2 + 18, r2 + 20), Q = Number.parseInt(p2);
        if (!(isNaN(Q) || Q < 10 && p2[0] !== "0")) return new Date(Date.UTC(a2, o2, i2, E, f2, Q));
      }
      __name(mO, "mO");
      vD.exports = { parseHttpDate: IO };
    });
    var OD = C2((v$, GD) => {
      "use strict";
      var yO = Y2(), { parseCacheControlHeader: wO, parseVaryHeader: DO, isEtagUsable: RO } = Fs(), { parseHttpDate: YD } = PD();
      function SO() {
      }
      __name(SO, "SO");
      var bO = [200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501], NO = 2147483647e3, jd = class {
        static {
          __name(this, "jd");
        }
        #e;
        #t;
        #r;
        #n;
        #i;
        #A;
        constructor({ store: e, type: r2, cacheByDefault: n2 }, A2, i2) {
          this.#n = e, this.#t = r2, this.#r = n2, this.#e = A2, this.#i = i2;
        }
        onRequestStart(e, r2) {
          this.#A?.destroy(), this.#A = void 0, this.#i.onRequestStart?.(e, r2);
        }
        onRequestUpgrade(e, r2, n2, A2) {
          this.#i.onRequestUpgrade?.(e, r2, n2, A2);
        }
        onResponseStart(e, r2, n2, A2) {
          let i2 = /* @__PURE__ */ __name(() => this.#i.onResponseStart?.(e, r2, n2, A2), "i");
          if (!yO.safeHTTPMethods.includes(this.#e.method) && r2 >= 200 && r2 <= 399) {
            try {
              this.#n.delete(this.#e)?.catch?.(SO);
            } catch {
            }
            return i2();
          }
          let s = n2["cache-control"], o2 = n2["last-modified"] && bO.includes(r2);
          if (!s && !n2.expires && !o2 && !this.#r) return i2();
          let a2 = s ? wO(s) : {};
          if (!FO(this.#t, r2, n2, a2)) return i2();
          let c2 = Date.now(), l2 = n2.age ? TO(n2.age) : void 0;
          if (l2 && l2 >= NO) return i2();
          let u2 = typeof n2.date == "string" ? YD(n2.date) : void 0, g = xO(this.#t, c2, l2, n2, u2, a2) ?? this.#r;
          if (g === void 0 || l2 && l2 > g) return i2();
          let E = u2 ? u2.getTime() : c2, h = g + E;
          if (c2 >= h) return i2();
          let f2;
          if (this.#e.headers && n2.vary && (f2 = DO(n2.vary, this.#e.headers), !f2)) return i2();
          let p2 = UO(E, a2, h), Q = kO(n2, a2), I2 = { statusCode: r2, statusMessage: A2, headers: Q, vary: f2, cacheControlDirectives: a2, cachedAt: l2 ? c2 - l2 : c2, staleAt: h, deleteAt: p2 };
          if (typeof n2.etag == "string" && RO(n2.etag) && (I2.etag = n2.etag), this.#A = this.#n.createWriteStream(this.#e, I2), !this.#A) return i2();
          let B = this;
          return this.#A.on("drain", () => e.resume()).on("error", function() {
            B.#A = void 0, B.#n.delete(B.#e);
          }).on("close", function() {
            B.#A === this && (B.#A = void 0), e.resume();
          }), i2();
        }
        onResponseData(e, r2) {
          this.#A?.write(r2) === false && e.pause(), this.#i.onResponseData?.(e, r2);
        }
        onResponseEnd(e, r2) {
          this.#A?.end(), this.#i.onResponseEnd?.(e, r2);
        }
        onResponseError(e, r2) {
          this.#A?.destroy(r2), this.#A = void 0, this.#i.onResponseError?.(e, r2);
        }
      };
      function FO(t2, e, r2, n2) {
        return !(e !== 200 && e !== 307 || n2["no-store"] || t2 === "shared" && n2.private === true || r2.vary?.includes("*") || r2.authorization && (!n2.public || typeof r2.authorization != "string" || Array.isArray(n2["no-cache"]) && n2["no-cache"].includes("authorization") || Array.isArray(n2.private) && n2.private.includes("authorization")));
      }
      __name(FO, "FO");
      function TO(t2) {
        let e = parseInt(Array.isArray(t2) ? t2[0] : t2);
        return isNaN(e) ? void 0 : e * 1e3;
      }
      __name(TO, "TO");
      function xO(t2, e, r2, n2, A2, i2) {
        if (t2 === "shared") {
          let o2 = i2["s-maxage"];
          if (o2 !== void 0) return o2 > 0 ? o2 * 1e3 : void 0;
        }
        let s = i2["max-age"];
        if (s !== void 0) return s > 0 ? s * 1e3 : void 0;
        if (typeof n2.expires == "string") {
          let o2 = YD(n2.expires);
          if (o2) return e >= o2.getTime() || A2 && (A2 >= o2 || r2 !== void 0 && r2 > o2 - A2) ? void 0 : o2.getTime() - e;
        }
        if (typeof n2["last-modified"] == "string") {
          let o2 = new Date(n2["last-modified"]);
          if (MO(o2)) return o2.getTime() >= e ? void 0 : (e - o2.getTime()) * 0.1;
        }
        if (i2.immutable) return 31536e3;
      }
      __name(xO, "xO");
      function UO(t2, e, r2) {
        let n2 = -1 / 0, A2 = -1 / 0, i2 = -1 / 0;
        return e["stale-while-revalidate"] && (n2 = r2 + e["stale-while-revalidate"] * 1e3), e["stale-if-error"] && (A2 = r2 + e["stale-if-error"] * 1e3), n2 === -1 / 0 && A2 === -1 / 0 && (i2 = t2 + 31536e6), Math.max(r2, n2, A2, i2);
      }
      __name(UO, "UO");
      function kO(t2, e) {
        let r2 = ["connection", "proxy-authenticate", "proxy-authentication-info", "proxy-authorization", "proxy-connection", "te", "transfer-encoding", "upgrade", "age"];
        t2.connection && (Array.isArray(t2.connection) ? r2.push(...t2.connection.map((A2) => A2.trim())) : r2.push(...t2.connection.split(",").map((A2) => A2.trim()))), Array.isArray(e["no-cache"]) && r2.push(...e["no-cache"]), Array.isArray(e.private) && r2.push(...e.private);
        let n2;
        for (let A2 of r2) t2[A2] && (n2 ??= { ...t2 }, delete n2[A2]);
        return n2 ?? t2;
      }
      __name(kO, "kO");
      function MO(t2) {
        return t2 instanceof Date && Number.isFinite(t2.valueOf());
      }
      __name(MO, "MO");
      GD.exports = jd;
    });
    var Xd = C2((P$, HD) => {
      "use strict";
      var { Writable: LO } = __require("node:stream"), { assertCacheKey: VD, assertCacheValue: vO } = Fs(), Zd = class {
        static {
          __name(this, "Zd");
        }
        #e = 1 / 0;
        #t = 1 / 0;
        #r = 1 / 0;
        #n = 0;
        #i = 0;
        #A = /* @__PURE__ */ new Map();
        constructor(e) {
          if (e) {
            if (typeof e != "object") throw new TypeError("MemoryCacheStore options must be an object");
            if (e.maxCount !== void 0) {
              if (typeof e.maxCount != "number" || !Number.isInteger(e.maxCount) || e.maxCount < 0) throw new TypeError("MemoryCacheStore options.maxCount must be a non-negative integer");
              this.#e = e.maxCount;
            }
            if (e.maxSize !== void 0) {
              if (typeof e.maxSize != "number" || !Number.isInteger(e.maxSize) || e.maxSize < 0) throw new TypeError("MemoryCacheStore options.maxSize must be a non-negative integer");
              this.#t = e.maxSize;
            }
            if (e.maxEntrySize !== void 0) {
              if (typeof e.maxEntrySize != "number" || !Number.isInteger(e.maxEntrySize) || e.maxEntrySize < 0) throw new TypeError("MemoryCacheStore options.maxEntrySize must be a non-negative integer");
              this.#r = e.maxEntrySize;
            }
          }
        }
        get(e) {
          VD(e);
          let r2 = `${e.origin}:${e.path}`, n2 = Date.now(), A2 = this.#A.get(r2)?.find((i2) => i2.deleteAt > n2 && i2.method === e.method && (i2.vary == null || Object.keys(i2.vary).every((s) => i2.vary[s] === null ? e.headers[s] === void 0 : i2.vary[s] === e.headers[s])));
          return A2 == null ? void 0 : { statusMessage: A2.statusMessage, statusCode: A2.statusCode, headers: A2.headers, body: A2.body, vary: A2.vary ? A2.vary : void 0, etag: A2.etag, cacheControlDirectives: A2.cacheControlDirectives, cachedAt: A2.cachedAt, staleAt: A2.staleAt, deleteAt: A2.deleteAt };
        }
        createWriteStream(e, r2) {
          VD(e), vO(r2);
          let n2 = `${e.origin}:${e.path}`, A2 = this, i2 = { ...e, ...r2, body: [], size: 0 };
          return new LO({ write(s, o2, a2) {
            typeof s == "string" && (s = Buffer.from(s, o2)), i2.size += s.byteLength, i2.size >= A2.#r ? this.destroy() : i2.body.push(s), a2(null);
          }, final(s) {
            let o2 = A2.#A.get(n2);
            if (o2 || (o2 = [], A2.#A.set(n2, o2)), o2.push(i2), A2.#n += i2.size, A2.#i += 1, A2.#n > A2.#t || A2.#i > A2.#e) for (let [a2, c2] of A2.#A) {
              for (let l2 of c2.splice(0, c2.length / 2)) A2.#n -= l2.size, A2.#i -= 1;
              c2.length === 0 && A2.#A.delete(a2);
            }
            s(null);
          } });
        }
        delete(e) {
          if (typeof e != "object") throw new TypeError(`expected key to be object, got ${typeof e}`);
          let r2 = `${e.origin}:${e.path}`;
          for (let n2 of this.#A.get(r2) ?? []) this.#n -= n2.size, this.#i -= 1;
          this.#A.delete(r2);
        }
      };
      HD.exports = Zd;
    });
    var JD = C2((Y$, qD) => {
      "use strict";
      var PO = __require("node:assert"), Kd = class {
        static {
          __name(this, "Kd");
        }
        #e = false;
        #t;
        #r;
        #n;
        #i;
        constructor(e, r2, n2) {
          if (typeof e != "function") throw new TypeError("callback must be a function");
          this.#t = e, this.#r = r2, this.#i = n2;
        }
        onRequestStart(e, r2) {
          this.#e = false, this.#n = r2;
        }
        onRequestUpgrade(e, r2, n2, A2) {
          this.#r.onRequestUpgrade?.(e, r2, n2, A2);
        }
        onResponseStart(e, r2, n2, A2) {
          if (PO(this.#t != null), this.#e = r2 === 304 || this.#i && r2 >= 500 && r2 <= 504, this.#t(this.#e, this.#n), this.#t = null, this.#e) return true;
          this.#r.onRequestStart?.(e, this.#n), this.#r.onResponseStart?.(e, r2, n2, A2);
        }
        onResponseData(e, r2) {
          if (!this.#e) return this.#r.onResponseData?.(e, r2);
        }
        onResponseEnd(e, r2) {
          this.#e || this.#r.onResponseEnd?.(e, r2);
        }
        onResponseError(e, r2) {
          if (!this.#e) if (this.#t && (this.#t(false), this.#t = null), typeof this.#r.onResponseError == "function") this.#r.onResponseError(e, r2);
          else throw r2;
        }
      };
      qD.exports = Kd;
    });
    var XD = C2((G$, ZD) => {
      "use strict";
      var WD = __require("node:assert"), { Readable: YO } = __require("node:stream"), _A = Y2(), Lc = OD(), GO = Xd(), OO = JD(), { assertCacheStore: VO, assertCacheMethods: HO, makeCacheKey: qO, parseCacheControlHeader: JO } = Fs(), { AbortError: WO } = H();
      function _O(t2, e) {
        if (e?.["no-cache"]) return true;
        let r2 = Date.now();
        if (r2 > t2.staleAt) {
          if (e?.["max-stale"]) {
            let n2 = t2.staleAt + e["max-stale"] * 1e3;
            return r2 > n2;
          }
          return true;
        }
        if (e?.["min-fresh"]) {
          let n2 = t2.staleAt - r2, A2 = e["min-fresh"] * 1e3;
          return n2 <= A2;
        }
        return false;
      }
      __name(_O, "_O");
      function jO(t2, e, r2, n2, A2, i2) {
        if (i2?.["only-if-cached"]) {
          let s = false;
          try {
            if (typeof n2.onConnect == "function" && (n2.onConnect(() => {
              s = true;
            }), s) || typeof n2.onHeaders == "function" && (n2.onHeaders(504, [], () => {
            }, "Gateway Timeout"), s)) return;
            typeof n2.onComplete == "function" && n2.onComplete([]);
          } catch (o2) {
            typeof n2.onError == "function" && n2.onError(o2);
          }
          return true;
        }
        return t2(A2, new Lc(e, r2, n2));
      }
      __name(jO, "jO");
      function _D(t2, e, r2, n2, A2, i2) {
        let s = _A.isStream(r2.body) ? r2.body : YO.from(r2.body ?? []);
        WD(!s.destroyed, "stream should not be destroyed"), WD(!s.readableDidRead, "stream should not be readableDidRead");
        let o2 = { resume() {
          s.resume();
        }, pause() {
          s.pause();
        }, get paused() {
          return s.isPaused();
        }, get aborted() {
          return s.destroyed;
        }, get reason() {
          return s.errored;
        }, abort(c2) {
          s.destroy(c2 ?? new WO());
        } };
        if (s.on("error", function(c2) {
          if (!this.readableEnded) if (typeof t2.onResponseError == "function") t2.onResponseError(o2, c2);
          else throw c2;
        }).on("close", function() {
          this.errored || t2.onResponseEnd?.(o2, {});
        }), t2.onRequestStart?.(o2, A2), s.destroyed) return;
        let a2 = { ...r2.headers, age: String(n2) };
        i2 && (a2.warning = '110 - "response is stale"'), t2.onResponseStart?.(o2, r2.statusCode, a2, r2.statusMessage), e.method === "HEAD" ? s.destroy() : s.on("data", function(c2) {
          t2.onResponseData?.(o2, c2);
        });
      }
      __name(_D, "_D");
      function jD(t2, e, r2, n2, A2, i2, s) {
        if (!s) return jO(t2, e, r2, n2, A2, i2);
        let o2 = Date.now();
        if (o2 > s.deleteAt) return t2(A2, new Lc(e, r2, n2));
        let a2 = Math.round((o2 - s.cachedAt) / 1e3);
        if (i2?.["max-age"] && a2 >= i2["max-age"]) return t2(A2, n2);
        if (_O(s, i2)) {
          if (_A.isStream(A2.body) && _A.bodyLength(A2.body) !== 0) return t2(A2, new Lc(e, r2, n2));
          let c2 = false, l2 = s.cacheControlDirectives["stale-if-error"] ?? i2?.["stale-if-error"];
          l2 && (c2 = o2 < s.staleAt + l2 * 1e3);
          let u2 = { ...A2.headers, "if-modified-since": new Date(s.cachedAt).toUTCString() };
          return s.etag && (u2["if-none-match"] = s.etag), s.vary && (u2 = { ...u2, ...s.vary }), t2({ ...A2, headers: u2 }, new OO((g, E) => {
            g ? _D(n2, A2, s, a2, E, true) : _A.isStream(s.body) && s.body.on("error", () => {
            }).destroy();
          }, new Lc(e, r2, n2), c2));
        }
        _A.isStream(A2.body) && A2.body.on("error", () => {
        }).destroy(), _D(n2, A2, s, a2, null, false);
      }
      __name(jD, "jD");
      ZD.exports = (t2 = {}) => {
        let { store: e = new GO(), methods: r2 = ["GET"], cacheByDefault: n2 = void 0, type: A2 = "shared" } = t2;
        if (typeof t2 != "object" || t2 === null) throw new TypeError(`expected type of opts to be an Object, got ${t2 === null ? "null" : typeof t2}`);
        if (VO(e, "opts.store"), HO(r2, "opts.methods"), typeof n2 < "u" && typeof n2 != "number") throw new TypeError(`exepcted opts.cacheByDefault to be number or undefined, got ${typeof n2}`);
        if (typeof A2 < "u" && A2 !== "shared" && A2 !== "private") throw new TypeError(`exepcted opts.type to be shared, private, or undefined, got ${typeof A2}`);
        let i2 = { store: e, methods: r2, cacheByDefault: n2, type: A2 }, s = _A.safeHTTPMethods.filter((o2) => r2.includes(o2) === false);
        return (o2) => (a2, c2) => {
          if (!a2.origin || s.includes(a2.method)) return o2(a2, c2);
          let l2 = a2.headers?.["cache-control"] ? JO(a2.headers["cache-control"]) : void 0;
          if (l2?.["no-store"]) return o2(a2, c2);
          let u2 = qO(a2), g = e.get(u2);
          return g && typeof g.then == "function" ? g.then((E) => {
            jD(o2, i2, u2, c2, a2, l2, E);
          }) : jD(o2, i2, u2, c2, a2, l2, g), true;
        };
      };
    });
    var zD = C2((V$, $D) => {
      "use strict";
      var { Writable: ZO } = __require("node:stream"), { assertCacheKey: $d, assertCacheValue: XO } = Fs(), zd, qe = 3, KD = 2 * 1e3 * 1e3 * 1e3;
      $D.exports = class {
        #e = KD;
        #t = 1 / 0;
        #r;
        #n;
        #i;
        #A;
        #a;
        #s;
        #o;
        #c;
        constructor(e) {
          if (e) {
            if (typeof e != "object") throw new TypeError("SqliteCacheStore options must be an object");
            if (e.maxEntrySize !== void 0) {
              if (typeof e.maxEntrySize != "number" || !Number.isInteger(e.maxEntrySize) || e.maxEntrySize < 0) throw new TypeError("SqliteCacheStore options.maxEntrySize must be a non-negative integer");
              if (e.maxEntrySize > KD) throw new TypeError("SqliteCacheStore options.maxEntrySize must be less than 2gb");
              this.#e = e.maxEntrySize;
            }
            if (e.maxCount !== void 0) {
              if (typeof e.maxCount != "number" || !Number.isInteger(e.maxCount) || e.maxCount < 0) throw new TypeError("SqliteCacheStore options.maxCount must be a non-negative integer");
              this.#t = e.maxCount;
            }
          }
          zd || (zd = __require("node:sqlite").DatabaseSync), this.#r = new zd(e?.location ?? ":memory:"), this.#r.exec(`
      CREATE TABLE IF NOT EXISTS cacheInterceptorV${qe} (
        -- Data specific to us
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        url TEXT NOT NULL,
        method TEXT NOT NULL,

        -- Data returned to the interceptor
        body BUF NULL,
        deleteAt INTEGER NOT NULL,
        statusCode INTEGER NOT NULL,
        statusMessage TEXT NOT NULL,
        headers TEXT NULL,
        cacheControlDirectives TEXT NULL,
        etag TEXT NULL,
        vary TEXT NULL,
        cachedAt INTEGER NOT NULL,
        staleAt INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${qe}_url ON cacheInterceptorV${qe}(url);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${qe}_method ON cacheInterceptorV${qe}(method);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${qe}_deleteAt ON cacheInterceptorV${qe}(deleteAt);
    `), this.#n = this.#r.prepare(`
      SELECT
        id,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      FROM cacheInterceptorV${qe}
      WHERE
        url = ?
        AND method = ?
      ORDER BY
        deleteAt ASC
    `), this.#i = this.#r.prepare(`
      UPDATE cacheInterceptorV${qe} SET
        body = ?,
        deleteAt = ?,
        statusCode = ?,
        statusMessage = ?,
        headers = ?,
        etag = ?,
        cacheControlDirectives = ?,
        cachedAt = ?,
        staleAt = ?
      WHERE
        id = ?
    `), this.#A = this.#r.prepare(`
      INSERT INTO cacheInterceptorV${qe} (
        url,
        method,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `), this.#s = this.#r.prepare(`DELETE FROM cacheInterceptorV${qe} WHERE url = ?`), this.#o = this.#r.prepare(`SELECT COUNT(*) AS total FROM cacheInterceptorV${qe}`), this.#a = this.#r.prepare(`DELETE FROM cacheInterceptorV${qe} WHERE deleteAt <= ?`), this.#c = this.#t === 1 / 0 ? null : this.#r.prepare(`
        DELETE FROM cacheInterceptorV${qe}
        WHERE id IN (
          SELECT
            id
          FROM cacheInterceptorV${qe}
          ORDER BY cachedAt DESC
          LIMIT ?
        )
      `);
        }
        close() {
          this.#r.close();
        }
        get(e) {
          $d(e);
          let r2 = this.#u(e);
          return r2 ? { body: r2.body ? Buffer.from(r2.body.buffer, r2.body.byteOffset, r2.body.byteLength) : void 0, statusCode: r2.statusCode, statusMessage: r2.statusMessage, headers: r2.headers ? JSON.parse(r2.headers) : void 0, etag: r2.etag ? r2.etag : void 0, vary: r2.vary ? JSON.parse(r2.vary) : void 0, cacheControlDirectives: r2.cacheControlDirectives ? JSON.parse(r2.cacheControlDirectives) : void 0, cachedAt: r2.cachedAt, staleAt: r2.staleAt, deleteAt: r2.deleteAt } : void 0;
        }
        set(e, r2) {
          $d(e);
          let n2 = this.#l(e), A2 = Array.isArray(r2.body) ? Buffer.concat(r2.body) : r2.body, i2 = A2?.byteLength;
          if (i2 && i2 > this.#e) return;
          let s = this.#u(e, true);
          s ? this.#i.run(A2, r2.deleteAt, r2.statusCode, r2.statusMessage, r2.headers ? JSON.stringify(r2.headers) : null, r2.etag ? r2.etag : null, r2.cacheControlDirectives ? JSON.stringify(r2.cacheControlDirectives) : null, r2.cachedAt, r2.staleAt, s.id) : (this.#g(), this.#A.run(n2, e.method, A2, r2.deleteAt, r2.statusCode, r2.statusMessage, r2.headers ? JSON.stringify(r2.headers) : null, r2.etag ? r2.etag : null, r2.cacheControlDirectives ? JSON.stringify(r2.cacheControlDirectives) : null, r2.vary ? JSON.stringify(r2.vary) : null, r2.cachedAt, r2.staleAt));
        }
        createWriteStream(e, r2) {
          $d(e), XO(r2);
          let n2 = 0, A2 = [], i2 = this;
          return new ZO({ decodeStrings: true, write(s, o2, a2) {
            n2 += s.byteLength, n2 < i2.#e ? A2.push(s) : this.destroy(), a2();
          }, final(s) {
            i2.set(e, { ...r2, body: A2 }), s();
          } });
        }
        delete(e) {
          if (typeof e != "object") throw new TypeError(`expected key to be object, got ${typeof e}`);
          this.#s.run(this.#l(e));
        }
        #g() {
          if (this.size <= this.#t) return 0;
          {
            let e = this.#a.run(Date.now()).changes;
            if (e) return e;
          }
          {
            let e = this.#c?.run(Math.max(Math.floor(this.#t * 0.1), 1)).changes;
            if (e) return e;
          }
          return 0;
        }
        get size() {
          let { total: e } = this.#o.get();
          return e;
        }
        #l(e) {
          return `${e.origin}/${e.path}`;
        }
        #u(e, r2 = false) {
          let n2 = this.#l(e), { headers: A2, method: i2 } = e, s = this.#n.all(n2, i2);
          if (s.length === 0) return;
          let o2 = Date.now();
          for (let a2 of s) {
            if (o2 >= a2.deleteAt && !r2) return;
            let c2 = true;
            if (a2.vary) {
              let l2 = JSON.parse(a2.vary);
              for (let u2 in l2) if (!KO(A2[u2], l2[u2])) {
                c2 = false;
                break;
              }
            }
            if (c2) return a2;
          }
        }
      };
      function KO(t2, e) {
        return t2 == null && e == null ? true : t2 == null && e != null || t2 != null && e == null ? false : Array.isArray(t2) && Array.isArray(e) ? t2.length !== e.length ? false : t2.every((r2, n2) => r2 === e[n2]) : t2 === e;
      }
      __name(KO, "KO");
    });
    var Tn = C2((H$, s0) => {
      "use strict";
      var { kConstruct: $O } = ne(), { kEnumerableProperty: jA } = Y2(), { iteratorMixin: zO, isValidHeaderName: Ts, isValidHeaderValue: t0 } = Ve(), { webidl: V2 } = Te(), eh = __require("node:assert"), vc = __require("node:util");
      function e0(t2) {
        return t2 === 10 || t2 === 13 || t2 === 9 || t2 === 32;
      }
      __name(e0, "e0");
      function r0(t2) {
        let e = 0, r2 = t2.length;
        for (; r2 > e && e0(t2.charCodeAt(r2 - 1)); ) --r2;
        for (; r2 > e && e0(t2.charCodeAt(e)); ) ++e;
        return e === 0 && r2 === t2.length ? t2 : t2.substring(e, r2);
      }
      __name(r0, "r0");
      function n0(t2, e) {
        if (Array.isArray(e)) for (let r2 = 0; r2 < e.length; ++r2) {
          let n2 = e[r2];
          if (n2.length !== 2) throw V2.errors.exception({ header: "Headers constructor", message: `expected name/value pair to be length 2, found ${n2.length}.` });
          th(t2, n2[0], n2[1]);
        }
        else if (typeof e == "object" && e !== null) {
          let r2 = Object.keys(e);
          for (let n2 = 0; n2 < r2.length; ++n2) th(t2, r2[n2], e[r2[n2]]);
        } else throw V2.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
      }
      __name(n0, "n0");
      function th(t2, e, r2) {
        if (r2 = r0(r2), Ts(e)) {
          if (!t0(r2)) throw V2.errors.invalidArgument({ prefix: "Headers.append", value: r2, type: "header value" });
        } else throw V2.errors.invalidArgument({ prefix: "Headers.append", value: e, type: "header name" });
        if (i0(t2) === "immutable") throw new TypeError("immutable");
        return Yc(t2).append(e, r2, false);
      }
      __name(th, "th");
      function eV(t2) {
        let e = Yc(t2);
        if (!e) return [];
        if (e.sortedMap) return e.sortedMap;
        let r2 = [], n2 = e.toSortedArray(), A2 = e.cookies;
        if (A2 === null || A2.length === 1) return e.sortedMap = n2;
        for (let i2 = 0; i2 < n2.length; ++i2) {
          let { 0: s, 1: o2 } = n2[i2];
          if (s === "set-cookie") for (let a2 = 0; a2 < A2.length; ++a2) r2.push([s, A2[a2]]);
          else r2.push([s, o2]);
        }
        return e.sortedMap = r2;
      }
      __name(eV, "eV");
      function A0(t2, e) {
        return t2[0] < e[0] ? -1 : 1;
      }
      __name(A0, "A0");
      var Pc = class t2 {
        static {
          __name(this, "t");
        }
        cookies = null;
        sortedMap;
        headersMap;
        constructor(e) {
          e instanceof t2 ? (this.headersMap = new Map(e.headersMap), this.sortedMap = e.sortedMap, this.cookies = e.cookies === null ? null : [...e.cookies]) : (this.headersMap = new Map(e), this.sortedMap = null);
        }
        contains(e, r2) {
          return this.headersMap.has(r2 ? e : e.toLowerCase());
        }
        clear() {
          this.headersMap.clear(), this.sortedMap = null, this.cookies = null;
        }
        append(e, r2, n2) {
          this.sortedMap = null;
          let A2 = n2 ? e : e.toLowerCase(), i2 = this.headersMap.get(A2);
          if (i2) {
            let s = A2 === "cookie" ? "; " : ", ";
            this.headersMap.set(A2, { name: i2.name, value: `${i2.value}${s}${r2}` });
          } else this.headersMap.set(A2, { name: e, value: r2 });
          A2 === "set-cookie" && (this.cookies ??= []).push(r2);
        }
        set(e, r2, n2) {
          this.sortedMap = null;
          let A2 = n2 ? e : e.toLowerCase();
          A2 === "set-cookie" && (this.cookies = [r2]), this.headersMap.set(A2, { name: e, value: r2 });
        }
        delete(e, r2) {
          this.sortedMap = null, r2 || (e = e.toLowerCase()), e === "set-cookie" && (this.cookies = null), this.headersMap.delete(e);
        }
        get(e, r2) {
          return this.headersMap.get(r2 ? e : e.toLowerCase())?.value ?? null;
        }
        *[Symbol.iterator]() {
          for (let { 0: e, 1: { value: r2 } } of this.headersMap) yield [e, r2];
        }
        get entries() {
          let e = {};
          if (this.headersMap.size !== 0) for (let { name: r2, value: n2 } of this.headersMap.values()) e[r2] = n2;
          return e;
        }
        rawValues() {
          return this.headersMap.values();
        }
        get entriesList() {
          let e = [];
          if (this.headersMap.size !== 0) for (let { 0: r2, 1: { name: n2, value: A2 } } of this.headersMap) if (r2 === "set-cookie") for (let i2 of this.cookies) e.push([n2, i2]);
          else e.push([n2, A2]);
          return e;
        }
        toSortedArray() {
          let e = this.headersMap.size, r2 = new Array(e);
          if (e <= 32) {
            if (e === 0) return r2;
            let n2 = this.headersMap[Symbol.iterator](), A2 = n2.next().value;
            r2[0] = [A2[0], A2[1].value], eh(A2[1].value !== null);
            for (let i2 = 1, s = 0, o2 = 0, a2 = 0, c2 = 0, l2, u2; i2 < e; ++i2) {
              for (u2 = n2.next().value, l2 = r2[i2] = [u2[0], u2[1].value], eh(l2[1] !== null), a2 = 0, o2 = i2; a2 < o2; ) c2 = a2 + (o2 - a2 >> 1), r2[c2][0] <= l2[0] ? a2 = c2 + 1 : o2 = c2;
              if (i2 !== c2) {
                for (s = i2; s > a2; ) r2[s] = r2[--s];
                r2[a2] = l2;
              }
            }
            if (!n2.next().done) throw new TypeError("Unreachable");
            return r2;
          } else {
            let n2 = 0;
            for (let { 0: A2, 1: { value: i2 } } of this.headersMap) r2[n2++] = [A2, i2], eh(i2 !== null);
            return r2.sort(A0);
          }
        }
      }, Nt = class t2 {
        static {
          __name(this, "t");
        }
        #e;
        #t;
        constructor(e = void 0) {
          V2.util.markAsUncloneable(this), e !== $O && (this.#t = new Pc(), this.#e = "none", e !== void 0 && (e = V2.converters.HeadersInit(e, "Headers constructor", "init"), n0(this, e)));
        }
        append(e, r2) {
          V2.brandCheck(this, t2), V2.argumentLengthCheck(arguments, 2, "Headers.append");
          let n2 = "Headers.append";
          return e = V2.converters.ByteString(e, n2, "name"), r2 = V2.converters.ByteString(r2, n2, "value"), th(this, e, r2);
        }
        delete(e) {
          if (V2.brandCheck(this, t2), V2.argumentLengthCheck(arguments, 1, "Headers.delete"), e = V2.converters.ByteString(e, "Headers.delete", "name"), !Ts(e)) throw V2.errors.invalidArgument({ prefix: "Headers.delete", value: e, type: "header name" });
          if (this.#e === "immutable") throw new TypeError("immutable");
          this.#t.contains(e, false) && this.#t.delete(e, false);
        }
        get(e) {
          V2.brandCheck(this, t2), V2.argumentLengthCheck(arguments, 1, "Headers.get");
          let r2 = "Headers.get";
          if (e = V2.converters.ByteString(e, r2, "name"), !Ts(e)) throw V2.errors.invalidArgument({ prefix: r2, value: e, type: "header name" });
          return this.#t.get(e, false);
        }
        has(e) {
          V2.brandCheck(this, t2), V2.argumentLengthCheck(arguments, 1, "Headers.has");
          let r2 = "Headers.has";
          if (e = V2.converters.ByteString(e, r2, "name"), !Ts(e)) throw V2.errors.invalidArgument({ prefix: r2, value: e, type: "header name" });
          return this.#t.contains(e, false);
        }
        set(e, r2) {
          V2.brandCheck(this, t2), V2.argumentLengthCheck(arguments, 2, "Headers.set");
          let n2 = "Headers.set";
          if (e = V2.converters.ByteString(e, n2, "name"), r2 = V2.converters.ByteString(r2, n2, "value"), r2 = r0(r2), Ts(e)) {
            if (!t0(r2)) throw V2.errors.invalidArgument({ prefix: n2, value: r2, type: "header value" });
          } else throw V2.errors.invalidArgument({ prefix: n2, value: e, type: "header name" });
          if (this.#e === "immutable") throw new TypeError("immutable");
          this.#t.set(e, r2, false);
        }
        getSetCookie() {
          V2.brandCheck(this, t2);
          let e = this.#t.cookies;
          return e ? [...e] : [];
        }
        [vc.inspect.custom](e, r2) {
          return r2.depth ??= e, `Headers ${vc.formatWithOptions(r2, this.#t.entries)}`;
        }
        static getHeadersGuard(e) {
          return e.#e;
        }
        static setHeadersGuard(e, r2) {
          e.#e = r2;
        }
        static getHeadersList(e) {
          return e.#t;
        }
        static setHeadersList(e, r2) {
          e.#t = r2;
        }
      }, { getHeadersGuard: i0, setHeadersGuard: tV, getHeadersList: Yc, setHeadersList: rV } = Nt;
      Reflect.deleteProperty(Nt, "getHeadersGuard");
      Reflect.deleteProperty(Nt, "setHeadersGuard");
      Reflect.deleteProperty(Nt, "getHeadersList");
      Reflect.deleteProperty(Nt, "setHeadersList");
      zO("Headers", Nt, eV, 0, 1);
      Object.defineProperties(Nt.prototype, { append: jA, delete: jA, get: jA, has: jA, set: jA, getSetCookie: jA, [Symbol.toStringTag]: { value: "Headers", configurable: true }, [vc.inspect.custom]: { enumerable: false } });
      V2.converters.HeadersInit = function(t2, e, r2) {
        if (V2.util.Type(t2) === V2.util.Types.OBJECT) {
          let n2 = Reflect.get(t2, Symbol.iterator);
          if (!vc.types.isProxy(t2) && n2 === Nt.prototype.entries) try {
            return Yc(t2).entriesList;
          } catch {
          }
          return typeof n2 == "function" ? V2.converters["sequence<sequence<ByteString>>"](t2, e, r2, n2.bind(t2)) : V2.converters["record<ByteString, ByteString>"](t2, e, r2);
        }
        throw V2.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
      };
      s0.exports = { fill: n0, compareHeaderName: A0, Headers: Nt, HeadersList: Pc, getHeadersGuard: i0, setHeadersGuard: tV, setHeadersList: rV, getHeadersList: Yc };
    });
    var Us = C2((q$, Q0) => {
      "use strict";
      var { Headers: g0, HeadersList: o0, fill: nV, getHeadersGuard: AV, setHeadersGuard: E0, setHeadersList: d0 } = Tn(), { extractBody: a0, cloneBody: iV, mixinBody: sV, hasFinalizationRegistry: oV, streamRegistry: aV, bodyUnusable: cV } = FA(), h0 = Y2(), c0 = __require("node:util"), { kEnumerableProperty: At } = h0, { isValidReasonPhrase: lV, isCancelled: uV, isAborted: gV, serializeJavascriptValueToJSONString: EV, isErrorLike: dV, isomorphicEncode: hV, environmentSettingsObject: fV } = Ve(), { redirectStatusSet: QV, nullBodyStatus: CV } = ts(), { webidl: O2 } = Te(), { URLSerializer: l0 } = tt(), { kConstruct: Oc } = ne(), rh = __require("node:assert"), { types: IV } = __require("node:util"), pV = new TextEncoder("utf-8"), it = class t2 {
        static {
          __name(this, "t");
        }
        #e;
        #t;
        static error() {
          return xs(Vc(), "immutable");
        }
        static json(e, r2 = void 0) {
          O2.argumentLengthCheck(arguments, 1, "Response.json"), r2 !== null && (r2 = O2.converters.ResponseInit(r2));
          let n2 = pV.encode(EV(e)), A2 = a0(n2), i2 = xs(ZA({}), "response");
          return u0(i2, r2, { body: A2[0], type: "application/json" }), i2;
        }
        static redirect(e, r2 = 302) {
          O2.argumentLengthCheck(arguments, 1, "Response.redirect"), e = O2.converters.USVString(e), r2 = O2.converters["unsigned short"](r2);
          let n2;
          try {
            n2 = new URL(e, fV.settingsObject.baseUrl);
          } catch (s) {
            throw new TypeError(`Failed to parse URL from ${e}`, { cause: s });
          }
          if (!QV.has(r2)) throw new RangeError(`Invalid status code ${r2}`);
          let A2 = xs(ZA({}), "immutable");
          A2.#t.status = r2;
          let i2 = hV(l0(n2));
          return A2.#t.headersList.append("location", i2, true), A2;
        }
        constructor(e = null, r2 = void 0) {
          if (O2.util.markAsUncloneable(this), e === Oc) return;
          e !== null && (e = O2.converters.BodyInit(e)), r2 = O2.converters.ResponseInit(r2), this.#t = ZA({}), this.#e = new g0(Oc), E0(this.#e, "response"), d0(this.#e, this.#t.headersList);
          let n2 = null;
          if (e != null) {
            let [A2, i2] = a0(e);
            n2 = { body: A2, type: i2 };
          }
          u0(this, r2, n2);
        }
        get type() {
          return O2.brandCheck(this, t2), this.#t.type;
        }
        get url() {
          O2.brandCheck(this, t2);
          let e = this.#t.urlList, r2 = e[e.length - 1] ?? null;
          return r2 === null ? "" : l0(r2, true);
        }
        get redirected() {
          return O2.brandCheck(this, t2), this.#t.urlList.length > 1;
        }
        get status() {
          return O2.brandCheck(this, t2), this.#t.status;
        }
        get ok() {
          return O2.brandCheck(this, t2), this.#t.status >= 200 && this.#t.status <= 299;
        }
        get statusText() {
          return O2.brandCheck(this, t2), this.#t.statusText;
        }
        get headers() {
          return O2.brandCheck(this, t2), this.#e;
        }
        get body() {
          return O2.brandCheck(this, t2), this.#t.body ? this.#t.body.stream : null;
        }
        get bodyUsed() {
          return O2.brandCheck(this, t2), !!this.#t.body && h0.isDisturbed(this.#t.body.stream);
        }
        clone() {
          if (O2.brandCheck(this, t2), cV(this.#t)) throw O2.errors.exception({ header: "Response.clone", message: "Body has already been consumed." });
          let e = nh(this.#t);
          return xs(e, AV(this.#e));
        }
        [c0.inspect.custom](e, r2) {
          r2.depth === null && (r2.depth = 2), r2.colors ??= true;
          let n2 = { status: this.status, statusText: this.statusText, headers: this.headers, body: this.body, bodyUsed: this.bodyUsed, ok: this.ok, redirected: this.redirected, type: this.type, url: this.url };
          return `Response ${c0.formatWithOptions(r2, n2)}`;
        }
        static getResponseHeaders(e) {
          return e.#e;
        }
        static setResponseHeaders(e, r2) {
          e.#e = r2;
        }
        static getResponseState(e) {
          return e.#t;
        }
        static setResponseState(e, r2) {
          e.#t = r2;
        }
      }, { getResponseHeaders: BV, setResponseHeaders: mV, getResponseState: xn, setResponseState: yV } = it;
      Reflect.deleteProperty(it, "getResponseHeaders");
      Reflect.deleteProperty(it, "setResponseHeaders");
      Reflect.deleteProperty(it, "getResponseState");
      Reflect.deleteProperty(it, "setResponseState");
      sV(it, xn);
      Object.defineProperties(it.prototype, { type: At, url: At, status: At, ok: At, redirected: At, statusText: At, headers: At, clone: At, body: At, bodyUsed: At, [Symbol.toStringTag]: { value: "Response", configurable: true } });
      Object.defineProperties(it, { json: At, redirect: At, error: At });
      function nh(t2) {
        if (t2.internalResponse) return f0(nh(t2.internalResponse), t2.type);
        let e = ZA({ ...t2, body: null });
        return t2.body != null && (e.body = iV(e, t2.body)), e;
      }
      __name(nh, "nh");
      function ZA(t2) {
        return { aborted: false, rangeRequested: false, timingAllowPassed: false, requestIncludesCredentials: false, type: "default", status: 200, timingInfo: null, cacheState: "", statusText: "", ...t2, headersList: t2?.headersList ? new o0(t2?.headersList) : new o0(), urlList: t2?.urlList ? [...t2.urlList] : [] };
      }
      __name(ZA, "ZA");
      function Vc(t2) {
        let e = dV(t2);
        return ZA({ type: "error", status: 0, error: e ? t2 : new Error(t2 && String(t2)), aborted: t2 && t2.name === "AbortError" });
      }
      __name(Vc, "Vc");
      function wV(t2) {
        return t2.type === "error" && t2.status === 0;
      }
      __name(wV, "wV");
      function Gc(t2, e) {
        return e = { internalResponse: t2, ...e }, new Proxy(t2, { get(r2, n2) {
          return n2 in e ? e[n2] : r2[n2];
        }, set(r2, n2, A2) {
          return rh(!(n2 in e)), r2[n2] = A2, true;
        } });
      }
      __name(Gc, "Gc");
      function f0(t2, e) {
        if (e === "basic") return Gc(t2, { type: "basic", headersList: t2.headersList });
        if (e === "cors") return Gc(t2, { type: "cors", headersList: t2.headersList });
        if (e === "opaque") return Gc(t2, { type: "opaque", urlList: Object.freeze([]), status: 0, statusText: "", body: null });
        if (e === "opaqueredirect") return Gc(t2, { type: "opaqueredirect", status: 0, statusText: "", headersList: [], body: null });
        rh(false);
      }
      __name(f0, "f0");
      function DV(t2, e = null) {
        return rh(uV(t2)), gV(t2) ? Vc(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: e })) : Vc(Object.assign(new DOMException("Request was cancelled."), { cause: e }));
      }
      __name(DV, "DV");
      function u0(t2, e, r2) {
        if (e.status !== null && (e.status < 200 || e.status > 599)) throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
        if ("statusText" in e && e.statusText != null && !lV(String(e.statusText))) throw new TypeError("Invalid statusText");
        if ("status" in e && e.status != null && (xn(t2).status = e.status), "statusText" in e && e.statusText != null && (xn(t2).statusText = e.statusText), "headers" in e && e.headers != null && nV(BV(t2), e.headers), r2) {
          if (CV.includes(t2.status)) throw O2.errors.exception({ header: "Response constructor", message: `Invalid response status code ${t2.status}` });
          xn(t2).body = r2.body, r2.type != null && !xn(t2).headersList.contains("content-type", true) && xn(t2).headersList.append("content-type", r2.type, true);
        }
      }
      __name(u0, "u0");
      function xs(t2, e) {
        let r2 = new it(Oc);
        yV(r2, t2);
        let n2 = new g0(Oc);
        return mV(r2, n2), d0(n2, t2.headersList), E0(n2, e), oV && t2.body?.stream && aV.register(r2, new WeakRef(t2.body.stream)), r2;
      }
      __name(xs, "xs");
      O2.converters.XMLHttpRequestBodyInit = function(t2, e, r2) {
        return typeof t2 == "string" ? O2.converters.USVString(t2, e, r2) : O2.is.Blob(t2) || ArrayBuffer.isView(t2) || IV.isArrayBuffer(t2) || O2.is.FormData(t2) || O2.is.URLSearchParams(t2) ? t2 : O2.converters.DOMString(t2, e, r2);
      };
      O2.converters.BodyInit = function(t2, e, r2) {
        return O2.is.ReadableStream(t2) || t2?.[Symbol.asyncIterator] ? t2 : O2.converters.XMLHttpRequestBodyInit(t2, e, r2);
      };
      O2.converters.ResponseInit = O2.dictionaryConverter([{ key: "status", converter: O2.converters["unsigned short"], defaultValue: /* @__PURE__ */ __name(() => 200, "defaultValue") }, { key: "statusText", converter: O2.converters.ByteString, defaultValue: /* @__PURE__ */ __name(() => "", "defaultValue") }, { key: "headers", converter: O2.converters.HeadersInit }]);
      O2.is.Response = O2.util.MakeTypeAssertion(it);
      Q0.exports = { isNetworkError: wV, makeNetworkError: Vc, makeResponse: ZA, makeAppropriateNetworkError: DV, filterResponse: f0, Response: it, cloneResponse: nh, fromInnerResponse: xs, getResponseState: xn };
    });
    var B0 = C2((J$, p0) => {
      "use strict";
      var { kConnected: C0, kSize: I0 } = ne(), Ah = class {
        static {
          __name(this, "Ah");
        }
        constructor(e) {
          this.value = e;
        }
        deref() {
          return this.value[C0] === 0 && this.value[I0] === 0 ? void 0 : this.value;
        }
      }, ih = class {
        static {
          __name(this, "ih");
        }
        constructor(e) {
          this.finalizer = e;
        }
        register(e, r2) {
          e.on && e.on("disconnect", () => {
            e[C0] === 0 && e[I0] === 0 && this.finalizer(r2);
          });
        }
        unregister(e) {
        }
      };
      p0.exports = function() {
        return process.env.NODE_V8_COVERAGE && process.version.startsWith("v18") ? (process._rawDebug("Using compatibility WeakRef and FinalizationRegistry"), { WeakRef: Ah, FinalizationRegistry: ih }) : { WeakRef, FinalizationRegistry };
      };
    });
    var XA = C2((W$, M0) => {
      "use strict";
      var { extractBody: RV, mixinBody: SV, cloneBody: bV, bodyUnusable: m0 } = FA(), { Headers: b0, fill: NV, HeadersList: Jc, setHeadersGuard: sh, getHeadersGuard: FV, setHeadersList: N0, getHeadersList: y0 } = Tn(), { FinalizationRegistry: TV } = B0()(), qc = Y2(), w0 = __require("node:util"), { isValidHTTPToken: xV, sameOrigin: D0, environmentSettingsObject: Hc } = Ve(), { forbiddenMethodsSet: UV, corsSafeListedMethodsSet: kV, referrerPolicy: MV, requestRedirect: LV, requestMode: vV, requestCredentials: PV, requestCache: YV, requestDuplex: GV } = ts(), { kEnumerableProperty: Ie, normalizedMethodRecordsBase: OV, normalizedMethodRecords: VV } = qc, { webidl: F2 } = Te(), { URLSerializer: HV } = tt(), { kConstruct: Wc } = ne(), qV = __require("node:assert"), { getMaxListeners: F0, setMaxListeners: JV, defaultMaxListeners: WV } = __require("node:events"), _V = Symbol("abortController"), T0 = new TV(({ signal: t2, abort: e }) => {
        t2.removeEventListener("abort", e);
      }), _c = /* @__PURE__ */ new WeakMap(), oh;
      try {
        oh = F0(new AbortController().signal) > 0;
      } catch {
        oh = false;
      }
      function R0(t2) {
        return e;
        function e() {
          let r2 = t2.deref();
          if (r2 !== void 0) {
            T0.unregister(e), this.removeEventListener("abort", e), r2.abort(this.reason);
            let n2 = _c.get(r2.signal);
            if (n2 !== void 0) {
              if (n2.size !== 0) {
                for (let A2 of n2) {
                  let i2 = A2.deref();
                  i2 !== void 0 && i2.abort(this.reason);
                }
                n2.clear();
              }
              _c.delete(r2.signal);
            }
          }
        }
        __name(e, "e");
      }
      __name(R0, "R0");
      var S0 = false, Xe = class t2 {
        static {
          __name(this, "t");
        }
        #e;
        #t;
        #r;
        #n;
        constructor(e, r2 = void 0) {
          if (F2.util.markAsUncloneable(this), e === Wc) return;
          let n2 = "Request constructor";
          F2.argumentLengthCheck(arguments, 1, n2), e = F2.converters.RequestInfo(e, n2, "input"), r2 = F2.converters.RequestInit(r2, n2, "init");
          let A2 = null, i2 = null, s = Hc.settingsObject.baseUrl, o2 = null;
          if (typeof e == "string") {
            this.#t = r2.dispatcher;
            let Q;
            try {
              Q = new URL(e, s);
            } catch (I2) {
              throw new TypeError("Failed to parse URL from " + e, { cause: I2 });
            }
            if (Q.username || Q.password) throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + e);
            A2 = jc({ urlList: [Q] }), i2 = "cors";
          } else qV(F2.is.Request(e)), A2 = e.#n, o2 = e.#e, this.#t = r2.dispatcher || e.#t;
          let a2 = Hc.settingsObject.origin, c2 = "client";
          if (A2.window?.constructor?.name === "EnvironmentSettingsObject" && D0(A2.window, a2) && (c2 = A2.window), r2.window != null) throw new TypeError(`'window' option '${c2}' must be null`);
          "window" in r2 && (c2 = "no-window"), A2 = jc({ method: A2.method, headersList: A2.headersList, unsafeRequest: A2.unsafeRequest, client: Hc.settingsObject, window: c2, priority: A2.priority, origin: A2.origin, referrer: A2.referrer, referrerPolicy: A2.referrerPolicy, mode: A2.mode, credentials: A2.credentials, cache: A2.cache, redirect: A2.redirect, integrity: A2.integrity, keepalive: A2.keepalive, reloadNavigation: A2.reloadNavigation, historyNavigation: A2.historyNavigation, urlList: [...A2.urlList] });
          let l2 = Object.keys(r2).length !== 0;
          if (l2 && (A2.mode === "navigate" && (A2.mode = "same-origin"), A2.reloadNavigation = false, A2.historyNavigation = false, A2.origin = "client", A2.referrer = "client", A2.referrerPolicy = "", A2.url = A2.urlList[A2.urlList.length - 1], A2.urlList = [A2.url]), r2.referrer !== void 0) {
            let Q = r2.referrer;
            if (Q === "") A2.referrer = "no-referrer";
            else {
              let I2;
              try {
                I2 = new URL(Q, s);
              } catch (B) {
                throw new TypeError(`Referrer "${Q}" is not a valid URL.`, { cause: B });
              }
              I2.protocol === "about:" && I2.hostname === "client" || a2 && !D0(I2, Hc.settingsObject.baseUrl) ? A2.referrer = "client" : A2.referrer = I2;
            }
          }
          r2.referrerPolicy !== void 0 && (A2.referrerPolicy = r2.referrerPolicy);
          let u2;
          if (r2.mode !== void 0 ? u2 = r2.mode : u2 = i2, u2 === "navigate") throw F2.errors.exception({ header: "Request constructor", message: "invalid request mode navigate." });
          if (u2 != null && (A2.mode = u2), r2.credentials !== void 0 && (A2.credentials = r2.credentials), r2.cache !== void 0 && (A2.cache = r2.cache), A2.cache === "only-if-cached" && A2.mode !== "same-origin") throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
          if (r2.redirect !== void 0 && (A2.redirect = r2.redirect), r2.integrity != null && (A2.integrity = String(r2.integrity)), r2.keepalive !== void 0 && (A2.keepalive = !!r2.keepalive), r2.method !== void 0) {
            let Q = r2.method, I2 = VV[Q];
            if (I2 !== void 0) A2.method = I2;
            else {
              if (!xV(Q)) throw new TypeError(`'${Q}' is not a valid HTTP method.`);
              let B = Q.toUpperCase();
              if (UV.has(B)) throw new TypeError(`'${Q}' HTTP method is unsupported.`);
              Q = OV[B] ?? Q, A2.method = Q;
            }
            !S0 && A2.method === "patch" && (process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", { code: "UNDICI-FETCH-patch" }), S0 = true);
          }
          r2.signal !== void 0 && (o2 = r2.signal), this.#n = A2;
          let g = new AbortController();
          if (this.#e = g.signal, o2 != null) if (o2.aborted) g.abort(o2.reason);
          else {
            this[_V] = g;
            let Q = new WeakRef(g), I2 = R0(Q);
            oh && F0(o2) === WV && JV(1500, o2), qc.addAbortListener(o2, I2), T0.register(g, { signal: o2, abort: I2 }, I2);
          }
          if (this.#r = new b0(Wc), N0(this.#r, A2.headersList), sh(this.#r, "request"), u2 === "no-cors") {
            if (!kV.has(A2.method)) throw new TypeError(`'${A2.method} is unsupported in no-cors mode.`);
            sh(this.#r, "request-no-cors");
          }
          if (l2) {
            let Q = y0(this.#r), I2 = r2.headers !== void 0 ? r2.headers : new Jc(Q);
            if (Q.clear(), I2 instanceof Jc) {
              for (let { name: B, value: w } of I2.rawValues()) Q.append(B, w, false);
              Q.cookies = I2.cookies;
            } else NV(this.#r, I2);
          }
          let E = F2.is.Request(e) ? e.#n.body : null;
          if ((r2.body != null || E != null) && (A2.method === "GET" || A2.method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body.");
          let h = null;
          if (r2.body != null) {
            let [Q, I2] = RV(r2.body, A2.keepalive);
            h = Q, I2 && !y0(this.#r).contains("content-type", true) && this.#r.append("content-type", I2, true);
          }
          let f2 = h ?? E;
          if (f2 != null && f2.source == null) {
            if (h != null && r2.duplex == null) throw new TypeError("RequestInit: duplex option is required when sending a body.");
            if (A2.mode !== "same-origin" && A2.mode !== "cors") throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
            A2.useCORSPreflightFlag = true;
          }
          let p2 = f2;
          if (h == null && E != null) {
            if (m0(e.#n)) throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
            let Q = new TransformStream();
            E.stream.pipeThrough(Q), p2 = { source: E.source, length: E.length, stream: Q.readable };
          }
          this.#n.body = p2;
        }
        get method() {
          return F2.brandCheck(this, t2), this.#n.method;
        }
        get url() {
          return F2.brandCheck(this, t2), HV(this.#n.url);
        }
        get headers() {
          return F2.brandCheck(this, t2), this.#r;
        }
        get destination() {
          return F2.brandCheck(this, t2), this.#n.destination;
        }
        get referrer() {
          return F2.brandCheck(this, t2), this.#n.referrer === "no-referrer" ? "" : this.#n.referrer === "client" ? "about:client" : this.#n.referrer.toString();
        }
        get referrerPolicy() {
          return F2.brandCheck(this, t2), this.#n.referrerPolicy;
        }
        get mode() {
          return F2.brandCheck(this, t2), this.#n.mode;
        }
        get credentials() {
          return F2.brandCheck(this, t2), this.#n.credentials;
        }
        get cache() {
          return F2.brandCheck(this, t2), this.#n.cache;
        }
        get redirect() {
          return F2.brandCheck(this, t2), this.#n.redirect;
        }
        get integrity() {
          return F2.brandCheck(this, t2), this.#n.integrity;
        }
        get keepalive() {
          return F2.brandCheck(this, t2), this.#n.keepalive;
        }
        get isReloadNavigation() {
          return F2.brandCheck(this, t2), this.#n.reloadNavigation;
        }
        get isHistoryNavigation() {
          return F2.brandCheck(this, t2), this.#n.historyNavigation;
        }
        get signal() {
          return F2.brandCheck(this, t2), this.#e;
        }
        get body() {
          return F2.brandCheck(this, t2), this.#n.body ? this.#n.body.stream : null;
        }
        get bodyUsed() {
          return F2.brandCheck(this, t2), !!this.#n.body && qc.isDisturbed(this.#n.body.stream);
        }
        get duplex() {
          return F2.brandCheck(this, t2), "half";
        }
        clone() {
          if (F2.brandCheck(this, t2), m0(this.#n)) throw new TypeError("unusable");
          let e = U0(this.#n), r2 = new AbortController();
          if (this.signal.aborted) r2.abort(this.signal.reason);
          else {
            let n2 = _c.get(this.signal);
            n2 === void 0 && (n2 = /* @__PURE__ */ new Set(), _c.set(this.signal, n2));
            let A2 = new WeakRef(r2);
            n2.add(A2), qc.addAbortListener(r2.signal, R0(A2));
          }
          return k0(e, this.#t, r2.signal, FV(this.#r));
        }
        [w0.inspect.custom](e, r2) {
          r2.depth === null && (r2.depth = 2), r2.colors ??= true;
          let n2 = { method: this.method, url: this.url, headers: this.headers, destination: this.destination, referrer: this.referrer, referrerPolicy: this.referrerPolicy, mode: this.mode, credentials: this.credentials, cache: this.cache, redirect: this.redirect, integrity: this.integrity, keepalive: this.keepalive, isReloadNavigation: this.isReloadNavigation, isHistoryNavigation: this.isHistoryNavigation, signal: this.signal };
          return `Request ${w0.formatWithOptions(r2, n2)}`;
        }
        static setRequestSignal(e, r2) {
          return e.#e = r2, e;
        }
        static getRequestDispatcher(e) {
          return e.#t;
        }
        static setRequestDispatcher(e, r2) {
          e.#t = r2;
        }
        static setRequestHeaders(e, r2) {
          e.#r = r2;
        }
        static getRequestState(e) {
          return e.#n;
        }
        static setRequestState(e, r2) {
          e.#n = r2;
        }
      }, { setRequestSignal: jV, getRequestDispatcher: ZV, setRequestDispatcher: XV, setRequestHeaders: KV, getRequestState: x0, setRequestState: $V } = Xe;
      Reflect.deleteProperty(Xe, "setRequestSignal");
      Reflect.deleteProperty(Xe, "getRequestDispatcher");
      Reflect.deleteProperty(Xe, "setRequestDispatcher");
      Reflect.deleteProperty(Xe, "setRequestHeaders");
      Reflect.deleteProperty(Xe, "getRequestState");
      Reflect.deleteProperty(Xe, "setRequestState");
      SV(Xe, x0);
      function jc(t2) {
        return { method: t2.method ?? "GET", localURLsOnly: t2.localURLsOnly ?? false, unsafeRequest: t2.unsafeRequest ?? false, body: t2.body ?? null, client: t2.client ?? null, reservedClient: t2.reservedClient ?? null, replacesClientId: t2.replacesClientId ?? "", window: t2.window ?? "client", keepalive: t2.keepalive ?? false, serviceWorkers: t2.serviceWorkers ?? "all", initiator: t2.initiator ?? "", destination: t2.destination ?? "", priority: t2.priority ?? null, origin: t2.origin ?? "client", policyContainer: t2.policyContainer ?? "client", referrer: t2.referrer ?? "client", referrerPolicy: t2.referrerPolicy ?? "", mode: t2.mode ?? "no-cors", useCORSPreflightFlag: t2.useCORSPreflightFlag ?? false, credentials: t2.credentials ?? "same-origin", useCredentials: t2.useCredentials ?? false, cache: t2.cache ?? "default", redirect: t2.redirect ?? "follow", integrity: t2.integrity ?? "", cryptoGraphicsNonceMetadata: t2.cryptoGraphicsNonceMetadata ?? "", parserMetadata: t2.parserMetadata ?? "", reloadNavigation: t2.reloadNavigation ?? false, historyNavigation: t2.historyNavigation ?? false, userActivation: t2.userActivation ?? false, taintedOrigin: t2.taintedOrigin ?? false, redirectCount: t2.redirectCount ?? 0, responseTainting: t2.responseTainting ?? "basic", preventNoCacheCacheControlHeaderModification: t2.preventNoCacheCacheControlHeaderModification ?? false, done: t2.done ?? false, timingAllowFailed: t2.timingAllowFailed ?? false, urlList: t2.urlList, url: t2.urlList[0], headersList: t2.headersList ? new Jc(t2.headersList) : new Jc() };
      }
      __name(jc, "jc");
      function U0(t2) {
        let e = jc({ ...t2, body: null });
        return t2.body != null && (e.body = bV(e, t2.body)), e;
      }
      __name(U0, "U0");
      function k0(t2, e, r2, n2) {
        let A2 = new Xe(Wc);
        $V(A2, t2), XV(A2, e), jV(A2, r2);
        let i2 = new b0(Wc);
        return KV(A2, i2), N0(i2, t2.headersList), sh(i2, n2), A2;
      }
      __name(k0, "k0");
      Object.defineProperties(Xe.prototype, { method: Ie, url: Ie, headers: Ie, redirect: Ie, clone: Ie, signal: Ie, duplex: Ie, destination: Ie, body: Ie, bodyUsed: Ie, isHistoryNavigation: Ie, isReloadNavigation: Ie, keepalive: Ie, integrity: Ie, cache: Ie, credentials: Ie, attribute: Ie, referrerPolicy: Ie, referrer: Ie, mode: Ie, [Symbol.toStringTag]: { value: "Request", configurable: true } });
      F2.is.Request = F2.util.MakeTypeAssertion(Xe);
      F2.converters.RequestInfo = function(t2, e, r2) {
        return typeof t2 == "string" ? F2.converters.USVString(t2) : F2.is.Request(t2) ? t2 : F2.converters.USVString(t2);
      };
      F2.converters.RequestInit = F2.dictionaryConverter([{ key: "method", converter: F2.converters.ByteString }, { key: "headers", converter: F2.converters.HeadersInit }, { key: "body", converter: F2.nullableConverter(F2.converters.BodyInit) }, { key: "referrer", converter: F2.converters.USVString }, { key: "referrerPolicy", converter: F2.converters.DOMString, allowedValues: MV }, { key: "mode", converter: F2.converters.DOMString, allowedValues: vV }, { key: "credentials", converter: F2.converters.DOMString, allowedValues: PV }, { key: "cache", converter: F2.converters.DOMString, allowedValues: YV }, { key: "redirect", converter: F2.converters.DOMString, allowedValues: LV }, { key: "integrity", converter: F2.converters.DOMString }, { key: "keepalive", converter: F2.converters.boolean }, { key: "signal", converter: F2.nullableConverter((t2) => F2.converters.AbortSignal(t2, "RequestInit", "signal")) }, { key: "window", converter: F2.converters.any }, { key: "duplex", converter: F2.converters.DOMString, allowedValues: GV }, { key: "dispatcher", converter: F2.converters.any }]);
      M0.exports = { Request: Xe, makeRequest: jc, fromInnerRequest: k0, cloneRequest: U0, getRequestDispatcher: ZV, getRequestState: x0 };
    });
    var Ms = C2((_$, Z0) => {
      "use strict";
      var { makeNetworkError: $, makeAppropriateNetworkError: Zc, filterResponse: ah, makeResponse: Xc, fromInnerResponse: zV, getResponseState: eH } = Us(), { HeadersList: L0 } = Tn(), { Request: tH, cloneRequest: rH, getRequestDispatcher: nH, getRequestState: AH } = XA(), $r = __require("node:zlib"), { bytesMatch: iH, makePolicyContainer: sH, clonePolicyContainer: oH, requestBadPort: aH, TAOCheck: cH, appendRequestOriginHeader: lH, responseLocationURL: uH, requestCurrentURL: $t, setRequestReferrerPolicyOnRedirect: gH, tryUpgradeRequestToAPotentiallyTrustworthyURL: EH, createOpaqueTimingInfo: Eh, appendFetchMetadata: dH, corsCheck: hH, crossOriginResourcePolicyCheck: fH, determineRequestsReferrer: QH, coarsenedSharedCurrentTime: ks, createDeferredPromise: CH, sameOrigin: gh, isCancelled: Un, isAborted: v0, isErrorLike: IH, fullyReadBody: pH, readableStreamClose: BH, isomorphicEncode: Kc, urlIsLocal: mH, urlIsHttpHttpsScheme: dh, urlHasHttpsScheme: yH, clampAndCoarsenConnectionTimingInfo: wH, simpleRangeHeaderValue: DH, buildContentRange: RH, createInflate: SH, extractMimeType: bH } = Ve(), kn = __require("node:assert"), { safelyExtractBody: hh, extractBody: P0 } = FA(), { redirectStatusSet: O0, nullBodyStatus: V0, safeMethodsSet: NH, requestBodyHeader: FH, subresourceSet: TH } = ts(), xH = __require("node:events"), { Readable: UH, pipeline: kH, finished: MH, isErrored: LH, isReadable: $c } = __require("node:stream"), { addAbortListener: vH, bufferToLowerCasedHeaderName: Y0 } = Y2(), { dataURLProcessor: PH, serializeAMimeType: YH, minimizeSupportedMimeType: GH } = tt(), { getGlobalDispatcher: OH } = kc(), { webidl: fh } = Te(), { STATUS_CODES: VH } = __require("node:http"), HH = ["GET", "HEAD"], qH = typeof __UNDICI_IS_NODE__ < "u" || typeof esbuildDetection < "u" ? "node" : "undici", ch, zc = class extends xH {
        static {
          __name(this, "zc");
        }
        constructor(e) {
          super(), this.dispatcher = e, this.connection = null, this.dump = false, this.state = "ongoing";
        }
        terminate(e) {
          this.state === "ongoing" && (this.state = "terminated", this.connection?.destroy(e), this.emit("terminated", e));
        }
        abort(e) {
          this.state === "ongoing" && (this.state = "aborted", e || (e = new DOMException("The operation was aborted.", "AbortError")), this.serializedAbortReason = e, this.connection?.destroy(e), this.emit("terminated", e));
        }
      };
      function JH(t2) {
        H0(t2, "fetch");
      }
      __name(JH, "JH");
      function WH(t2, e = void 0) {
        fh.argumentLengthCheck(arguments, 1, "globalThis.fetch");
        let r2 = CH(), n2;
        try {
          n2 = new tH(t2, e);
        } catch (l2) {
          return r2.reject(l2), r2.promise;
        }
        let A2 = AH(n2);
        if (n2.signal.aborted) return lh(r2, A2, null, n2.signal.reason), r2.promise;
        A2.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope" && (A2.serviceWorkers = "none");
        let s = null, o2 = false, a2 = null;
        return vH(n2.signal, () => {
          o2 = true, kn(a2 != null), a2.abort(n2.signal.reason);
          let l2 = s?.deref();
          lh(r2, A2, l2, n2.signal.reason);
        }), a2 = J0({ request: A2, processResponseEndOfBody: JH, processResponse: /* @__PURE__ */ __name((l2) => {
          if (!o2) {
            if (l2.aborted) {
              lh(r2, A2, s, a2.serializedAbortReason);
              return;
            }
            if (l2.type === "error") {
              r2.reject(new TypeError("fetch failed", { cause: l2.error }));
              return;
            }
            s = new WeakRef(zV(l2, "immutable")), r2.resolve(s.deref()), r2 = null;
          }
        }, "processResponse"), dispatcher: nH(n2) }), r2.promise;
      }
      __name(WH, "WH");
      function H0(t2, e = "other") {
        if (t2.type === "error" && t2.aborted || !t2.urlList?.length) return;
        let r2 = t2.urlList[0], n2 = t2.timingInfo, A2 = t2.cacheState;
        dh(r2) && n2 !== null && (t2.timingAllowPassed || (n2 = Eh({ startTime: n2.startTime }), A2 = ""), n2.endTime = ks(), t2.timingInfo = n2, q0(n2, r2.href, e, globalThis, A2));
      }
      __name(H0, "H0");
      var q0 = performance.markResourceTiming;
      function lh(t2, e, r2, n2) {
        if (t2 && t2.reject(n2), e.body?.stream != null && $c(e.body.stream) && e.body.stream.cancel(n2).catch((i2) => {
          if (i2.code !== "ERR_INVALID_STATE") throw i2;
        }), r2 == null) return;
        let A2 = eH(r2);
        A2.body?.stream != null && $c(A2.body.stream) && A2.body.stream.cancel(n2).catch((i2) => {
          if (i2.code !== "ERR_INVALID_STATE") throw i2;
        });
      }
      __name(lh, "lh");
      function J0({ request: t2, processRequestBodyChunkLength: e, processRequestEndOfBody: r2, processResponse: n2, processResponseEndOfBody: A2, processResponseConsumeBody: i2, useParallelQueue: s = false, dispatcher: o2 = OH() }) {
        kn(o2);
        let a2 = null, c2 = false;
        t2.client != null && (a2 = t2.client.globalObject, c2 = t2.client.crossOriginIsolatedCapability);
        let l2 = ks(c2), u2 = Eh({ startTime: l2 }), g = { controller: new zc(o2), request: t2, timingInfo: u2, processRequestBodyChunkLength: e, processRequestEndOfBody: r2, processResponse: n2, processResponseConsumeBody: i2, processResponseEndOfBody: A2, taskDestination: a2, crossOriginIsolatedCapability: c2 };
        return kn(!t2.body || t2.body.stream), t2.window === "client" && (t2.window = t2.client?.globalObject?.constructor?.name === "Window" ? t2.client : "no-window"), t2.origin === "client" && (t2.origin = t2.client.origin), t2.policyContainer === "client" && (t2.client != null ? t2.policyContainer = oH(t2.client.policyContainer) : t2.policyContainer = sH()), t2.headersList.contains("accept", true) || t2.headersList.append("accept", "*/*", true), t2.headersList.contains("accept-language", true) || t2.headersList.append("accept-language", "*", true), t2.priority, TH.has(t2.destination), W0(g).catch((E) => {
          g.controller.terminate(E);
        }), g.controller;
      }
      __name(J0, "J0");
      async function W0(t2, e = false) {
        let r2 = t2.request, n2 = null;
        if (r2.localURLsOnly && !mH($t(r2)) && (n2 = $("local URLs only")), EH(r2), aH(r2) === "blocked" && (n2 = $("bad port")), r2.referrerPolicy === "" && (r2.referrerPolicy = r2.policyContainer.referrerPolicy), r2.referrer !== "no-referrer" && (r2.referrer = QH(r2)), n2 === null) {
          let i2 = $t(r2);
          gh(i2, r2.url) && r2.responseTainting === "basic" || i2.protocol === "data:" || r2.mode === "navigate" || r2.mode === "websocket" ? (r2.responseTainting = "basic", n2 = await G0(t2)) : r2.mode === "same-origin" ? n2 = $('request mode cannot be "same-origin"') : r2.mode === "no-cors" ? r2.redirect !== "follow" ? n2 = $('redirect mode cannot be "follow" for "no-cors" request') : (r2.responseTainting = "opaque", n2 = await G0(t2)) : dh($t(r2)) ? (r2.responseTainting = "cors", n2 = await _0(t2)) : n2 = $("URL scheme must be a HTTP(S) scheme");
        }
        if (e) return n2;
        n2.status !== 0 && !n2.internalResponse && (r2.responseTainting, r2.responseTainting === "basic" ? n2 = ah(n2, "basic") : r2.responseTainting === "cors" ? n2 = ah(n2, "cors") : r2.responseTainting === "opaque" ? n2 = ah(n2, "opaque") : kn(false));
        let A2 = n2.status === 0 ? n2 : n2.internalResponse;
        if (A2.urlList.length === 0 && A2.urlList.push(...r2.urlList), r2.timingAllowFailed || (n2.timingAllowPassed = true), n2.type === "opaque" && A2.status === 206 && A2.rangeRequested && !r2.headers.contains("range", true) && (n2 = A2 = $()), n2.status !== 0 && (r2.method === "HEAD" || r2.method === "CONNECT" || V0.includes(A2.status)) && (A2.body = null, t2.controller.dump = true), r2.integrity) {
          let i2 = /* @__PURE__ */ __name((o2) => uh(t2, $(o2)), "i");
          if (r2.responseTainting === "opaque" || n2.body == null) {
            i2(n2.error);
            return;
          }
          let s = /* @__PURE__ */ __name((o2) => {
            if (!iH(o2, r2.integrity)) {
              i2("integrity mismatch");
              return;
            }
            n2.body = hh(o2)[0], uh(t2, n2);
          }, "s");
          await pH(n2.body, s, i2);
        } else uh(t2, n2);
      }
      __name(W0, "W0");
      function G0(t2) {
        if (Un(t2) && t2.request.redirectCount === 0) return Promise.resolve(Zc(t2));
        let { request: e } = t2, { protocol: r2 } = $t(e);
        switch (r2) {
          case "about:":
            return Promise.resolve($("about scheme is not supported"));
          case "blob:": {
            ch || (ch = __require("node:buffer").resolveObjectURL);
            let n2 = $t(e);
            if (n2.search.length !== 0) return Promise.resolve($("NetworkError when attempting to fetch resource."));
            let A2 = ch(n2.toString());
            if (e.method !== "GET" || !fh.is.Blob(A2)) return Promise.resolve($("invalid method"));
            let i2 = Xc(), s = A2.size, o2 = Kc(`${s}`), a2 = A2.type;
            if (e.headersList.contains("range", true)) {
              i2.rangeRequested = true;
              let c2 = e.headersList.get("range", true), l2 = DH(c2, true);
              if (l2 === "failure") return Promise.resolve($("failed to fetch the data URL"));
              let { rangeStartValue: u2, rangeEndValue: g } = l2;
              if (u2 === null) u2 = s - g, g = u2 + g - 1;
              else {
                if (u2 >= s) return Promise.resolve($("Range start is greater than the blob's size."));
                (g === null || g >= s) && (g = s - 1);
              }
              let E = A2.slice(u2, g, a2), h = P0(E);
              i2.body = h[0];
              let f2 = Kc(`${E.size}`), p2 = RH(u2, g, s);
              i2.status = 206, i2.statusText = "Partial Content", i2.headersList.set("content-length", f2, true), i2.headersList.set("content-type", a2, true), i2.headersList.set("content-range", p2, true);
            } else {
              let c2 = P0(A2);
              i2.statusText = "OK", i2.body = c2[0], i2.headersList.set("content-length", o2, true), i2.headersList.set("content-type", a2, true);
            }
            return Promise.resolve(i2);
          }
          case "data:": {
            let n2 = $t(e), A2 = PH(n2);
            if (A2 === "failure") return Promise.resolve($("failed to fetch the data URL"));
            let i2 = YH(A2.mimeType);
            return Promise.resolve(Xc({ statusText: "OK", headersList: [["content-type", { name: "Content-Type", value: i2 }]], body: hh(A2.body)[0] }));
          }
          case "file:":
            return Promise.resolve($("not implemented... yet..."));
          case "http:":
          case "https:":
            return _0(t2).catch((n2) => $(n2));
          default:
            return Promise.resolve($("unknown scheme"));
        }
      }
      __name(G0, "G0");
      function _H(t2, e) {
        t2.request.done = true, t2.processResponseDone != null && queueMicrotask(() => t2.processResponseDone(e));
      }
      __name(_H, "_H");
      function uh(t2, e) {
        let r2 = t2.timingInfo, n2 = /* @__PURE__ */ __name(() => {
          let i2 = Date.now();
          t2.request.destination === "document" && (t2.controller.fullTimingInfo = r2), t2.controller.reportTimingSteps = () => {
            if (t2.request.url.protocol !== "https:") return;
            r2.endTime = i2;
            let o2 = e.cacheState, a2 = e.bodyInfo;
            e.timingAllowPassed || (r2 = Eh(r2), o2 = "");
            let c2 = 0;
            if (t2.request.mode !== "navigator" || !e.hasCrossOriginRedirects) {
              c2 = e.status;
              let l2 = bH(e.headersList);
              l2 !== "failure" && (a2.contentType = GH(l2));
            }
            t2.request.initiatorType != null && q0(r2, t2.request.url.href, t2.request.initiatorType, globalThis, o2, a2, c2);
          };
          let s = /* @__PURE__ */ __name(() => {
            t2.request.done = true, t2.processResponseEndOfBody != null && queueMicrotask(() => t2.processResponseEndOfBody(e)), t2.request.initiatorType != null && t2.controller.reportTimingSteps();
          }, "s");
          queueMicrotask(() => s());
        }, "n");
        t2.processResponse != null && queueMicrotask(() => {
          t2.processResponse(e), t2.processResponse = null;
        });
        let A2 = e.type === "error" ? e : e.internalResponse ?? e;
        A2.body == null ? n2() : MH(A2.body.stream, () => {
          n2();
        });
      }
      __name(uh, "uh");
      async function _0(t2) {
        let e = t2.request, r2 = null, n2 = null, A2 = t2.timingInfo;
        if (e.serviceWorkers, r2 === null) {
          if (e.redirect === "follow" && (e.serviceWorkers = "none"), n2 = r2 = await j0(t2), e.responseTainting === "cors" && hH(e, r2) === "failure") return $("cors failure");
          cH(e, r2) === "failure" && (e.timingAllowFailed = true);
        }
        return (e.responseTainting === "opaque" || r2.type === "opaque") && fH(e.origin, e.client, e.destination, n2) === "blocked" ? $("blocked") : (O0.has(n2.status) && (e.redirect !== "manual" && t2.controller.connection.destroy(void 0, false), e.redirect === "error" ? r2 = $("unexpected redirect") : e.redirect === "manual" ? r2 = n2 : e.redirect === "follow" ? r2 = await jH(t2, r2) : kn(false)), r2.timingInfo = A2, r2);
      }
      __name(_0, "_0");
      function jH(t2, e) {
        let r2 = t2.request, n2 = e.internalResponse ? e.internalResponse : e, A2;
        try {
          if (A2 = uH(n2, $t(r2).hash), A2 == null) return e;
        } catch (s) {
          return Promise.resolve($(s));
        }
        if (!dh(A2)) return Promise.resolve($("URL scheme must be a HTTP(S) scheme"));
        if (r2.redirectCount === 20) return Promise.resolve($("redirect count exceeded"));
        if (r2.redirectCount += 1, r2.mode === "cors" && (A2.username || A2.password) && !gh(r2, A2)) return Promise.resolve($('cross origin not allowed for request mode "cors"'));
        if (r2.responseTainting === "cors" && (A2.username || A2.password)) return Promise.resolve($('URL cannot contain credentials for request mode "cors"'));
        if (n2.status !== 303 && r2.body != null && r2.body.source == null) return Promise.resolve($());
        if ([301, 302].includes(n2.status) && r2.method === "POST" || n2.status === 303 && !HH.includes(r2.method)) {
          r2.method = "GET", r2.body = null;
          for (let s of FH) r2.headersList.delete(s);
        }
        gh($t(r2), A2) || (r2.headersList.delete("authorization", true), r2.headersList.delete("proxy-authorization", true), r2.headersList.delete("cookie", true), r2.headersList.delete("host", true)), r2.body != null && (kn(r2.body.source != null), r2.body = hh(r2.body.source)[0]);
        let i2 = t2.timingInfo;
        return i2.redirectEndTime = i2.postRedirectStartTime = ks(t2.crossOriginIsolatedCapability), i2.redirectStartTime === 0 && (i2.redirectStartTime = i2.startTime), r2.urlList.push(A2), gH(r2, n2), W0(t2, true);
      }
      __name(jH, "jH");
      async function j0(t2, e = false, r2 = false) {
        let n2 = t2.request, A2 = null, i2 = null, s = null, o2 = null, a2 = false;
        n2.window === "no-window" && n2.redirect === "error" ? (A2 = t2, i2 = n2) : (i2 = rH(n2), A2 = { ...t2 }, A2.request = i2);
        let c2 = n2.credentials === "include" || n2.credentials === "same-origin" && n2.responseTainting === "basic", l2 = i2.body ? i2.body.length : null, u2 = null;
        if (i2.body == null && ["POST", "PUT"].includes(i2.method) && (u2 = "0"), l2 != null && (u2 = Kc(`${l2}`)), u2 != null && i2.headersList.append("content-length", u2, true), l2 != null && i2.keepalive, fh.is.URL(i2.referrer) && i2.headersList.append("referer", Kc(i2.referrer.href), true), lH(i2), dH(i2), i2.headersList.contains("user-agent", true) || i2.headersList.append("user-agent", qH, true), i2.cache === "default" && (i2.headersList.contains("if-modified-since", true) || i2.headersList.contains("if-none-match", true) || i2.headersList.contains("if-unmodified-since", true) || i2.headersList.contains("if-match", true) || i2.headersList.contains("if-range", true)) && (i2.cache = "no-store"), i2.cache === "no-cache" && !i2.preventNoCacheCacheControlHeaderModification && !i2.headersList.contains("cache-control", true) && i2.headersList.append("cache-control", "max-age=0", true), (i2.cache === "no-store" || i2.cache === "reload") && (i2.headersList.contains("pragma", true) || i2.headersList.append("pragma", "no-cache", true), i2.headersList.contains("cache-control", true) || i2.headersList.append("cache-control", "no-cache", true)), i2.headersList.contains("range", true) && i2.headersList.append("accept-encoding", "identity", true), i2.headersList.contains("accept-encoding", true) || (yH($t(i2)) ? i2.headersList.append("accept-encoding", "br, gzip, deflate", true) : i2.headersList.append("accept-encoding", "gzip, deflate", true)), i2.headersList.delete("host", true), o2 == null && (i2.cache = "no-store"), i2.cache !== "no-store" && i2.cache, s == null) {
          if (i2.cache === "only-if-cached") return $("only if cached");
          let g = await ZH(A2, c2, r2);
          !NH.has(i2.method) && g.status >= 200 && g.status <= 399, a2 && g.status, s == null && (s = g);
        }
        if (s.urlList = [...i2.urlList], i2.headersList.contains("range", true) && (s.rangeRequested = true), s.requestIncludesCredentials = c2, s.status === 407) return n2.window === "no-window" ? $() : Un(t2) ? Zc(t2) : $("proxy authentication required");
        if (s.status === 421 && !r2 && (n2.body == null || n2.body.source != null)) {
          if (Un(t2)) return Zc(t2);
          t2.controller.connection.destroy(), s = await j0(t2, e, true);
        }
        return s;
      }
      __name(j0, "j0");
      async function ZH(t2, e = false, r2 = false) {
        kn(!t2.controller.connection || t2.controller.connection.destroyed), t2.controller.connection = { abort: null, destroyed: false, destroy(h, f2 = true) {
          this.destroyed || (this.destroyed = true, f2 && this.abort?.(h ?? new DOMException("The operation was aborted.", "AbortError")));
        } };
        let n2 = t2.request, A2 = null, i2 = t2.timingInfo;
        n2.cache = "no-store";
        let o2 = r2 ? "yes" : "no";
        n2.mode;
        let a2 = null;
        if (n2.body == null && t2.processRequestEndOfBody) queueMicrotask(() => t2.processRequestEndOfBody());
        else if (n2.body != null) {
          let h = /* @__PURE__ */ __name(async function* (Q) {
            Un(t2) || (yield Q, t2.processRequestBodyChunkLength?.(Q.byteLength));
          }, "h"), f2 = /* @__PURE__ */ __name(() => {
            Un(t2) || t2.processRequestEndOfBody && t2.processRequestEndOfBody();
          }, "f"), p2 = /* @__PURE__ */ __name((Q) => {
            Un(t2) || (Q.name === "AbortError" ? t2.controller.abort() : t2.controller.terminate(Q));
          }, "p");
          a2 = async function* () {
            try {
              for await (let Q of n2.body.stream) yield* h(Q);
              f2();
            } catch (Q) {
              p2(Q);
            }
          }();
        }
        try {
          let { body: h, status: f2, statusText: p2, headersList: Q, socket: I2 } = await E({ body: a2 });
          if (I2) A2 = Xc({ status: f2, statusText: p2, headersList: Q, socket: I2 });
          else {
            let B = h[Symbol.asyncIterator]();
            t2.controller.next = () => B.next(), A2 = Xc({ status: f2, statusText: p2, headersList: Q });
          }
        } catch (h) {
          return h.name === "AbortError" ? (t2.controller.connection.destroy(), Zc(t2, h)) : $(h);
        }
        let c2 = /* @__PURE__ */ __name(() => t2.controller.resume(), "c"), l2 = /* @__PURE__ */ __name((h) => {
          Un(t2) || t2.controller.abort(h);
        }, "l"), u2 = new ReadableStream({ async start(h) {
          t2.controller.controller = h;
        }, async pull(h) {
          await c2(h);
        }, async cancel(h) {
          await l2(h);
        }, type: "bytes" });
        A2.body = { stream: u2, source: null, length: null }, t2.controller.resume || t2.controller.on("terminated", g), t2.controller.resume = async () => {
          for (; ; ) {
            let h, f2;
            try {
              let { done: Q, value: I2 } = await t2.controller.next();
              if (v0(t2)) break;
              h = Q ? void 0 : I2;
            } catch (Q) {
              t2.controller.ended && !i2.encodedBodySize ? h = void 0 : (h = Q, f2 = true);
            }
            if (h === void 0) {
              BH(t2.controller.controller), _H(t2, A2);
              return;
            }
            if (i2.decodedBodySize += h?.byteLength ?? 0, f2) {
              t2.controller.terminate(h);
              return;
            }
            let p2 = new Uint8Array(h);
            if (p2.byteLength && t2.controller.controller.enqueue(p2), LH(u2)) {
              t2.controller.terminate();
              return;
            }
            if (t2.controller.controller.desiredSize <= 0) return;
          }
        };
        function g(h) {
          v0(t2) ? (A2.aborted = true, $c(u2) && t2.controller.controller.error(t2.controller.serializedAbortReason)) : $c(u2) && t2.controller.controller.error(new TypeError("terminated", { cause: IH(h) ? h : void 0 })), t2.controller.connection.destroy();
        }
        __name(g, "g");
        return A2;
        function E({ body: h }) {
          let f2 = $t(n2), p2 = t2.controller.dispatcher;
          return new Promise((Q, I2) => p2.dispatch({ path: f2.pathname + f2.search, origin: f2.origin, method: n2.method, body: p2.isMockActive ? n2.body && (n2.body.source || n2.body.stream) : h, headers: n2.headersList.entries, maxRedirections: 0, upgrade: n2.mode === "websocket" ? "websocket" : void 0 }, { body: null, abort: null, onConnect(B) {
            let { connection: w } = t2.controller;
            i2.finalConnectionTimingInfo = wH(void 0, i2.postRedirectStartTime, t2.crossOriginIsolatedCapability), w.destroyed ? B(new DOMException("The operation was aborted.", "AbortError")) : (t2.controller.on("terminated", B), this.abort = w.abort = B), i2.finalNetworkRequestStartTime = ks(t2.crossOriginIsolatedCapability);
          }, onResponseStarted() {
            i2.finalNetworkResponseStartTime = ks(t2.crossOriginIsolatedCapability);
          }, onHeaders(B, w, D2, v2) {
            if (B < 200) return;
            let K2 = [], W2 = "", ae = new L0();
            for (let Se = 0; Se < w.length; Se += 2) ae.append(Y0(w[Se]), w[Se + 1].toString("latin1"), true);
            let xe = ae.get("content-encoding", true);
            xe && (K2 = xe.toLowerCase().split(",").map((Se) => Se.trim())), W2 = ae.get("location", true), this.body = new UH({ read: D2 });
            let te = [], Rr = W2 && n2.redirect === "follow" && O0.has(B);
            if (K2.length !== 0 && n2.method !== "HEAD" && n2.method !== "CONNECT" && !V0.includes(B) && !Rr) for (let Se = K2.length - 1; Se >= 0; --Se) {
              let he = K2[Se];
              if (he === "x-gzip" || he === "gzip") te.push($r.createGunzip({ flush: $r.constants.Z_SYNC_FLUSH, finishFlush: $r.constants.Z_SYNC_FLUSH }));
              else if (he === "deflate") te.push(SH({ flush: $r.constants.Z_SYNC_FLUSH, finishFlush: $r.constants.Z_SYNC_FLUSH }));
              else if (he === "br") te.push($r.createBrotliDecompress({ flush: $r.constants.BROTLI_OPERATION_FLUSH, finishFlush: $r.constants.BROTLI_OPERATION_FLUSH }));
              else {
                te.length = 0;
                break;
              }
            }
            let rn = this.onError.bind(this);
            return Q({ status: B, statusText: v2, headersList: ae, body: te.length ? kH(this.body, ...te, (Se) => {
              Se && this.onError(Se);
            }).on("error", rn) : this.body.on("error", rn) }), true;
          }, onData(B) {
            if (t2.controller.dump) return;
            let w = B;
            return i2.encodedBodySize += w.byteLength, this.body.push(w);
          }, onComplete() {
            this.abort && t2.controller.off("terminated", this.abort), t2.controller.ended = true, this.body.push(null);
          }, onError(B) {
            this.abort && t2.controller.off("terminated", this.abort), this.body?.destroy(B), t2.controller.terminate(B), I2(B);
          }, onUpgrade(B, w, D2) {
            if (B !== 101) return;
            let v2 = new L0();
            for (let K2 = 0; K2 < w.length; K2 += 2) v2.append(Y0(w[K2]), w[K2 + 1].toString("latin1"), true);
            return Q({ status: B, statusText: VH[B], headersList: v2, socket: D2 }), true;
          } }));
        }
        __name(E, "E");
      }
      __name(ZH, "ZH");
      Z0.exports = { fetch: WH, Fetch: zc, fetching: J0, finalizeAndReportTiming: H0 };
    });
    var $0 = C2((j$, K0) => {
      "use strict";
      var XH = __require("node:assert"), { URLSerializer: X0 } = tt(), { isValidHeaderName: KH } = Ve();
      function $H(t2, e, r2 = false) {
        let n2 = X0(t2, r2), A2 = X0(e, r2);
        return n2 === A2;
      }
      __name($H, "$H");
      function zH(t2) {
        XH(t2 !== null);
        let e = [];
        for (let r2 of t2.split(",")) r2 = r2.trim(), KH(r2) && e.push(r2);
        return e;
      }
      __name(zH, "zH");
      K0.exports = { urlEquals: $H, getFieldValues: zH };
    });
    var tR = C2((Z$, eR) => {
      "use strict";
      var { kConstruct: eq } = ne(), { urlEquals: tq, getFieldValues: Qh } = $0(), { kEnumerableProperty: Mn, isDisturbed: rq } = Y2(), { webidl: R2 } = Te(), { cloneResponse: nq, fromInnerResponse: Aq, getResponseState: iq } = Us(), { Request: Ls, fromInnerRequest: sq, getRequestState: zt } = XA(), { fetching: oq } = Ms(), { urlIsHttpHttpsScheme: el, createDeferredPromise: KA, readAllBytes: aq } = Ve(), Ch = __require("node:assert"), tl = class t2 {
        static {
          __name(this, "t");
        }
        #e;
        constructor() {
          arguments[0] !== eq && R2.illegalConstructor(), R2.util.markAsUncloneable(this), this.#e = arguments[1];
        }
        async match(e, r2 = {}) {
          R2.brandCheck(this, t2);
          let n2 = "Cache.match";
          R2.argumentLengthCheck(arguments, 1, n2), e = R2.converters.RequestInfo(e, n2, "request"), r2 = R2.converters.CacheQueryOptions(r2, n2, "options");
          let A2 = this.#i(e, r2, 1);
          if (A2.length !== 0) return A2[0];
        }
        async matchAll(e = void 0, r2 = {}) {
          R2.brandCheck(this, t2);
          let n2 = "Cache.matchAll";
          return e !== void 0 && (e = R2.converters.RequestInfo(e, n2, "request")), r2 = R2.converters.CacheQueryOptions(r2, n2, "options"), this.#i(e, r2);
        }
        async add(e) {
          R2.brandCheck(this, t2);
          let r2 = "Cache.add";
          R2.argumentLengthCheck(arguments, 1, r2), e = R2.converters.RequestInfo(e, r2, "request");
          let n2 = [e];
          return await this.addAll(n2);
        }
        async addAll(e) {
          R2.brandCheck(this, t2);
          let r2 = "Cache.addAll";
          R2.argumentLengthCheck(arguments, 1, r2);
          let n2 = [], A2 = [];
          for (let g of e) {
            if (g === void 0) throw R2.errors.conversionFailed({ prefix: r2, argument: "Argument 1", types: ["undefined is not allowed"] });
            if (g = R2.converters.RequestInfo(g), typeof g == "string") continue;
            let E = zt(g);
            if (!el(E.url) || E.method !== "GET") throw R2.errors.exception({ header: r2, message: "Expected http/s scheme when method is not GET." });
          }
          let i2 = [];
          for (let g of e) {
            let E = zt(new Ls(g));
            if (!el(E.url)) throw R2.errors.exception({ header: r2, message: "Expected http/s scheme." });
            E.initiator = "fetch", E.destination = "subresource", A2.push(E);
            let h = KA();
            i2.push(oq({ request: E, processResponse(f2) {
              if (f2.type === "error" || f2.status === 206 || f2.status < 200 || f2.status > 299) h.reject(R2.errors.exception({ header: "Cache.addAll", message: "Received an invalid status code or the request failed." }));
              else if (f2.headersList.contains("vary")) {
                let p2 = Qh(f2.headersList.get("vary"));
                for (let Q of p2) if (Q === "*") {
                  h.reject(R2.errors.exception({ header: "Cache.addAll", message: "invalid vary field value" }));
                  for (let I2 of i2) I2.abort();
                  return;
                }
              }
            }, processResponseEndOfBody(f2) {
              if (f2.aborted) {
                h.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              h.resolve(f2);
            } })), n2.push(h.promise);
          }
          let o2 = await Promise.all(n2), a2 = [], c2 = 0;
          for (let g of o2) {
            let E = { type: "put", request: A2[c2], response: g };
            a2.push(E), c2++;
          }
          let l2 = KA(), u2 = null;
          try {
            this.#t(a2);
          } catch (g) {
            u2 = g;
          }
          return queueMicrotask(() => {
            u2 === null ? l2.resolve(void 0) : l2.reject(u2);
          }), l2.promise;
        }
        async put(e, r2) {
          R2.brandCheck(this, t2);
          let n2 = "Cache.put";
          R2.argumentLengthCheck(arguments, 2, n2), e = R2.converters.RequestInfo(e, n2, "request"), r2 = R2.converters.Response(r2, n2, "response");
          let A2 = null;
          if (R2.is.Request(e) ? A2 = zt(e) : A2 = zt(new Ls(e)), !el(A2.url) || A2.method !== "GET") throw R2.errors.exception({ header: n2, message: "Expected an http/s scheme when method is not GET" });
          let i2 = iq(r2);
          if (i2.status === 206) throw R2.errors.exception({ header: n2, message: "Got 206 status" });
          if (i2.headersList.contains("vary")) {
            let E = Qh(i2.headersList.get("vary"));
            for (let h of E) if (h === "*") throw R2.errors.exception({ header: n2, message: "Got * vary field value" });
          }
          if (i2.body && (rq(i2.body.stream) || i2.body.stream.locked)) throw R2.errors.exception({ header: n2, message: "Response body is locked or disturbed" });
          let s = nq(i2), o2 = KA();
          if (i2.body != null) {
            let h = i2.body.stream.getReader();
            aq(h, o2.resolve, o2.reject);
          } else o2.resolve(void 0);
          let a2 = [], c2 = { type: "put", request: A2, response: s };
          a2.push(c2);
          let l2 = await o2.promise;
          s.body != null && (s.body.source = l2);
          let u2 = KA(), g = null;
          try {
            this.#t(a2);
          } catch (E) {
            g = E;
          }
          return queueMicrotask(() => {
            g === null ? u2.resolve() : u2.reject(g);
          }), u2.promise;
        }
        async delete(e, r2 = {}) {
          R2.brandCheck(this, t2);
          let n2 = "Cache.delete";
          R2.argumentLengthCheck(arguments, 1, n2), e = R2.converters.RequestInfo(e, n2, "request"), r2 = R2.converters.CacheQueryOptions(r2, n2, "options");
          let A2 = null;
          if (R2.is.Request(e)) {
            if (A2 = zt(e), A2.method !== "GET" && !r2.ignoreMethod) return false;
          } else Ch(typeof e == "string"), A2 = zt(new Ls(e));
          let i2 = [], s = { type: "delete", request: A2, options: r2 };
          i2.push(s);
          let o2 = KA(), a2 = null, c2;
          try {
            c2 = this.#t(i2);
          } catch (l2) {
            a2 = l2;
          }
          return queueMicrotask(() => {
            a2 === null ? o2.resolve(!!c2?.length) : o2.reject(a2);
          }), o2.promise;
        }
        async keys(e = void 0, r2 = {}) {
          R2.brandCheck(this, t2);
          let n2 = "Cache.keys";
          e !== void 0 && (e = R2.converters.RequestInfo(e, n2, "request")), r2 = R2.converters.CacheQueryOptions(r2, n2, "options");
          let A2 = null;
          if (e !== void 0) if (R2.is.Request(e)) {
            if (A2 = zt(e), A2.method !== "GET" && !r2.ignoreMethod) return [];
          } else typeof e == "string" && (A2 = zt(new Ls(e)));
          let i2 = KA(), s = [];
          if (e === void 0) for (let o2 of this.#e) s.push(o2[0]);
          else {
            let o2 = this.#r(A2, r2);
            for (let a2 of o2) s.push(a2[0]);
          }
          return queueMicrotask(() => {
            let o2 = [];
            for (let a2 of s) {
              let c2 = sq(a2, void 0, new AbortController().signal, "immutable");
              o2.push(c2);
            }
            i2.resolve(Object.freeze(o2));
          }), i2.promise;
        }
        #t(e) {
          let r2 = this.#e, n2 = [...r2], A2 = [], i2 = [];
          try {
            for (let s of e) {
              if (s.type !== "delete" && s.type !== "put") throw R2.errors.exception({ header: "Cache.#batchCacheOperations", message: 'operation type does not match "delete" or "put"' });
              if (s.type === "delete" && s.response != null) throw R2.errors.exception({ header: "Cache.#batchCacheOperations", message: "delete operation should not have an associated response" });
              if (this.#r(s.request, s.options, A2).length) throw new DOMException("???", "InvalidStateError");
              let o2;
              if (s.type === "delete") {
                if (o2 = this.#r(s.request, s.options), o2.length === 0) return [];
                for (let a2 of o2) {
                  let c2 = r2.indexOf(a2);
                  Ch(c2 !== -1), r2.splice(c2, 1);
                }
              } else if (s.type === "put") {
                if (s.response == null) throw R2.errors.exception({ header: "Cache.#batchCacheOperations", message: "put operation should have an associated response" });
                let a2 = s.request;
                if (!el(a2.url)) throw R2.errors.exception({ header: "Cache.#batchCacheOperations", message: "expected http or https scheme" });
                if (a2.method !== "GET") throw R2.errors.exception({ header: "Cache.#batchCacheOperations", message: "not get method" });
                if (s.options != null) throw R2.errors.exception({ header: "Cache.#batchCacheOperations", message: "options must not be defined" });
                o2 = this.#r(s.request);
                for (let c2 of o2) {
                  let l2 = r2.indexOf(c2);
                  Ch(l2 !== -1), r2.splice(l2, 1);
                }
                r2.push([s.request, s.response]), A2.push([s.request, s.response]);
              }
              i2.push([s.request, s.response]);
            }
            return i2;
          } catch (s) {
            throw this.#e.length = 0, this.#e = n2, s;
          }
        }
        #r(e, r2, n2) {
          let A2 = [], i2 = n2 ?? this.#e;
          for (let s of i2) {
            let [o2, a2] = s;
            this.#n(e, o2, a2, r2) && A2.push(s);
          }
          return A2;
        }
        #n(e, r2, n2 = null, A2) {
          let i2 = new URL(e.url), s = new URL(r2.url);
          if (A2?.ignoreSearch && (s.search = "", i2.search = ""), !tq(i2, s, true)) return false;
          if (n2 == null || A2?.ignoreVary || !n2.headersList.contains("vary")) return true;
          let o2 = Qh(n2.headersList.get("vary"));
          for (let a2 of o2) {
            if (a2 === "*") return false;
            let c2 = r2.headersList.get(a2), l2 = e.headersList.get(a2);
            if (c2 !== l2) return false;
          }
          return true;
        }
        #i(e, r2, n2 = 1 / 0) {
          let A2 = null;
          if (e !== void 0) if (R2.is.Request(e)) {
            if (A2 = zt(e), A2.method !== "GET" && !r2.ignoreMethod) return [];
          } else typeof e == "string" && (A2 = zt(new Ls(e)));
          let i2 = [];
          if (e === void 0) for (let o2 of this.#e) i2.push(o2[1]);
          else {
            let o2 = this.#r(A2, r2);
            for (let a2 of o2) i2.push(a2[1]);
          }
          let s = [];
          for (let o2 of i2) {
            let a2 = Aq(o2, "immutable");
            if (s.push(a2.clone()), s.length >= n2) break;
          }
          return Object.freeze(s);
        }
      };
      Object.defineProperties(tl.prototype, { [Symbol.toStringTag]: { value: "Cache", configurable: true }, match: Mn, matchAll: Mn, add: Mn, addAll: Mn, put: Mn, delete: Mn, keys: Mn });
      var z0 = [{ key: "ignoreSearch", converter: R2.converters.boolean, defaultValue: /* @__PURE__ */ __name(() => false, "defaultValue") }, { key: "ignoreMethod", converter: R2.converters.boolean, defaultValue: /* @__PURE__ */ __name(() => false, "defaultValue") }, { key: "ignoreVary", converter: R2.converters.boolean, defaultValue: /* @__PURE__ */ __name(() => false, "defaultValue") }];
      R2.converters.CacheQueryOptions = R2.dictionaryConverter(z0);
      R2.converters.MultiCacheQueryOptions = R2.dictionaryConverter([...z0, { key: "cacheName", converter: R2.converters.DOMString }]);
      R2.converters.Response = R2.interfaceConverter(R2.is.Response, "Response");
      R2.converters["sequence<RequestInfo>"] = R2.sequenceConverter(R2.converters.RequestInfo);
      eR.exports = { Cache: tl };
    });
    var nR = C2((X$, rR) => {
      "use strict";
      var { Cache: rl } = tR(), { webidl: ve } = Te(), { kEnumerableProperty: vs } = Y2(), { kConstruct: Ps } = ne(), nl = class t2 {
        static {
          __name(this, "t");
        }
        #e = /* @__PURE__ */ new Map();
        constructor() {
          arguments[0] !== Ps && ve.illegalConstructor(), ve.util.markAsUncloneable(this);
        }
        async match(e, r2 = {}) {
          if (ve.brandCheck(this, t2), ve.argumentLengthCheck(arguments, 1, "CacheStorage.match"), e = ve.converters.RequestInfo(e), r2 = ve.converters.MultiCacheQueryOptions(r2), r2.cacheName != null) {
            if (this.#e.has(r2.cacheName)) {
              let n2 = this.#e.get(r2.cacheName);
              return await new rl(Ps, n2).match(e, r2);
            }
          } else for (let n2 of this.#e.values()) {
            let i2 = await new rl(Ps, n2).match(e, r2);
            if (i2 !== void 0) return i2;
          }
        }
        async has(e) {
          ve.brandCheck(this, t2);
          let r2 = "CacheStorage.has";
          return ve.argumentLengthCheck(arguments, 1, r2), e = ve.converters.DOMString(e, r2, "cacheName"), this.#e.has(e);
        }
        async open(e) {
          ve.brandCheck(this, t2);
          let r2 = "CacheStorage.open";
          if (ve.argumentLengthCheck(arguments, 1, r2), e = ve.converters.DOMString(e, r2, "cacheName"), this.#e.has(e)) {
            let A2 = this.#e.get(e);
            return new rl(Ps, A2);
          }
          let n2 = [];
          return this.#e.set(e, n2), new rl(Ps, n2);
        }
        async delete(e) {
          ve.brandCheck(this, t2);
          let r2 = "CacheStorage.delete";
          return ve.argumentLengthCheck(arguments, 1, r2), e = ve.converters.DOMString(e, r2, "cacheName"), this.#e.delete(e);
        }
        async keys() {
          return ve.brandCheck(this, t2), [...this.#e.keys()];
        }
      };
      Object.defineProperties(nl.prototype, { [Symbol.toStringTag]: { value: "CacheStorage", configurable: true }, match: vs, has: vs, open: vs, delete: vs, keys: vs });
      rR.exports = { CacheStorage: nl };
    });
    var iR = C2((K$, AR) => {
      "use strict";
      AR.exports = { maxAttributeValueSize: 1024, maxNameValuePairSize: 4096 };
    });
    var Ih = C2(($$, lR) => {
      "use strict";
      function cq(t2) {
        for (let e = 0; e < t2.length; ++e) {
          let r2 = t2.charCodeAt(e);
          if (r2 >= 0 && r2 <= 8 || r2 >= 10 && r2 <= 31 || r2 === 127) return true;
        }
        return false;
      }
      __name(cq, "cq");
      function sR(t2) {
        for (let e = 0; e < t2.length; ++e) {
          let r2 = t2.charCodeAt(e);
          if (r2 < 33 || r2 > 126 || r2 === 34 || r2 === 40 || r2 === 41 || r2 === 60 || r2 === 62 || r2 === 64 || r2 === 44 || r2 === 59 || r2 === 58 || r2 === 92 || r2 === 47 || r2 === 91 || r2 === 93 || r2 === 63 || r2 === 61 || r2 === 123 || r2 === 125) throw new Error("Invalid cookie name");
        }
      }
      __name(sR, "sR");
      function oR(t2) {
        let e = t2.length, r2 = 0;
        if (t2[0] === '"') {
          if (e === 1 || t2[e - 1] !== '"') throw new Error("Invalid cookie value");
          --e, ++r2;
        }
        for (; r2 < e; ) {
          let n2 = t2.charCodeAt(r2++);
          if (n2 < 33 || n2 > 126 || n2 === 34 || n2 === 44 || n2 === 59 || n2 === 92) throw new Error("Invalid cookie value");
        }
      }
      __name(oR, "oR");
      function aR(t2) {
        for (let e = 0; e < t2.length; ++e) {
          let r2 = t2.charCodeAt(e);
          if (r2 < 32 || r2 === 127 || r2 === 59) throw new Error("Invalid cookie path");
        }
      }
      __name(aR, "aR");
      function lq(t2) {
        if (t2.startsWith("-") || t2.endsWith(".") || t2.endsWith("-")) throw new Error("Invalid cookie domain");
      }
      __name(lq, "lq");
      var uq = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], gq = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], Al = Array(61).fill(0).map((t2, e) => e.toString().padStart(2, "0"));
      function cR(t2) {
        return typeof t2 == "number" && (t2 = new Date(t2)), `${uq[t2.getUTCDay()]}, ${Al[t2.getUTCDate()]} ${gq[t2.getUTCMonth()]} ${t2.getUTCFullYear()} ${Al[t2.getUTCHours()]}:${Al[t2.getUTCMinutes()]}:${Al[t2.getUTCSeconds()]} GMT`;
      }
      __name(cR, "cR");
      function Eq(t2) {
        if (t2 < 0) throw new Error("Invalid cookie max-age");
      }
      __name(Eq, "Eq");
      function dq(t2) {
        if (t2.name.length === 0) return null;
        sR(t2.name), oR(t2.value);
        let e = [`${t2.name}=${t2.value}`];
        t2.name.startsWith("__Secure-") && (t2.secure = true), t2.name.startsWith("__Host-") && (t2.secure = true, t2.domain = null, t2.path = "/"), t2.secure && e.push("Secure"), t2.httpOnly && e.push("HttpOnly"), typeof t2.maxAge == "number" && (Eq(t2.maxAge), e.push(`Max-Age=${t2.maxAge}`)), t2.domain && (lq(t2.domain), e.push(`Domain=${t2.domain}`)), t2.path && (aR(t2.path), e.push(`Path=${t2.path}`)), t2.expires && t2.expires.toString() !== "Invalid Date" && e.push(`Expires=${cR(t2.expires)}`), t2.sameSite && e.push(`SameSite=${t2.sameSite}`);
        for (let r2 of t2.unparsed) {
          if (!r2.includes("=")) throw new Error("Invalid unparsed");
          let [n2, ...A2] = r2.split("=");
          e.push(`${n2.trim()}=${A2.join("=")}`);
        }
        return e.join("; ");
      }
      __name(dq, "dq");
      lR.exports = { isCTLExcludingHtab: cq, validateCookieName: sR, validateCookiePath: aR, validateCookieValue: oR, toIMFDate: cR, stringify: dq };
    });
    var gR = C2((z$, uR) => {
      "use strict";
      var { maxNameValuePairSize: hq, maxAttributeValueSize: fq } = iR(), { isCTLExcludingHtab: Qq } = Ih(), { collectASequenceOfCodePointsFast: il } = tt(), Cq = __require("node:assert"), { unescape: Iq } = __require("node:querystring");
      function pq(t2) {
        if (Qq(t2)) return null;
        let e = "", r2 = "", n2 = "", A2 = "";
        if (t2.includes(";")) {
          let i2 = { position: 0 };
          e = il(";", t2, i2), r2 = t2.slice(i2.position);
        } else e = t2;
        if (!e.includes("=")) A2 = e;
        else {
          let i2 = { position: 0 };
          n2 = il("=", e, i2), A2 = e.slice(i2.position + 1);
        }
        return n2 = n2.trim(), A2 = A2.trim(), n2.length + A2.length > hq ? null : { name: n2, value: Iq(A2), ...$A(r2) };
      }
      __name(pq, "pq");
      function $A(t2, e = {}) {
        if (t2.length === 0) return e;
        Cq(t2[0] === ";"), t2 = t2.slice(1);
        let r2 = "";
        t2.includes(";") ? (r2 = il(";", t2, { position: 0 }), t2 = t2.slice(r2.length)) : (r2 = t2, t2 = "");
        let n2 = "", A2 = "";
        if (r2.includes("=")) {
          let s = { position: 0 };
          n2 = il("=", r2, s), A2 = r2.slice(s.position + 1);
        } else n2 = r2;
        if (n2 = n2.trim(), A2 = A2.trim(), A2.length > fq) return $A(t2, e);
        let i2 = n2.toLowerCase();
        if (i2 === "expires") {
          let s = new Date(A2);
          e.expires = s;
        } else if (i2 === "max-age") {
          let s = A2.charCodeAt(0);
          if ((s < 48 || s > 57) && A2[0] !== "-" || !/^\d+$/.test(A2)) return $A(t2, e);
          let o2 = Number(A2);
          e.maxAge = o2;
        } else if (i2 === "domain") {
          let s = A2;
          s[0] === "." && (s = s.slice(1)), s = s.toLowerCase(), e.domain = s;
        } else if (i2 === "path") {
          let s = "";
          A2.length === 0 || A2[0] !== "/" ? s = "/" : s = A2, e.path = s;
        } else if (i2 === "secure") e.secure = true;
        else if (i2 === "httponly") e.httpOnly = true;
        else if (i2 === "samesite") {
          let s = "Default", o2 = A2.toLowerCase();
          o2.includes("none") && (s = "None"), o2.includes("strict") && (s = "Strict"), o2.includes("lax") && (s = "Lax"), e.sameSite = s;
        } else e.unparsed ??= [], e.unparsed.push(`${n2}=${A2}`);
        return $A(t2, e);
      }
      __name($A, "$A");
      uR.exports = { parseSetCookie: pq, parseUnparsedAttributes: $A };
    });
    var fR = C2((ez, hR) => {
      "use strict";
      var { parseSetCookie: ER } = gR(), { stringify: Bq } = Ih(), { webidl: q } = Te(), { Headers: mq } = Tn(), sl = q.brandCheckMultiple([mq, globalThis.Headers].filter(Boolean));
      function yq(t2) {
        q.argumentLengthCheck(arguments, 1, "getCookies"), sl(t2);
        let e = t2.get("cookie"), r2 = {};
        if (!e) return r2;
        for (let n2 of e.split(";")) {
          let [A2, ...i2] = n2.split("=");
          r2[A2.trim()] = i2.join("=");
        }
        return r2;
      }
      __name(yq, "yq");
      function wq(t2, e, r2) {
        sl(t2);
        let n2 = "deleteCookie";
        q.argumentLengthCheck(arguments, 2, n2), e = q.converters.DOMString(e, n2, "name"), r2 = q.converters.DeleteCookieAttributes(r2), dR(t2, { name: e, value: "", expires: /* @__PURE__ */ new Date(0), ...r2 });
      }
      __name(wq, "wq");
      function Dq(t2) {
        q.argumentLengthCheck(arguments, 1, "getSetCookies"), sl(t2);
        let e = t2.getSetCookie();
        return e ? e.map((r2) => ER(r2)) : [];
      }
      __name(Dq, "Dq");
      function Rq(t2) {
        return t2 = q.converters.DOMString(t2), ER(t2);
      }
      __name(Rq, "Rq");
      function dR(t2, e) {
        q.argumentLengthCheck(arguments, 2, "setCookie"), sl(t2), e = q.converters.Cookie(e);
        let r2 = Bq(e);
        r2 && t2.append("set-cookie", r2, true);
      }
      __name(dR, "dR");
      q.converters.DeleteCookieAttributes = q.dictionaryConverter([{ converter: q.nullableConverter(q.converters.DOMString), key: "path", defaultValue: /* @__PURE__ */ __name(() => null, "defaultValue") }, { converter: q.nullableConverter(q.converters.DOMString), key: "domain", defaultValue: /* @__PURE__ */ __name(() => null, "defaultValue") }]);
      q.converters.Cookie = q.dictionaryConverter([{ converter: q.converters.DOMString, key: "name" }, { converter: q.converters.DOMString, key: "value" }, { converter: q.nullableConverter((t2) => typeof t2 == "number" ? q.converters["unsigned long long"](t2) : new Date(t2)), key: "expires", defaultValue: /* @__PURE__ */ __name(() => null, "defaultValue") }, { converter: q.nullableConverter(q.converters["long long"]), key: "maxAge", defaultValue: /* @__PURE__ */ __name(() => null, "defaultValue") }, { converter: q.nullableConverter(q.converters.DOMString), key: "domain", defaultValue: /* @__PURE__ */ __name(() => null, "defaultValue") }, { converter: q.nullableConverter(q.converters.DOMString), key: "path", defaultValue: /* @__PURE__ */ __name(() => null, "defaultValue") }, { converter: q.nullableConverter(q.converters.boolean), key: "secure", defaultValue: /* @__PURE__ */ __name(() => null, "defaultValue") }, { converter: q.nullableConverter(q.converters.boolean), key: "httpOnly", defaultValue: /* @__PURE__ */ __name(() => null, "defaultValue") }, { converter: q.converters.USVString, key: "sameSite", allowedValues: ["Strict", "Lax", "None"] }, { converter: q.sequenceConverter(q.converters.DOMString), key: "unparsed", defaultValue: /* @__PURE__ */ __name(() => new Array(0), "defaultValue") }]);
      hR.exports = { getCookies: yq, deleteCookie: wq, getSetCookies: Dq, setCookie: dR, parseCookie: Rq };
    });
    var cl = C2((tz, CR) => {
      "use strict";
      var { webidl: S2 } = Te(), { kEnumerableProperty: Ke } = Y2(), { kConstruct: QR } = ne(), zA = class t2 extends Event {
        static {
          __name(this, "t");
        }
        #e;
        constructor(e, r2 = {}) {
          if (e === QR) {
            super(arguments[1], arguments[2]), S2.util.markAsUncloneable(this);
            return;
          }
          let n2 = "MessageEvent constructor";
          S2.argumentLengthCheck(arguments, 1, n2), e = S2.converters.DOMString(e, n2, "type"), r2 = S2.converters.MessageEventInit(r2, n2, "eventInitDict"), super(e, r2), this.#e = r2, S2.util.markAsUncloneable(this);
        }
        get data() {
          return S2.brandCheck(this, t2), this.#e.data;
        }
        get origin() {
          return S2.brandCheck(this, t2), this.#e.origin;
        }
        get lastEventId() {
          return S2.brandCheck(this, t2), this.#e.lastEventId;
        }
        get source() {
          return S2.brandCheck(this, t2), this.#e.source;
        }
        get ports() {
          return S2.brandCheck(this, t2), Object.isFrozen(this.#e.ports) || Object.freeze(this.#e.ports), this.#e.ports;
        }
        initMessageEvent(e, r2 = false, n2 = false, A2 = null, i2 = "", s = "", o2 = null, a2 = []) {
          return S2.brandCheck(this, t2), S2.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent"), new t2(e, { bubbles: r2, cancelable: n2, data: A2, origin: i2, lastEventId: s, source: o2, ports: a2 });
        }
        static createFastMessageEvent(e, r2) {
          let n2 = new t2(QR, e, r2);
          return n2.#e = r2, n2.#e.data ??= null, n2.#e.origin ??= "", n2.#e.lastEventId ??= "", n2.#e.source ??= null, n2.#e.ports ??= [], n2;
        }
      }, { createFastMessageEvent: Sq } = zA;
      delete zA.createFastMessageEvent;
      var ol = class t2 extends Event {
        static {
          __name(this, "t");
        }
        #e;
        constructor(e, r2 = {}) {
          let n2 = "CloseEvent constructor";
          S2.argumentLengthCheck(arguments, 1, n2), e = S2.converters.DOMString(e, n2, "type"), r2 = S2.converters.CloseEventInit(r2), super(e, r2), this.#e = r2, S2.util.markAsUncloneable(this);
        }
        get wasClean() {
          return S2.brandCheck(this, t2), this.#e.wasClean;
        }
        get code() {
          return S2.brandCheck(this, t2), this.#e.code;
        }
        get reason() {
          return S2.brandCheck(this, t2), this.#e.reason;
        }
      }, al = class t2 extends Event {
        static {
          __name(this, "t");
        }
        #e;
        constructor(e, r2) {
          let n2 = "ErrorEvent constructor";
          S2.argumentLengthCheck(arguments, 1, n2), super(e, r2), S2.util.markAsUncloneable(this), e = S2.converters.DOMString(e, n2, "type"), r2 = S2.converters.ErrorEventInit(r2 ?? {}), this.#e = r2;
        }
        get message() {
          return S2.brandCheck(this, t2), this.#e.message;
        }
        get filename() {
          return S2.brandCheck(this, t2), this.#e.filename;
        }
        get lineno() {
          return S2.brandCheck(this, t2), this.#e.lineno;
        }
        get colno() {
          return S2.brandCheck(this, t2), this.#e.colno;
        }
        get error() {
          return S2.brandCheck(this, t2), this.#e.error;
        }
      };
      Object.defineProperties(zA.prototype, { [Symbol.toStringTag]: { value: "MessageEvent", configurable: true }, data: Ke, origin: Ke, lastEventId: Ke, source: Ke, ports: Ke, initMessageEvent: Ke });
      Object.defineProperties(ol.prototype, { [Symbol.toStringTag]: { value: "CloseEvent", configurable: true }, reason: Ke, code: Ke, wasClean: Ke });
      Object.defineProperties(al.prototype, { [Symbol.toStringTag]: { value: "ErrorEvent", configurable: true }, message: Ke, filename: Ke, lineno: Ke, colno: Ke, error: Ke });
      S2.converters.MessagePort = S2.interfaceConverter(S2.is.MessagePort, "MessagePort");
      S2.converters["sequence<MessagePort>"] = S2.sequenceConverter(S2.converters.MessagePort);
      var ph = [{ key: "bubbles", converter: S2.converters.boolean, defaultValue: /* @__PURE__ */ __name(() => false, "defaultValue") }, { key: "cancelable", converter: S2.converters.boolean, defaultValue: /* @__PURE__ */ __name(() => false, "defaultValue") }, { key: "composed", converter: S2.converters.boolean, defaultValue: /* @__PURE__ */ __name(() => false, "defaultValue") }];
      S2.converters.MessageEventInit = S2.dictionaryConverter([...ph, { key: "data", converter: S2.converters.any, defaultValue: /* @__PURE__ */ __name(() => null, "defaultValue") }, { key: "origin", converter: S2.converters.USVString, defaultValue: /* @__PURE__ */ __name(() => "", "defaultValue") }, { key: "lastEventId", converter: S2.converters.DOMString, defaultValue: /* @__PURE__ */ __name(() => "", "defaultValue") }, { key: "source", converter: S2.nullableConverter(S2.converters.MessagePort), defaultValue: /* @__PURE__ */ __name(() => null, "defaultValue") }, { key: "ports", converter: S2.converters["sequence<MessagePort>"], defaultValue: /* @__PURE__ */ __name(() => new Array(0), "defaultValue") }]);
      S2.converters.CloseEventInit = S2.dictionaryConverter([...ph, { key: "wasClean", converter: S2.converters.boolean, defaultValue: /* @__PURE__ */ __name(() => false, "defaultValue") }, { key: "code", converter: S2.converters["unsigned short"], defaultValue: /* @__PURE__ */ __name(() => 0, "defaultValue") }, { key: "reason", converter: S2.converters.USVString, defaultValue: /* @__PURE__ */ __name(() => "", "defaultValue") }]);
      S2.converters.ErrorEventInit = S2.dictionaryConverter([...ph, { key: "message", converter: S2.converters.DOMString, defaultValue: /* @__PURE__ */ __name(() => "", "defaultValue") }, { key: "filename", converter: S2.converters.USVString, defaultValue: /* @__PURE__ */ __name(() => "", "defaultValue") }, { key: "lineno", converter: S2.converters["unsigned long"], defaultValue: /* @__PURE__ */ __name(() => 0, "defaultValue") }, { key: "colno", converter: S2.converters["unsigned long"], defaultValue: /* @__PURE__ */ __name(() => 0, "defaultValue") }, { key: "error", converter: S2.converters.any }]);
      CR.exports = { MessageEvent: zA, CloseEvent: ol, ErrorEvent: al, createFastMessageEvent: Sq };
    });
    var zr = C2((rz, IR) => {
      "use strict";
      var bq = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", Nq = { enumerable: true, writable: false, configurable: false }, Fq = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 }, Tq = { SENT: 1, RECEIVED: 2 }, xq = { CONTINUATION: 0, TEXT: 1, BINARY: 2, CLOSE: 8, PING: 9, PONG: 10 }, Uq = 65535, kq = { INFO: 0, PAYLOADLENGTH_16: 2, PAYLOADLENGTH_64: 3, READ_DATA: 4 }, Mq = Buffer.allocUnsafe(0), Lq = { text: 1, typedArray: 2, arrayBuffer: 3, blob: 4 };
      IR.exports = { uid: bq, sentCloseFrameState: Tq, staticPropertyDescriptors: Nq, states: Fq, opcodes: xq, maxUnsigned16Bit: Uq, parserStates: kq, emptyBuffer: Mq, sendHints: Lq };
    });
    var Ln = C2((nz, wR) => {
      "use strict";
      var { states: ll, opcodes: ei } = zr(), { isUtf8: vq } = __require("node:buffer"), { collectASequenceOfCodePointsFast: Pq, removeHTTPWhitespace: pR } = tt();
      function Yq(t2) {
        return t2 === ll.CONNECTING;
      }
      __name(Yq, "Yq");
      function Gq(t2) {
        return t2 === ll.OPEN;
      }
      __name(Gq, "Gq");
      function Oq(t2) {
        return t2 === ll.CLOSING;
      }
      __name(Oq, "Oq");
      function Vq(t2) {
        return t2 === ll.CLOSED;
      }
      __name(Vq, "Vq");
      function Hq(t2, e, r2 = (A2, i2) => new Event(A2, i2), n2 = {}) {
        let A2 = r2(t2, n2);
        e.dispatchEvent(A2);
      }
      __name(Hq, "Hq");
      function qq(t2, e, r2) {
        t2.onMessage(e, r2);
      }
      __name(qq, "qq");
      function Jq(t2) {
        return t2.byteLength === t2.buffer.byteLength ? t2.buffer : new Uint8Array(t2).buffer;
      }
      __name(Jq, "Jq");
      function Wq(t2) {
        if (t2.length === 0) return false;
        for (let e = 0; e < t2.length; ++e) {
          let r2 = t2.charCodeAt(e);
          if (r2 < 33 || r2 > 126 || r2 === 34 || r2 === 40 || r2 === 41 || r2 === 44 || r2 === 47 || r2 === 58 || r2 === 59 || r2 === 60 || r2 === 61 || r2 === 62 || r2 === 63 || r2 === 64 || r2 === 91 || r2 === 92 || r2 === 93 || r2 === 123 || r2 === 125) return false;
        }
        return true;
      }
      __name(Wq, "Wq");
      function _q(t2) {
        return t2 >= 1e3 && t2 < 1015 ? t2 !== 1004 && t2 !== 1005 && t2 !== 1006 : t2 >= 3e3 && t2 <= 4999;
      }
      __name(_q, "_q");
      function BR(t2) {
        return t2 === ei.CLOSE || t2 === ei.PING || t2 === ei.PONG;
      }
      __name(BR, "BR");
      function mR(t2) {
        return t2 === ei.CONTINUATION;
      }
      __name(mR, "mR");
      function yR(t2) {
        return t2 === ei.TEXT || t2 === ei.BINARY;
      }
      __name(yR, "yR");
      function jq(t2) {
        return yR(t2) || mR(t2) || BR(t2);
      }
      __name(jq, "jq");
      function Zq(t2) {
        let e = { position: 0 }, r2 = /* @__PURE__ */ new Map();
        for (; e.position < t2.length; ) {
          let n2 = Pq(";", t2, e), [A2, i2 = ""] = n2.split("=");
          r2.set(pR(A2, true, false), pR(i2, false, true)), e.position++;
        }
        return r2;
      }
      __name(Zq, "Zq");
      function Xq(t2) {
        for (let e = 0; e < t2.length; e++) {
          let r2 = t2.charCodeAt(e);
          if (r2 < 48 || r2 > 57) return false;
        }
        return true;
      }
      __name(Xq, "Xq");
      function Kq(t2, e) {
        let r2;
        try {
          r2 = new URL(t2, e);
        } catch (n2) {
          throw new DOMException(n2, "SyntaxError");
        }
        if (r2.protocol === "http:" ? r2.protocol = "ws:" : r2.protocol === "https:" && (r2.protocol = "wss:"), r2.protocol !== "ws:" && r2.protocol !== "wss:") throw new DOMException("expected a ws: or wss: url", "SyntaxError");
        if (r2.hash.length || r2.href.endsWith("#")) throw new DOMException("hash", "SyntaxError");
        return r2;
      }
      __name(Kq, "Kq");
      function $q(t2, e) {
        if (t2 !== null && t2 !== 1e3 && (t2 < 3e3 || t2 > 4999)) throw new DOMException("invalid code", "InvalidAccessError");
        if (e !== null) {
          let r2 = Buffer.byteLength(e);
          if (r2 > 123) throw new DOMException(`Reason must be less than 123 bytes; received ${r2}`, "SyntaxError");
        }
      }
      __name($q, "$q");
      var zq = (() => {
        if (typeof process.versions.icu == "string") {
          let t2 = new TextDecoder("utf-8", { fatal: true });
          return t2.decode.bind(t2);
        }
        return function(t2) {
          if (vq(t2)) return t2.toString("utf-8");
          throw new TypeError("Invalid utf-8 received.");
        };
      })();
      wR.exports = { isConnecting: Yq, isEstablished: Gq, isClosing: Oq, isClosed: Vq, fireEvent: Hq, isValidSubprotocol: Wq, isValidStatusCode: _q, websocketMessageReceived: qq, utf8Decode: zq, isControlFrame: BR, isContinuationFrame: mR, isTextBinaryFrame: yR, isValidOpcode: jq, parseExtensions: Zq, isValidClientWindowBits: Xq, toArrayBuffer: Jq, getURLRecord: Kq, validateCloseCodeAndReason: $q };
    });
    var Gs = C2((Az, SR) => {
      "use strict";
      var { maxUnsigned16Bit: DR, opcodes: eJ } = zr(), ul = 8 * 1024, Bh, Ys = null, ti = ul;
      try {
        Bh = __require("node:crypto");
      } catch {
        Bh = { randomFillSync: /* @__PURE__ */ __name(function(e, r2, n2) {
          for (let A2 = 0; A2 < e.length; ++A2) e[A2] = Math.random() * 255 | 0;
          return e;
        }, "randomFillSync") };
      }
      function RR() {
        return ti === ul && (ti = 0, Bh.randomFillSync(Ys ??= Buffer.allocUnsafeSlow(ul), 0, ul)), [Ys[ti++], Ys[ti++], Ys[ti++], Ys[ti++]];
      }
      __name(RR, "RR");
      var mh = class {
        static {
          __name(this, "mh");
        }
        constructor(e) {
          this.frameData = e;
        }
        createFrame(e) {
          let r2 = this.frameData, n2 = RR(), A2 = r2?.byteLength ?? 0, i2 = A2, s = 6;
          A2 > DR ? (s += 8, i2 = 127) : A2 > 125 && (s += 2, i2 = 126);
          let o2 = Buffer.allocUnsafe(A2 + s);
          o2[0] = o2[1] = 0, o2[0] |= 128, o2[0] = (o2[0] & 240) + e;
          o2[s - 4] = n2[0], o2[s - 3] = n2[1], o2[s - 2] = n2[2], o2[s - 1] = n2[3], o2[1] = i2, i2 === 126 ? o2.writeUInt16BE(A2, 2) : i2 === 127 && (o2[2] = o2[3] = 0, o2.writeUIntBE(A2, 4, 6)), o2[1] |= 128;
          for (let a2 = 0; a2 < A2; ++a2) o2[s + a2] = r2[a2] ^ n2[a2 & 3];
          return o2;
        }
        static createFastTextFrame(e) {
          let r2 = RR(), n2 = e.length;
          for (let o2 = 0; o2 < n2; ++o2) e[o2] ^= r2[o2 & 3];
          let A2 = n2, i2 = 6;
          n2 > DR ? (i2 += 8, A2 = 127) : n2 > 125 && (i2 += 2, A2 = 126);
          let s = Buffer.allocUnsafeSlow(i2);
          return s[0] = 128 | eJ.TEXT, s[1] = A2 | 128, s[i2 - 4] = r2[0], s[i2 - 3] = r2[1], s[i2 - 2] = r2[2], s[i2 - 1] = r2[3], A2 === 126 ? s.writeUInt16BE(n2, 2) : A2 === 127 && (s[2] = s[3] = 0, s.writeUIntBE(n2, 4, 6)), [s, e];
        }
      };
      SR.exports = { WebsocketFrameSend: mh };
    });
    var El = C2((iz, xR) => {
      "use strict";
      var { uid: tJ, states: gl, sentCloseFrameState: yh, emptyBuffer: bR, opcodes: rJ } = zr(), { parseExtensions: nJ, isClosed: AJ, isClosing: iJ, isEstablished: FR, validateCloseCodeAndReason: sJ } = Ln(), { channels: NR } = lr(), { makeRequest: oJ } = XA(), { fetching: aJ } = Ms(), { Headers: cJ, getHeadersList: lJ } = Tn(), { getDecodeSplit: uJ } = Ve(), { WebsocketFrameSend: gJ } = Gs(), EJ = __require("node:assert"), wh;
      try {
        wh = __require("node:crypto");
      } catch {
      }
      function dJ(t2, e, r2, n2, A2) {
        let i2 = t2;
        i2.protocol = t2.protocol === "ws:" ? "http:" : "https:";
        let s = oJ({ urlList: [i2], client: r2, serviceWorkers: "none", referrer: "no-referrer", mode: "websocket", credentials: "include", cache: "no-store", redirect: "error" });
        if (A2.headers) {
          let l2 = lJ(new cJ(A2.headers));
          s.headersList = l2;
        }
        let o2 = wh.randomBytes(16).toString("base64");
        s.headersList.append("sec-websocket-key", o2, true), s.headersList.append("sec-websocket-version", "13", true);
        for (let l2 of e) s.headersList.append("sec-websocket-protocol", l2, true);
        return s.headersList.append("sec-websocket-extensions", "permessage-deflate; client_max_window_bits", true), aJ({ request: s, useParallelQueue: true, dispatcher: A2.dispatcher, processResponse(l2) {
          if (l2.type === "error" && (n2.readyState = gl.CLOSED), l2.type === "error" || l2.status !== 101) {
            mr(n2, 1002, "Received network error or non-101 status code.");
            return;
          }
          if (e.length !== 0 && !l2.headersList.get("Sec-WebSocket-Protocol")) {
            mr(n2, 1002, "Server did not respond with sent protocols.");
            return;
          }
          if (l2.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            mr(n2, 1002, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (l2.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            mr(n2, 1002, 'Server did not set Connection header to "upgrade".');
            return;
          }
          let u2 = l2.headersList.get("Sec-WebSocket-Accept"), g = wh.createHash("sha1").update(o2 + tJ).digest("base64");
          if (u2 !== g) {
            mr(n2, 1002, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          let E = l2.headersList.get("Sec-WebSocket-Extensions"), h;
          if (E !== null && (h = nJ(E), !h.has("permessage-deflate"))) {
            mr(n2, 1002, "Sec-WebSocket-Extensions header does not match.");
            return;
          }
          let f2 = l2.headersList.get("Sec-WebSocket-Protocol");
          if (f2 !== null && !uJ("sec-websocket-protocol", s.headersList).includes(f2)) {
            mr(n2, 1002, "Protocol was not set in the opening handshake.");
            return;
          }
          l2.socket.on("data", n2.onSocketData), l2.socket.on("close", n2.onSocketClose), l2.socket.on("error", n2.onSocketError), NR.open.hasSubscribers && NR.open.publish({ address: l2.socket.address(), protocol: f2, extensions: E }), n2.wasEverConnected = true, n2.onConnectionEstablished(l2, h);
        } });
      }
      __name(dJ, "dJ");
      function TR(t2, e, r2, n2 = false) {
        if (e ??= null, r2 ??= "", n2 && sJ(e, r2), !(AJ(t2.readyState) || iJ(t2.readyState))) if (!FR(t2.readyState)) mr(t2), t2.readyState = gl.CLOSING;
        else if (!t2.closeState.has(yh.SENT) && !t2.closeState.has(yh.RECEIVED)) {
          let A2 = new gJ();
          r2.length !== 0 && e === null && (e = 1e3), EJ(e === null || Number.isInteger(e)), e === null && r2.length === 0 ? A2.frameData = bR : e !== null && r2 === null ? (A2.frameData = Buffer.allocUnsafe(2), A2.frameData.writeUInt16BE(e, 0)) : e !== null && r2 !== null ? (A2.frameData = Buffer.allocUnsafe(2 + Buffer.byteLength(r2)), A2.frameData.writeUInt16BE(e, 0), A2.frameData.write(r2, 2, "utf-8")) : A2.frameData = bR, t2.socket.write(A2.createFrame(rJ.CLOSE)), t2.closeState.add(yh.SENT), t2.readyState = gl.CLOSING;
        } else t2.readyState = gl.CLOSING;
      }
      __name(TR, "TR");
      function mr(t2, e, r2) {
        FR(t2.readyState) && TR(t2, e, r2, false), t2.controller.abort(), t2.socket?.destroyed === false && t2.socket.destroy(), t2.onFail(e, r2);
      }
      __name(mr, "mr");
      xR.exports = { establishWebSocketConnection: dJ, failWebsocketConnection: mr, closeWebSocketConnection: TR };
    });
    var kR = C2((sz, UR) => {
      "use strict";
      var { createInflateRaw: hJ, Z_DEFAULT_WINDOWBITS: fJ } = __require("node:zlib"), { isValidClientWindowBits: QJ } = Ln(), CJ = Buffer.from([0, 0, 255, 255]), dl = Symbol("kBuffer"), hl = Symbol("kLength"), Dh = class {
        static {
          __name(this, "Dh");
        }
        #e;
        #t = {};
        constructor(e) {
          this.#t.serverNoContextTakeover = e.has("server_no_context_takeover"), this.#t.serverMaxWindowBits = e.get("server_max_window_bits");
        }
        decompress(e, r2, n2) {
          if (!this.#e) {
            let A2 = fJ;
            if (this.#t.serverMaxWindowBits) {
              if (!QJ(this.#t.serverMaxWindowBits)) {
                n2(new Error("Invalid server_max_window_bits"));
                return;
              }
              A2 = Number.parseInt(this.#t.serverMaxWindowBits);
            }
            this.#e = hJ({ windowBits: A2 }), this.#e[dl] = [], this.#e[hl] = 0, this.#e.on("data", (i2) => {
              this.#e[dl].push(i2), this.#e[hl] += i2.length;
            }), this.#e.on("error", (i2) => {
              this.#e = null, n2(i2);
            });
          }
          this.#e.write(e), r2 && this.#e.write(CJ), this.#e.flush(() => {
            let A2 = Buffer.concat(this.#e[dl], this.#e[hl]);
            this.#e[dl].length = 0, this.#e[hl] = 0, n2(null, A2);
          });
        }
      };
      UR.exports = { PerMessageDeflate: Dh };
    });
    var bh = C2((oz, YR) => {
      "use strict";
      var { Writable: IJ } = __require("node:stream"), pJ = __require("node:assert"), { parserStates: $e, opcodes: ri, states: BJ, emptyBuffer: MR, sentCloseFrameState: Os } = zr(), { channels: fl } = lr(), { isValidStatusCode: mJ, isValidOpcode: yJ, websocketMessageReceived: LR, utf8Decode: wJ, isControlFrame: vR, isTextBinaryFrame: Rh, isContinuationFrame: DJ } = Ln(), { failWebsocketConnection: st } = El(), { WebsocketFrameSend: PR } = Gs(), { PerMessageDeflate: RJ } = kR(), Sh = class extends IJ {
        static {
          __name(this, "Sh");
        }
        #e = [];
        #t = 0;
        #r = 0;
        #n = false;
        #i = $e.INFO;
        #A = {};
        #a = [];
        #s;
        #o;
        constructor(e, r2) {
          super(), this.#o = e, this.#s = r2 ?? /* @__PURE__ */ new Map(), this.#s.has("permessage-deflate") && this.#s.set("permessage-deflate", new RJ(r2));
        }
        _write(e, r2, n2) {
          this.#e.push(e), this.#r += e.length, this.#n = true, this.run(n2);
        }
        run(e) {
          for (; this.#n; ) if (this.#i === $e.INFO) {
            if (this.#r < 2) return e();
            let r2 = this.consume(2), n2 = (r2[0] & 128) !== 0, A2 = r2[0] & 15, i2 = (r2[1] & 128) === 128, s = !n2 && A2 !== ri.CONTINUATION, o2 = r2[1] & 127, a2 = r2[0] & 64, c2 = r2[0] & 32, l2 = r2[0] & 16;
            if (!yJ(A2)) return st(this.#o, 1002, "Invalid opcode received"), e();
            if (i2) return st(this.#o, 1002, "Frame cannot be masked"), e();
            if (a2 !== 0 && !this.#s.has("permessage-deflate")) {
              st(this.#o, 1002, "Expected RSV1 to be clear.");
              return;
            }
            if (c2 !== 0 || l2 !== 0) {
              st(this.#o, 1002, "RSV1, RSV2, RSV3 must be clear");
              return;
            }
            if (s && !Rh(A2)) {
              st(this.#o, 1002, "Invalid frame type was fragmented.");
              return;
            }
            if (Rh(A2) && this.#a.length > 0) {
              st(this.#o, 1002, "Expected continuation frame");
              return;
            }
            if (this.#A.fragmented && s) {
              st(this.#o, 1002, "Fragmented frame exceeded 125 bytes.");
              return;
            }
            if ((o2 > 125 || s) && vR(A2)) {
              st(this.#o, 1002, "Control frame either too large or fragmented");
              return;
            }
            if (DJ(A2) && this.#a.length === 0 && !this.#A.compressed) {
              st(this.#o, 1002, "Unexpected continuation frame");
              return;
            }
            o2 <= 125 ? (this.#A.payloadLength = o2, this.#i = $e.READ_DATA) : o2 === 126 ? this.#i = $e.PAYLOADLENGTH_16 : o2 === 127 && (this.#i = $e.PAYLOADLENGTH_64), Rh(A2) && (this.#A.binaryType = A2, this.#A.compressed = a2 !== 0), this.#A.opcode = A2, this.#A.masked = i2, this.#A.fin = n2, this.#A.fragmented = s;
          } else if (this.#i === $e.PAYLOADLENGTH_16) {
            if (this.#r < 2) return e();
            let r2 = this.consume(2);
            this.#A.payloadLength = r2.readUInt16BE(0), this.#i = $e.READ_DATA;
          } else if (this.#i === $e.PAYLOADLENGTH_64) {
            if (this.#r < 8) return e();
            let r2 = this.consume(8), n2 = r2.readUInt32BE(0);
            if (n2 > 2 ** 31 - 1) {
              st(this.#o, 1009, "Received payload length > 2^31 bytes.");
              return;
            }
            let A2 = r2.readUInt32BE(4);
            this.#A.payloadLength = (n2 << 8) + A2, this.#i = $e.READ_DATA;
          } else if (this.#i === $e.READ_DATA) {
            if (this.#r < this.#A.payloadLength) return e();
            let r2 = this.consume(this.#A.payloadLength);
            if (vR(this.#A.opcode)) this.#n = this.parseControlFrame(r2), this.#i = $e.INFO;
            else if (!this.#A.compressed) this.writeFragments(r2), !this.#A.fragmented && this.#A.fin && LR(this.#o, this.#A.binaryType, this.consumeFragments()), this.#i = $e.INFO;
            else {
              this.#s.get("permessage-deflate").decompress(r2, this.#A.fin, (n2, A2) => {
                if (n2) {
                  st(this.#o, 1007, n2.message);
                  return;
                }
                if (this.writeFragments(A2), !this.#A.fin) {
                  this.#i = $e.INFO, this.#n = true, this.run(e);
                  return;
                }
                LR(this.#o, this.#A.binaryType, this.consumeFragments()), this.#n = true, this.#i = $e.INFO, this.run(e);
              }), this.#n = false;
              break;
            }
          }
        }
        consume(e) {
          if (e > this.#r) throw new Error("Called consume() before buffers satiated.");
          if (e === 0) return MR;
          this.#r -= e;
          let r2 = this.#e[0];
          if (r2.length > e) return this.#e[0] = r2.subarray(e, r2.length), r2.subarray(0, e);
          if (r2.length === e) return this.#e.shift();
          {
            let n2 = 0, A2 = Buffer.allocUnsafeSlow(e);
            for (; n2 !== e; ) {
              let i2 = this.#e[0], s = i2.length;
              if (s + n2 === e) {
                A2.set(this.#e.shift(), n2);
                break;
              } else if (s + n2 > e) {
                A2.set(i2.subarray(0, e - n2), n2), this.#e[0] = i2.subarray(e - n2);
                break;
              } else A2.set(this.#e.shift(), n2), n2 += s;
            }
            return A2;
          }
        }
        writeFragments(e) {
          this.#t += e.length, this.#a.push(e);
        }
        consumeFragments() {
          let e = this.#a;
          if (e.length === 1) return this.#t = 0, e.shift();
          let r2 = 0, n2 = Buffer.allocUnsafeSlow(this.#t);
          for (let A2 = 0; A2 < e.length; ++A2) {
            let i2 = e[A2];
            n2.set(i2, r2), r2 += i2.length;
          }
          return this.#a = [], this.#t = 0, n2;
        }
        parseCloseBody(e) {
          pJ(e.length !== 1);
          let r2;
          if (e.length >= 2 && (r2 = e.readUInt16BE(0)), r2 !== void 0 && !mJ(r2)) return { code: 1002, reason: "Invalid status code", error: true };
          let n2 = e.subarray(2);
          n2[0] === 239 && n2[1] === 187 && n2[2] === 191 && (n2 = n2.subarray(3));
          try {
            n2 = wJ(n2);
          } catch {
            return { code: 1007, reason: "Invalid UTF-8", error: true };
          }
          return { code: r2, reason: n2, error: false };
        }
        parseControlFrame(e) {
          let { opcode: r2, payloadLength: n2 } = this.#A;
          if (r2 === ri.CLOSE) {
            if (n2 === 1) return st(this.#o, 1002, "Received close frame with a 1-byte body."), false;
            if (this.#A.closeInfo = this.parseCloseBody(e), this.#A.closeInfo.error) {
              let { code: A2, reason: i2 } = this.#A.closeInfo;
              return st(this.#o, A2, i2), false;
            }
            if (!this.#o.closeState.has(Os.SENT) && !this.#o.closeState.has(Os.RECEIVED)) {
              let A2 = MR;
              this.#A.closeInfo.code && (A2 = Buffer.allocUnsafe(2), A2.writeUInt16BE(this.#A.closeInfo.code, 0));
              let i2 = new PR(A2);
              this.#o.socket.write(i2.createFrame(ri.CLOSE)), this.#o.closeState.add(Os.SENT);
            }
            return this.#o.readyState = BJ.CLOSING, this.#o.closeState.add(Os.RECEIVED), false;
          } else if (r2 === ri.PING) {
            if (!this.#o.closeState.has(Os.RECEIVED)) {
              let A2 = new PR(e);
              this.#o.socket.write(A2.createFrame(ri.PONG)), fl.ping.hasSubscribers && fl.ping.publish({ payload: e });
            }
          } else r2 === ri.PONG && fl.pong.hasSubscribers && fl.pong.publish({ payload: e });
          return true;
        }
        get closingInfo() {
          return this.#A.closeInfo;
        }
      };
      YR.exports = { ByteParser: Sh };
    });
    var HR = C2((az, VR) => {
      "use strict";
      var { WebsocketFrameSend: OR } = Gs(), { opcodes: GR, sendHints: vn } = zr(), SJ = xE(), Fh = class {
        static {
          __name(this, "Fh");
        }
        #e = new SJ();
        #t = false;
        #r;
        constructor(e) {
          this.#r = e;
        }
        add(e, r2, n2) {
          if (n2 !== vn.blob) {
            if (this.#t) {
              let i2 = { promise: null, callback: r2, frame: Nh(e, n2) };
              this.#e.push(i2);
            } else if (n2 === vn.text) {
              let { 0: i2, 1: s } = OR.createFastTextFrame(e);
              this.#r.cork(), this.#r.write(i2), this.#r.write(s, r2), this.#r.uncork();
            } else this.#r.write(Nh(e, n2), r2);
            return;
          }
          let A2 = { promise: e.arrayBuffer().then((i2) => {
            A2.promise = null, A2.frame = Nh(i2, n2);
          }), callback: r2, frame: null };
          this.#e.push(A2), this.#t || this.#n();
        }
        async #n() {
          this.#t = true;
          let e = this.#e;
          for (; !e.isEmpty(); ) {
            let r2 = e.shift();
            r2.promise !== null && await r2.promise, this.#r.write(r2.frame, r2.callback), r2.callback = r2.frame = null;
          }
          this.#t = false;
        }
      };
      function Nh(t2, e) {
        return new OR(bJ(t2, e)).createFrame(e === vn.text ? GR.TEXT : GR.BINARY);
      }
      __name(Nh, "Nh");
      function bJ(t2, e) {
        switch (e) {
          case vn.text:
          case vn.typedArray:
            return new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength);
          case vn.arrayBuffer:
          case vn.blob:
            return new Uint8Array(t2);
        }
      }
      __name(bJ, "bJ");
      VR.exports = { SendQueue: Fh };
    });
    var XR = C2((cz, ZR) => {
      "use strict";
      var { webidl: x } = Te(), { URLSerializer: NJ } = tt(), { environmentSettingsObject: qR } = Ve(), { staticPropertyDescriptors: en, states: er, sentCloseFrameState: Th, sendHints: Ql, opcodes: JR } = zr(), { isConnecting: FJ, isEstablished: TJ, isClosing: xJ, isValidSubprotocol: UJ, fireEvent: Vs, utf8Decode: kJ, toArrayBuffer: MJ, getURLRecord: LJ } = Ln(), { establishWebSocketConnection: vJ, closeWebSocketConnection: PJ, failWebsocketConnection: WR } = El(), { ByteParser: YJ } = bh(), { kEnumerableProperty: It } = Y2(), { getGlobalDispatcher: GJ } = kc(), { types: jR } = __require("node:util"), { ErrorEvent: OJ, CloseEvent: _R, createFastMessageEvent: VJ } = cl(), { SendQueue: HJ } = HR(), { channels: Cl } = lr(), ot = class t2 extends EventTarget {
        static {
          __name(this, "t");
        }
        #e = { open: null, error: null, close: null, message: null };
        #t = 0;
        #r = "";
        #n = "";
        #i;
        #A = { onConnectionEstablished: /* @__PURE__ */ __name((e, r2) => this.#c(e, r2), "onConnectionEstablished"), onFail: /* @__PURE__ */ __name((e, r2) => this.#g(e, r2), "onFail"), onMessage: /* @__PURE__ */ __name((e, r2) => this.#l(e, r2), "onMessage"), onParserError: /* @__PURE__ */ __name((e) => WR(this.#A, null, e.message), "onParserError"), onParserDrain: /* @__PURE__ */ __name(() => this.#u(), "onParserDrain"), onSocketData: /* @__PURE__ */ __name((e) => {
          this.#o.write(e) || this.#A.socket.pause();
        }, "onSocketData"), onSocketError: /* @__PURE__ */ __name((e) => {
          this.#A.readyState = er.CLOSING, Cl.socketError.hasSubscribers && Cl.socketError.publish(e), this.#A.socket.destroy();
        }, "onSocketError"), onSocketClose: /* @__PURE__ */ __name(() => this.#E(), "onSocketClose"), readyState: er.CONNECTING, socket: null, closeState: /* @__PURE__ */ new Set(), controller: null, wasEverConnected: false };
        #a;
        #s;
        #o;
        constructor(e, r2 = []) {
          super(), x.util.markAsUncloneable(this);
          let n2 = "WebSocket constructor";
          x.argumentLengthCheck(arguments, 1, n2);
          let A2 = x.converters["DOMString or sequence<DOMString> or WebSocketInit"](r2, n2, "options");
          e = x.converters.USVString(e), r2 = A2.protocols;
          let i2 = qR.settingsObject.baseUrl, s = LJ(e, i2);
          if (typeof r2 == "string" && (r2 = [r2]), r2.length !== new Set(r2.map((a2) => a2.toLowerCase())).size) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          if (r2.length > 0 && !r2.every((a2) => UJ(a2))) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          this.#a = new URL(s.href);
          let o2 = qR.settingsObject;
          this.#A.controller = vJ(s, r2, o2, this.#A, A2), this.#A.readyState = t2.CONNECTING, this.#s = "blob";
        }
        close(e = void 0, r2 = void 0) {
          x.brandCheck(this, t2), e !== void 0 && (e = x.converters["unsigned short"](e, "WebSocket.close", "code", { clamp: true })), r2 !== void 0 && (r2 = x.converters.USVString(r2)), e ??= null, r2 ??= "", PJ(this.#A, e, r2, true);
        }
        send(e) {
          x.brandCheck(this, t2);
          let r2 = "WebSocket.send";
          if (x.argumentLengthCheck(arguments, 1, r2), e = x.converters.WebSocketSendData(e, r2, "data"), FJ(this.#A.readyState)) throw new DOMException("Sent before connected.", "InvalidStateError");
          if (!(!TJ(this.#A.readyState) || xJ(this.#A.readyState))) if (typeof e == "string") {
            let n2 = Buffer.from(e);
            this.#t += n2.byteLength, this.#i.add(n2, () => {
              this.#t -= n2.byteLength;
            }, Ql.text);
          } else jR.isArrayBuffer(e) ? (this.#t += e.byteLength, this.#i.add(e, () => {
            this.#t -= e.byteLength;
          }, Ql.arrayBuffer)) : ArrayBuffer.isView(e) ? (this.#t += e.byteLength, this.#i.add(e, () => {
            this.#t -= e.byteLength;
          }, Ql.typedArray)) : x.is.Blob(e) && (this.#t += e.size, this.#i.add(e, () => {
            this.#t -= e.size;
          }, Ql.blob));
        }
        get readyState() {
          return x.brandCheck(this, t2), this.#A.readyState;
        }
        get bufferedAmount() {
          return x.brandCheck(this, t2), this.#t;
        }
        get url() {
          return x.brandCheck(this, t2), NJ(this.#a);
        }
        get extensions() {
          return x.brandCheck(this, t2), this.#n;
        }
        get protocol() {
          return x.brandCheck(this, t2), this.#r;
        }
        get onopen() {
          return x.brandCheck(this, t2), this.#e.open;
        }
        set onopen(e) {
          x.brandCheck(this, t2), this.#e.open && this.removeEventListener("open", this.#e.open), typeof e == "function" ? (this.#e.open = e, this.addEventListener("open", e)) : this.#e.open = null;
        }
        get onerror() {
          return x.brandCheck(this, t2), this.#e.error;
        }
        set onerror(e) {
          x.brandCheck(this, t2), this.#e.error && this.removeEventListener("error", this.#e.error), typeof e == "function" ? (this.#e.error = e, this.addEventListener("error", e)) : this.#e.error = null;
        }
        get onclose() {
          return x.brandCheck(this, t2), this.#e.close;
        }
        set onclose(e) {
          x.brandCheck(this, t2), this.#e.close && this.removeEventListener("close", this.#e.close), typeof e == "function" ? (this.#e.close = e, this.addEventListener("close", e)) : this.#e.close = null;
        }
        get onmessage() {
          return x.brandCheck(this, t2), this.#e.message;
        }
        set onmessage(e) {
          x.brandCheck(this, t2), this.#e.message && this.removeEventListener("message", this.#e.message), typeof e == "function" ? (this.#e.message = e, this.addEventListener("message", e)) : this.#e.message = null;
        }
        get binaryType() {
          return x.brandCheck(this, t2), this.#s;
        }
        set binaryType(e) {
          x.brandCheck(this, t2), e !== "blob" && e !== "arraybuffer" ? this.#s = "blob" : this.#s = e;
        }
        #c(e, r2) {
          this.#A.socket = e.socket;
          let n2 = new YJ(this.#A, r2);
          n2.on("drain", () => this.#A.onParserDrain()), n2.on("error", (s) => this.#A.onParserError(s)), this.#o = n2, this.#i = new HJ(e.socket), this.#A.readyState = er.OPEN;
          let A2 = e.headersList.get("sec-websocket-extensions");
          A2 !== null && (this.#n = A2);
          let i2 = e.headersList.get("sec-websocket-protocol");
          i2 !== null && (this.#r = i2), Vs("open", this);
        }
        #g(e, r2) {
          r2 && Vs("error", this, (n2, A2) => new OJ(n2, A2), { error: new Error(r2), message: r2 }), this.#A.wasEverConnected || (this.#A.readyState = er.CLOSED, Vs("close", this, (n2, A2) => new _R(n2, A2), { wasClean: false, code: e, reason: r2 }));
        }
        #l(e, r2) {
          if (this.#A.readyState !== er.OPEN) return;
          let n2;
          if (e === JR.TEXT) try {
            n2 = kJ(r2);
          } catch {
            WR(this.#A, 1007, "Received invalid UTF-8 in text frame.");
            return;
          }
          else e === JR.BINARY && (this.#s === "blob" ? n2 = new Blob([r2]) : n2 = MJ(r2));
          Vs("message", this, VJ, { origin: this.#a.origin, data: n2 });
        }
        #u() {
          this.#A.socket.resume();
        }
        #E() {
          let e = this.#A.closeState.has(Th.SENT) && this.#A.closeState.has(Th.RECEIVED), r2 = 1005, n2 = "", A2 = this.#o.closingInfo;
          A2 && !A2.error ? (r2 = A2.code ?? 1005, n2 = A2.reason) : this.#A.closeState.has(Th.RECEIVED) || (r2 = 1006), this.#A.readyState = er.CLOSED, Vs("close", this, (i2, s) => new _R(i2, s), { wasClean: e, code: r2, reason: n2 }), Cl.close.hasSubscribers && Cl.close.publish({ websocket: this, code: r2, reason: n2 });
        }
      };
      ot.CONNECTING = ot.prototype.CONNECTING = er.CONNECTING;
      ot.OPEN = ot.prototype.OPEN = er.OPEN;
      ot.CLOSING = ot.prototype.CLOSING = er.CLOSING;
      ot.CLOSED = ot.prototype.CLOSED = er.CLOSED;
      Object.defineProperties(ot.prototype, { CONNECTING: en, OPEN: en, CLOSING: en, CLOSED: en, url: It, readyState: It, bufferedAmount: It, onopen: It, onerror: It, onclose: It, close: It, onmessage: It, binaryType: It, send: It, extensions: It, protocol: It, [Symbol.toStringTag]: { value: "WebSocket", writable: false, enumerable: false, configurable: true } });
      Object.defineProperties(ot, { CONNECTING: en, OPEN: en, CLOSING: en, CLOSED: en });
      x.converters["sequence<DOMString>"] = x.sequenceConverter(x.converters.DOMString);
      x.converters["DOMString or sequence<DOMString>"] = function(t2, e, r2) {
        return x.util.Type(t2) === x.util.Types.OBJECT && Symbol.iterator in t2 ? x.converters["sequence<DOMString>"](t2) : x.converters.DOMString(t2, e, r2);
      };
      x.converters.WebSocketInit = x.dictionaryConverter([{ key: "protocols", converter: x.converters["DOMString or sequence<DOMString>"], defaultValue: /* @__PURE__ */ __name(() => new Array(0), "defaultValue") }, { key: "dispatcher", converter: x.converters.any, defaultValue: /* @__PURE__ */ __name(() => GJ(), "defaultValue") }, { key: "headers", converter: x.nullableConverter(x.converters.HeadersInit) }]);
      x.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(t2) {
        return x.util.Type(t2) === x.util.Types.OBJECT && !(Symbol.iterator in t2) ? x.converters.WebSocketInit(t2) : { protocols: x.converters["DOMString or sequence<DOMString>"](t2) };
      };
      x.converters.WebSocketSendData = function(t2) {
        return x.util.Type(t2) === x.util.Types.OBJECT && (x.is.Blob(t2) || ArrayBuffer.isView(t2) || jR.isArrayBuffer(t2)) ? t2 : x.converters.USVString(t2);
      };
      ZR.exports = { WebSocket: ot };
    });
    var xh = C2((lz, zR) => {
      "use strict";
      var { webidl: Il } = Te(), { validateCloseCodeAndReason: qJ } = Ln(), { kConstruct: KR } = ne(), { kEnumerableProperty: $R } = Y2(), Pn = class t2 extends DOMException {
        static {
          __name(this, "t");
        }
        #e;
        #t;
        constructor(e = "", r2 = void 0) {
          if (e = Il.converters.DOMString(e, "WebSocketError", "message"), super(e, "WebSocketError"), r2 === KR) return;
          r2 !== null && (r2 = Il.converters.WebSocketCloseInfo(r2));
          let n2 = r2.closeCode ?? null, A2 = r2.reason ?? "";
          qJ(n2, A2), A2.length !== 0 && n2 === null && (n2 = 1e3), this.#e = n2, this.#t = A2;
        }
        get closeCode() {
          return this.#e;
        }
        get reason() {
          return this.#t;
        }
        static createUnvalidatedWebSocketError(e, r2, n2) {
          let A2 = new t2(e, KR);
          return A2.#e = r2, A2.#t = n2, A2;
        }
      }, { createUnvalidatedWebSocketError: JJ } = Pn;
      delete Pn.createUnvalidatedWebSocketError;
      Object.defineProperties(Pn.prototype, { closeCode: $R, reason: $R, [Symbol.toStringTag]: { value: "WebSocketError", writable: false, enumerable: false, configurable: true } });
      Il.is.WebSocketError = Il.util.MakeTypeAssertion(Pn);
      zR.exports = { WebSocketError: Pn, createUnvalidatedWebSocketError: JJ };
    });
    var AS = C2((uz, nS) => {
      "use strict";
      var { createDeferredPromise: Uh, environmentSettingsObject: eS } = Ve(), { states: ni, opcodes: pl, sentCloseFrameState: Ai } = zr(), { webidl: Pe } = Te(), { getURLRecord: WJ, isValidSubprotocol: _J, isEstablished: jJ, utf8Decode: ZJ } = Ln(), { establishWebSocketConnection: XJ, failWebsocketConnection: kh, closeWebSocketConnection: Mh } = El(), { types: KJ } = __require("node:util"), { channels: tS } = lr(), { WebsocketFrameSend: $J } = Gs(), { ByteParser: zJ } = bh(), { WebSocketError: eW, createUnvalidatedWebSocketError: tW } = xh(), { utf8DecodeBytes: rW } = Ve(), { kEnumerableProperty: Bl } = Y2(), rS = false, ml = class {
        static {
          __name(this, "ml");
        }
        #e;
        #t;
        #r;
        #n;
        #i;
        #A;
        #a = false;
        #s = { onConnectionEstablished: /* @__PURE__ */ __name((e, r2) => this.#g(e, r2), "onConnectionEstablished"), onFail: /* @__PURE__ */ __name((e, r2) => {
        }, "onFail"), onMessage: /* @__PURE__ */ __name((e, r2) => this.#l(e, r2), "onMessage"), onParserError: /* @__PURE__ */ __name((e) => kh(this.#s, null, e.message), "onParserError"), onParserDrain: /* @__PURE__ */ __name(() => this.#s.socket.resume(), "onParserDrain"), onSocketData: /* @__PURE__ */ __name((e) => {
          this.#o.write(e) || this.#s.socket.pause();
        }, "onSocketData"), onSocketError: /* @__PURE__ */ __name((e) => {
          this.#s.readyState = ni.CLOSING, tS.socketError.hasSubscribers && tS.socketError.publish(e), this.#s.socket.destroy();
        }, "onSocketError"), onSocketClose: /* @__PURE__ */ __name(() => this.#u(), "onSocketClose"), readyState: ni.CONNECTING, socket: null, closeState: /* @__PURE__ */ new Set(), controller: null, wasEverConnected: false };
        #o;
        constructor(e, r2 = void 0) {
          rS || (process.emitWarning("WebSocketStream is experimental! Expect it to change at any time.", { code: "UNDICI-WSS" }), rS = true), Pe.argumentLengthCheck(arguments, 1, "WebSocket"), e = Pe.converters.USVString(e), r2 !== null && (r2 = Pe.converters.WebSocketStreamOptions(r2));
          let n2 = eS.settingsObject.baseUrl, A2 = WJ(e, n2), i2 = r2.protocols;
          if (i2.length !== new Set(i2.map((o2) => o2.toLowerCase())).size) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          if (i2.length > 0 && !i2.every((o2) => _J(o2))) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          if (this.#e = A2.toString(), this.#t = Uh(), this.#r = Uh(), r2.signal != null) {
            let o2 = r2.signal;
            if (o2.aborted) {
              this.#t.reject(o2.reason), this.#r.reject(o2.reason);
              return;
            }
            o2.addEventListener("abort", () => {
              jJ(this.#s.readyState) || (kh(this.#s), this.#s.readyState = ni.CLOSING, this.#t.reject(o2.reason), this.#r.reject(o2.reason), this.#a = true);
            }, { once: true });
          }
          let s = eS.settingsObject;
          this.#s.controller = XJ(A2, i2, s, this.#s, r2);
        }
        get url() {
          return this.#e.toString();
        }
        get opened() {
          return this.#t.promise;
        }
        get closed() {
          return this.#r.promise;
        }
        close(e = void 0) {
          e !== null && (e = Pe.converters.WebSocketCloseInfo(e));
          let r2 = e.closeCode ?? null, n2 = e.reason;
          Mh(this.#s, r2, n2, true);
        }
        #c(e) {
          let r2 = Uh(), n2 = null, A2 = null;
          if (ArrayBuffer.isView(e) || KJ.isArrayBuffer(e)) n2 = new Uint8Array(ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e), A2 = pl.BINARY;
          else {
            let i2;
            try {
              i2 = Pe.converters.DOMString(e);
            } catch (s) {
              r2.reject(s);
              return;
            }
            n2 = new TextEncoder().encode(i2), A2 = pl.TEXT;
          }
          if (!this.#s.closeState.has(Ai.SENT) && !this.#s.closeState.has(Ai.RECEIVED)) {
            let i2 = new $J(n2);
            this.#s.socket.write(i2.createFrame(A2), () => {
              r2.resolve(void 0);
            });
          }
          return r2;
        }
        #g(e, r2) {
          this.#s.socket = e.socket;
          let n2 = new zJ(this.#s, r2);
          n2.on("drain", () => this.#s.onParserDrain()), n2.on("error", (a2) => this.#s.onParserError(a2)), this.#o = n2, this.#s.readyState = ni.OPEN;
          let A2 = r2 ?? "", i2 = e.headersList.get("sec-websocket-protocol") ?? "", s = new ReadableStream({ start: /* @__PURE__ */ __name((a2) => {
            this.#i = a2;
          }, "start"), pull(a2) {
            let c2;
            for (; a2.desiredSize > 0 && (c2 = e.socket.read()) !== null; ) a2.enqueue(c2);
          }, cancel: /* @__PURE__ */ __name((a2) => this.#d(a2), "cancel") }), o2 = new WritableStream({ write: /* @__PURE__ */ __name((a2) => this.#c(a2), "write"), close: /* @__PURE__ */ __name(() => Mh(this.#s, null, null), "close"), abort: /* @__PURE__ */ __name((a2) => this.#E(a2), "abort") });
          this.#n = s, this.#A = o2, this.#t.resolve({ extensions: A2, protocol: i2, readable: s, writable: o2 });
        }
        #l(e, r2) {
          if (this.#s.readyState !== ni.OPEN) return;
          let n2;
          if (e === pl.TEXT) try {
            n2 = ZJ(r2);
          } catch {
            kh(this.#s, "Received invalid UTF-8 in text frame.");
            return;
          }
          else e === pl.BINARY && (n2 = new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength));
          this.#i.enqueue(n2);
        }
        #u() {
          let e = this.#s.closeState.has(Ai.SENT) && this.#s.closeState.has(Ai.RECEIVED);
          if (this.#s.readyState = ni.CLOSED, this.#a) return;
          this.#s.wasEverConnected || this.#t.reject(new eW("Socket never opened"));
          let r2 = this.#o.closingInfo, n2 = r2?.code ?? 1005;
          !this.#s.closeState.has(Ai.SENT) && !this.#s.closeState.has(Ai.RECEIVED) && (n2 = 1006);
          let A2 = r2?.reason == null ? "" : rW(Buffer.from(r2.reason));
          if (e) this.#n.cancel().catch(() => {
          }), this.#A.locked || this.#A.abort(new DOMException("A closed WebSocketStream cannot be written to", "InvalidStateError")), this.#r.resolve({ closeCode: n2, reason: A2 });
          else {
            let i2 = tW("unclean close", n2, A2);
            this.#i.error(i2), this.#A.abort(i2), this.#r.reject(i2);
          }
        }
        #E(e) {
          let r2 = null, n2 = "";
          Pe.is.WebSocketError(e) && (r2 = e.closeCode, n2 = e.reason), Mh(this.#s, r2, n2);
        }
        #d(e) {
          this.#E(e);
        }
      };
      Object.defineProperties(ml.prototype, { url: Bl, opened: Bl, closed: Bl, close: Bl, [Symbol.toStringTag]: { value: "WebSocketStream", writable: false, enumerable: false, configurable: true } });
      Pe.converters.WebSocketStreamOptions = Pe.dictionaryConverter([{ key: "protocols", converter: Pe.sequenceConverter(Pe.converters.USVString), defaultValue: /* @__PURE__ */ __name(() => [], "defaultValue") }, { key: "signal", converter: Pe.nullableConverter(Pe.converters.AbortSignal), defaultValue: /* @__PURE__ */ __name(() => null, "defaultValue") }]);
      Pe.converters.WebSocketCloseInfo = Pe.dictionaryConverter([{ key: "closeCode", converter: /* @__PURE__ */ __name((t2) => Pe.converters["unsigned short"](t2, { enforceRange: true }), "converter") }, { key: "reason", converter: Pe.converters.USVString, defaultValue: /* @__PURE__ */ __name(() => "", "defaultValue") }]);
      nS.exports = { WebSocketStream: ml };
    });
    var Lh = C2((gz, iS) => {
      "use strict";
      function nW(t2) {
        return t2.indexOf("\0") === -1;
      }
      __name(nW, "nW");
      function AW(t2) {
        if (t2.length === 0) return false;
        for (let e = 0; e < t2.length; e++) if (t2.charCodeAt(e) < 48 || t2.charCodeAt(e) > 57) return false;
        return true;
      }
      __name(AW, "AW");
      function iW(t2) {
        return new Promise((e) => {
          setTimeout(e, t2).unref();
        });
      }
      __name(iW, "iW");
      iS.exports = { isValidLastEventId: nW, isASCIINumber: AW, delay: iW };
    });
    var cS = C2((Ez, aS) => {
      "use strict";
      var { Transform: sW } = __require("node:stream"), { isASCIINumber: sS, isValidLastEventId: oS } = Lh(), yr = [239, 187, 191], vh = 10, yl = 13, oW = 58, aW = 32, Ph = class extends sW {
        static {
          __name(this, "Ph");
        }
        state;
        checkBOM = true;
        crlfCheck = false;
        eventEndCheck = false;
        buffer = null;
        pos = 0;
        event = { data: void 0, event: void 0, id: void 0, retry: void 0 };
        constructor(e = {}) {
          e.readableObjectMode = true, super(e), this.state = e.eventSourceSettings || {}, e.push && (this.push = e.push);
        }
        _transform(e, r2, n2) {
          if (e.length === 0) {
            n2();
            return;
          }
          if (this.buffer ? this.buffer = Buffer.concat([this.buffer, e]) : this.buffer = e, this.checkBOM) switch (this.buffer.length) {
            case 1:
              if (this.buffer[0] === yr[0]) {
                n2();
                return;
              }
              this.checkBOM = false, n2();
              return;
            case 2:
              if (this.buffer[0] === yr[0] && this.buffer[1] === yr[1]) {
                n2();
                return;
              }
              this.checkBOM = false;
              break;
            case 3:
              if (this.buffer[0] === yr[0] && this.buffer[1] === yr[1] && this.buffer[2] === yr[2]) {
                this.buffer = Buffer.alloc(0), this.checkBOM = false, n2();
                return;
              }
              this.checkBOM = false;
              break;
            default:
              this.buffer[0] === yr[0] && this.buffer[1] === yr[1] && this.buffer[2] === yr[2] && (this.buffer = this.buffer.subarray(3)), this.checkBOM = false;
              break;
          }
          for (; this.pos < this.buffer.length; ) {
            if (this.eventEndCheck) {
              if (this.crlfCheck) {
                if (this.buffer[this.pos] === vh) {
                  this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.crlfCheck = false;
                  continue;
                }
                this.crlfCheck = false;
              }
              if (this.buffer[this.pos] === vh || this.buffer[this.pos] === yl) {
                this.buffer[this.pos] === yl && (this.crlfCheck = true), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) && this.processEvent(this.event), this.clearEvent();
                continue;
              }
              this.eventEndCheck = false;
              continue;
            }
            if (this.buffer[this.pos] === vh || this.buffer[this.pos] === yl) {
              this.buffer[this.pos] === yl && (this.crlfCheck = true), this.parseLine(this.buffer.subarray(0, this.pos), this.event), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.eventEndCheck = true;
              continue;
            }
            this.pos++;
          }
          n2();
        }
        parseLine(e, r2) {
          if (e.length === 0) return;
          let n2 = e.indexOf(oW);
          if (n2 === 0) return;
          let A2 = "", i2 = "";
          if (n2 !== -1) {
            A2 = e.subarray(0, n2).toString("utf8");
            let s = n2 + 1;
            e[s] === aW && ++s, i2 = e.subarray(s).toString("utf8");
          } else A2 = e.toString("utf8"), i2 = "";
          switch (A2) {
            case "data":
              r2[A2] === void 0 ? r2[A2] = i2 : r2[A2] += `
${i2}`;
              break;
            case "retry":
              sS(i2) && (r2[A2] = i2);
              break;
            case "id":
              oS(i2) && (r2[A2] = i2);
              break;
            case "event":
              i2.length > 0 && (r2[A2] = i2);
              break;
          }
        }
        processEvent(e) {
          e.retry && sS(e.retry) && (this.state.reconnectionTime = parseInt(e.retry, 10)), e.id && oS(e.id) && (this.state.lastEventId = e.id), e.data !== void 0 && this.push({ type: e.event || "message", options: { data: e.data, lastEventId: this.state.lastEventId, origin: this.state.origin } });
        }
        clearEvent() {
          this.event = { data: void 0, event: void 0, id: void 0, retry: void 0 };
        }
      };
      aS.exports = { EventSourceStream: Ph };
    });
    var QS = C2((dz, fS) => {
      "use strict";
      var { pipeline: cW } = __require("node:stream"), { fetching: lW } = Ms(), { makeRequest: uW } = XA(), { webidl: wr } = Te(), { EventSourceStream: gW } = cS(), { parseMIMEType: EW } = tt(), { createFastMessageEvent: dW } = cl(), { isNetworkError: lS } = Us(), { delay: hW } = Lh(), { kEnumerableProperty: Yn } = Y2(), { environmentSettingsObject: uS } = Ve(), gS = false, ES = 3e3, Hs = 0, dS = 1, qs = 2, fW = "anonymous", QW = "use-credentials", ii = class t2 extends EventTarget {
        static {
          __name(this, "t");
        }
        #e = { open: null, error: null, message: null };
        #t;
        #r = false;
        #n = Hs;
        #i = null;
        #A = null;
        #a;
        #s;
        constructor(e, r2 = {}) {
          super(), wr.util.markAsUncloneable(this);
          let n2 = "EventSource constructor";
          wr.argumentLengthCheck(arguments, 1, n2), gS || (gS = true, process.emitWarning("EventSource is experimental, expect them to change at any time.", { code: "UNDICI-ES" })), e = wr.converters.USVString(e), r2 = wr.converters.EventSourceInitDict(r2, n2, "eventSourceInitDict"), this.#a = r2.dispatcher, this.#s = { lastEventId: "", reconnectionTime: ES };
          let A2 = uS, i2;
          try {
            i2 = new URL(e, A2.settingsObject.baseUrl), this.#s.origin = i2.origin;
          } catch (a2) {
            throw new DOMException(a2, "SyntaxError");
          }
          this.#t = i2.href;
          let s = fW;
          r2.withCredentials === true && (s = QW, this.#r = true);
          let o2 = { redirect: "follow", keepalive: true, mode: "cors", credentials: s === "anonymous" ? "same-origin" : "omit", referrer: "no-referrer" };
          o2.client = uS.settingsObject, o2.headersList = [["accept", { name: "accept", value: "text/event-stream" }]], o2.cache = "no-store", o2.initiator = "other", o2.urlList = [new URL(this.#t)], this.#i = uW(o2), this.#o();
        }
        get readyState() {
          return this.#n;
        }
        get url() {
          return this.#t;
        }
        get withCredentials() {
          return this.#r;
        }
        #o() {
          if (this.#n === qs) return;
          this.#n = Hs;
          let e = { request: this.#i, dispatcher: this.#a }, r2 = /* @__PURE__ */ __name((n2) => {
            lS(n2) && (this.dispatchEvent(new Event("error")), this.close()), this.#c();
          }, "r");
          e.processResponseEndOfBody = r2, e.processResponse = (n2) => {
            if (lS(n2)) if (n2.aborted) {
              this.close(), this.dispatchEvent(new Event("error"));
              return;
            } else {
              this.#c();
              return;
            }
            let A2 = n2.headersList.get("content-type", true), i2 = A2 !== null ? EW(A2) : "failure", s = i2 !== "failure" && i2.essence === "text/event-stream";
            if (n2.status !== 200 || s === false) {
              this.close(), this.dispatchEvent(new Event("error"));
              return;
            }
            this.#n = dS, this.dispatchEvent(new Event("open")), this.#s.origin = n2.urlList[n2.urlList.length - 1].origin;
            let o2 = new gW({ eventSourceSettings: this.#s, push: /* @__PURE__ */ __name((a2) => {
              this.dispatchEvent(dW(a2.type, a2.options));
            }, "push") });
            cW(n2.body.stream, o2, (a2) => {
              a2?.aborted === false && (this.close(), this.dispatchEvent(new Event("error")));
            });
          }, this.#A = lW(e);
        }
        async #c() {
          this.#n !== qs && (this.#n = Hs, this.dispatchEvent(new Event("error")), await hW(this.#s.reconnectionTime), this.#n === Hs && (this.#s.lastEventId.length && this.#i.headersList.set("last-event-id", this.#s.lastEventId, true), this.#o()));
        }
        close() {
          wr.brandCheck(this, t2), this.#n !== qs && (this.#n = qs, this.#A.abort(), this.#i = null);
        }
        get onopen() {
          return this.#e.open;
        }
        set onopen(e) {
          this.#e.open && this.removeEventListener("open", this.#e.open), typeof e == "function" ? (this.#e.open = e, this.addEventListener("open", e)) : this.#e.open = null;
        }
        get onmessage() {
          return this.#e.message;
        }
        set onmessage(e) {
          this.#e.message && this.removeEventListener("message", this.#e.message), typeof e == "function" ? (this.#e.message = e, this.addEventListener("message", e)) : this.#e.message = null;
        }
        get onerror() {
          return this.#e.error;
        }
        set onerror(e) {
          this.#e.error && this.removeEventListener("error", this.#e.error), typeof e == "function" ? (this.#e.error = e, this.addEventListener("error", e)) : this.#e.error = null;
        }
      }, hS = { CONNECTING: { __proto__: null, configurable: false, enumerable: true, value: Hs, writable: false }, OPEN: { __proto__: null, configurable: false, enumerable: true, value: dS, writable: false }, CLOSED: { __proto__: null, configurable: false, enumerable: true, value: qs, writable: false } };
      Object.defineProperties(ii, hS);
      Object.defineProperties(ii.prototype, hS);
      Object.defineProperties(ii.prototype, { close: Yn, onerror: Yn, onmessage: Yn, onopen: Yn, readyState: Yn, url: Yn, withCredentials: Yn });
      wr.converters.EventSourceInitDict = wr.dictionaryConverter([{ key: "withCredentials", converter: wr.converters.boolean, defaultValue: /* @__PURE__ */ __name(() => false, "defaultValue") }, { key: "dispatcher", converter: wr.converters.any }]);
      fS.exports = { EventSource: ii, defaultReconnectionTime: ES };
    });
    var BS = C2((hz, T2) => {
      "use strict";
      var CW = fs(), CS = $i(), IW = LA(), pW = by(), BW = vA(), mW = XE(), yW = Jy(), wW = Ky(), IS = H(), Dl = Y2(), { InvalidArgumentError: wl } = IS, si = xw(), DW = es(), RW = xd(), SW = ED(), bW = Md(), NW = Cd(), FW = pc(), { getGlobalDispatcher: pS, setGlobalDispatcher: TW } = kc(), xW = bs(), UW = Od();
      Object.assign(CS.prototype, si);
      T2.exports.Dispatcher = CS;
      T2.exports.Client = CW;
      T2.exports.Pool = IW;
      T2.exports.BalancedPool = pW;
      T2.exports.Agent = BW;
      T2.exports.ProxyAgent = mW;
      T2.exports.EnvHttpProxyAgent = yW;
      T2.exports.RetryAgent = wW;
      T2.exports.RetryHandler = FW;
      T2.exports.DecoratorHandler = xW;
      T2.exports.RedirectHandler = UW;
      T2.exports.interceptors = { redirect: DD(), responseError: SD(), retry: ND(), dump: TD(), dns: UD(), cache: XD() };
      T2.exports.cacheStores = { MemoryCacheStore: Xd() };
      var kW = zD();
      T2.exports.cacheStores.SqliteCacheStore = kW;
      T2.exports.buildConnector = DW;
      T2.exports.errors = IS;
      T2.exports.util = { parseHeaders: Dl.parseHeaders, headerNameToString: Dl.headerNameToString };
      function Js(t2) {
        return (e, r2, n2) => {
          if (typeof r2 == "function" && (n2 = r2, r2 = null), !e || typeof e != "string" && typeof e != "object" && !(e instanceof URL)) throw new wl("invalid url");
          if (r2 != null && typeof r2 != "object") throw new wl("invalid opts");
          if (r2 && r2.path != null) {
            if (typeof r2.path != "string") throw new wl("invalid opts.path");
            let s = r2.path;
            r2.path.startsWith("/") || (s = `/${s}`), e = new URL(Dl.parseOrigin(e).origin + s);
          } else r2 || (r2 = typeof e == "object" ? e : {}), e = Dl.parseURL(e);
          let { agent: A2, dispatcher: i2 = pS() } = r2;
          if (A2) throw new wl("unsupported opts.agent. Did you mean opts.client?");
          return t2.call(i2, { ...r2, origin: e.origin, path: e.search ? `${e.pathname}${e.search}` : e.pathname, method: r2.method || (r2.body ? "PUT" : "GET") }, n2);
        };
      }
      __name(Js, "Js");
      T2.exports.setGlobalDispatcher = TW;
      T2.exports.getGlobalDispatcher = pS;
      var MW = Ms().fetch;
      T2.exports.fetch = async function(e, r2 = void 0) {
        try {
          return await MW(e, r2);
        } catch (n2) {
          throw n2 && typeof n2 == "object" && Error.captureStackTrace(n2), n2;
        }
      };
      T2.exports.Headers = Tn().Headers;
      T2.exports.Response = Us().Response;
      T2.exports.Request = XA().Request;
      T2.exports.FormData = Za().FormData;
      var { setGlobalOrigin: LW, getGlobalOrigin: vW } = Xg();
      T2.exports.setGlobalOrigin = LW;
      T2.exports.getGlobalOrigin = vW;
      var { CacheStorage: PW } = nR(), { kConstruct: YW } = ne();
      T2.exports.caches = new PW(YW);
      var { deleteCookie: GW, getCookies: OW, getSetCookies: VW, setCookie: HW, parseCookie: qW } = fR();
      T2.exports.deleteCookie = GW;
      T2.exports.getCookies = OW;
      T2.exports.getSetCookies = VW;
      T2.exports.setCookie = HW;
      T2.exports.parseCookie = qW;
      var { parseMIMEType: JW, serializeAMimeType: WW } = tt();
      T2.exports.parseMIMEType = JW;
      T2.exports.serializeAMimeType = WW;
      var { CloseEvent: _W, ErrorEvent: jW, MessageEvent: ZW } = cl();
      T2.exports.WebSocket = XR().WebSocket;
      T2.exports.CloseEvent = _W;
      T2.exports.ErrorEvent = jW;
      T2.exports.MessageEvent = ZW;
      T2.exports.WebSocketStream = AS().WebSocketStream;
      T2.exports.WebSocketError = xh().WebSocketError;
      T2.exports.request = Js(si.request);
      T2.exports.stream = Js(si.stream);
      T2.exports.pipeline = Js(si.pipeline);
      T2.exports.connect = Js(si.connect);
      T2.exports.upgrade = Js(si.upgrade);
      T2.exports.MockClient = RW;
      T2.exports.MockPool = bW;
      T2.exports.MockAgent = SW;
      T2.exports.mockErrors = NW;
      var { EventSource: XW } = QS();
      T2.exports.EventSource = XW;
    });
    var x_ = {};
    Jn(x_, { DMMF: /* @__PURE__ */ __name(() => Ui, "DMMF"), Debug: /* @__PURE__ */ __name(() => ce, "Debug"), Decimal: /* @__PURE__ */ __name(() => ar, "Decimal"), Extensions: /* @__PURE__ */ __name(() => Ml, "Extensions"), MetricsClient: /* @__PURE__ */ __name(() => fA, "MetricsClient"), PrismaClientInitializationError: /* @__PURE__ */ __name(() => Z, "PrismaClientInitializationError"), PrismaClientKnownRequestError: /* @__PURE__ */ __name(() => Ne, "PrismaClientKnownRequestError"), PrismaClientRustPanicError: /* @__PURE__ */ __name(() => ut, "PrismaClientRustPanicError"), PrismaClientUnknownRequestError: /* @__PURE__ */ __name(() => Be, "PrismaClientUnknownRequestError"), PrismaClientValidationError: /* @__PURE__ */ __name(() => Ue, "PrismaClientValidationError"), Public: /* @__PURE__ */ __name(() => Ll, "Public"), Sql: /* @__PURE__ */ __name(() => _e, "Sql"), createParam: /* @__PURE__ */ __name(() => DI, "createParam"), defineDmmfProperty: /* @__PURE__ */ __name(() => TI, "defineDmmfProperty"), deserializeJsonResponse: /* @__PURE__ */ __name(() => ai, "deserializeJsonResponse"), deserializeRawResult: /* @__PURE__ */ __name(() => xl, "deserializeRawResult"), dmmfToRuntimeDataModel: /* @__PURE__ */ __name(() => vC, "dmmfToRuntimeDataModel"), empty: /* @__PURE__ */ __name(() => kI, "empty"), getPrismaClient: /* @__PURE__ */ __name(() => Ib, "getPrismaClient"), getRuntime: /* @__PURE__ */ __name(() => up, "getRuntime"), join: /* @__PURE__ */ __name(() => UI, "join"), makeStrictEnum: /* @__PURE__ */ __name(() => pb, "makeStrictEnum"), makeTypedQueryFactory: /* @__PURE__ */ __name(() => xI, "makeTypedQueryFactory"), objectEnumValues: /* @__PURE__ */ __name(() => ca, "objectEnumValues"), raw: /* @__PURE__ */ __name(() => Wu, "raw"), serializeJsonQuery: /* @__PURE__ */ __name(() => fa, "serializeJsonQuery"), skip: /* @__PURE__ */ __name(() => ha, "skip"), sqltag: /* @__PURE__ */ __name(() => _u, "sqltag"), warnEnvConflicts: /* @__PURE__ */ __name(() => Bb, "warnEnvConflicts"), warnOnce: /* @__PURE__ */ __name(() => Fi, "warnOnce") });
    module.exports = Sb(x_);
    var Ml = {};
    Jn(Ml, { defineExtension: /* @__PURE__ */ __name(() => ef, "defineExtension"), getExtensionContext: /* @__PURE__ */ __name(() => tf, "getExtensionContext") });
    function ef(t2) {
      return typeof t2 == "function" ? t2 : (e) => e.$extends(t2);
    }
    __name(ef, "ef");
    function tf(t2) {
      return t2;
    }
    __name(tf, "tf");
    var Ll = {};
    Jn(Ll, { validator: /* @__PURE__ */ __name(() => rf, "validator") });
    function rf(...t2) {
      return (e) => e;
    }
    __name(rf, "rf");
    var lo = {};
    Jn(lo, { $: /* @__PURE__ */ __name(() => af, "$"), bgBlack: /* @__PURE__ */ __name(() => vb, "bgBlack"), bgBlue: /* @__PURE__ */ __name(() => Ob, "bgBlue"), bgCyan: /* @__PURE__ */ __name(() => Hb, "bgCyan"), bgGreen: /* @__PURE__ */ __name(() => Yb, "bgGreen"), bgMagenta: /* @__PURE__ */ __name(() => Vb, "bgMagenta"), bgRed: /* @__PURE__ */ __name(() => Pb, "bgRed"), bgWhite: /* @__PURE__ */ __name(() => qb, "bgWhite"), bgYellow: /* @__PURE__ */ __name(() => Gb, "bgYellow"), black: /* @__PURE__ */ __name(() => Ub, "black"), blue: /* @__PURE__ */ __name(() => An, "blue"), bold: /* @__PURE__ */ __name(() => be, "bold"), cyan: /* @__PURE__ */ __name(() => nr, "cyan"), dim: /* @__PURE__ */ __name(() => nn, "dim"), gray: /* @__PURE__ */ __name(() => hi, "gray"), green: /* @__PURE__ */ __name(() => Sr, "green"), grey: /* @__PURE__ */ __name(() => Lb, "grey"), hidden: /* @__PURE__ */ __name(() => Tb, "hidden"), inverse: /* @__PURE__ */ __name(() => Fb, "inverse"), italic: /* @__PURE__ */ __name(() => Nb, "italic"), magenta: /* @__PURE__ */ __name(() => kb, "magenta"), red: /* @__PURE__ */ __name(() => at, "red"), reset: /* @__PURE__ */ __name(() => bb, "reset"), strikethrough: /* @__PURE__ */ __name(() => xb, "strikethrough"), underline: /* @__PURE__ */ __name(() => Je, "underline"), white: /* @__PURE__ */ __name(() => Mb, "white"), yellow: /* @__PURE__ */ __name(() => rr, "yellow") });
    var vl;
    var nf;
    var Af;
    var sf;
    var of = true;
    typeof process < "u" && ({ FORCE_COLOR: vl, NODE_DISABLE_COLORS: nf, NO_COLOR: Af, TERM: sf } = process.env || {}, of = process.stdout && process.stdout.isTTY);
    var af = { enabled: !nf && Af == null && sf !== "dumb" && (vl != null && vl !== "0" || of) };
    function Ae(t2, e) {
      let r2 = new RegExp(`\\x1b\\[${e}m`, "g"), n2 = `\x1B[${t2}m`, A2 = `\x1B[${e}m`;
      return function(i2) {
        return !af.enabled || i2 == null ? i2 : n2 + (~("" + i2).indexOf(A2) ? i2.replace(r2, A2 + n2) : i2) + A2;
      };
    }
    __name(Ae, "Ae");
    var bb = Ae(0, 0);
    var be = Ae(1, 22);
    var nn = Ae(2, 22);
    var Nb = Ae(3, 23);
    var Je = Ae(4, 24);
    var Fb = Ae(7, 27);
    var Tb = Ae(8, 28);
    var xb = Ae(9, 29);
    var Ub = Ae(30, 39);
    var at = Ae(31, 39);
    var Sr = Ae(32, 39);
    var rr = Ae(33, 39);
    var An = Ae(34, 39);
    var kb = Ae(35, 39);
    var nr = Ae(36, 39);
    var Mb = Ae(37, 39);
    var hi = Ae(90, 39);
    var Lb = Ae(90, 39);
    var vb = Ae(40, 49);
    var Pb = Ae(41, 49);
    var Yb = Ae(42, 49);
    var Gb = Ae(43, 49);
    var Ob = Ae(44, 49);
    var Vb = Ae(45, 49);
    var Hb = Ae(46, 49);
    var qb = Ae(47, 49);
    var Jb = 100;
    var cf = ["green", "yellow", "blue", "magenta", "cyan", "red"];
    var fi = [];
    var lf = Date.now();
    var Wb = 0;
    var Pl = typeof process < "u" ? process.env : {};
    globalThis.DEBUG ??= Pl.DEBUG ?? "";
    globalThis.DEBUG_COLORS ??= Pl.DEBUG_COLORS ? Pl.DEBUG_COLORS === "true" : true;
    var Qi = { enable(t2) {
      typeof t2 == "string" && (globalThis.DEBUG = t2);
    }, disable() {
      let t2 = globalThis.DEBUG;
      return globalThis.DEBUG = "", t2;
    }, enabled(t2) {
      let e = globalThis.DEBUG.split(",").map((A2) => A2.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), r2 = e.some((A2) => A2 === "" || A2[0] === "-" ? false : t2.match(RegExp(A2.split("*").join(".*") + "$"))), n2 = e.some((A2) => A2 === "" || A2[0] !== "-" ? false : t2.match(RegExp(A2.slice(1).split("*").join(".*") + "$")));
      return r2 && !n2;
    }, log: /* @__PURE__ */ __name((...t2) => {
      let [e, r2, ...n2] = t2;
      (console.warn ?? console.log)(`${e} ${r2}`, ...n2);
    }, "log"), formatters: {} };
    function _b(t2) {
      let e = { color: cf[Wb++ % cf.length], enabled: Qi.enabled(t2), namespace: t2, log: Qi.log, extend: /* @__PURE__ */ __name(() => {
      }, "extend") }, r2 = /* @__PURE__ */ __name((...n2) => {
        let { enabled: A2, namespace: i2, color: s, log: o2 } = e;
        if (n2.length !== 0 && fi.push([i2, ...n2]), fi.length > Jb && fi.shift(), Qi.enabled(i2) || A2) {
          let a2 = n2.map((l2) => typeof l2 == "string" ? l2 : jb(l2)), c2 = `+${Date.now() - lf}ms`;
          lf = Date.now(), globalThis.DEBUG_COLORS ? o2(lo[s](be(i2)), ...a2, lo[s](c2)) : o2(i2, ...a2, c2);
        }
      }, "r");
      return new Proxy(r2, { get: /* @__PURE__ */ __name((n2, A2) => e[A2], "get"), set: /* @__PURE__ */ __name((n2, A2, i2) => e[A2] = i2, "set") });
    }
    __name(_b, "_b");
    var ce = new Proxy(_b, { get: /* @__PURE__ */ __name((t2, e) => Qi[e], "get"), set: /* @__PURE__ */ __name((t2, e, r2) => Qi[e] = r2, "set") });
    function jb(t2, e = 2) {
      let r2 = /* @__PURE__ */ new Set();
      return JSON.stringify(t2, (n2, A2) => {
        if (typeof A2 == "object" && A2 !== null) {
          if (r2.has(A2)) return "[Circular *]";
          r2.add(A2);
        } else if (typeof A2 == "bigint") return A2.toString();
        return A2;
      }, e);
    }
    __name(jb, "jb");
    function uf(t2 = 7500) {
      let e = fi.map(([r2, ...n2]) => `${r2} ${n2.map((A2) => typeof A2 == "string" ? A2 : JSON.stringify(A2)).join(" ")}`).join(`
`);
      return e.length < t2 ? e : e.slice(-t2);
    }
    __name(uf, "uf");
    function gf() {
      fi.length = 0;
    }
    __name(gf, "gf");
    var Wn = ce;
    var Yl = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "freebsd15", "openbsd", "netbsd", "arm"];
    var uo = "libquery_engine";
    function go(t2, e) {
      let r2 = e === "url";
      return t2.includes("windows") ? r2 ? "query_engine.dll.node" : `query_engine-${t2}.dll.node` : t2.includes("darwin") ? r2 ? `${uo}.dylib.node` : `${uo}-${t2}.dylib.node` : r2 ? `${uo}.so.node` : `${uo}-${t2}.so.node`;
    }
    __name(go, "go");
    var ff = G2(__require("node:child_process"));
    var ql = G2(__require("node:fs/promises"));
    var Io = G2(__require("node:os"));
    var Ar = Symbol.for("@ts-pattern/matcher");
    var Zb = Symbol.for("@ts-pattern/isVariadic");
    var ho = "@ts-pattern/anonymous-select-key";
    var Gl = /* @__PURE__ */ __name((t2) => !!(t2 && typeof t2 == "object"), "Gl");
    var Eo = /* @__PURE__ */ __name((t2) => t2 && !!t2[Ar], "Eo");
    var xt = /* @__PURE__ */ __name((t2, e, r2) => {
      if (Eo(t2)) {
        let n2 = t2[Ar](), { matched: A2, selections: i2 } = n2.match(e);
        return A2 && i2 && Object.keys(i2).forEach((s) => r2(s, i2[s])), A2;
      }
      if (Gl(t2)) {
        if (!Gl(e)) return false;
        if (Array.isArray(t2)) {
          if (!Array.isArray(e)) return false;
          let n2 = [], A2 = [], i2 = [];
          for (let s of t2.keys()) {
            let o2 = t2[s];
            Eo(o2) && o2[Zb] ? i2.push(o2) : i2.length ? A2.push(o2) : n2.push(o2);
          }
          if (i2.length) {
            if (i2.length > 1) throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
            if (e.length < n2.length + A2.length) return false;
            let s = e.slice(0, n2.length), o2 = A2.length === 0 ? [] : e.slice(-A2.length), a2 = e.slice(n2.length, A2.length === 0 ? 1 / 0 : -A2.length);
            return n2.every((c2, l2) => xt(c2, s[l2], r2)) && A2.every((c2, l2) => xt(c2, o2[l2], r2)) && (i2.length === 0 || xt(i2[0], a2, r2));
          }
          return t2.length === e.length && t2.every((s, o2) => xt(s, e[o2], r2));
        }
        return Reflect.ownKeys(t2).every((n2) => {
          let A2 = t2[n2];
          return (n2 in e || Eo(i2 = A2) && i2[Ar]().matcherType === "optional") && xt(A2, e[n2], r2);
          var i2;
        });
      }
      return Object.is(e, t2);
    }, "xt");
    var xr = /* @__PURE__ */ __name((t2) => {
      var e, r2, n2;
      return Gl(t2) ? Eo(t2) ? (e = (r2 = (n2 = t2[Ar]()).getSelectionKeys) == null ? void 0 : r2.call(n2)) != null ? e : [] : Array.isArray(t2) ? Ci(t2, xr) : Ci(Object.values(t2), xr) : [];
    }, "xr");
    var Ci = /* @__PURE__ */ __name((t2, e) => t2.reduce((r2, n2) => r2.concat(e(n2)), []), "Ci");
    function ct(t2) {
      return Object.assign(t2, { optional: /* @__PURE__ */ __name(() => Xb(t2), "optional"), and: /* @__PURE__ */ __name((e) => le(t2, e), "and"), or: /* @__PURE__ */ __name((e) => Kb(t2, e), "or"), select: /* @__PURE__ */ __name((e) => e === void 0 ? Ef(t2) : Ef(e, t2), "select") });
    }
    __name(ct, "ct");
    function Xb(t2) {
      return ct({ [Ar]: () => ({ match: /* @__PURE__ */ __name((e) => {
        let r2 = {}, n2 = /* @__PURE__ */ __name((A2, i2) => {
          r2[A2] = i2;
        }, "n");
        return e === void 0 ? (xr(t2).forEach((A2) => n2(A2, void 0)), { matched: true, selections: r2 }) : { matched: xt(t2, e, n2), selections: r2 };
      }, "match"), getSelectionKeys: /* @__PURE__ */ __name(() => xr(t2), "getSelectionKeys"), matcherType: "optional" }) });
    }
    __name(Xb, "Xb");
    function le(...t2) {
      return ct({ [Ar]: () => ({ match: /* @__PURE__ */ __name((e) => {
        let r2 = {}, n2 = /* @__PURE__ */ __name((A2, i2) => {
          r2[A2] = i2;
        }, "n");
        return { matched: t2.every((A2) => xt(A2, e, n2)), selections: r2 };
      }, "match"), getSelectionKeys: /* @__PURE__ */ __name(() => Ci(t2, xr), "getSelectionKeys"), matcherType: "and" }) });
    }
    __name(le, "le");
    function Kb(...t2) {
      return ct({ [Ar]: () => ({ match: /* @__PURE__ */ __name((e) => {
        let r2 = {}, n2 = /* @__PURE__ */ __name((A2, i2) => {
          r2[A2] = i2;
        }, "n");
        return Ci(t2, xr).forEach((A2) => n2(A2, void 0)), { matched: t2.some((A2) => xt(A2, e, n2)), selections: r2 };
      }, "match"), getSelectionKeys: /* @__PURE__ */ __name(() => Ci(t2, xr), "getSelectionKeys"), matcherType: "or" }) });
    }
    __name(Kb, "Kb");
    function j(t2) {
      return { [Ar]: () => ({ match: /* @__PURE__ */ __name((e) => ({ matched: !!t2(e) }), "match") }) };
    }
    __name(j, "j");
    function Ef(...t2) {
      let e = typeof t2[0] == "string" ? t2[0] : void 0, r2 = t2.length === 2 ? t2[1] : typeof t2[0] == "string" ? void 0 : t2[0];
      return ct({ [Ar]: () => ({ match: /* @__PURE__ */ __name((n2) => {
        let A2 = { [e ?? ho]: n2 };
        return { matched: r2 === void 0 || xt(r2, n2, (i2, s) => {
          A2[i2] = s;
        }), selections: A2 };
      }, "match"), getSelectionKeys: /* @__PURE__ */ __name(() => [e ?? ho].concat(r2 === void 0 ? [] : xr(r2)), "getSelectionKeys") }) });
    }
    __name(Ef, "Ef");
    function Ft(t2) {
      return typeof t2 == "number";
    }
    __name(Ft, "Ft");
    function br(t2) {
      return typeof t2 == "string";
    }
    __name(br, "br");
    function Nr(t2) {
      return typeof t2 == "bigint";
    }
    __name(Nr, "Nr");
    var q_ = ct(j(function(t2) {
      return true;
    }));
    var Fr = /* @__PURE__ */ __name((t2) => Object.assign(ct(t2), { startsWith: /* @__PURE__ */ __name((e) => {
      return Fr(le(t2, (r2 = e, j((n2) => br(n2) && n2.startsWith(r2)))));
      var r2;
    }, "startsWith"), endsWith: /* @__PURE__ */ __name((e) => {
      return Fr(le(t2, (r2 = e, j((n2) => br(n2) && n2.endsWith(r2)))));
      var r2;
    }, "endsWith"), minLength: /* @__PURE__ */ __name((e) => Fr(le(t2, ((r2) => j((n2) => br(n2) && n2.length >= r2))(e))), "minLength"), length: /* @__PURE__ */ __name((e) => Fr(le(t2, ((r2) => j((n2) => br(n2) && n2.length === r2))(e))), "length"), maxLength: /* @__PURE__ */ __name((e) => Fr(le(t2, ((r2) => j((n2) => br(n2) && n2.length <= r2))(e))), "maxLength"), includes: /* @__PURE__ */ __name((e) => {
      return Fr(le(t2, (r2 = e, j((n2) => br(n2) && n2.includes(r2)))));
      var r2;
    }, "includes"), regex: /* @__PURE__ */ __name((e) => {
      return Fr(le(t2, (r2 = e, j((n2) => br(n2) && !!n2.match(r2)))));
      var r2;
    }, "regex") }), "Fr");
    var J_ = Fr(j(br));
    var Tt = /* @__PURE__ */ __name((t2) => Object.assign(ct(t2), { between: /* @__PURE__ */ __name((e, r2) => Tt(le(t2, ((n2, A2) => j((i2) => Ft(i2) && n2 <= i2 && A2 >= i2))(e, r2))), "between"), lt: /* @__PURE__ */ __name((e) => Tt(le(t2, ((r2) => j((n2) => Ft(n2) && n2 < r2))(e))), "lt"), gt: /* @__PURE__ */ __name((e) => Tt(le(t2, ((r2) => j((n2) => Ft(n2) && n2 > r2))(e))), "gt"), lte: /* @__PURE__ */ __name((e) => Tt(le(t2, ((r2) => j((n2) => Ft(n2) && n2 <= r2))(e))), "lte"), gte: /* @__PURE__ */ __name((e) => Tt(le(t2, ((r2) => j((n2) => Ft(n2) && n2 >= r2))(e))), "gte"), int: /* @__PURE__ */ __name(() => Tt(le(t2, j((e) => Ft(e) && Number.isInteger(e)))), "int"), finite: /* @__PURE__ */ __name(() => Tt(le(t2, j((e) => Ft(e) && Number.isFinite(e)))), "finite"), positive: /* @__PURE__ */ __name(() => Tt(le(t2, j((e) => Ft(e) && e > 0))), "positive"), negative: /* @__PURE__ */ __name(() => Tt(le(t2, j((e) => Ft(e) && e < 0))), "negative") }), "Tt");
    var W_ = Tt(j(Ft));
    var Tr = /* @__PURE__ */ __name((t2) => Object.assign(ct(t2), { between: /* @__PURE__ */ __name((e, r2) => Tr(le(t2, ((n2, A2) => j((i2) => Nr(i2) && n2 <= i2 && A2 >= i2))(e, r2))), "between"), lt: /* @__PURE__ */ __name((e) => Tr(le(t2, ((r2) => j((n2) => Nr(n2) && n2 < r2))(e))), "lt"), gt: /* @__PURE__ */ __name((e) => Tr(le(t2, ((r2) => j((n2) => Nr(n2) && n2 > r2))(e))), "gt"), lte: /* @__PURE__ */ __name((e) => Tr(le(t2, ((r2) => j((n2) => Nr(n2) && n2 <= r2))(e))), "lte"), gte: /* @__PURE__ */ __name((e) => Tr(le(t2, ((r2) => j((n2) => Nr(n2) && n2 >= r2))(e))), "gte"), positive: /* @__PURE__ */ __name(() => Tr(le(t2, j((e) => Nr(e) && e > 0))), "positive"), negative: /* @__PURE__ */ __name(() => Tr(le(t2, j((e) => Nr(e) && e < 0))), "negative") }), "Tr");
    var __ = Tr(j(Nr));
    var j_ = ct(j(function(t2) {
      return typeof t2 == "boolean";
    }));
    var Z_ = ct(j(function(t2) {
      return typeof t2 == "symbol";
    }));
    var X_ = ct(j(function(t2) {
      return t2 == null;
    }));
    var K_ = ct(j(function(t2) {
      return t2 != null;
    }));
    var Ol = class extends Error {
      static {
        __name(this, "Ol");
      }
      constructor(e) {
        let r2;
        try {
          r2 = JSON.stringify(e);
        } catch {
          r2 = e;
        }
        super(`Pattern matching error: no pattern matches value ${r2}`), this.input = void 0, this.input = e;
      }
    };
    var Vl = { matched: false, value: void 0 };
    function fo(t2) {
      return new Hl(t2, Vl);
    }
    __name(fo, "fo");
    var Hl = class t2 {
      static {
        __name(this, "t");
      }
      constructor(e, r2) {
        this.input = void 0, this.state = void 0, this.input = e, this.state = r2;
      }
      with(...e) {
        if (this.state.matched) return this;
        let r2 = e[e.length - 1], n2 = [e[0]], A2;
        e.length === 3 && typeof e[1] == "function" ? A2 = e[1] : e.length > 2 && n2.push(...e.slice(1, e.length - 1));
        let i2 = false, s = {}, o2 = /* @__PURE__ */ __name((c2, l2) => {
          i2 = true, s[c2] = l2;
        }, "o"), a2 = !n2.some((c2) => xt(c2, this.input, o2)) || A2 && !A2(this.input) ? Vl : { matched: true, value: r2(i2 ? ho in s ? s[ho] : s : this.input, this.input) };
        return new t2(this.input, a2);
      }
      when(e, r2) {
        if (this.state.matched) return this;
        let n2 = !!e(this.input);
        return new t2(this.input, n2 ? { matched: true, value: r2(this.input, this.input) } : Vl);
      }
      otherwise(e) {
        return this.state.matched ? this.state.value : e(this.input);
      }
      exhaustive() {
        if (this.state.matched) return this.state.value;
        throw new Ol(this.input);
      }
      run() {
        return this.exhaustive();
      }
      returnType() {
        return this;
      }
    };
    var Qf = __require("node:util");
    var $b = { warn: rr("prisma:warn") };
    var zb = { warn: /* @__PURE__ */ __name(() => !process.env.PRISMA_DISABLE_WARNINGS, "warn") };
    function Qo(t2, ...e) {
      zb.warn() && console.warn(`${$b.warn} ${t2}`, ...e);
    }
    __name(Qo, "Qo");
    var eN = (0, Qf.promisify)(ff.default.exec);
    var Ge = Wn("prisma:get-platform");
    var tN = ["1.0.x", "1.1.x", "3.0.x"];
    async function Cf() {
      let t2 = Io.default.platform(), e = process.arch;
      if (t2 === "freebsd") {
        let s = await po("freebsd-version");
        if (s && s.trim().length > 0) {
          let a2 = /^(\d+)\.?/.exec(s);
          if (a2) return { platform: "freebsd", targetDistro: `freebsd${a2[1]}`, arch: e };
        }
      }
      if (t2 !== "linux") return { platform: t2, arch: e };
      let r2 = await nN(), n2 = await gN(), A2 = iN({ arch: e, archFromUname: n2, familyDistro: r2.familyDistro }), { libssl: i2 } = await sN(A2);
      return { platform: "linux", libssl: i2, arch: e, archFromUname: n2, ...r2 };
    }
    __name(Cf, "Cf");
    function rN(t2) {
      let e = /^ID="?([^"\n]*)"?$/im, r2 = /^ID_LIKE="?([^"\n]*)"?$/im, n2 = e.exec(t2), A2 = n2 && n2[1] && n2[1].toLowerCase() || "", i2 = r2.exec(t2), s = i2 && i2[1] && i2[1].toLowerCase() || "", o2 = fo({ id: A2, idLike: s }).with({ id: "alpine" }, ({ id: a2 }) => ({ targetDistro: "musl", familyDistro: a2, originalDistro: a2 })).with({ id: "raspbian" }, ({ id: a2 }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: a2 })).with({ id: "nixos" }, ({ id: a2 }) => ({ targetDistro: "nixos", originalDistro: a2, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: a2 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: a2 })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: a2 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: a2 })).when(({ idLike: a2 }) => a2.includes("debian") || a2.includes("ubuntu"), ({ id: a2 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: a2 })).when(({ idLike: a2 }) => A2 === "arch" || a2.includes("arch"), ({ id: a2 }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: a2 })).when(({ idLike: a2 }) => a2.includes("centos") || a2.includes("fedora") || a2.includes("rhel") || a2.includes("suse"), ({ id: a2 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: a2 })).otherwise(({ id: a2 }) => ({ targetDistro: void 0, familyDistro: void 0, originalDistro: a2 }));
      return Ge(`Found distro info:
${JSON.stringify(o2, null, 2)}`), o2;
    }
    __name(rN, "rN");
    async function nN() {
      let t2 = "/etc/os-release";
      try {
        let e = await ql.default.readFile(t2, { encoding: "utf-8" });
        return rN(e);
      } catch {
        return { targetDistro: void 0, familyDistro: void 0, originalDistro: void 0 };
      }
    }
    __name(nN, "nN");
    function AN(t2) {
      let e = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(t2);
      if (e) {
        let r2 = `${e[1]}.x`;
        return If(r2);
      }
    }
    __name(AN, "AN");
    function df(t2) {
      let e = /libssl\.so\.(\d)(\.\d)?/.exec(t2);
      if (e) {
        let r2 = `${e[1]}${e[2] ?? ".0"}.x`;
        return If(r2);
      }
    }
    __name(df, "df");
    function If(t2) {
      let e = (() => {
        if (pf(t2)) return t2;
        let r2 = t2.split(".");
        return r2[1] = "0", r2.join(".");
      })();
      if (tN.includes(e)) return e;
    }
    __name(If, "If");
    function iN(t2) {
      return fo(t2).with({ familyDistro: "musl" }, () => (Ge('Trying platform-specific paths for "alpine"'), ["/lib", "/usr/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: e }) => (Ge('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${e}-linux-gnu`, `/lib/${e}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (Ge('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: e, arch: r2, archFromUname: n2 }) => (Ge(`Don't know any platform-specific paths for "${e}" on ${r2} (${n2})`), []));
    }
    __name(iN, "iN");
    async function sN(t2) {
      let e = 'grep -v "libssl.so.0"', r2 = await hf(t2);
      if (r2) {
        Ge(`Found libssl.so file using platform-specific paths: ${r2}`);
        let i2 = df(r2);
        if (Ge(`The parsed libssl version is: ${i2}`), i2) return { libssl: i2, strategy: "libssl-specific-path" };
      }
      Ge('Falling back to "ldconfig" and other generic paths');
      let n2 = await po(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${e}`);
      if (n2 || (n2 = await hf(["/lib64", "/usr/lib64", "/lib", "/usr/lib"])), n2) {
        Ge(`Found libssl.so file using "ldconfig" or other generic paths: ${n2}`);
        let i2 = df(n2);
        if (Ge(`The parsed libssl version is: ${i2}`), i2) return { libssl: i2, strategy: "ldconfig" };
      }
      let A2 = await po("openssl version -v");
      if (A2) {
        Ge(`Found openssl binary with version: ${A2}`);
        let i2 = AN(A2);
        if (Ge(`The parsed openssl version is: ${i2}`), i2) return { libssl: i2, strategy: "openssl-binary" };
      }
      return Ge("Couldn't find any version of libssl or OpenSSL in the system"), {};
    }
    __name(sN, "sN");
    async function hf(t2) {
      for (let e of t2) {
        let r2 = await oN(e);
        if (r2) return r2;
      }
    }
    __name(hf, "hf");
    async function oN(t2) {
      try {
        return (await ql.default.readdir(t2)).find((r2) => r2.startsWith("libssl.so.") && !r2.startsWith("libssl.so.0"));
      } catch (e) {
        if (e.code === "ENOENT") return;
        throw e;
      }
    }
    __name(oN, "oN");
    async function sn() {
      let { binaryTarget: t2 } = await cN();
      return t2;
    }
    __name(sn, "sn");
    function aN(t2) {
      return t2.binaryTarget !== void 0;
    }
    __name(aN, "aN");
    var Co = {};
    async function cN() {
      if (aN(Co)) return Promise.resolve({ ...Co, memoized: true });
      let t2 = await Cf(), e = lN(t2);
      return Co = { ...t2, binaryTarget: e }, { ...Co, memoized: false };
    }
    __name(cN, "cN");
    function lN(t2) {
      let { platform: e, arch: r2, archFromUname: n2, libssl: A2, targetDistro: i2, familyDistro: s, originalDistro: o2 } = t2;
      e === "linux" && !["x64", "arm64"].includes(r2) && Qo(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${r2}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n2}".`);
      let a2 = "1.1.x";
      if (e === "linux" && A2 === void 0) {
        let l2 = fo({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
        Qo(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${a2}".
${l2}`);
      }
      let c2 = "debian";
      if (e === "linux" && i2 === void 0 && Ge(`Distro is "${o2}". Falling back to Prisma engines built for "${c2}".`), e === "darwin" && r2 === "arm64") return "darwin-arm64";
      if (e === "darwin") return "darwin";
      if (e === "win32") return "windows";
      if (e === "freebsd") return i2;
      if (e === "openbsd") return "openbsd";
      if (e === "netbsd") return "netbsd";
      if (e === "linux" && i2 === "nixos") return "linux-nixos";
      if (e === "linux" && r2 === "arm64") return `${i2 === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${A2 || a2}`;
      if (e === "linux" && r2 === "arm") return `linux-arm-openssl-${A2 || a2}`;
      if (e === "linux" && i2 === "musl") {
        let l2 = "linux-musl";
        return !A2 || pf(A2) ? l2 : `${l2}-openssl-${A2}`;
      }
      return e === "linux" && i2 && A2 ? `${i2}-openssl-${A2}` : (e !== "linux" && Qo(`Prisma detected unknown OS "${e}" and may not work as expected. Defaulting to "linux".`), A2 ? `${c2}-openssl-${A2}` : i2 ? `${i2}-openssl-${a2}` : `${c2}-openssl-${a2}`);
    }
    __name(lN, "lN");
    async function uN(t2) {
      try {
        return await t2();
      } catch {
        return;
      }
    }
    __name(uN, "uN");
    function po(t2) {
      return uN(async () => {
        let e = await eN(t2);
        return Ge(`Command "${t2}" successfully returned "${e.stdout}"`), e.stdout;
      });
    }
    __name(po, "po");
    async function gN() {
      return typeof Io.default.machine == "function" ? Io.default.machine() : (await po("uname -m"))?.trim();
    }
    __name(gN, "gN");
    function pf(t2) {
      return t2.startsWith("1.");
    }
    __name(pf, "pf");
    var oT = nC();
    var uu = oT.version;
    function tA(t2) {
      let e = aT();
      return e || (t2?.config.engineType === "library" ? "library" : t2?.config.engineType === "binary" ? "binary" : t2?.config.engineType === "client" ? "client" : cT(t2));
    }
    __name(tA, "tA");
    function aT() {
      let t2 = process.env.PRISMA_CLIENT_ENGINE_TYPE;
      return t2 === "library" ? "library" : t2 === "binary" ? "binary" : t2 === "client" ? "client" : void 0;
    }
    __name(aT, "aT");
    function cT(t2) {
      return t2?.previewFeatures.includes("queryCompiler") ? "client" : "library";
    }
    __name(cT, "cT");
    var CT = G2(vo());
    var ie = G2(__require("node:path"));
    var IT = G2(vo());
    var cj = ce("prisma:engines");
    function gC() {
      return ie.default.join(__dirname, "../");
    }
    __name(gC, "gC");
    ie.default.join(__dirname, "../query-engine-darwin");
    ie.default.join(__dirname, "../query-engine-darwin-arm64");
    ie.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
    ie.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
    ie.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
    ie.default.join(__dirname, "../query-engine-linux-static-x64");
    ie.default.join(__dirname, "../query-engine-linux-static-arm64");
    ie.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
    ie.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
    ie.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
    ie.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
    ie.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
    ie.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
    ie.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
    ie.default.join(__dirname, "../query_engine-windows.dll.node");
    var hu = G2(__require("node:fs"));
    var EC = Wn("chmodPlusX");
    function fu(t2) {
      if (process.platform === "win32") return;
      let e = hu.default.statSync(t2), r2 = e.mode | 64 | 8 | 1;
      if (e.mode === r2) {
        EC(`Execution permissions of ${t2} are fine`);
        return;
      }
      let n2 = r2.toString(8).slice(-3);
      EC(`Have to call chmodPlusX on ${t2}`), hu.default.chmodSync(t2, n2);
    }
    __name(fu, "fu");
    var fC = G2(hC(), 1);
    function Qu(t2) {
      let e = (0, fC.default)(t2);
      if (e === 0) return t2;
      let r2 = new RegExp(`^[ \\t]{${e}}`, "gm");
      return t2.replace(r2, "");
    }
    __name(Qu, "Qu");
    var QC = "prisma+postgres";
    var Po = `${QC}:`;
    function Yo(t2) {
      return t2?.toString().startsWith(`${Po}//`) ?? false;
    }
    __name(Yo, "Yo");
    function Cu(t2) {
      if (!Yo(t2)) return false;
      let { host: e } = new URL(t2);
      return e.includes("localhost") || e.includes("127.0.0.1") || e.includes("[::1]");
    }
    __name(Cu, "Cu");
    var IC = G2(Iu());
    function Bu(t2) {
      return String(new pu(t2));
    }
    __name(Bu, "Bu");
    var pu = class {
      static {
        __name(this, "pu");
      }
      constructor(e) {
        this.config = e;
      }
      toString() {
        let { config: e } = this, r2 = e.provider.fromEnvVar ? `env("${e.provider.fromEnvVar}")` : e.provider.value, n2 = JSON.parse(JSON.stringify({ provider: r2, binaryTargets: pT(e.binaryTargets) }));
        return `generator ${e.name} {
${(0, IC.default)(BT(n2), 2)}
}`;
      }
    };
    function pT(t2) {
      let e;
      if (t2.length > 0) {
        let r2 = t2.find((n2) => n2.fromEnvVar !== null);
        r2 ? e = `env("${r2.fromEnvVar}")` : e = t2.map((n2) => n2.native ? "native" : n2.value);
      } else e = void 0;
      return e;
    }
    __name(pT, "pT");
    function BT(t2) {
      let e = Object.keys(t2).reduce((r2, n2) => Math.max(r2, n2.length), 0);
      return Object.entries(t2).map(([r2, n2]) => `${r2.padEnd(e)} = ${mT(n2)}`).join(`
`);
    }
    __name(BT, "BT");
    function mT(t2) {
      return JSON.parse(JSON.stringify(t2, (e, r2) => Array.isArray(r2) ? `[${r2.map((n2) => JSON.stringify(n2)).join(", ")}]` : JSON.stringify(r2)));
    }
    __name(mT, "mT");
    var Di = {};
    Jn(Di, { error: /* @__PURE__ */ __name(() => DT, "error"), info: /* @__PURE__ */ __name(() => wT, "info"), log: /* @__PURE__ */ __name(() => yT, "log"), query: /* @__PURE__ */ __name(() => RT, "query"), should: /* @__PURE__ */ __name(() => pC, "should"), tags: /* @__PURE__ */ __name(() => wi, "tags"), warn: /* @__PURE__ */ __name(() => mu, "warn") });
    var wi = { error: at("prisma:error"), warn: rr("prisma:warn"), info: nr("prisma:info"), query: An("prisma:query") };
    var pC = { warn: /* @__PURE__ */ __name(() => !process.env.PRISMA_DISABLE_WARNINGS, "warn") };
    function yT(...t2) {
      console.log(...t2);
    }
    __name(yT, "yT");
    function mu(t2, ...e) {
      pC.warn() && console.warn(`${wi.warn} ${t2}`, ...e);
    }
    __name(mu, "mu");
    function wT(t2, ...e) {
      console.info(`${wi.info} ${t2}`, ...e);
    }
    __name(wT, "wT");
    function DT(t2, ...e) {
      console.error(`${wi.error} ${t2}`, ...e);
    }
    __name(DT, "DT");
    function RT(t2, ...e) {
      console.log(`${wi.query} ${t2}`, ...e);
    }
    __name(RT, "RT");
    function ln(t2, e) {
      throw new Error(e);
    }
    __name(ln, "ln");
    var Go = G2(__require("node:stream"));
    var wC = G2(__require("node:util"));
    function Ri(t2, e) {
      return bT(t2, e);
    }
    __name(Ri, "Ri");
    function bT(t2, e) {
      return t2 ? NT(t2, e) : new un(e);
    }
    __name(bT, "bT");
    function NT(t2, e) {
      if (!t2) throw new Error("expected readStream");
      if (!t2.readable) throw new Error("readStream must be readable");
      let r2 = new un(e);
      return t2.pipe(r2), r2;
    }
    __name(NT, "NT");
    function un(t2) {
      Go.default.Transform.call(this, t2), t2 = t2 || {}, this._readableState.objectMode = true, this._lineBuffer = [], this._keepEmptyLines = t2.keepEmptyLines || false, this._lastChunkEndedWithCR = false, this.on("pipe", function(e) {
        this.encoding || e instanceof Go.default.Readable && (this.encoding = e._readableState.encoding);
      });
    }
    __name(un, "un");
    wC.default.inherits(un, Go.default.Transform);
    un.prototype._transform = function(t2, e, r2) {
      e = e || "utf8", Buffer.isBuffer(t2) && (e == "buffer" ? (t2 = t2.toString(), e = "utf8") : t2 = t2.toString(e)), this._chunkEncoding = e;
      let n2 = t2.split(/\r\n|\r|\n/g);
      this._lastChunkEndedWithCR && t2[0] == `
` && n2.shift(), this._lineBuffer.length > 0 && (this._lineBuffer[this._lineBuffer.length - 1] += n2[0], n2.shift()), this._lastChunkEndedWithCR = t2[t2.length - 1] == "\r", this._lineBuffer = this._lineBuffer.concat(n2), this._pushBuffer(e, 1, r2);
    };
    un.prototype._pushBuffer = function(t2, e, r2) {
      for (; this._lineBuffer.length > e; ) {
        let n2 = this._lineBuffer.shift();
        if ((this._keepEmptyLines || n2.length > 0) && !this.push(this._reencode(n2, t2))) {
          let A2 = this;
          setImmediate(function() {
            A2._pushBuffer(t2, e, r2);
          });
          return;
        }
      }
      r2();
    };
    un.prototype._flush = function(t2) {
      this._pushBuffer(this._chunkEncoding, 0, t2);
    };
    un.prototype._reencode = function(t2, e) {
      return this.encoding && this.encoding != e ? Buffer.from(t2, e).toString(this.encoding) : this.encoding ? t2 : Buffer.from(t2, e);
    };
    var Si = G2(__require("node:path"));
    function wu(t2) {
      return Si.default.sep === Si.default.posix.sep ? t2 : t2.split(Si.default.sep).join(Si.default.posix.sep);
    }
    __name(wu, "wu");
    var bu = G2(FC());
    var Oo = G2(__require("node:fs"));
    var rA = G2(__require("node:path"));
    function TC(t2) {
      let e = t2.ignoreProcessEnv ? {} : process.env, r2 = /* @__PURE__ */ __name((n2) => n2.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(i2, s) {
        let o2 = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
        if (!o2) return i2;
        let a2 = o2[1], c2, l2;
        if (a2 === "\\") l2 = o2[0], c2 = l2.replace("\\$", "$");
        else {
          let u2 = o2[2];
          l2 = o2[0].substring(a2.length), c2 = Object.hasOwnProperty.call(e, u2) ? e[u2] : t2.parsed[u2] || "", c2 = r2(c2);
        }
        return i2.replace(l2, c2);
      }, n2) ?? n2, "r");
      for (let n2 in t2.parsed) {
        let A2 = Object.hasOwnProperty.call(e, n2) ? e[n2] : t2.parsed[n2];
        t2.parsed[n2] = r2(A2);
      }
      for (let n2 in t2.parsed) e[n2] = t2.parsed[n2];
      return t2;
    }
    __name(TC, "TC");
    var Su = Wn("prisma:tryLoadEnv");
    function Ni({ rootEnvPath: t2, schemaEnvPath: e }, r2 = { conflictCheck: "none" }) {
      let n2 = xC(t2);
      r2.conflictCheck !== "none" && qT(n2, e, r2.conflictCheck);
      let A2 = null;
      return UC(n2?.path, e) || (A2 = xC(e)), !n2 && !A2 && Su("No Environment variables loaded"), A2?.dotenvResult.error ? console.error(at(be("Schema Env Error: ")) + A2.dotenvResult.error) : { message: [n2?.message, A2?.message].filter(Boolean).join(`
`), parsed: { ...n2?.dotenvResult?.parsed, ...A2?.dotenvResult?.parsed } };
    }
    __name(Ni, "Ni");
    function qT(t2, e, r2) {
      let n2 = t2?.dotenvResult.parsed, A2 = !UC(t2?.path, e);
      if (n2 && e && A2 && Oo.default.existsSync(e)) {
        let i2 = bu.default.parse(Oo.default.readFileSync(e)), s = [];
        for (let o2 in i2) n2[o2] === i2[o2] && s.push(o2);
        if (s.length > 0) {
          let o2 = rA.default.relative(process.cwd(), t2.path), a2 = rA.default.relative(process.cwd(), e);
          if (r2 === "error") {
            let c2 = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${Je(o2)} and ${Je(a2)}
Conflicting env vars:
${s.map((l2) => `  ${be(l2)}`).join(`
`)}

We suggest to move the contents of ${Je(a2)} to ${Je(o2)} to consolidate your env vars.
`;
            throw new Error(c2);
          } else if (r2 === "warn") {
            let c2 = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((l2) => be(l2)).join(", ")} in ${Je(o2)} and ${Je(a2)}
Env vars from ${Je(a2)} overwrite the ones from ${Je(o2)}
      `;
            console.warn(`${rr("warn(prisma)")} ${c2}`);
          }
        }
      }
    }
    __name(qT, "qT");
    function xC(t2) {
      if (JT(t2)) {
        Su(`Environment variables loaded from ${t2}`);
        let e = bu.default.config({ path: t2, debug: process.env.DOTENV_CONFIG_DEBUG ? true : void 0 });
        return { dotenvResult: TC(e), message: nn(`Environment variables loaded from ${rA.default.relative(process.cwd(), t2)}`), path: t2 };
      } else Su(`Environment variables not found at ${t2}`);
      return null;
    }
    __name(xC, "xC");
    function UC(t2, e) {
      return t2 && e && rA.default.resolve(t2) === rA.default.resolve(e);
    }
    __name(UC, "UC");
    function JT(t2) {
      return !!(t2 && Oo.default.existsSync(t2));
    }
    __name(JT, "JT");
    function Nu(t2, e) {
      return Object.prototype.hasOwnProperty.call(t2, e);
    }
    __name(Nu, "Nu");
    function Ho(t2, e) {
      let r2 = {};
      for (let n2 of Object.keys(t2)) r2[n2] = e(t2[n2], n2);
      return r2;
    }
    __name(Ho, "Ho");
    function Fu(t2, e) {
      if (t2.length === 0) return;
      let r2 = t2[0];
      for (let n2 = 1; n2 < t2.length; n2++) e(r2, t2[n2]) < 0 && (r2 = t2[n2]);
      return r2;
    }
    __name(Fu, "Fu");
    function M2(t2, e) {
      Object.defineProperty(t2, "name", { value: e, configurable: true });
    }
    __name(M2, "M");
    var MC = /* @__PURE__ */ new Set();
    var Fi = /* @__PURE__ */ __name((t2, e, ...r2) => {
      MC.has(t2) || (MC.add(t2), mu(e, ...r2));
    }, "Fi");
    var Z = class t2 extends Error {
      static {
        __name(this, "t");
      }
      clientVersion;
      errorCode;
      retryable;
      constructor(e, r2, n2) {
        super(e), this.name = "PrismaClientInitializationError", this.clientVersion = r2, this.errorCode = n2, Error.captureStackTrace(t2);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientInitializationError";
      }
    };
    M2(Z, "PrismaClientInitializationError");
    var Ne = class extends Error {
      static {
        __name(this, "Ne");
      }
      code;
      meta;
      clientVersion;
      batchRequestIdx;
      constructor(e, { code: r2, clientVersion: n2, meta: A2, batchRequestIdx: i2 }) {
        super(e), this.name = "PrismaClientKnownRequestError", this.code = r2, this.clientVersion = n2, this.meta = A2, Object.defineProperty(this, "batchRequestIdx", { value: i2, enumerable: false, writable: true });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientKnownRequestError";
      }
    };
    M2(Ne, "PrismaClientKnownRequestError");
    var ut = class extends Error {
      static {
        __name(this, "ut");
      }
      clientVersion;
      constructor(e, r2) {
        super(e), this.name = "PrismaClientRustPanicError", this.clientVersion = r2;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    };
    M2(ut, "PrismaClientRustPanicError");
    var Be = class extends Error {
      static {
        __name(this, "Be");
      }
      clientVersion;
      batchRequestIdx;
      constructor(e, { clientVersion: r2, batchRequestIdx: n2 }) {
        super(e), this.name = "PrismaClientUnknownRequestError", this.clientVersion = r2, Object.defineProperty(this, "batchRequestIdx", { value: n2, writable: true, enumerable: false });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientUnknownRequestError";
      }
    };
    M2(Be, "PrismaClientUnknownRequestError");
    var Ue = class extends Error {
      static {
        __name(this, "Ue");
      }
      name = "PrismaClientValidationError";
      clientVersion;
      constructor(e, { clientVersion: r2 }) {
        super(e), this.clientVersion = r2;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientValidationError";
      }
    };
    M2(Ue, "PrismaClientValidationError");
    var kt = class {
      static {
        __name(this, "kt");
      }
      _map = /* @__PURE__ */ new Map();
      get(e) {
        return this._map.get(e)?.value;
      }
      set(e, r2) {
        this._map.set(e, { value: r2 });
      }
      getOrCreate(e, r2) {
        let n2 = this._map.get(e);
        if (n2) return n2.value;
        let A2 = r2();
        return this.set(e, A2), A2;
      }
    };
    function Ur(t2) {
      return t2.substring(0, 1).toLowerCase() + t2.substring(1);
    }
    __name(Ur, "Ur");
    function LC(t2, e) {
      let r2 = {};
      for (let n2 of t2) {
        let A2 = n2[e];
        r2[A2] = n2;
      }
      return r2;
    }
    __name(LC, "LC");
    function Ti(t2) {
      let e;
      return { get() {
        return e || (e = { value: t2() }), e.value;
      } };
    }
    __name(Ti, "Ti");
    function vC(t2) {
      return { models: Tu(t2.models), enums: Tu(t2.enums), types: Tu(t2.types) };
    }
    __name(vC, "vC");
    function Tu(t2) {
      let e = {};
      for (let { name: r2, ...n2 } of t2) e[r2] = n2;
      return e;
    }
    __name(Tu, "Tu");
    function nA(t2) {
      return t2 instanceof Date || Object.prototype.toString.call(t2) === "[object Date]";
    }
    __name(nA, "nA");
    function Jo(t2) {
      return t2.toString() !== "Invalid Date";
    }
    __name(Jo, "Jo");
    var AA = 9e15;
    var vr = 1e9;
    var xu = "0123456789abcdef";
    var jo = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    var Zo = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    var Uu = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -AA, maxE: AA, crypto: false };
    var OC;
    var sr;
    var L2 = true;
    var Ko = "[DecimalError] ";
    var Lr = Ko + "Invalid argument: ";
    var VC = Ko + "Precision limit exceeded";
    var HC = Ko + "crypto unavailable";
    var qC = "[object Decimal]";
    var ke = Math.floor;
    var me = Math.pow;
    var WT = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    var _T = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    var jT = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    var JC = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    var pt = 1e7;
    var N2 = 7;
    var ZT = 9007199254740991;
    var XT = jo.length - 1;
    var ku = Zo.length - 1;
    var y2 = { toStringTag: qC };
    y2.absoluteValue = y2.abs = function() {
      var t2 = new this.constructor(this);
      return t2.s < 0 && (t2.s = 1), b2(t2);
    };
    y2.ceil = function() {
      return b2(new this.constructor(this), this.e + 1, 2);
    };
    y2.clampedTo = y2.clamp = function(t2, e) {
      var r2, n2 = this, A2 = n2.constructor;
      if (t2 = new A2(t2), e = new A2(e), !t2.s || !e.s) return new A2(NaN);
      if (t2.gt(e)) throw Error(Lr + e);
      return r2 = n2.cmp(t2), r2 < 0 ? t2 : n2.cmp(e) > 0 ? e : new A2(n2);
    };
    y2.comparedTo = y2.cmp = function(t2) {
      var e, r2, n2, A2, i2 = this, s = i2.d, o2 = (t2 = new i2.constructor(t2)).d, a2 = i2.s, c2 = t2.s;
      if (!s || !o2) return !a2 || !c2 ? NaN : a2 !== c2 ? a2 : s === o2 ? 0 : !s ^ a2 < 0 ? 1 : -1;
      if (!s[0] || !o2[0]) return s[0] ? a2 : o2[0] ? -c2 : 0;
      if (a2 !== c2) return a2;
      if (i2.e !== t2.e) return i2.e > t2.e ^ a2 < 0 ? 1 : -1;
      for (n2 = s.length, A2 = o2.length, e = 0, r2 = n2 < A2 ? n2 : A2; e < r2; ++e) if (s[e] !== o2[e]) return s[e] > o2[e] ^ a2 < 0 ? 1 : -1;
      return n2 === A2 ? 0 : n2 > A2 ^ a2 < 0 ? 1 : -1;
    };
    y2.cosine = y2.cos = function() {
      var t2, e, r2 = this, n2 = r2.constructor;
      return r2.d ? r2.d[0] ? (t2 = n2.precision, e = n2.rounding, n2.precision = t2 + Math.max(r2.e, r2.sd()) + N2, n2.rounding = 1, r2 = KT(n2, XC(n2, r2)), n2.precision = t2, n2.rounding = e, b2(sr == 2 || sr == 3 ? r2.neg() : r2, t2, e, true)) : new n2(1) : new n2(NaN);
    };
    y2.cubeRoot = y2.cbrt = function() {
      var t2, e, r2, n2, A2, i2, s, o2, a2, c2, l2 = this, u2 = l2.constructor;
      if (!l2.isFinite() || l2.isZero()) return new u2(l2);
      for (L2 = false, i2 = l2.s * me(l2.s * l2, 1 / 3), !i2 || Math.abs(i2) == 1 / 0 ? (r2 = Fe(l2.d), t2 = l2.e, (i2 = (t2 - r2.length + 1) % 3) && (r2 += i2 == 1 || i2 == -2 ? "0" : "00"), i2 = me(r2, 1 / 3), t2 = ke((t2 + 1) / 3) - (t2 % 3 == (t2 < 0 ? -1 : 2)), i2 == 1 / 0 ? r2 = "5e" + t2 : (r2 = i2.toExponential(), r2 = r2.slice(0, r2.indexOf("e") + 1) + t2), n2 = new u2(r2), n2.s = l2.s) : n2 = new u2(i2.toString()), s = (t2 = u2.precision) + 3; ; ) if (o2 = n2, a2 = o2.times(o2).times(o2), c2 = a2.plus(l2), n2 = re2(c2.plus(l2).times(o2), c2.plus(a2), s + 2, 1), Fe(o2.d).slice(0, s) === (r2 = Fe(n2.d)).slice(0, s)) if (r2 = r2.slice(s - 3, s + 1), r2 == "9999" || !A2 && r2 == "4999") {
        if (!A2 && (b2(o2, t2 + 1, 0), o2.times(o2).times(o2).eq(l2))) {
          n2 = o2;
          break;
        }
        s += 4, A2 = 1;
      } else {
        (!+r2 || !+r2.slice(1) && r2.charAt(0) == "5") && (b2(n2, t2 + 1, 1), e = !n2.times(n2).times(n2).eq(l2));
        break;
      }
      return L2 = true, b2(n2, t2, u2.rounding, e);
    };
    y2.decimalPlaces = y2.dp = function() {
      var t2, e = this.d, r2 = NaN;
      if (e) {
        if (t2 = e.length - 1, r2 = (t2 - ke(this.e / N2)) * N2, t2 = e[t2], t2) for (; t2 % 10 == 0; t2 /= 10) r2--;
        r2 < 0 && (r2 = 0);
      }
      return r2;
    };
    y2.dividedBy = y2.div = function(t2) {
      return re2(this, new this.constructor(t2));
    };
    y2.dividedToIntegerBy = y2.divToInt = function(t2) {
      var e = this, r2 = e.constructor;
      return b2(re2(e, new r2(t2), 0, 1, 1), r2.precision, r2.rounding);
    };
    y2.equals = y2.eq = function(t2) {
      return this.cmp(t2) === 0;
    };
    y2.floor = function() {
      return b2(new this.constructor(this), this.e + 1, 3);
    };
    y2.greaterThan = y2.gt = function(t2) {
      return this.cmp(t2) > 0;
    };
    y2.greaterThanOrEqualTo = y2.gte = function(t2) {
      var e = this.cmp(t2);
      return e == 1 || e === 0;
    };
    y2.hyperbolicCosine = y2.cosh = function() {
      var t2, e, r2, n2, A2, i2 = this, s = i2.constructor, o2 = new s(1);
      if (!i2.isFinite()) return new s(i2.s ? 1 / 0 : NaN);
      if (i2.isZero()) return o2;
      r2 = s.precision, n2 = s.rounding, s.precision = r2 + Math.max(i2.e, i2.sd()) + 4, s.rounding = 1, A2 = i2.d.length, A2 < 32 ? (t2 = Math.ceil(A2 / 3), e = (1 / zo(4, t2)).toString()) : (t2 = 16, e = "2.3283064365386962890625e-10"), i2 = iA(s, 1, i2.times(e), new s(1), true);
      for (var a2, c2 = t2, l2 = new s(8); c2--; ) a2 = i2.times(i2), i2 = o2.minus(a2.times(l2.minus(a2.times(l2))));
      return b2(i2, s.precision = r2, s.rounding = n2, true);
    };
    y2.hyperbolicSine = y2.sinh = function() {
      var t2, e, r2, n2, A2 = this, i2 = A2.constructor;
      if (!A2.isFinite() || A2.isZero()) return new i2(A2);
      if (e = i2.precision, r2 = i2.rounding, i2.precision = e + Math.max(A2.e, A2.sd()) + 4, i2.rounding = 1, n2 = A2.d.length, n2 < 3) A2 = iA(i2, 2, A2, A2, true);
      else {
        t2 = 1.4 * Math.sqrt(n2), t2 = t2 > 16 ? 16 : t2 | 0, A2 = A2.times(1 / zo(5, t2)), A2 = iA(i2, 2, A2, A2, true);
        for (var s, o2 = new i2(5), a2 = new i2(16), c2 = new i2(20); t2--; ) s = A2.times(A2), A2 = A2.times(o2.plus(s.times(a2.times(s).plus(c2))));
      }
      return i2.precision = e, i2.rounding = r2, b2(A2, e, r2, true);
    };
    y2.hyperbolicTangent = y2.tanh = function() {
      var t2, e, r2 = this, n2 = r2.constructor;
      return r2.isFinite() ? r2.isZero() ? new n2(r2) : (t2 = n2.precision, e = n2.rounding, n2.precision = t2 + 7, n2.rounding = 1, re2(r2.sinh(), r2.cosh(), n2.precision = t2, n2.rounding = e)) : new n2(r2.s);
    };
    y2.inverseCosine = y2.acos = function() {
      var t2 = this, e = t2.constructor, r2 = t2.abs().cmp(1), n2 = e.precision, A2 = e.rounding;
      return r2 !== -1 ? r2 === 0 ? t2.isNeg() ? Mt(e, n2, A2) : new e(0) : new e(NaN) : t2.isZero() ? Mt(e, n2 + 4, A2).times(0.5) : (e.precision = n2 + 6, e.rounding = 1, t2 = new e(1).minus(t2).div(t2.plus(1)).sqrt().atan(), e.precision = n2, e.rounding = A2, t2.times(2));
    };
    y2.inverseHyperbolicCosine = y2.acosh = function() {
      var t2, e, r2 = this, n2 = r2.constructor;
      return r2.lte(1) ? new n2(r2.eq(1) ? 0 : NaN) : r2.isFinite() ? (t2 = n2.precision, e = n2.rounding, n2.precision = t2 + Math.max(Math.abs(r2.e), r2.sd()) + 4, n2.rounding = 1, L2 = false, r2 = r2.times(r2).minus(1).sqrt().plus(r2), L2 = true, n2.precision = t2, n2.rounding = e, r2.ln()) : new n2(r2);
    };
    y2.inverseHyperbolicSine = y2.asinh = function() {
      var t2, e, r2 = this, n2 = r2.constructor;
      return !r2.isFinite() || r2.isZero() ? new n2(r2) : (t2 = n2.precision, e = n2.rounding, n2.precision = t2 + 2 * Math.max(Math.abs(r2.e), r2.sd()) + 6, n2.rounding = 1, L2 = false, r2 = r2.times(r2).plus(1).sqrt().plus(r2), L2 = true, n2.precision = t2, n2.rounding = e, r2.ln());
    };
    y2.inverseHyperbolicTangent = y2.atanh = function() {
      var t2, e, r2, n2, A2 = this, i2 = A2.constructor;
      return A2.isFinite() ? A2.e >= 0 ? new i2(A2.abs().eq(1) ? A2.s / 0 : A2.isZero() ? A2 : NaN) : (t2 = i2.precision, e = i2.rounding, n2 = A2.sd(), Math.max(n2, t2) < 2 * -A2.e - 1 ? b2(new i2(A2), t2, e, true) : (i2.precision = r2 = n2 - A2.e, A2 = re2(A2.plus(1), new i2(1).minus(A2), r2 + t2, 1), i2.precision = t2 + 4, i2.rounding = 1, A2 = A2.ln(), i2.precision = t2, i2.rounding = e, A2.times(0.5))) : new i2(NaN);
    };
    y2.inverseSine = y2.asin = function() {
      var t2, e, r2, n2, A2 = this, i2 = A2.constructor;
      return A2.isZero() ? new i2(A2) : (e = A2.abs().cmp(1), r2 = i2.precision, n2 = i2.rounding, e !== -1 ? e === 0 ? (t2 = Mt(i2, r2 + 4, n2).times(0.5), t2.s = A2.s, t2) : new i2(NaN) : (i2.precision = r2 + 6, i2.rounding = 1, A2 = A2.div(new i2(1).minus(A2.times(A2)).sqrt().plus(1)).atan(), i2.precision = r2, i2.rounding = n2, A2.times(2)));
    };
    y2.inverseTangent = y2.atan = function() {
      var t2, e, r2, n2, A2, i2, s, o2, a2, c2 = this, l2 = c2.constructor, u2 = l2.precision, g = l2.rounding;
      if (c2.isFinite()) {
        if (c2.isZero()) return new l2(c2);
        if (c2.abs().eq(1) && u2 + 4 <= ku) return s = Mt(l2, u2 + 4, g).times(0.25), s.s = c2.s, s;
      } else {
        if (!c2.s) return new l2(NaN);
        if (u2 + 4 <= ku) return s = Mt(l2, u2 + 4, g).times(0.5), s.s = c2.s, s;
      }
      for (l2.precision = o2 = u2 + 10, l2.rounding = 1, r2 = Math.min(28, o2 / N2 + 2 | 0), t2 = r2; t2; --t2) c2 = c2.div(c2.times(c2).plus(1).sqrt().plus(1));
      for (L2 = false, e = Math.ceil(o2 / N2), n2 = 1, a2 = c2.times(c2), s = new l2(c2), A2 = c2; t2 !== -1; ) if (A2 = A2.times(a2), i2 = s.minus(A2.div(n2 += 2)), A2 = A2.times(a2), s = i2.plus(A2.div(n2 += 2)), s.d[e] !== void 0) for (t2 = e; s.d[t2] === i2.d[t2] && t2--; ) ;
      return r2 && (s = s.times(2 << r2 - 1)), L2 = true, b2(s, l2.precision = u2, l2.rounding = g, true);
    };
    y2.isFinite = function() {
      return !!this.d;
    };
    y2.isInteger = y2.isInt = function() {
      return !!this.d && ke(this.e / N2) > this.d.length - 2;
    };
    y2.isNaN = function() {
      return !this.s;
    };
    y2.isNegative = y2.isNeg = function() {
      return this.s < 0;
    };
    y2.isPositive = y2.isPos = function() {
      return this.s > 0;
    };
    y2.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    y2.lessThan = y2.lt = function(t2) {
      return this.cmp(t2) < 0;
    };
    y2.lessThanOrEqualTo = y2.lte = function(t2) {
      return this.cmp(t2) < 1;
    };
    y2.logarithm = y2.log = function(t2) {
      var e, r2, n2, A2, i2, s, o2, a2, c2 = this, l2 = c2.constructor, u2 = l2.precision, g = l2.rounding, E = 5;
      if (t2 == null) t2 = new l2(10), e = true;
      else {
        if (t2 = new l2(t2), r2 = t2.d, t2.s < 0 || !r2 || !r2[0] || t2.eq(1)) return new l2(NaN);
        e = t2.eq(10);
      }
      if (r2 = c2.d, c2.s < 0 || !r2 || !r2[0] || c2.eq(1)) return new l2(r2 && !r2[0] ? -1 / 0 : c2.s != 1 ? NaN : r2 ? 0 : 1 / 0);
      if (e) if (r2.length > 1) i2 = true;
      else {
        for (A2 = r2[0]; A2 % 10 === 0; ) A2 /= 10;
        i2 = A2 !== 1;
      }
      if (L2 = false, o2 = u2 + E, s = Mr(c2, o2), n2 = e ? Xo(l2, o2 + 10) : Mr(t2, o2), a2 = re2(s, n2, o2, 1), xi(a2.d, A2 = u2, g)) do
        if (o2 += 10, s = Mr(c2, o2), n2 = e ? Xo(l2, o2 + 10) : Mr(t2, o2), a2 = re2(s, n2, o2, 1), !i2) {
          +Fe(a2.d).slice(A2 + 1, A2 + 15) + 1 == 1e14 && (a2 = b2(a2, u2 + 1, 0));
          break;
        }
      while (xi(a2.d, A2 += 10, g));
      return L2 = true, b2(a2, u2, g);
    };
    y2.minus = y2.sub = function(t2) {
      var e, r2, n2, A2, i2, s, o2, a2, c2, l2, u2, g, E = this, h = E.constructor;
      if (t2 = new h(t2), !E.d || !t2.d) return !E.s || !t2.s ? t2 = new h(NaN) : E.d ? t2.s = -t2.s : t2 = new h(t2.d || E.s !== t2.s ? E : NaN), t2;
      if (E.s != t2.s) return t2.s = -t2.s, E.plus(t2);
      if (c2 = E.d, g = t2.d, o2 = h.precision, a2 = h.rounding, !c2[0] || !g[0]) {
        if (g[0]) t2.s = -t2.s;
        else if (c2[0]) t2 = new h(E);
        else return new h(a2 === 3 ? -0 : 0);
        return L2 ? b2(t2, o2, a2) : t2;
      }
      if (r2 = ke(t2.e / N2), l2 = ke(E.e / N2), c2 = c2.slice(), i2 = l2 - r2, i2) {
        for (u2 = i2 < 0, u2 ? (e = c2, i2 = -i2, s = g.length) : (e = g, r2 = l2, s = c2.length), n2 = Math.max(Math.ceil(o2 / N2), s) + 2, i2 > n2 && (i2 = n2, e.length = 1), e.reverse(), n2 = i2; n2--; ) e.push(0);
        e.reverse();
      } else {
        for (n2 = c2.length, s = g.length, u2 = n2 < s, u2 && (s = n2), n2 = 0; n2 < s; n2++) if (c2[n2] != g[n2]) {
          u2 = c2[n2] < g[n2];
          break;
        }
        i2 = 0;
      }
      for (u2 && (e = c2, c2 = g, g = e, t2.s = -t2.s), s = c2.length, n2 = g.length - s; n2 > 0; --n2) c2[s++] = 0;
      for (n2 = g.length; n2 > i2; ) {
        if (c2[--n2] < g[n2]) {
          for (A2 = n2; A2 && c2[--A2] === 0; ) c2[A2] = pt - 1;
          --c2[A2], c2[n2] += pt;
        }
        c2[n2] -= g[n2];
      }
      for (; c2[--s] === 0; ) c2.pop();
      for (; c2[0] === 0; c2.shift()) --r2;
      return c2[0] ? (t2.d = c2, t2.e = $o(c2, r2), L2 ? b2(t2, o2, a2) : t2) : new h(a2 === 3 ? -0 : 0);
    };
    y2.modulo = y2.mod = function(t2) {
      var e, r2 = this, n2 = r2.constructor;
      return t2 = new n2(t2), !r2.d || !t2.s || t2.d && !t2.d[0] ? new n2(NaN) : !t2.d || r2.d && !r2.d[0] ? b2(new n2(r2), n2.precision, n2.rounding) : (L2 = false, n2.modulo == 9 ? (e = re2(r2, t2.abs(), 0, 3, 1), e.s *= t2.s) : e = re2(r2, t2, 0, n2.modulo, 1), e = e.times(t2), L2 = true, r2.minus(e));
    };
    y2.naturalExponential = y2.exp = function() {
      return Mu(this);
    };
    y2.naturalLogarithm = y2.ln = function() {
      return Mr(this);
    };
    y2.negated = y2.neg = function() {
      var t2 = new this.constructor(this);
      return t2.s = -t2.s, b2(t2);
    };
    y2.plus = y2.add = function(t2) {
      var e, r2, n2, A2, i2, s, o2, a2, c2, l2, u2 = this, g = u2.constructor;
      if (t2 = new g(t2), !u2.d || !t2.d) return !u2.s || !t2.s ? t2 = new g(NaN) : u2.d || (t2 = new g(t2.d || u2.s === t2.s ? u2 : NaN)), t2;
      if (u2.s != t2.s) return t2.s = -t2.s, u2.minus(t2);
      if (c2 = u2.d, l2 = t2.d, o2 = g.precision, a2 = g.rounding, !c2[0] || !l2[0]) return l2[0] || (t2 = new g(u2)), L2 ? b2(t2, o2, a2) : t2;
      if (i2 = ke(u2.e / N2), n2 = ke(t2.e / N2), c2 = c2.slice(), A2 = i2 - n2, A2) {
        for (A2 < 0 ? (r2 = c2, A2 = -A2, s = l2.length) : (r2 = l2, n2 = i2, s = c2.length), i2 = Math.ceil(o2 / N2), s = i2 > s ? i2 + 1 : s + 1, A2 > s && (A2 = s, r2.length = 1), r2.reverse(); A2--; ) r2.push(0);
        r2.reverse();
      }
      for (s = c2.length, A2 = l2.length, s - A2 < 0 && (A2 = s, r2 = l2, l2 = c2, c2 = r2), e = 0; A2; ) e = (c2[--A2] = c2[A2] + l2[A2] + e) / pt | 0, c2[A2] %= pt;
      for (e && (c2.unshift(e), ++n2), s = c2.length; c2[--s] == 0; ) c2.pop();
      return t2.d = c2, t2.e = $o(c2, n2), L2 ? b2(t2, o2, a2) : t2;
    };
    y2.precision = y2.sd = function(t2) {
      var e, r2 = this;
      if (t2 !== void 0 && t2 !== !!t2 && t2 !== 1 && t2 !== 0) throw Error(Lr + t2);
      return r2.d ? (e = WC(r2.d), t2 && r2.e + 1 > e && (e = r2.e + 1)) : e = NaN, e;
    };
    y2.round = function() {
      var t2 = this, e = t2.constructor;
      return b2(new e(t2), t2.e + 1, e.rounding);
    };
    y2.sine = y2.sin = function() {
      var t2, e, r2 = this, n2 = r2.constructor;
      return r2.isFinite() ? r2.isZero() ? new n2(r2) : (t2 = n2.precision, e = n2.rounding, n2.precision = t2 + Math.max(r2.e, r2.sd()) + N2, n2.rounding = 1, r2 = zT(n2, XC(n2, r2)), n2.precision = t2, n2.rounding = e, b2(sr > 2 ? r2.neg() : r2, t2, e, true)) : new n2(NaN);
    };
    y2.squareRoot = y2.sqrt = function() {
      var t2, e, r2, n2, A2, i2, s = this, o2 = s.d, a2 = s.e, c2 = s.s, l2 = s.constructor;
      if (c2 !== 1 || !o2 || !o2[0]) return new l2(!c2 || c2 < 0 && (!o2 || o2[0]) ? NaN : o2 ? s : 1 / 0);
      for (L2 = false, c2 = Math.sqrt(+s), c2 == 0 || c2 == 1 / 0 ? (e = Fe(o2), (e.length + a2) % 2 == 0 && (e += "0"), c2 = Math.sqrt(e), a2 = ke((a2 + 1) / 2) - (a2 < 0 || a2 % 2), c2 == 1 / 0 ? e = "5e" + a2 : (e = c2.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + a2), n2 = new l2(e)) : n2 = new l2(c2.toString()), r2 = (a2 = l2.precision) + 3; ; ) if (i2 = n2, n2 = i2.plus(re2(s, i2, r2 + 2, 1)).times(0.5), Fe(i2.d).slice(0, r2) === (e = Fe(n2.d)).slice(0, r2)) if (e = e.slice(r2 - 3, r2 + 1), e == "9999" || !A2 && e == "4999") {
        if (!A2 && (b2(i2, a2 + 1, 0), i2.times(i2).eq(s))) {
          n2 = i2;
          break;
        }
        r2 += 4, A2 = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (b2(n2, a2 + 1, 1), t2 = !n2.times(n2).eq(s));
        break;
      }
      return L2 = true, b2(n2, a2, l2.rounding, t2);
    };
    y2.tangent = y2.tan = function() {
      var t2, e, r2 = this, n2 = r2.constructor;
      return r2.isFinite() ? r2.isZero() ? new n2(r2) : (t2 = n2.precision, e = n2.rounding, n2.precision = t2 + 10, n2.rounding = 1, r2 = r2.sin(), r2.s = 1, r2 = re2(r2, new n2(1).minus(r2.times(r2)).sqrt(), t2 + 10, 0), n2.precision = t2, n2.rounding = e, b2(sr == 2 || sr == 4 ? r2.neg() : r2, t2, e, true)) : new n2(NaN);
    };
    y2.times = y2.mul = function(t2) {
      var e, r2, n2, A2, i2, s, o2, a2, c2, l2 = this, u2 = l2.constructor, g = l2.d, E = (t2 = new u2(t2)).d;
      if (t2.s *= l2.s, !g || !g[0] || !E || !E[0]) return new u2(!t2.s || g && !g[0] && !E || E && !E[0] && !g ? NaN : !g || !E ? t2.s / 0 : t2.s * 0);
      for (r2 = ke(l2.e / N2) + ke(t2.e / N2), a2 = g.length, c2 = E.length, a2 < c2 && (i2 = g, g = E, E = i2, s = a2, a2 = c2, c2 = s), i2 = [], s = a2 + c2, n2 = s; n2--; ) i2.push(0);
      for (n2 = c2; --n2 >= 0; ) {
        for (e = 0, A2 = a2 + n2; A2 > n2; ) o2 = i2[A2] + E[n2] * g[A2 - n2 - 1] + e, i2[A2--] = o2 % pt | 0, e = o2 / pt | 0;
        i2[A2] = (i2[A2] + e) % pt | 0;
      }
      for (; !i2[--s]; ) i2.pop();
      return e ? ++r2 : i2.shift(), t2.d = i2, t2.e = $o(i2, r2), L2 ? b2(t2, u2.precision, u2.rounding) : t2;
    };
    y2.toBinary = function(t2, e) {
      return Lu(this, 2, t2, e);
    };
    y2.toDecimalPlaces = y2.toDP = function(t2, e) {
      var r2 = this, n2 = r2.constructor;
      return r2 = new n2(r2), t2 === void 0 ? r2 : (We(t2, 0, vr), e === void 0 ? e = n2.rounding : We(e, 0, 8), b2(r2, t2 + r2.e + 1, e));
    };
    y2.toExponential = function(t2, e) {
      var r2, n2 = this, A2 = n2.constructor;
      return t2 === void 0 ? r2 = Lt(n2, true) : (We(t2, 0, vr), e === void 0 ? e = A2.rounding : We(e, 0, 8), n2 = b2(new A2(n2), t2 + 1, e), r2 = Lt(n2, true, t2 + 1)), n2.isNeg() && !n2.isZero() ? "-" + r2 : r2;
    };
    y2.toFixed = function(t2, e) {
      var r2, n2, A2 = this, i2 = A2.constructor;
      return t2 === void 0 ? r2 = Lt(A2) : (We(t2, 0, vr), e === void 0 ? e = i2.rounding : We(e, 0, 8), n2 = b2(new i2(A2), t2 + A2.e + 1, e), r2 = Lt(n2, false, t2 + n2.e + 1)), A2.isNeg() && !A2.isZero() ? "-" + r2 : r2;
    };
    y2.toFraction = function(t2) {
      var e, r2, n2, A2, i2, s, o2, a2, c2, l2, u2, g, E = this, h = E.d, f2 = E.constructor;
      if (!h) return new f2(E);
      if (c2 = r2 = new f2(1), n2 = a2 = new f2(0), e = new f2(n2), i2 = e.e = WC(h) - E.e - 1, s = i2 % N2, e.d[0] = me(10, s < 0 ? N2 + s : s), t2 == null) t2 = i2 > 0 ? e : c2;
      else {
        if (o2 = new f2(t2), !o2.isInt() || o2.lt(c2)) throw Error(Lr + o2);
        t2 = o2.gt(e) ? i2 > 0 ? e : c2 : o2;
      }
      for (L2 = false, o2 = new f2(Fe(h)), l2 = f2.precision, f2.precision = i2 = h.length * N2 * 2; u2 = re2(o2, e, 0, 1, 1), A2 = r2.plus(u2.times(n2)), A2.cmp(t2) != 1; ) r2 = n2, n2 = A2, A2 = c2, c2 = a2.plus(u2.times(A2)), a2 = A2, A2 = e, e = o2.minus(u2.times(A2)), o2 = A2;
      return A2 = re2(t2.minus(r2), n2, 0, 1, 1), a2 = a2.plus(A2.times(c2)), r2 = r2.plus(A2.times(n2)), a2.s = c2.s = E.s, g = re2(c2, n2, i2, 1).minus(E).abs().cmp(re2(a2, r2, i2, 1).minus(E).abs()) < 1 ? [c2, n2] : [a2, r2], f2.precision = l2, L2 = true, g;
    };
    y2.toHexadecimal = y2.toHex = function(t2, e) {
      return Lu(this, 16, t2, e);
    };
    y2.toNearest = function(t2, e) {
      var r2 = this, n2 = r2.constructor;
      if (r2 = new n2(r2), t2 == null) {
        if (!r2.d) return r2;
        t2 = new n2(1), e = n2.rounding;
      } else {
        if (t2 = new n2(t2), e === void 0 ? e = n2.rounding : We(e, 0, 8), !r2.d) return t2.s ? r2 : t2;
        if (!t2.d) return t2.s && (t2.s = r2.s), t2;
      }
      return t2.d[0] ? (L2 = false, r2 = re2(r2, t2, 0, e, 1).times(t2), L2 = true, b2(r2)) : (t2.s = r2.s, r2 = t2), r2;
    };
    y2.toNumber = function() {
      return +this;
    };
    y2.toOctal = function(t2, e) {
      return Lu(this, 8, t2, e);
    };
    y2.toPower = y2.pow = function(t2) {
      var e, r2, n2, A2, i2, s, o2 = this, a2 = o2.constructor, c2 = +(t2 = new a2(t2));
      if (!o2.d || !t2.d || !o2.d[0] || !t2.d[0]) return new a2(me(+o2, c2));
      if (o2 = new a2(o2), o2.eq(1)) return o2;
      if (n2 = a2.precision, i2 = a2.rounding, t2.eq(1)) return b2(o2, n2, i2);
      if (e = ke(t2.e / N2), e >= t2.d.length - 1 && (r2 = c2 < 0 ? -c2 : c2) <= ZT) return A2 = _C(a2, o2, r2, n2), t2.s < 0 ? new a2(1).div(A2) : b2(A2, n2, i2);
      if (s = o2.s, s < 0) {
        if (e < t2.d.length - 1) return new a2(NaN);
        if ((t2.d[e] & 1) == 0 && (s = 1), o2.e == 0 && o2.d[0] == 1 && o2.d.length == 1) return o2.s = s, o2;
      }
      return r2 = me(+o2, c2), e = r2 == 0 || !isFinite(r2) ? ke(c2 * (Math.log("0." + Fe(o2.d)) / Math.LN10 + o2.e + 1)) : new a2(r2 + "").e, e > a2.maxE + 1 || e < a2.minE - 1 ? new a2(e > 0 ? s / 0 : 0) : (L2 = false, a2.rounding = o2.s = 1, r2 = Math.min(12, (e + "").length), A2 = Mu(t2.times(Mr(o2, n2 + r2)), n2), A2.d && (A2 = b2(A2, n2 + 5, 1), xi(A2.d, n2, i2) && (e = n2 + 10, A2 = b2(Mu(t2.times(Mr(o2, e + r2)), e), e + 5, 1), +Fe(A2.d).slice(n2 + 1, n2 + 15) + 1 == 1e14 && (A2 = b2(A2, n2 + 1, 0)))), A2.s = s, L2 = true, a2.rounding = i2, b2(A2, n2, i2));
    };
    y2.toPrecision = function(t2, e) {
      var r2, n2 = this, A2 = n2.constructor;
      return t2 === void 0 ? r2 = Lt(n2, n2.e <= A2.toExpNeg || n2.e >= A2.toExpPos) : (We(t2, 1, vr), e === void 0 ? e = A2.rounding : We(e, 0, 8), n2 = b2(new A2(n2), t2, e), r2 = Lt(n2, t2 <= n2.e || n2.e <= A2.toExpNeg, t2)), n2.isNeg() && !n2.isZero() ? "-" + r2 : r2;
    };
    y2.toSignificantDigits = y2.toSD = function(t2, e) {
      var r2 = this, n2 = r2.constructor;
      return t2 === void 0 ? (t2 = n2.precision, e = n2.rounding) : (We(t2, 1, vr), e === void 0 ? e = n2.rounding : We(e, 0, 8)), b2(new n2(r2), t2, e);
    };
    y2.toString = function() {
      var t2 = this, e = t2.constructor, r2 = Lt(t2, t2.e <= e.toExpNeg || t2.e >= e.toExpPos);
      return t2.isNeg() && !t2.isZero() ? "-" + r2 : r2;
    };
    y2.truncated = y2.trunc = function() {
      return b2(new this.constructor(this), this.e + 1, 1);
    };
    y2.valueOf = y2.toJSON = function() {
      var t2 = this, e = t2.constructor, r2 = Lt(t2, t2.e <= e.toExpNeg || t2.e >= e.toExpPos);
      return t2.isNeg() ? "-" + r2 : r2;
    };
    function Fe(t2) {
      var e, r2, n2, A2 = t2.length - 1, i2 = "", s = t2[0];
      if (A2 > 0) {
        for (i2 += s, e = 1; e < A2; e++) n2 = t2[e] + "", r2 = N2 - n2.length, r2 && (i2 += kr(r2)), i2 += n2;
        s = t2[e], n2 = s + "", r2 = N2 - n2.length, r2 && (i2 += kr(r2));
      } else if (s === 0) return "0";
      for (; s % 10 === 0; ) s /= 10;
      return i2 + s;
    }
    __name(Fe, "Fe");
    function We(t2, e, r2) {
      if (t2 !== ~~t2 || t2 < e || t2 > r2) throw Error(Lr + t2);
    }
    __name(We, "We");
    function xi(t2, e, r2, n2) {
      var A2, i2, s, o2;
      for (i2 = t2[0]; i2 >= 10; i2 /= 10) --e;
      return --e < 0 ? (e += N2, A2 = 0) : (A2 = Math.ceil((e + 1) / N2), e %= N2), i2 = me(10, N2 - e), o2 = t2[A2] % i2 | 0, n2 == null ? e < 3 ? (e == 0 ? o2 = o2 / 100 | 0 : e == 1 && (o2 = o2 / 10 | 0), s = r2 < 4 && o2 == 99999 || r2 > 3 && o2 == 49999 || o2 == 5e4 || o2 == 0) : s = (r2 < 4 && o2 + 1 == i2 || r2 > 3 && o2 + 1 == i2 / 2) && (t2[A2 + 1] / i2 / 100 | 0) == me(10, e - 2) - 1 || (o2 == i2 / 2 || o2 == 0) && (t2[A2 + 1] / i2 / 100 | 0) == 0 : e < 4 ? (e == 0 ? o2 = o2 / 1e3 | 0 : e == 1 ? o2 = o2 / 100 | 0 : e == 2 && (o2 = o2 / 10 | 0), s = (n2 || r2 < 4) && o2 == 9999 || !n2 && r2 > 3 && o2 == 4999) : s = ((n2 || r2 < 4) && o2 + 1 == i2 || !n2 && r2 > 3 && o2 + 1 == i2 / 2) && (t2[A2 + 1] / i2 / 1e3 | 0) == me(10, e - 3) - 1, s;
    }
    __name(xi, "xi");
    function Wo(t2, e, r2) {
      for (var n2, A2 = [0], i2, s = 0, o2 = t2.length; s < o2; ) {
        for (i2 = A2.length; i2--; ) A2[i2] *= e;
        for (A2[0] += xu.indexOf(t2.charAt(s++)), n2 = 0; n2 < A2.length; n2++) A2[n2] > r2 - 1 && (A2[n2 + 1] === void 0 && (A2[n2 + 1] = 0), A2[n2 + 1] += A2[n2] / r2 | 0, A2[n2] %= r2);
      }
      return A2.reverse();
    }
    __name(Wo, "Wo");
    function KT(t2, e) {
      var r2, n2, A2;
      if (e.isZero()) return e;
      n2 = e.d.length, n2 < 32 ? (r2 = Math.ceil(n2 / 3), A2 = (1 / zo(4, r2)).toString()) : (r2 = 16, A2 = "2.3283064365386962890625e-10"), t2.precision += r2, e = iA(t2, 1, e.times(A2), new t2(1));
      for (var i2 = r2; i2--; ) {
        var s = e.times(e);
        e = s.times(s).minus(s).times(8).plus(1);
      }
      return t2.precision -= r2, e;
    }
    __name(KT, "KT");
    var re2 = /* @__PURE__ */ function() {
      function t2(n2, A2, i2) {
        var s, o2 = 0, a2 = n2.length;
        for (n2 = n2.slice(); a2--; ) s = n2[a2] * A2 + o2, n2[a2] = s % i2 | 0, o2 = s / i2 | 0;
        return o2 && n2.unshift(o2), n2;
      }
      __name(t2, "t");
      function e(n2, A2, i2, s) {
        var o2, a2;
        if (i2 != s) a2 = i2 > s ? 1 : -1;
        else for (o2 = a2 = 0; o2 < i2; o2++) if (n2[o2] != A2[o2]) {
          a2 = n2[o2] > A2[o2] ? 1 : -1;
          break;
        }
        return a2;
      }
      __name(e, "e");
      function r2(n2, A2, i2, s) {
        for (var o2 = 0; i2--; ) n2[i2] -= o2, o2 = n2[i2] < A2[i2] ? 1 : 0, n2[i2] = o2 * s + n2[i2] - A2[i2];
        for (; !n2[0] && n2.length > 1; ) n2.shift();
      }
      __name(r2, "r");
      return function(n2, A2, i2, s, o2, a2) {
        var c2, l2, u2, g, E, h, f2, p2, Q, I2, B, w, D2, v2, K2, W2, ae, xe, te, Rr, rn = n2.constructor, Se = n2.s == A2.s ? 1 : -1, he = n2.d, ee = A2.d;
        if (!he || !he[0] || !ee || !ee[0]) return new rn(!n2.s || !A2.s || (he ? ee && he[0] == ee[0] : !ee) ? NaN : he && he[0] == 0 || !ee ? Se * 0 : Se / 0);
        for (a2 ? (E = 1, l2 = n2.e - A2.e) : (a2 = pt, E = N2, l2 = ke(n2.e / E) - ke(A2.e / E)), te = ee.length, ae = he.length, Q = new rn(Se), I2 = Q.d = [], u2 = 0; ee[u2] == (he[u2] || 0); u2++) ;
        if (ee[u2] > (he[u2] || 0) && l2--, i2 == null ? (v2 = i2 = rn.precision, s = rn.rounding) : o2 ? v2 = i2 + (n2.e - A2.e) + 1 : v2 = i2, v2 < 0) I2.push(1), h = true;
        else {
          if (v2 = v2 / E + 2 | 0, u2 = 0, te == 1) {
            for (g = 0, ee = ee[0], v2++; (u2 < ae || g) && v2--; u2++) K2 = g * a2 + (he[u2] || 0), I2[u2] = K2 / ee | 0, g = K2 % ee | 0;
            h = g || u2 < ae;
          } else {
            for (g = a2 / (ee[0] + 1) | 0, g > 1 && (ee = t2(ee, g, a2), he = t2(he, g, a2), te = ee.length, ae = he.length), W2 = te, B = he.slice(0, te), w = B.length; w < te; ) B[w++] = 0;
            Rr = ee.slice(), Rr.unshift(0), xe = ee[0], ee[1] >= a2 / 2 && ++xe;
            do
              g = 0, c2 = e(ee, B, te, w), c2 < 0 ? (D2 = B[0], te != w && (D2 = D2 * a2 + (B[1] || 0)), g = D2 / xe | 0, g > 1 ? (g >= a2 && (g = a2 - 1), f2 = t2(ee, g, a2), p2 = f2.length, w = B.length, c2 = e(f2, B, p2, w), c2 == 1 && (g--, r2(f2, te < p2 ? Rr : ee, p2, a2))) : (g == 0 && (c2 = g = 1), f2 = ee.slice()), p2 = f2.length, p2 < w && f2.unshift(0), r2(B, f2, w, a2), c2 == -1 && (w = B.length, c2 = e(ee, B, te, w), c2 < 1 && (g++, r2(B, te < w ? Rr : ee, w, a2))), w = B.length) : c2 === 0 && (g++, B = [0]), I2[u2++] = g, c2 && B[0] ? B[w++] = he[W2] || 0 : (B = [he[W2]], w = 1);
            while ((W2++ < ae || B[0] !== void 0) && v2--);
            h = B[0] !== void 0;
          }
          I2[0] || I2.shift();
        }
        if (E == 1) Q.e = l2, OC = h;
        else {
          for (u2 = 1, g = I2[0]; g >= 10; g /= 10) u2++;
          Q.e = u2 + l2 * E - 1, b2(Q, o2 ? i2 + Q.e + 1 : i2, s, h);
        }
        return Q;
      };
    }();
    function b2(t2, e, r2, n2) {
      var A2, i2, s, o2, a2, c2, l2, u2, g, E = t2.constructor;
      e: if (e != null) {
        if (u2 = t2.d, !u2) return t2;
        for (A2 = 1, o2 = u2[0]; o2 >= 10; o2 /= 10) A2++;
        if (i2 = e - A2, i2 < 0) i2 += N2, s = e, l2 = u2[g = 0], a2 = l2 / me(10, A2 - s - 1) % 10 | 0;
        else if (g = Math.ceil((i2 + 1) / N2), o2 = u2.length, g >= o2) if (n2) {
          for (; o2++ <= g; ) u2.push(0);
          l2 = a2 = 0, A2 = 1, i2 %= N2, s = i2 - N2 + 1;
        } else break e;
        else {
          for (l2 = o2 = u2[g], A2 = 1; o2 >= 10; o2 /= 10) A2++;
          i2 %= N2, s = i2 - N2 + A2, a2 = s < 0 ? 0 : l2 / me(10, A2 - s - 1) % 10 | 0;
        }
        if (n2 = n2 || e < 0 || u2[g + 1] !== void 0 || (s < 0 ? l2 : l2 % me(10, A2 - s - 1)), c2 = r2 < 4 ? (a2 || n2) && (r2 == 0 || r2 == (t2.s < 0 ? 3 : 2)) : a2 > 5 || a2 == 5 && (r2 == 4 || n2 || r2 == 6 && (i2 > 0 ? s > 0 ? l2 / me(10, A2 - s) : 0 : u2[g - 1]) % 10 & 1 || r2 == (t2.s < 0 ? 8 : 7)), e < 1 || !u2[0]) return u2.length = 0, c2 ? (e -= t2.e + 1, u2[0] = me(10, (N2 - e % N2) % N2), t2.e = -e || 0) : u2[0] = t2.e = 0, t2;
        if (i2 == 0 ? (u2.length = g, o2 = 1, g--) : (u2.length = g + 1, o2 = me(10, N2 - i2), u2[g] = s > 0 ? (l2 / me(10, A2 - s) % me(10, s) | 0) * o2 : 0), c2) for (; ; ) if (g == 0) {
          for (i2 = 1, s = u2[0]; s >= 10; s /= 10) i2++;
          for (s = u2[0] += o2, o2 = 1; s >= 10; s /= 10) o2++;
          i2 != o2 && (t2.e++, u2[0] == pt && (u2[0] = 1));
          break;
        } else {
          if (u2[g] += o2, u2[g] != pt) break;
          u2[g--] = 0, o2 = 1;
        }
        for (i2 = u2.length; u2[--i2] === 0; ) u2.pop();
      }
      return L2 && (t2.e > E.maxE ? (t2.d = null, t2.e = NaN) : t2.e < E.minE && (t2.e = 0, t2.d = [0])), t2;
    }
    __name(b2, "b");
    function Lt(t2, e, r2) {
      if (!t2.isFinite()) return ZC(t2);
      var n2, A2 = t2.e, i2 = Fe(t2.d), s = i2.length;
      return e ? (r2 && (n2 = r2 - s) > 0 ? i2 = i2.charAt(0) + "." + i2.slice(1) + kr(n2) : s > 1 && (i2 = i2.charAt(0) + "." + i2.slice(1)), i2 = i2 + (t2.e < 0 ? "e" : "e+") + t2.e) : A2 < 0 ? (i2 = "0." + kr(-A2 - 1) + i2, r2 && (n2 = r2 - s) > 0 && (i2 += kr(n2))) : A2 >= s ? (i2 += kr(A2 + 1 - s), r2 && (n2 = r2 - A2 - 1) > 0 && (i2 = i2 + "." + kr(n2))) : ((n2 = A2 + 1) < s && (i2 = i2.slice(0, n2) + "." + i2.slice(n2)), r2 && (n2 = r2 - s) > 0 && (A2 + 1 === s && (i2 += "."), i2 += kr(n2))), i2;
    }
    __name(Lt, "Lt");
    function $o(t2, e) {
      var r2 = t2[0];
      for (e *= N2; r2 >= 10; r2 /= 10) e++;
      return e;
    }
    __name($o, "$o");
    function Xo(t2, e, r2) {
      if (e > XT) throw L2 = true, r2 && (t2.precision = r2), Error(VC);
      return b2(new t2(jo), e, 1, true);
    }
    __name(Xo, "Xo");
    function Mt(t2, e, r2) {
      if (e > ku) throw Error(VC);
      return b2(new t2(Zo), e, r2, true);
    }
    __name(Mt, "Mt");
    function WC(t2) {
      var e = t2.length - 1, r2 = e * N2 + 1;
      if (e = t2[e], e) {
        for (; e % 10 == 0; e /= 10) r2--;
        for (e = t2[0]; e >= 10; e /= 10) r2++;
      }
      return r2;
    }
    __name(WC, "WC");
    function kr(t2) {
      for (var e = ""; t2--; ) e += "0";
      return e;
    }
    __name(kr, "kr");
    function _C(t2, e, r2, n2) {
      var A2, i2 = new t2(1), s = Math.ceil(n2 / N2 + 4);
      for (L2 = false; ; ) {
        if (r2 % 2 && (i2 = i2.times(e), YC(i2.d, s) && (A2 = true)), r2 = ke(r2 / 2), r2 === 0) {
          r2 = i2.d.length - 1, A2 && i2.d[r2] === 0 && ++i2.d[r2];
          break;
        }
        e = e.times(e), YC(e.d, s);
      }
      return L2 = true, i2;
    }
    __name(_C, "_C");
    function PC(t2) {
      return t2.d[t2.d.length - 1] & 1;
    }
    __name(PC, "PC");
    function jC(t2, e, r2) {
      for (var n2, A2, i2 = new t2(e[0]), s = 0; ++s < e.length; ) {
        if (A2 = new t2(e[s]), !A2.s) {
          i2 = A2;
          break;
        }
        n2 = i2.cmp(A2), (n2 === r2 || n2 === 0 && i2.s === r2) && (i2 = A2);
      }
      return i2;
    }
    __name(jC, "jC");
    function Mu(t2, e) {
      var r2, n2, A2, i2, s, o2, a2, c2 = 0, l2 = 0, u2 = 0, g = t2.constructor, E = g.rounding, h = g.precision;
      if (!t2.d || !t2.d[0] || t2.e > 17) return new g(t2.d ? t2.d[0] ? t2.s < 0 ? 0 : 1 / 0 : 1 : t2.s ? t2.s < 0 ? 0 : t2 : NaN);
      for (e == null ? (L2 = false, a2 = h) : a2 = e, o2 = new g(0.03125); t2.e > -2; ) t2 = t2.times(o2), u2 += 5;
      for (n2 = Math.log(me(2, u2)) / Math.LN10 * 2 + 5 | 0, a2 += n2, r2 = i2 = s = new g(1), g.precision = a2; ; ) {
        if (i2 = b2(i2.times(t2), a2, 1), r2 = r2.times(++l2), o2 = s.plus(re2(i2, r2, a2, 1)), Fe(o2.d).slice(0, a2) === Fe(s.d).slice(0, a2)) {
          for (A2 = u2; A2--; ) s = b2(s.times(s), a2, 1);
          if (e == null) if (c2 < 3 && xi(s.d, a2 - n2, E, c2)) g.precision = a2 += 10, r2 = i2 = o2 = new g(1), l2 = 0, c2++;
          else return b2(s, g.precision = h, E, L2 = true);
          else return g.precision = h, s;
        }
        s = o2;
      }
    }
    __name(Mu, "Mu");
    function Mr(t2, e) {
      var r2, n2, A2, i2, s, o2, a2, c2, l2, u2, g, E = 1, h = 10, f2 = t2, p2 = f2.d, Q = f2.constructor, I2 = Q.rounding, B = Q.precision;
      if (f2.s < 0 || !p2 || !p2[0] || !f2.e && p2[0] == 1 && p2.length == 1) return new Q(p2 && !p2[0] ? -1 / 0 : f2.s != 1 ? NaN : p2 ? 0 : f2);
      if (e == null ? (L2 = false, l2 = B) : l2 = e, Q.precision = l2 += h, r2 = Fe(p2), n2 = r2.charAt(0), Math.abs(i2 = f2.e) < 15e14) {
        for (; n2 < 7 && n2 != 1 || n2 == 1 && r2.charAt(1) > 3; ) f2 = f2.times(t2), r2 = Fe(f2.d), n2 = r2.charAt(0), E++;
        i2 = f2.e, n2 > 1 ? (f2 = new Q("0." + r2), i2++) : f2 = new Q(n2 + "." + r2.slice(1));
      } else return c2 = Xo(Q, l2 + 2, B).times(i2 + ""), f2 = Mr(new Q(n2 + "." + r2.slice(1)), l2 - h).plus(c2), Q.precision = B, e == null ? b2(f2, B, I2, L2 = true) : f2;
      for (u2 = f2, a2 = s = f2 = re2(f2.minus(1), f2.plus(1), l2, 1), g = b2(f2.times(f2), l2, 1), A2 = 3; ; ) {
        if (s = b2(s.times(g), l2, 1), c2 = a2.plus(re2(s, new Q(A2), l2, 1)), Fe(c2.d).slice(0, l2) === Fe(a2.d).slice(0, l2)) if (a2 = a2.times(2), i2 !== 0 && (a2 = a2.plus(Xo(Q, l2 + 2, B).times(i2 + ""))), a2 = re2(a2, new Q(E), l2, 1), e == null) if (xi(a2.d, l2 - h, I2, o2)) Q.precision = l2 += h, c2 = s = f2 = re2(u2.minus(1), u2.plus(1), l2, 1), g = b2(f2.times(f2), l2, 1), A2 = o2 = 1;
        else return b2(a2, Q.precision = B, I2, L2 = true);
        else return Q.precision = B, a2;
        a2 = c2, A2 += 2;
      }
    }
    __name(Mr, "Mr");
    function ZC(t2) {
      return String(t2.s * t2.s / 0);
    }
    __name(ZC, "ZC");
    function _o(t2, e) {
      var r2, n2, A2;
      for ((r2 = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n2 = e.search(/e/i)) > 0 ? (r2 < 0 && (r2 = n2), r2 += +e.slice(n2 + 1), e = e.substring(0, n2)) : r2 < 0 && (r2 = e.length), n2 = 0; e.charCodeAt(n2) === 48; n2++) ;
      for (A2 = e.length; e.charCodeAt(A2 - 1) === 48; --A2) ;
      if (e = e.slice(n2, A2), e) {
        if (A2 -= n2, t2.e = r2 = r2 - n2 - 1, t2.d = [], n2 = (r2 + 1) % N2, r2 < 0 && (n2 += N2), n2 < A2) {
          for (n2 && t2.d.push(+e.slice(0, n2)), A2 -= N2; n2 < A2; ) t2.d.push(+e.slice(n2, n2 += N2));
          e = e.slice(n2), n2 = N2 - e.length;
        } else n2 -= A2;
        for (; n2--; ) e += "0";
        t2.d.push(+e), L2 && (t2.e > t2.constructor.maxE ? (t2.d = null, t2.e = NaN) : t2.e < t2.constructor.minE && (t2.e = 0, t2.d = [0]));
      } else t2.e = 0, t2.d = [0];
      return t2;
    }
    __name(_o, "_o");
    function $T(t2, e) {
      var r2, n2, A2, i2, s, o2, a2, c2, l2;
      if (e.indexOf("_") > -1) {
        if (e = e.replace(/(\d)_(?=\d)/g, "$1"), JC.test(e)) return _o(t2, e);
      } else if (e === "Infinity" || e === "NaN") return +e || (t2.s = NaN), t2.e = NaN, t2.d = null, t2;
      if (_T.test(e)) r2 = 16, e = e.toLowerCase();
      else if (WT.test(e)) r2 = 2;
      else if (jT.test(e)) r2 = 8;
      else throw Error(Lr + e);
      for (i2 = e.search(/p/i), i2 > 0 ? (a2 = +e.slice(i2 + 1), e = e.substring(2, i2)) : e = e.slice(2), i2 = e.indexOf("."), s = i2 >= 0, n2 = t2.constructor, s && (e = e.replace(".", ""), o2 = e.length, i2 = o2 - i2, A2 = _C(n2, new n2(r2), i2, i2 * 2)), c2 = Wo(e, r2, pt), l2 = c2.length - 1, i2 = l2; c2[i2] === 0; --i2) c2.pop();
      return i2 < 0 ? new n2(t2.s * 0) : (t2.e = $o(c2, l2), t2.d = c2, L2 = false, s && (t2 = re2(t2, A2, o2 * 4)), a2 && (t2 = t2.times(Math.abs(a2) < 54 ? me(2, a2) : or.pow(2, a2))), L2 = true, t2);
    }
    __name($T, "$T");
    function zT(t2, e) {
      var r2, n2 = e.d.length;
      if (n2 < 3) return e.isZero() ? e : iA(t2, 2, e, e);
      r2 = 1.4 * Math.sqrt(n2), r2 = r2 > 16 ? 16 : r2 | 0, e = e.times(1 / zo(5, r2)), e = iA(t2, 2, e, e);
      for (var A2, i2 = new t2(5), s = new t2(16), o2 = new t2(20); r2--; ) A2 = e.times(e), e = e.times(i2.plus(A2.times(s.times(A2).minus(o2))));
      return e;
    }
    __name(zT, "zT");
    function iA(t2, e, r2, n2, A2) {
      var i2, s, o2, a2, c2 = 1, l2 = t2.precision, u2 = Math.ceil(l2 / N2);
      for (L2 = false, a2 = r2.times(r2), o2 = new t2(n2); ; ) {
        if (s = re2(o2.times(a2), new t2(e++ * e++), l2, 1), o2 = A2 ? n2.plus(s) : n2.minus(s), n2 = re2(s.times(a2), new t2(e++ * e++), l2, 1), s = o2.plus(n2), s.d[u2] !== void 0) {
          for (i2 = u2; s.d[i2] === o2.d[i2] && i2--; ) ;
          if (i2 == -1) break;
        }
        i2 = o2, o2 = n2, n2 = s, s = i2, c2++;
      }
      return L2 = true, s.d.length = u2 + 1, s;
    }
    __name(iA, "iA");
    function zo(t2, e) {
      for (var r2 = t2; --e; ) r2 *= t2;
      return r2;
    }
    __name(zo, "zo");
    function XC(t2, e) {
      var r2, n2 = e.s < 0, A2 = Mt(t2, t2.precision, 1), i2 = A2.times(0.5);
      if (e = e.abs(), e.lte(i2)) return sr = n2 ? 4 : 1, e;
      if (r2 = e.divToInt(A2), r2.isZero()) sr = n2 ? 3 : 2;
      else {
        if (e = e.minus(r2.times(A2)), e.lte(i2)) return sr = PC(r2) ? n2 ? 2 : 3 : n2 ? 4 : 1, e;
        sr = PC(r2) ? n2 ? 1 : 4 : n2 ? 3 : 2;
      }
      return e.minus(A2).abs();
    }
    __name(XC, "XC");
    function Lu(t2, e, r2, n2) {
      var A2, i2, s, o2, a2, c2, l2, u2, g, E = t2.constructor, h = r2 !== void 0;
      if (h ? (We(r2, 1, vr), n2 === void 0 ? n2 = E.rounding : We(n2, 0, 8)) : (r2 = E.precision, n2 = E.rounding), !t2.isFinite()) l2 = ZC(t2);
      else {
        for (l2 = Lt(t2), s = l2.indexOf("."), h ? (A2 = 2, e == 16 ? r2 = r2 * 4 - 3 : e == 8 && (r2 = r2 * 3 - 2)) : A2 = e, s >= 0 && (l2 = l2.replace(".", ""), g = new E(1), g.e = l2.length - s, g.d = Wo(Lt(g), 10, A2), g.e = g.d.length), u2 = Wo(l2, 10, A2), i2 = a2 = u2.length; u2[--a2] == 0; ) u2.pop();
        if (!u2[0]) l2 = h ? "0p+0" : "0";
        else {
          if (s < 0 ? i2-- : (t2 = new E(t2), t2.d = u2, t2.e = i2, t2 = re2(t2, g, r2, n2, 0, A2), u2 = t2.d, i2 = t2.e, c2 = OC), s = u2[r2], o2 = A2 / 2, c2 = c2 || u2[r2 + 1] !== void 0, c2 = n2 < 4 ? (s !== void 0 || c2) && (n2 === 0 || n2 === (t2.s < 0 ? 3 : 2)) : s > o2 || s === o2 && (n2 === 4 || c2 || n2 === 6 && u2[r2 - 1] & 1 || n2 === (t2.s < 0 ? 8 : 7)), u2.length = r2, c2) for (; ++u2[--r2] > A2 - 1; ) u2[r2] = 0, r2 || (++i2, u2.unshift(1));
          for (a2 = u2.length; !u2[a2 - 1]; --a2) ;
          for (s = 0, l2 = ""; s < a2; s++) l2 += xu.charAt(u2[s]);
          if (h) {
            if (a2 > 1) if (e == 16 || e == 8) {
              for (s = e == 16 ? 4 : 3, --a2; a2 % s; a2++) l2 += "0";
              for (u2 = Wo(l2, A2, e), a2 = u2.length; !u2[a2 - 1]; --a2) ;
              for (s = 1, l2 = "1."; s < a2; s++) l2 += xu.charAt(u2[s]);
            } else l2 = l2.charAt(0) + "." + l2.slice(1);
            l2 = l2 + (i2 < 0 ? "p" : "p+") + i2;
          } else if (i2 < 0) {
            for (; ++i2; ) l2 = "0" + l2;
            l2 = "0." + l2;
          } else if (++i2 > a2) for (i2 -= a2; i2--; ) l2 += "0";
          else i2 < a2 && (l2 = l2.slice(0, i2) + "." + l2.slice(i2));
        }
        l2 = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + l2;
      }
      return t2.s < 0 ? "-" + l2 : l2;
    }
    __name(Lu, "Lu");
    function YC(t2, e) {
      if (t2.length > e) return t2.length = e, true;
    }
    __name(YC, "YC");
    function ex(t2) {
      return new this(t2).abs();
    }
    __name(ex, "ex");
    function tx(t2) {
      return new this(t2).acos();
    }
    __name(tx, "tx");
    function rx(t2) {
      return new this(t2).acosh();
    }
    __name(rx, "rx");
    function nx(t2, e) {
      return new this(t2).plus(e);
    }
    __name(nx, "nx");
    function Ax(t2) {
      return new this(t2).asin();
    }
    __name(Ax, "Ax");
    function ix(t2) {
      return new this(t2).asinh();
    }
    __name(ix, "ix");
    function sx(t2) {
      return new this(t2).atan();
    }
    __name(sx, "sx");
    function ox(t2) {
      return new this(t2).atanh();
    }
    __name(ox, "ox");
    function ax(t2, e) {
      t2 = new this(t2), e = new this(e);
      var r2, n2 = this.precision, A2 = this.rounding, i2 = n2 + 4;
      return !t2.s || !e.s ? r2 = new this(NaN) : !t2.d && !e.d ? (r2 = Mt(this, i2, 1).times(e.s > 0 ? 0.25 : 0.75), r2.s = t2.s) : !e.d || t2.isZero() ? (r2 = e.s < 0 ? Mt(this, n2, A2) : new this(0), r2.s = t2.s) : !t2.d || e.isZero() ? (r2 = Mt(this, i2, 1).times(0.5), r2.s = t2.s) : e.s < 0 ? (this.precision = i2, this.rounding = 1, r2 = this.atan(re2(t2, e, i2, 1)), e = Mt(this, i2, 1), this.precision = n2, this.rounding = A2, r2 = t2.s < 0 ? r2.minus(e) : r2.plus(e)) : r2 = this.atan(re2(t2, e, i2, 1)), r2;
    }
    __name(ax, "ax");
    function cx(t2) {
      return new this(t2).cbrt();
    }
    __name(cx, "cx");
    function lx(t2) {
      return b2(t2 = new this(t2), t2.e + 1, 2);
    }
    __name(lx, "lx");
    function ux(t2, e, r2) {
      return new this(t2).clamp(e, r2);
    }
    __name(ux, "ux");
    function gx(t2) {
      if (!t2 || typeof t2 != "object") throw Error(Ko + "Object expected");
      var e, r2, n2, A2 = t2.defaults === true, i2 = ["precision", 1, vr, "rounding", 0, 8, "toExpNeg", -AA, 0, "toExpPos", 0, AA, "maxE", 0, AA, "minE", -AA, 0, "modulo", 0, 9];
      for (e = 0; e < i2.length; e += 3) if (r2 = i2[e], A2 && (this[r2] = Uu[r2]), (n2 = t2[r2]) !== void 0) if (ke(n2) === n2 && n2 >= i2[e + 1] && n2 <= i2[e + 2]) this[r2] = n2;
      else throw Error(Lr + r2 + ": " + n2);
      if (r2 = "crypto", A2 && (this[r2] = Uu[r2]), (n2 = t2[r2]) !== void 0) if (n2 === true || n2 === false || n2 === 0 || n2 === 1) if (n2) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) this[r2] = true;
      else throw Error(HC);
      else this[r2] = false;
      else throw Error(Lr + r2 + ": " + n2);
      return this;
    }
    __name(gx, "gx");
    function Ex(t2) {
      return new this(t2).cos();
    }
    __name(Ex, "Ex");
    function dx(t2) {
      return new this(t2).cosh();
    }
    __name(dx, "dx");
    function KC(t2) {
      var e, r2, n2;
      function A2(i2) {
        var s, o2, a2, c2 = this;
        if (!(c2 instanceof A2)) return new A2(i2);
        if (c2.constructor = A2, GC(i2)) {
          c2.s = i2.s, L2 ? !i2.d || i2.e > A2.maxE ? (c2.e = NaN, c2.d = null) : i2.e < A2.minE ? (c2.e = 0, c2.d = [0]) : (c2.e = i2.e, c2.d = i2.d.slice()) : (c2.e = i2.e, c2.d = i2.d ? i2.d.slice() : i2.d);
          return;
        }
        if (a2 = typeof i2, a2 === "number") {
          if (i2 === 0) {
            c2.s = 1 / i2 < 0 ? -1 : 1, c2.e = 0, c2.d = [0];
            return;
          }
          if (i2 < 0 ? (i2 = -i2, c2.s = -1) : c2.s = 1, i2 === ~~i2 && i2 < 1e7) {
            for (s = 0, o2 = i2; o2 >= 10; o2 /= 10) s++;
            L2 ? s > A2.maxE ? (c2.e = NaN, c2.d = null) : s < A2.minE ? (c2.e = 0, c2.d = [0]) : (c2.e = s, c2.d = [i2]) : (c2.e = s, c2.d = [i2]);
            return;
          }
          if (i2 * 0 !== 0) {
            i2 || (c2.s = NaN), c2.e = NaN, c2.d = null;
            return;
          }
          return _o(c2, i2.toString());
        }
        if (a2 === "string") return (o2 = i2.charCodeAt(0)) === 45 ? (i2 = i2.slice(1), c2.s = -1) : (o2 === 43 && (i2 = i2.slice(1)), c2.s = 1), JC.test(i2) ? _o(c2, i2) : $T(c2, i2);
        if (a2 === "bigint") return i2 < 0 ? (i2 = -i2, c2.s = -1) : c2.s = 1, _o(c2, i2.toString());
        throw Error(Lr + i2);
      }
      __name(A2, "A");
      if (A2.prototype = y2, A2.ROUND_UP = 0, A2.ROUND_DOWN = 1, A2.ROUND_CEIL = 2, A2.ROUND_FLOOR = 3, A2.ROUND_HALF_UP = 4, A2.ROUND_HALF_DOWN = 5, A2.ROUND_HALF_EVEN = 6, A2.ROUND_HALF_CEIL = 7, A2.ROUND_HALF_FLOOR = 8, A2.EUCLID = 9, A2.config = A2.set = gx, A2.clone = KC, A2.isDecimal = GC, A2.abs = ex, A2.acos = tx, A2.acosh = rx, A2.add = nx, A2.asin = Ax, A2.asinh = ix, A2.atan = sx, A2.atanh = ox, A2.atan2 = ax, A2.cbrt = cx, A2.ceil = lx, A2.clamp = ux, A2.cos = Ex, A2.cosh = dx, A2.div = hx, A2.exp = fx, A2.floor = Qx, A2.hypot = Cx, A2.ln = Ix, A2.log = px, A2.log10 = mx, A2.log2 = Bx, A2.max = yx, A2.min = wx, A2.mod = Dx, A2.mul = Rx, A2.pow = Sx, A2.random = bx, A2.round = Nx, A2.sign = Fx, A2.sin = Tx, A2.sinh = xx, A2.sqrt = Ux, A2.sub = kx, A2.sum = Mx, A2.tan = Lx, A2.tanh = vx, A2.trunc = Px, t2 === void 0 && (t2 = {}), t2 && t2.defaults !== true) for (n2 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n2.length; ) t2.hasOwnProperty(r2 = n2[e++]) || (t2[r2] = this[r2]);
      return A2.config(t2), A2;
    }
    __name(KC, "KC");
    function hx(t2, e) {
      return new this(t2).div(e);
    }
    __name(hx, "hx");
    function fx(t2) {
      return new this(t2).exp();
    }
    __name(fx, "fx");
    function Qx(t2) {
      return b2(t2 = new this(t2), t2.e + 1, 3);
    }
    __name(Qx, "Qx");
    function Cx() {
      var t2, e, r2 = new this(0);
      for (L2 = false, t2 = 0; t2 < arguments.length; ) if (e = new this(arguments[t2++]), e.d) r2.d && (r2 = r2.plus(e.times(e)));
      else {
        if (e.s) return L2 = true, new this(1 / 0);
        r2 = e;
      }
      return L2 = true, r2.sqrt();
    }
    __name(Cx, "Cx");
    function GC(t2) {
      return t2 instanceof or || t2 && t2.toStringTag === qC || false;
    }
    __name(GC, "GC");
    function Ix(t2) {
      return new this(t2).ln();
    }
    __name(Ix, "Ix");
    function px(t2, e) {
      return new this(t2).log(e);
    }
    __name(px, "px");
    function Bx(t2) {
      return new this(t2).log(2);
    }
    __name(Bx, "Bx");
    function mx(t2) {
      return new this(t2).log(10);
    }
    __name(mx, "mx");
    function yx() {
      return jC(this, arguments, -1);
    }
    __name(yx, "yx");
    function wx() {
      return jC(this, arguments, 1);
    }
    __name(wx, "wx");
    function Dx(t2, e) {
      return new this(t2).mod(e);
    }
    __name(Dx, "Dx");
    function Rx(t2, e) {
      return new this(t2).mul(e);
    }
    __name(Rx, "Rx");
    function Sx(t2, e) {
      return new this(t2).pow(e);
    }
    __name(Sx, "Sx");
    function bx(t2) {
      var e, r2, n2, A2, i2 = 0, s = new this(1), o2 = [];
      if (t2 === void 0 ? t2 = this.precision : We(t2, 1, vr), n2 = Math.ceil(t2 / N2), this.crypto) if (crypto.getRandomValues) for (e = crypto.getRandomValues(new Uint32Array(n2)); i2 < n2; ) A2 = e[i2], A2 >= 429e7 ? e[i2] = crypto.getRandomValues(new Uint32Array(1))[0] : o2[i2++] = A2 % 1e7;
      else if (crypto.randomBytes) {
        for (e = crypto.randomBytes(n2 *= 4); i2 < n2; ) A2 = e[i2] + (e[i2 + 1] << 8) + (e[i2 + 2] << 16) + ((e[i2 + 3] & 127) << 24), A2 >= 214e7 ? crypto.randomBytes(4).copy(e, i2) : (o2.push(A2 % 1e7), i2 += 4);
        i2 = n2 / 4;
      } else throw Error(HC);
      else for (; i2 < n2; ) o2[i2++] = Math.random() * 1e7 | 0;
      for (n2 = o2[--i2], t2 %= N2, n2 && t2 && (A2 = me(10, N2 - t2), o2[i2] = (n2 / A2 | 0) * A2); o2[i2] === 0; i2--) o2.pop();
      if (i2 < 0) r2 = 0, o2 = [0];
      else {
        for (r2 = -1; o2[0] === 0; r2 -= N2) o2.shift();
        for (n2 = 1, A2 = o2[0]; A2 >= 10; A2 /= 10) n2++;
        n2 < N2 && (r2 -= N2 - n2);
      }
      return s.e = r2, s.d = o2, s;
    }
    __name(bx, "bx");
    function Nx(t2) {
      return b2(t2 = new this(t2), t2.e + 1, this.rounding);
    }
    __name(Nx, "Nx");
    function Fx(t2) {
      return t2 = new this(t2), t2.d ? t2.d[0] ? t2.s : 0 * t2.s : t2.s || NaN;
    }
    __name(Fx, "Fx");
    function Tx(t2) {
      return new this(t2).sin();
    }
    __name(Tx, "Tx");
    function xx(t2) {
      return new this(t2).sinh();
    }
    __name(xx, "xx");
    function Ux(t2) {
      return new this(t2).sqrt();
    }
    __name(Ux, "Ux");
    function kx(t2, e) {
      return new this(t2).sub(e);
    }
    __name(kx, "kx");
    function Mx() {
      var t2 = 0, e = arguments, r2 = new this(e[t2]);
      for (L2 = false; r2.s && ++t2 < e.length; ) r2 = r2.plus(e[t2]);
      return L2 = true, b2(r2, this.precision, this.rounding);
    }
    __name(Mx, "Mx");
    function Lx(t2) {
      return new this(t2).tan();
    }
    __name(Lx, "Lx");
    function vx(t2) {
      return new this(t2).tanh();
    }
    __name(vx, "vx");
    function Px(t2) {
      return b2(t2 = new this(t2), t2.e + 1, 1);
    }
    __name(Px, "Px");
    y2[Symbol.for("nodejs.util.inspect.custom")] = y2.toString;
    y2[Symbol.toStringTag] = "Decimal";
    var or = y2.constructor = KC(Uu);
    jo = new or(jo);
    Zo = new or(Zo);
    var ar = or;
    function sA(t2) {
      return or.isDecimal(t2) ? true : t2 !== null && typeof t2 == "object" && typeof t2.s == "number" && typeof t2.e == "number" && typeof t2.toFixed == "function" && Array.isArray(t2.d);
    }
    __name(sA, "sA");
    var Ui = {};
    Jn(Ui, { ModelAction: /* @__PURE__ */ __name(() => oA, "ModelAction"), datamodelEnumToSchemaEnum: /* @__PURE__ */ __name(() => Yx, "datamodelEnumToSchemaEnum") });
    function Yx(t2) {
      return { name: t2.name, values: t2.values.map((e) => e.name) };
    }
    __name(Yx, "Yx");
    var oA = ((B) => (B.findUnique = "findUnique", B.findUniqueOrThrow = "findUniqueOrThrow", B.findFirst = "findFirst", B.findFirstOrThrow = "findFirstOrThrow", B.findMany = "findMany", B.create = "create", B.createMany = "createMany", B.createManyAndReturn = "createManyAndReturn", B.update = "update", B.updateMany = "updateMany", B.updateManyAndReturn = "updateManyAndReturn", B.upsert = "upsert", B.delete = "delete", B.deleteMany = "deleteMany", B.groupBy = "groupBy", B.count = "count", B.aggregate = "aggregate", B.findRaw = "findRaw", B.aggregateRaw = "aggregateRaw", B))(oA || {});
    var rI = G2(Iu());
    var tI = G2(__require("node:fs"));
    var $C = { keyword: nr, entity: nr, value: /* @__PURE__ */ __name((t2) => be(An(t2)), "value"), punctuation: An, directive: nr, function: nr, variable: /* @__PURE__ */ __name((t2) => be(An(t2)), "variable"), string: /* @__PURE__ */ __name((t2) => be(Sr(t2)), "string"), boolean: rr, number: nr, comment: hi };
    var Gx = /* @__PURE__ */ __name((t2) => t2, "Gx");
    var ea = {};
    var Ox = 0;
    var P2 = { manual: ea.Prism && ea.Prism.manual, disableWorkerMessageHandler: ea.Prism && ea.Prism.disableWorkerMessageHandler, util: { encode: /* @__PURE__ */ __name(function(t2) {
      if (t2 instanceof Bt) {
        let e = t2;
        return new Bt(e.type, P2.util.encode(e.content), e.alias);
      } else return Array.isArray(t2) ? t2.map(P2.util.encode) : t2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
    }, "encode"), type: /* @__PURE__ */ __name(function(t2) {
      return Object.prototype.toString.call(t2).slice(8, -1);
    }, "type"), objId: /* @__PURE__ */ __name(function(t2) {
      return t2.__id || Object.defineProperty(t2, "__id", { value: ++Ox }), t2.__id;
    }, "objId"), clone: /* @__PURE__ */ __name(function t2(e, r2) {
      let n2, A2, i2 = P2.util.type(e);
      switch (r2 = r2 || {}, i2) {
        case "Object":
          if (A2 = P2.util.objId(e), r2[A2]) return r2[A2];
          n2 = {}, r2[A2] = n2;
          for (let s in e) e.hasOwnProperty(s) && (n2[s] = t2(e[s], r2));
          return n2;
        case "Array":
          return A2 = P2.util.objId(e), r2[A2] ? r2[A2] : (n2 = [], r2[A2] = n2, e.forEach(function(s, o2) {
            n2[o2] = t2(s, r2);
          }), n2);
        default:
          return e;
      }
    }, "t") }, languages: { extend: /* @__PURE__ */ __name(function(t2, e) {
      let r2 = P2.util.clone(P2.languages[t2]);
      for (let n2 in e) r2[n2] = e[n2];
      return r2;
    }, "extend"), insertBefore: /* @__PURE__ */ __name(function(t2, e, r2, n2) {
      n2 = n2 || P2.languages;
      let A2 = n2[t2], i2 = {};
      for (let o2 in A2) if (A2.hasOwnProperty(o2)) {
        if (o2 == e) for (let a2 in r2) r2.hasOwnProperty(a2) && (i2[a2] = r2[a2]);
        r2.hasOwnProperty(o2) || (i2[o2] = A2[o2]);
      }
      let s = n2[t2];
      return n2[t2] = i2, P2.languages.DFS(P2.languages, function(o2, a2) {
        a2 === s && o2 != t2 && (this[o2] = i2);
      }), i2;
    }, "insertBefore"), DFS: /* @__PURE__ */ __name(function t2(e, r2, n2, A2) {
      A2 = A2 || {};
      let i2 = P2.util.objId;
      for (let s in e) if (e.hasOwnProperty(s)) {
        r2.call(e, s, e[s], n2 || s);
        let o2 = e[s], a2 = P2.util.type(o2);
        a2 === "Object" && !A2[i2(o2)] ? (A2[i2(o2)] = true, t2(o2, r2, null, A2)) : a2 === "Array" && !A2[i2(o2)] && (A2[i2(o2)] = true, t2(o2, r2, s, A2));
      }
    }, "t") }, plugins: {}, highlight: /* @__PURE__ */ __name(function(t2, e, r2) {
      let n2 = { code: t2, grammar: e, language: r2 };
      return P2.hooks.run("before-tokenize", n2), n2.tokens = P2.tokenize(n2.code, n2.grammar), P2.hooks.run("after-tokenize", n2), Bt.stringify(P2.util.encode(n2.tokens), n2.language);
    }, "highlight"), matchGrammar: /* @__PURE__ */ __name(function(t2, e, r2, n2, A2, i2, s) {
      for (let f2 in r2) {
        if (!r2.hasOwnProperty(f2) || !r2[f2]) continue;
        if (f2 == s) return;
        let p2 = r2[f2];
        p2 = P2.util.type(p2) === "Array" ? p2 : [p2];
        for (let Q = 0; Q < p2.length; ++Q) {
          let I2 = p2[Q], B = I2.inside, w = !!I2.lookbehind, D2 = !!I2.greedy, v2 = 0, K2 = I2.alias;
          if (D2 && !I2.pattern.global) {
            let W2 = I2.pattern.toString().match(/[imuy]*$/)[0];
            I2.pattern = RegExp(I2.pattern.source, W2 + "g");
          }
          I2 = I2.pattern || I2;
          for (let W2 = n2, ae = A2; W2 < e.length; ae += e[W2].length, ++W2) {
            let xe = e[W2];
            if (e.length > t2.length) return;
            if (xe instanceof Bt) continue;
            if (D2 && W2 != e.length - 1) {
              I2.lastIndex = ae;
              var u2 = I2.exec(t2);
              if (!u2) break;
              var l2 = u2.index + (w ? u2[1].length : 0), g = u2.index + u2[0].length, o2 = W2, a2 = ae;
              for (let ee = e.length; o2 < ee && (a2 < g || !e[o2].type && !e[o2 - 1].greedy); ++o2) a2 += e[o2].length, l2 >= a2 && (++W2, ae = a2);
              if (e[W2] instanceof Bt) continue;
              c2 = o2 - W2, xe = t2.slice(ae, a2), u2.index -= ae;
            } else {
              I2.lastIndex = 0;
              var u2 = I2.exec(xe), c2 = 1;
            }
            if (!u2) {
              if (i2) break;
              continue;
            }
            w && (v2 = u2[1] ? u2[1].length : 0);
            var l2 = u2.index + v2, u2 = u2[0].slice(v2), g = l2 + u2.length, E = xe.slice(0, l2), h = xe.slice(g);
            let te = [W2, c2];
            E && (++W2, ae += E.length, te.push(E));
            let Rr = new Bt(f2, B ? P2.tokenize(u2, B) : u2, K2, u2, D2);
            if (te.push(Rr), h && te.push(h), Array.prototype.splice.apply(e, te), c2 != 1 && P2.matchGrammar(t2, e, r2, W2, ae, true, f2), i2) break;
          }
        }
      }
    }, "matchGrammar"), tokenize: /* @__PURE__ */ __name(function(t2, e) {
      let r2 = [t2], n2 = e.rest;
      if (n2) {
        for (let A2 in n2) e[A2] = n2[A2];
        delete e.rest;
      }
      return P2.matchGrammar(t2, r2, e, 0, 0, false), r2;
    }, "tokenize"), hooks: { all: {}, add: /* @__PURE__ */ __name(function(t2, e) {
      let r2 = P2.hooks.all;
      r2[t2] = r2[t2] || [], r2[t2].push(e);
    }, "add"), run: /* @__PURE__ */ __name(function(t2, e) {
      let r2 = P2.hooks.all[t2];
      if (!(!r2 || !r2.length)) for (var n2 = 0, A2; A2 = r2[n2++]; ) A2(e);
    }, "run") }, Token: Bt };
    P2.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
    P2.languages.javascript = P2.languages.extend("clike", { "class-name": [P2.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
    P2.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    P2.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: P2.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: P2.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: P2.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: P2.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
    P2.languages.markup && P2.languages.markup.tag.addInlined("script", "javascript");
    P2.languages.js = P2.languages.javascript;
    P2.languages.typescript = P2.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
    P2.languages.ts = P2.languages.typescript;
    function Bt(t2, e, r2, n2, A2) {
      this.type = t2, this.content = e, this.alias = r2, this.length = (n2 || "").length | 0, this.greedy = !!A2;
    }
    __name(Bt, "Bt");
    Bt.stringify = function(t2, e) {
      return typeof t2 == "string" ? t2 : Array.isArray(t2) ? t2.map(function(r2) {
        return Bt.stringify(r2, e);
      }).join("") : Vx(t2.type)(t2.content);
    };
    function Vx(t2) {
      return $C[t2] || Gx;
    }
    __name(Vx, "Vx");
    function zC(t2) {
      return Hx(t2, P2.languages.javascript);
    }
    __name(zC, "zC");
    function Hx(t2, e) {
      return P2.tokenize(t2, e).map((n2) => Bt.stringify(n2)).join("");
    }
    __name(Hx, "Hx");
    function eI(t2) {
      return Qu(t2);
    }
    __name(eI, "eI");
    var ta = class t2 {
      static {
        __name(this, "t");
      }
      firstLineNumber;
      lines;
      static read(e) {
        let r2;
        try {
          r2 = tI.default.readFileSync(e, "utf-8");
        } catch {
          return null;
        }
        return t2.fromContent(r2);
      }
      static fromContent(e) {
        let r2 = e.split(/\r?\n/);
        return new t2(1, r2);
      }
      constructor(e, r2) {
        this.firstLineNumber = e, this.lines = r2;
      }
      get lastLineNumber() {
        return this.firstLineNumber + this.lines.length - 1;
      }
      mapLineAt(e, r2) {
        if (e < this.firstLineNumber || e > this.lines.length + this.firstLineNumber) return this;
        let n2 = e - this.firstLineNumber, A2 = [...this.lines];
        return A2[n2] = r2(A2[n2]), new t2(this.firstLineNumber, A2);
      }
      mapLines(e) {
        return new t2(this.firstLineNumber, this.lines.map((r2, n2) => e(r2, this.firstLineNumber + n2)));
      }
      lineAt(e) {
        return this.lines[e - this.firstLineNumber];
      }
      prependSymbolAt(e, r2) {
        return this.mapLines((n2, A2) => A2 === e ? `${r2} ${n2}` : `  ${n2}`);
      }
      slice(e, r2) {
        let n2 = this.lines.slice(e - 1, r2).join(`
`);
        return new t2(e, eI(n2).split(`
`));
      }
      highlight() {
        let e = zC(this.toString());
        return new t2(this.firstLineNumber, e.split(`
`));
      }
      toString() {
        return this.lines.join(`
`);
      }
    };
    var qx = { red: at, gray: hi, dim: nn, bold: be, underline: Je, highlightSource: /* @__PURE__ */ __name((t2) => t2.highlight(), "highlightSource") };
    var Jx = { red: /* @__PURE__ */ __name((t2) => t2, "red"), gray: /* @__PURE__ */ __name((t2) => t2, "gray"), dim: /* @__PURE__ */ __name((t2) => t2, "dim"), bold: /* @__PURE__ */ __name((t2) => t2, "bold"), underline: /* @__PURE__ */ __name((t2) => t2, "underline"), highlightSource: /* @__PURE__ */ __name((t2) => t2, "highlightSource") };
    function Wx({ message: t2, originalMethod: e, isPanic: r2, callArguments: n2 }) {
      return { functionName: `prisma.${e}()`, message: t2, isPanic: r2 ?? false, callArguments: n2 };
    }
    __name(Wx, "Wx");
    function _x({ callsite: t2, message: e, originalMethod: r2, isPanic: n2, callArguments: A2 }, i2) {
      let s = Wx({ message: e, originalMethod: r2, isPanic: n2, callArguments: A2 });
      if (!t2 || typeof window < "u" || process.env.NODE_ENV === "production") return s;
      let o2 = t2.getLocation();
      if (!o2 || !o2.lineNumber || !o2.columnNumber) return s;
      let a2 = Math.max(1, o2.lineNumber - 3), c2 = ta.read(o2.fileName)?.slice(a2, o2.lineNumber), l2 = c2?.lineAt(o2.lineNumber);
      if (c2 && l2) {
        let u2 = Zx(l2), g = jx(l2);
        if (!g) return s;
        s.functionName = `${g.code})`, s.location = o2, n2 || (c2 = c2.mapLineAt(o2.lineNumber, (h) => h.slice(0, g.openingBraceIndex))), c2 = i2.highlightSource(c2);
        let E = String(c2.lastLineNumber).length;
        if (s.contextLines = c2.mapLines((h, f2) => i2.gray(String(f2).padStart(E)) + " " + h).mapLines((h) => i2.dim(h)).prependSymbolAt(o2.lineNumber, i2.bold(i2.red(""))), A2) {
          let h = u2 + E + 1;
          h += 2, s.callArguments = (0, rI.default)(A2, h).slice(h);
        }
      }
      return s;
    }
    __name(_x, "_x");
    function jx(t2) {
      let e = Object.keys(oA).join("|"), n2 = new RegExp(String.raw`\.(${e})\(`).exec(t2);
      if (n2) {
        let A2 = n2.index + n2[0].length, i2 = t2.lastIndexOf(" ", n2.index) + 1;
        return { code: t2.slice(i2, A2), openingBraceIndex: A2 };
      }
      return null;
    }
    __name(jx, "jx");
    function Zx(t2) {
      let e = 0;
      for (let r2 = 0; r2 < t2.length; r2++) {
        if (t2.charAt(r2) !== " ") return e;
        e++;
      }
      return e;
    }
    __name(Zx, "Zx");
    function Xx({ functionName: t2, location: e, message: r2, isPanic: n2, contextLines: A2, callArguments: i2 }, s) {
      let o2 = [""], a2 = e ? " in" : ":";
      if (n2 ? (o2.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), o2.push(s.red(`It occurred in the ${s.bold(`\`${t2}\``)} invocation${a2}`))) : o2.push(s.red(`Invalid ${s.bold(`\`${t2}\``)} invocation${a2}`)), e && o2.push(s.underline(Kx(e))), A2) {
        o2.push("");
        let c2 = [A2.toString()];
        i2 && (c2.push(i2), c2.push(s.dim(")"))), o2.push(c2.join("")), i2 && o2.push("");
      } else o2.push(""), i2 && o2.push(i2), o2.push("");
      return o2.push(r2), o2.join(`
`);
    }
    __name(Xx, "Xx");
    function Kx(t2) {
      let e = [t2.fileName];
      return t2.lineNumber && e.push(String(t2.lineNumber)), t2.columnNumber && e.push(String(t2.columnNumber)), e.join(":");
    }
    __name(Kx, "Kx");
    function ra(t2) {
      let e = t2.showColors ? qx : Jx, r2;
      return r2 = _x(t2, e), Xx(r2, e);
    }
    __name(ra, "ra");
    var uI = G2(vu());
    function sI(t2, e, r2) {
      let n2 = oI(t2), A2 = $x(n2), i2 = eU(A2);
      i2 ? na(i2, e, r2) : e.addErrorMessage(() => "Unknown error");
    }
    __name(sI, "sI");
    function oI(t2) {
      return t2.errors.flatMap((e) => e.kind === "Union" ? oI(e) : [e]);
    }
    __name(oI, "oI");
    function $x(t2) {
      let e = /* @__PURE__ */ new Map(), r2 = [];
      for (let n2 of t2) {
        if (n2.kind !== "InvalidArgumentType") {
          r2.push(n2);
          continue;
        }
        let A2 = `${n2.selectionPath.join(".")}:${n2.argumentPath.join(".")}`, i2 = e.get(A2);
        i2 ? e.set(A2, { ...n2, argument: { ...n2.argument, typeNames: zx(i2.argument.typeNames, n2.argument.typeNames) } }) : e.set(A2, n2);
      }
      return r2.push(...e.values()), r2;
    }
    __name($x, "$x");
    function zx(t2, e) {
      return [...new Set(t2.concat(e))];
    }
    __name(zx, "zx");
    function eU(t2) {
      return Fu(t2, (e, r2) => {
        let n2 = AI(e), A2 = AI(r2);
        return n2 !== A2 ? n2 - A2 : iI(e) - iI(r2);
      });
    }
    __name(eU, "eU");
    function AI(t2) {
      let e = 0;
      return Array.isArray(t2.selectionPath) && (e += t2.selectionPath.length), Array.isArray(t2.argumentPath) && (e += t2.argumentPath.length), e;
    }
    __name(AI, "AI");
    function iI(t2) {
      switch (t2.kind) {
        case "InvalidArgumentValue":
        case "ValueTooLarge":
          return 20;
        case "InvalidArgumentType":
          return 10;
        case "RequiredArgumentMissing":
          return -10;
        default:
          return 0;
      }
    }
    __name(iI, "iI");
    var et = class {
      static {
        __name(this, "et");
      }
      constructor(e, r2) {
        this.name = e;
        this.value = r2;
      }
      isRequired = false;
      makeRequired() {
        return this.isRequired = true, this;
      }
      write(e) {
        let { colors: { green: r2 } } = e.context;
        e.addMarginSymbol(r2(this.isRequired ? "+" : "?")), e.write(r2(this.name)), this.isRequired || e.write(r2("?")), e.write(r2(": ")), typeof this.value == "string" ? e.write(r2(this.value)) : e.write(this.value);
      }
    };
    cI();
    var aA = class {
      static {
        __name(this, "aA");
      }
      constructor(e = 0, r2) {
        this.context = r2;
        this.currentIndent = e;
      }
      lines = [];
      currentLine = "";
      currentIndent = 0;
      marginSymbol;
      afterNextNewLineCallback;
      write(e) {
        return typeof e == "string" ? this.currentLine += e : e.write(this), this;
      }
      writeJoined(e, r2, n2 = (A2, i2) => i2.write(A2)) {
        let A2 = r2.length - 1;
        for (let i2 = 0; i2 < r2.length; i2++) n2(r2[i2], this), i2 !== A2 && this.write(e);
        return this;
      }
      writeLine(e) {
        return this.write(e).newLine();
      }
      newLine() {
        this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = void 0;
        let e = this.afterNextNewLineCallback;
        return this.afterNextNewLineCallback = void 0, e?.(), this;
      }
      withIndent(e) {
        return this.indent(), e(this), this.unindent(), this;
      }
      afterNextNewline(e) {
        return this.afterNextNewLineCallback = e, this;
      }
      indent() {
        return this.currentIndent++, this;
      }
      unindent() {
        return this.currentIndent > 0 && this.currentIndent--, this;
      }
      addMarginSymbol(e) {
        return this.marginSymbol = e, this;
      }
      toString() {
        return this.lines.concat(this.indentedCurrentLine()).join(`
`);
      }
      getCurrentLineLength() {
        return this.currentLine.length;
      }
      indentedCurrentLine() {
        let e = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
        return this.marginSymbol ? this.marginSymbol + e.slice(1) : e;
      }
    };
    aI();
    var Aa = class {
      static {
        __name(this, "Aa");
      }
      constructor(e) {
        this.value = e;
      }
      write(e) {
        e.write(this.value);
      }
      markAsError() {
        this.value.markAsError();
      }
    };
    var ia = /* @__PURE__ */ __name((t2) => t2, "ia");
    var sa = { bold: ia, red: ia, green: ia, dim: ia, enabled: false };
    var lI = { bold: be, red: at, green: Sr, dim: nn, enabled: true };
    var cA = { write(t2) {
      t2.writeLine(",");
    } };
    var vt = class {
      static {
        __name(this, "vt");
      }
      constructor(e) {
        this.contents = e;
      }
      isUnderlined = false;
      color = /* @__PURE__ */ __name((e) => e, "color");
      underline() {
        return this.isUnderlined = true, this;
      }
      setColor(e) {
        return this.color = e, this;
      }
      write(e) {
        let r2 = e.getCurrentLineLength();
        e.write(this.color(this.contents)), this.isUnderlined && e.afterNextNewline(() => {
          e.write(" ".repeat(r2)).writeLine(this.color("~".repeat(this.contents.length)));
        });
      }
    };
    var Pr = class {
      static {
        __name(this, "Pr");
      }
      hasError = false;
      markAsError() {
        return this.hasError = true, this;
      }
    };
    var lA = class extends Pr {
      static {
        __name(this, "lA");
      }
      items = [];
      addItem(e) {
        return this.items.push(new Aa(e)), this;
      }
      getField(e) {
        return this.items[e];
      }
      getPrintWidth() {
        return this.items.length === 0 ? 2 : Math.max(...this.items.map((r2) => r2.value.getPrintWidth())) + 2;
      }
      write(e) {
        if (this.items.length === 0) {
          this.writeEmpty(e);
          return;
        }
        this.writeWithItems(e);
      }
      writeEmpty(e) {
        let r2 = new vt("[]");
        this.hasError && r2.setColor(e.context.colors.red).underline(), e.write(r2);
      }
      writeWithItems(e) {
        let { colors: r2 } = e.context;
        e.writeLine("[").withIndent(() => e.writeJoined(cA, this.items).newLine()).write("]"), this.hasError && e.afterNextNewline(() => {
          e.writeLine(r2.red("~".repeat(this.getPrintWidth())));
        });
      }
      asObject() {
      }
    };
    var uA = class t2 extends Pr {
      static {
        __name(this, "t");
      }
      fields = {};
      suggestions = [];
      addField(e) {
        this.fields[e.name] = e;
      }
      addSuggestion(e) {
        this.suggestions.push(e);
      }
      getField(e) {
        return this.fields[e];
      }
      getDeepField(e) {
        let [r2, ...n2] = e, A2 = this.getField(r2);
        if (!A2) return;
        let i2 = A2;
        for (let s of n2) {
          let o2;
          if (i2.value instanceof t2 ? o2 = i2.value.getField(s) : i2.value instanceof lA && (o2 = i2.value.getField(Number(s))), !o2) return;
          i2 = o2;
        }
        return i2;
      }
      getDeepFieldValue(e) {
        return e.length === 0 ? this : this.getDeepField(e)?.value;
      }
      hasField(e) {
        return !!this.getField(e);
      }
      removeAllFields() {
        this.fields = {};
      }
      removeField(e) {
        delete this.fields[e];
      }
      getFields() {
        return this.fields;
      }
      isEmpty() {
        return Object.keys(this.fields).length === 0;
      }
      getFieldValue(e) {
        return this.getField(e)?.value;
      }
      getDeepSubSelectionValue(e) {
        let r2 = this;
        for (let n2 of e) {
          if (!(r2 instanceof t2)) return;
          let A2 = r2.getSubSelectionValue(n2);
          if (!A2) return;
          r2 = A2;
        }
        return r2;
      }
      getDeepSelectionParent(e) {
        let r2 = this.getSelectionParent();
        if (!r2) return;
        let n2 = r2;
        for (let A2 of e) {
          let i2 = n2.value.getFieldValue(A2);
          if (!i2 || !(i2 instanceof t2)) return;
          let s = i2.getSelectionParent();
          if (!s) return;
          n2 = s;
        }
        return n2;
      }
      getSelectionParent() {
        let e = this.getField("select")?.value.asObject();
        if (e) return { kind: "select", value: e };
        let r2 = this.getField("include")?.value.asObject();
        if (r2) return { kind: "include", value: r2 };
      }
      getSubSelectionValue(e) {
        return this.getSelectionParent()?.value.fields[e].value;
      }
      getPrintWidth() {
        let e = Object.values(this.fields);
        return e.length == 0 ? 2 : Math.max(...e.map((n2) => n2.getPrintWidth())) + 2;
      }
      write(e) {
        let r2 = Object.values(this.fields);
        if (r2.length === 0 && this.suggestions.length === 0) {
          this.writeEmpty(e);
          return;
        }
        this.writeWithContents(e, r2);
      }
      asObject() {
        return this;
      }
      writeEmpty(e) {
        let r2 = new vt("{}");
        this.hasError && r2.setColor(e.context.colors.red).underline(), e.write(r2);
      }
      writeWithContents(e, r2) {
        e.writeLine("{").withIndent(() => {
          e.writeJoined(cA, [...r2, ...this.suggestions]).newLine();
        }), e.write("}"), this.hasError && e.afterNextNewline(() => {
          e.writeLine(e.context.colors.red("~".repeat(this.getPrintWidth())));
        });
      }
    };
    var De = class extends Pr {
      static {
        __name(this, "De");
      }
      constructor(r2) {
        super();
        this.text = r2;
      }
      getPrintWidth() {
        return this.text.length;
      }
      write(r2) {
        let n2 = new vt(this.text);
        this.hasError && n2.underline().setColor(r2.context.colors.red), r2.write(n2);
      }
      asObject() {
      }
    };
    var ki = class {
      static {
        __name(this, "ki");
      }
      fields = [];
      addField(e, r2) {
        return this.fields.push({ write(n2) {
          let { green: A2, dim: i2 } = n2.context.colors;
          n2.write(A2(i2(`${e}: ${r2}`))).addMarginSymbol(A2(i2("+")));
        } }), this;
      }
      write(e) {
        let { colors: { green: r2 } } = e.context;
        e.writeLine(r2("{")).withIndent(() => {
          e.writeJoined(cA, this.fields).newLine();
        }).write(r2("}")).addMarginSymbol(r2("+"));
      }
    };
    function na(t2, e, r2) {
      switch (t2.kind) {
        case "MutuallyExclusiveFields":
          tU(t2, e);
          break;
        case "IncludeOnScalar":
          rU(t2, e);
          break;
        case "EmptySelection":
          nU(t2, e, r2);
          break;
        case "UnknownSelectionField":
          oU(t2, e);
          break;
        case "InvalidSelectionValue":
          aU(t2, e);
          break;
        case "UnknownArgument":
          cU(t2, e);
          break;
        case "UnknownInputField":
          lU(t2, e);
          break;
        case "RequiredArgumentMissing":
          uU(t2, e);
          break;
        case "InvalidArgumentType":
          gU(t2, e);
          break;
        case "InvalidArgumentValue":
          EU(t2, e);
          break;
        case "ValueTooLarge":
          dU(t2, e);
          break;
        case "SomeFieldsMissing":
          hU(t2, e);
          break;
        case "TooManyFieldsGiven":
          fU(t2, e);
          break;
        case "Union":
          sI(t2, e, r2);
          break;
        default:
          throw new Error("not implemented: " + t2.kind);
      }
    }
    __name(na, "na");
    function tU(t2, e) {
      let r2 = e.arguments.getDeepSubSelectionValue(t2.selectionPath)?.asObject();
      r2 && (r2.getField(t2.firstField)?.markAsError(), r2.getField(t2.secondField)?.markAsError()), e.addErrorMessage((n2) => `Please ${n2.bold("either")} use ${n2.green(`\`${t2.firstField}\``)} or ${n2.green(`\`${t2.secondField}\``)}, but ${n2.red("not both")} at the same time.`);
    }
    __name(tU, "tU");
    function rU(t2, e) {
      let [r2, n2] = gA(t2.selectionPath), A2 = t2.outputType, i2 = e.arguments.getDeepSelectionParent(r2)?.value;
      if (i2 && (i2.getField(n2)?.markAsError(), A2)) for (let s of A2.fields) s.isRelation && i2.addSuggestion(new et(s.name, "true"));
      e.addErrorMessage((s) => {
        let o2 = `Invalid scalar field ${s.red(`\`${n2}\``)} for ${s.bold("include")} statement`;
        return A2 ? o2 += ` on model ${s.bold(A2.name)}. ${Mi(s)}` : o2 += ".", o2 += `
Note that ${s.bold("include")} statements only accept relation fields.`, o2;
      });
    }
    __name(rU, "rU");
    function nU(t2, e, r2) {
      let n2 = e.arguments.getDeepSubSelectionValue(t2.selectionPath)?.asObject();
      if (n2) {
        let A2 = n2.getField("omit")?.value.asObject();
        if (A2) {
          AU(t2, e, A2);
          return;
        }
        if (n2.hasField("select")) {
          iU(t2, e);
          return;
        }
      }
      if (r2?.[Ur(t2.outputType.name)]) {
        sU(t2, e);
        return;
      }
      e.addErrorMessage(() => `Unknown field at "${t2.selectionPath.join(".")} selection"`);
    }
    __name(nU, "nU");
    function AU(t2, e, r2) {
      r2.removeAllFields();
      for (let n2 of t2.outputType.fields) r2.addSuggestion(new et(n2.name, "false"));
      e.addErrorMessage((n2) => `The ${n2.red("omit")} statement includes every field of the model ${n2.bold(t2.outputType.name)}. At least one field must be included in the result`);
    }
    __name(AU, "AU");
    function iU(t2, e) {
      let r2 = t2.outputType, n2 = e.arguments.getDeepSelectionParent(t2.selectionPath)?.value, A2 = n2?.isEmpty() ?? false;
      n2 && (n2.removeAllFields(), dI(n2, r2)), e.addErrorMessage((i2) => A2 ? `The ${i2.red("`select`")} statement for type ${i2.bold(r2.name)} must not be empty. ${Mi(i2)}` : `The ${i2.red("`select`")} statement for type ${i2.bold(r2.name)} needs ${i2.bold("at least one truthy value")}.`);
    }
    __name(iU, "iU");
    function sU(t2, e) {
      let r2 = new ki();
      for (let A2 of t2.outputType.fields) A2.isRelation || r2.addField(A2.name, "false");
      let n2 = new et("omit", r2).makeRequired();
      if (t2.selectionPath.length === 0) e.arguments.addSuggestion(n2);
      else {
        let [A2, i2] = gA(t2.selectionPath), o2 = e.arguments.getDeepSelectionParent(A2)?.value.asObject()?.getField(i2);
        if (o2) {
          let a2 = o2?.value.asObject() ?? new uA();
          a2.addSuggestion(n2), o2.value = a2;
        }
      }
      e.addErrorMessage((A2) => `The global ${A2.red("omit")} configuration excludes every field of the model ${A2.bold(t2.outputType.name)}. At least one field must be included in the result`);
    }
    __name(sU, "sU");
    function oU(t2, e) {
      let r2 = hI(t2.selectionPath, e);
      if (r2.parentKind !== "unknown") {
        r2.field.markAsError();
        let n2 = r2.parent;
        switch (r2.parentKind) {
          case "select":
            dI(n2, t2.outputType);
            break;
          case "include":
            QU(n2, t2.outputType);
            break;
          case "omit":
            CU(n2, t2.outputType);
            break;
        }
      }
      e.addErrorMessage((n2) => {
        let A2 = [`Unknown field ${n2.red(`\`${r2.fieldName}\``)}`];
        return r2.parentKind !== "unknown" && A2.push(`for ${n2.bold(r2.parentKind)} statement`), A2.push(`on model ${n2.bold(`\`${t2.outputType.name}\``)}.`), A2.push(Mi(n2)), A2.join(" ");
      });
    }
    __name(oU, "oU");
    function aU(t2, e) {
      let r2 = hI(t2.selectionPath, e);
      r2.parentKind !== "unknown" && r2.field.value.markAsError(), e.addErrorMessage((n2) => `Invalid value for selection field \`${n2.red(r2.fieldName)}\`: ${t2.underlyingError}`);
    }
    __name(aU, "aU");
    function cU(t2, e) {
      let r2 = t2.argumentPath[0], n2 = e.arguments.getDeepSubSelectionValue(t2.selectionPath)?.asObject();
      n2 && (n2.getField(r2)?.markAsError(), IU(n2, t2.arguments)), e.addErrorMessage((A2) => gI(A2, r2, t2.arguments.map((i2) => i2.name)));
    }
    __name(cU, "cU");
    function lU(t2, e) {
      let [r2, n2] = gA(t2.argumentPath), A2 = e.arguments.getDeepSubSelectionValue(t2.selectionPath)?.asObject();
      if (A2) {
        A2.getDeepField(t2.argumentPath)?.markAsError();
        let i2 = A2.getDeepFieldValue(r2)?.asObject();
        i2 && fI(i2, t2.inputType);
      }
      e.addErrorMessage((i2) => gI(i2, n2, t2.inputType.fields.map((s) => s.name)));
    }
    __name(lU, "lU");
    function gI(t2, e, r2) {
      let n2 = [`Unknown argument \`${t2.red(e)}\`.`], A2 = BU(e, r2);
      return A2 && n2.push(`Did you mean \`${t2.green(A2)}\`?`), r2.length > 0 && n2.push(Mi(t2)), n2.join(" ");
    }
    __name(gI, "gI");
    function uU(t2, e) {
      let r2;
      e.addErrorMessage((a2) => r2?.value instanceof De && r2.value.text === "null" ? `Argument \`${a2.green(i2)}\` must not be ${a2.red("null")}.` : `Argument \`${a2.green(i2)}\` is missing.`);
      let n2 = e.arguments.getDeepSubSelectionValue(t2.selectionPath)?.asObject();
      if (!n2) return;
      let [A2, i2] = gA(t2.argumentPath), s = new ki(), o2 = n2.getDeepFieldValue(A2)?.asObject();
      if (o2) {
        if (r2 = o2.getField(i2), r2 && o2.removeField(i2), t2.inputTypes.length === 1 && t2.inputTypes[0].kind === "object") {
          for (let a2 of t2.inputTypes[0].fields) s.addField(a2.name, a2.typeNames.join(" | "));
          o2.addSuggestion(new et(i2, s).makeRequired());
        } else {
          let a2 = t2.inputTypes.map(EI).join(" | ");
          o2.addSuggestion(new et(i2, a2).makeRequired());
        }
        if (t2.dependentArgumentPath) {
          n2.getDeepField(t2.dependentArgumentPath)?.markAsError();
          let [, a2] = gA(t2.dependentArgumentPath);
          e.addErrorMessage((c2) => `Argument \`${c2.green(i2)}\` is required because argument \`${c2.green(a2)}\` was provided.`);
        }
      }
    }
    __name(uU, "uU");
    function EI(t2) {
      return t2.kind === "list" ? `${EI(t2.elementType)}[]` : t2.name;
    }
    __name(EI, "EI");
    function gU(t2, e) {
      let r2 = t2.argument.name, n2 = e.arguments.getDeepSubSelectionValue(t2.selectionPath)?.asObject();
      n2 && n2.getDeepFieldValue(t2.argumentPath)?.markAsError(), e.addErrorMessage((A2) => {
        let i2 = oa("or", t2.argument.typeNames.map((s) => A2.green(s)));
        return `Argument \`${A2.bold(r2)}\`: Invalid value provided. Expected ${i2}, provided ${A2.red(t2.inferredType)}.`;
      });
    }
    __name(gU, "gU");
    function EU(t2, e) {
      let r2 = t2.argument.name, n2 = e.arguments.getDeepSubSelectionValue(t2.selectionPath)?.asObject();
      n2 && n2.getDeepFieldValue(t2.argumentPath)?.markAsError(), e.addErrorMessage((A2) => {
        let i2 = [`Invalid value for argument \`${A2.bold(r2)}\``];
        if (t2.underlyingError && i2.push(`: ${t2.underlyingError}`), i2.push("."), t2.argument.typeNames.length > 0) {
          let s = oa("or", t2.argument.typeNames.map((o2) => A2.green(o2)));
          i2.push(` Expected ${s}.`);
        }
        return i2.join("");
      });
    }
    __name(EU, "EU");
    function dU(t2, e) {
      let r2 = t2.argument.name, n2 = e.arguments.getDeepSubSelectionValue(t2.selectionPath)?.asObject(), A2;
      if (n2) {
        let s = n2.getDeepField(t2.argumentPath)?.value;
        s?.markAsError(), s instanceof De && (A2 = s.text);
      }
      e.addErrorMessage((i2) => {
        let s = ["Unable to fit value"];
        return A2 && s.push(i2.red(A2)), s.push(`into a 64-bit signed integer for field \`${i2.bold(r2)}\``), s.join(" ");
      });
    }
    __name(dU, "dU");
    function hU(t2, e) {
      let r2 = t2.argumentPath[t2.argumentPath.length - 1], n2 = e.arguments.getDeepSubSelectionValue(t2.selectionPath)?.asObject();
      if (n2) {
        let A2 = n2.getDeepFieldValue(t2.argumentPath)?.asObject();
        A2 && fI(A2, t2.inputType);
      }
      e.addErrorMessage((A2) => {
        let i2 = [`Argument \`${A2.bold(r2)}\` of type ${A2.bold(t2.inputType.name)} needs`];
        return t2.constraints.minFieldCount === 1 ? t2.constraints.requiredFields ? i2.push(`${A2.green("at least one of")} ${oa("or", t2.constraints.requiredFields.map((s) => `\`${A2.bold(s)}\``))} arguments.`) : i2.push(`${A2.green("at least one")} argument.`) : i2.push(`${A2.green(`at least ${t2.constraints.minFieldCount}`)} arguments.`), i2.push(Mi(A2)), i2.join(" ");
      });
    }
    __name(hU, "hU");
    function fU(t2, e) {
      let r2 = t2.argumentPath[t2.argumentPath.length - 1], n2 = e.arguments.getDeepSubSelectionValue(t2.selectionPath)?.asObject(), A2 = [];
      if (n2) {
        let i2 = n2.getDeepFieldValue(t2.argumentPath)?.asObject();
        i2 && (i2.markAsError(), A2 = Object.keys(i2.getFields()));
      }
      e.addErrorMessage((i2) => {
        let s = [`Argument \`${i2.bold(r2)}\` of type ${i2.bold(t2.inputType.name)} needs`];
        return t2.constraints.minFieldCount === 1 && t2.constraints.maxFieldCount == 1 ? s.push(`${i2.green("exactly one")} argument,`) : t2.constraints.maxFieldCount == 1 ? s.push(`${i2.green("at most one")} argument,`) : s.push(`${i2.green(`at most ${t2.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${oa("and", A2.map((o2) => i2.red(o2)))}. Please choose`), t2.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${t2.constraints.maxFieldCount}.`), s.join(" ");
      });
    }
    __name(fU, "fU");
    function dI(t2, e) {
      for (let r2 of e.fields) t2.hasField(r2.name) || t2.addSuggestion(new et(r2.name, "true"));
    }
    __name(dI, "dI");
    function QU(t2, e) {
      for (let r2 of e.fields) r2.isRelation && !t2.hasField(r2.name) && t2.addSuggestion(new et(r2.name, "true"));
    }
    __name(QU, "QU");
    function CU(t2, e) {
      for (let r2 of e.fields) !t2.hasField(r2.name) && !r2.isRelation && t2.addSuggestion(new et(r2.name, "true"));
    }
    __name(CU, "CU");
    function IU(t2, e) {
      for (let r2 of e) t2.hasField(r2.name) || t2.addSuggestion(new et(r2.name, r2.typeNames.join(" | ")));
    }
    __name(IU, "IU");
    function hI(t2, e) {
      let [r2, n2] = gA(t2), A2 = e.arguments.getDeepSubSelectionValue(r2)?.asObject();
      if (!A2) return { parentKind: "unknown", fieldName: n2 };
      let i2 = A2.getFieldValue("select")?.asObject(), s = A2.getFieldValue("include")?.asObject(), o2 = A2.getFieldValue("omit")?.asObject(), a2 = i2?.getField(n2);
      return i2 && a2 ? { parentKind: "select", parent: i2, field: a2, fieldName: n2 } : (a2 = s?.getField(n2), s && a2 ? { parentKind: "include", field: a2, parent: s, fieldName: n2 } : (a2 = o2?.getField(n2), o2 && a2 ? { parentKind: "omit", field: a2, parent: o2, fieldName: n2 } : { parentKind: "unknown", fieldName: n2 }));
    }
    __name(hI, "hI");
    function fI(t2, e) {
      if (e.kind === "object") for (let r2 of e.fields) t2.hasField(r2.name) || t2.addSuggestion(new et(r2.name, r2.typeNames.join(" | ")));
    }
    __name(fI, "fI");
    function gA(t2) {
      let e = [...t2], r2 = e.pop();
      if (!r2) throw new Error("unexpected empty path");
      return [e, r2];
    }
    __name(gA, "gA");
    function Mi({ green: t2, enabled: e }) {
      return "Available options are " + (e ? `listed in ${t2("green")}` : "marked with ?") + ".";
    }
    __name(Mi, "Mi");
    function oa(t2, e) {
      if (e.length === 1) return e[0];
      let r2 = [...e], n2 = r2.pop();
      return `${r2.join(", ")} ${t2} ${n2}`;
    }
    __name(oa, "oa");
    var pU = 3;
    function BU(t2, e) {
      let r2 = 1 / 0, n2;
      for (let A2 of e) {
        let i2 = (0, uI.default)(t2, A2);
        i2 > pU || i2 < r2 && (r2 = i2, n2 = A2);
      }
      return n2;
    }
    __name(BU, "BU");
    var Li = class {
      static {
        __name(this, "Li");
      }
      modelName;
      name;
      typeName;
      isList;
      isEnum;
      constructor(e, r2, n2, A2, i2) {
        this.modelName = e, this.name = r2, this.typeName = n2, this.isList = A2, this.isEnum = i2;
      }
      _toGraphQLInputType() {
        let e = this.isList ? "List" : "", r2 = this.isEnum ? "Enum" : "";
        return `${e}${r2}${this.typeName}FieldRefInput<${this.modelName}>`;
      }
    };
    function EA(t2) {
      return t2 instanceof Li;
    }
    __name(EA, "EA");
    var aa = Symbol();
    var Yu = /* @__PURE__ */ new WeakMap();
    var cr = class {
      static {
        __name(this, "cr");
      }
      constructor(e) {
        e === aa ? Yu.set(this, `Prisma.${this._getName()}`) : Yu.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
      }
      _getName() {
        return this.constructor.name;
      }
      toString() {
        return Yu.get(this);
      }
    };
    var vi = class extends cr {
      static {
        __name(this, "vi");
      }
      _getNamespace() {
        return "NullTypes";
      }
    };
    var Pi = class extends vi {
      static {
        __name(this, "Pi");
      }
      #e;
    };
    Gu(Pi, "DbNull");
    var Yi = class extends vi {
      static {
        __name(this, "Yi");
      }
      #e;
    };
    Gu(Yi, "JsonNull");
    var Gi = class extends vi {
      static {
        __name(this, "Gi");
      }
      #e;
    };
    Gu(Gi, "AnyNull");
    var ca = { classes: { DbNull: Pi, JsonNull: Yi, AnyNull: Gi }, instances: { DbNull: new Pi(aa), JsonNull: new Yi(aa), AnyNull: new Gi(aa) } };
    function Gu(t2, e) {
      Object.defineProperty(t2, "name", { value: e, configurable: true });
    }
    __name(Gu, "Gu");
    var QI = ": ";
    var la = class {
      static {
        __name(this, "la");
      }
      constructor(e, r2) {
        this.name = e;
        this.value = r2;
      }
      hasError = false;
      markAsError() {
        this.hasError = true;
      }
      getPrintWidth() {
        return this.name.length + this.value.getPrintWidth() + QI.length;
      }
      write(e) {
        let r2 = new vt(this.name);
        this.hasError && r2.underline().setColor(e.context.colors.red), e.write(r2).write(QI).write(this.value);
      }
    };
    var Ou = class {
      static {
        __name(this, "Ou");
      }
      arguments;
      errorMessages = [];
      constructor(e) {
        this.arguments = e;
      }
      write(e) {
        e.write(this.arguments);
      }
      addErrorMessage(e) {
        this.errorMessages.push(e);
      }
      renderAllMessages(e) {
        return this.errorMessages.map((r2) => r2(e)).join(`
`);
      }
    };
    function dA(t2) {
      return new Ou(CI(t2));
    }
    __name(dA, "dA");
    function CI(t2) {
      let e = new uA();
      for (let [r2, n2] of Object.entries(t2)) {
        let A2 = new la(r2, II(n2));
        e.addField(A2);
      }
      return e;
    }
    __name(CI, "CI");
    function II(t2) {
      if (typeof t2 == "string") return new De(JSON.stringify(t2));
      if (typeof t2 == "number" || typeof t2 == "boolean") return new De(String(t2));
      if (typeof t2 == "bigint") return new De(`${t2}n`);
      if (t2 === null) return new De("null");
      if (t2 === void 0) return new De("undefined");
      if (sA(t2)) return new De(`new Prisma.Decimal("${t2.toFixed()}")`);
      if (t2 instanceof Uint8Array) return Buffer.isBuffer(t2) ? new De(`Buffer.alloc(${t2.byteLength})`) : new De(`new Uint8Array(${t2.byteLength})`);
      if (t2 instanceof Date) {
        let e = Jo(t2) ? t2.toISOString() : "Invalid Date";
        return new De(`new Date("${e}")`);
      }
      return t2 instanceof cr ? new De(`Prisma.${t2._getName()}`) : EA(t2) ? new De(`prisma.${Ur(t2.modelName)}.$fields.${t2.name}`) : Array.isArray(t2) ? mU(t2) : typeof t2 == "object" ? CI(t2) : new De(Object.prototype.toString.call(t2));
    }
    __name(II, "II");
    function mU(t2) {
      let e = new lA();
      for (let r2 of t2) e.addItem(II(r2));
      return e;
    }
    __name(mU, "mU");
    function ua(t2, e) {
      let r2 = e === "pretty" ? lI : sa, n2 = t2.renderAllMessages(r2), A2 = new aA(0, { colors: r2 }).write(t2).toString();
      return { message: n2, args: A2 };
    }
    __name(ua, "ua");
    function ga({ args: t2, errors: e, errorFormat: r2, callsite: n2, originalMethod: A2, clientVersion: i2, globalOmit: s }) {
      let o2 = dA(t2);
      for (let u2 of e) na(u2, o2, s);
      let { message: a2, args: c2 } = ua(o2, r2), l2 = ra({ message: a2, callsite: n2, originalMethod: A2, showColors: r2 === "pretty", callArguments: c2 });
      throw new Ue(l2, { clientVersion: i2 });
    }
    __name(ga, "ga");
    function Pt(t2) {
      return t2.replace(/^./, (e) => e.toLowerCase());
    }
    __name(Pt, "Pt");
    function BI(t2, e, r2) {
      let n2 = Pt(r2);
      return !e.result || !(e.result.$allModels || e.result[n2]) ? t2 : yU({ ...t2, ...pI(e.name, t2, e.result.$allModels), ...pI(e.name, t2, e.result[n2]) });
    }
    __name(BI, "BI");
    function yU(t2) {
      let e = new kt(), r2 = /* @__PURE__ */ __name((n2, A2) => e.getOrCreate(n2, () => A2.has(n2) ? [n2] : (A2.add(n2), t2[n2] ? t2[n2].needs.flatMap((i2) => r2(i2, A2)) : [n2])), "r");
      return Ho(t2, (n2) => ({ ...n2, needs: r2(n2.name, /* @__PURE__ */ new Set()) }));
    }
    __name(yU, "yU");
    function pI(t2, e, r2) {
      return r2 ? Ho(r2, ({ needs: n2, compute: A2 }, i2) => ({ name: i2, needs: n2 ? Object.keys(n2).filter((s) => n2[s]) : [], compute: wU(e, i2, A2) })) : {};
    }
    __name(pI, "pI");
    function wU(t2, e, r2) {
      let n2 = t2?.[e]?.compute;
      return n2 ? (A2) => r2({ ...A2, [e]: n2(A2) }) : r2;
    }
    __name(wU, "wU");
    function mI(t2, e) {
      if (!e) return t2;
      let r2 = { ...t2 };
      for (let n2 of Object.values(e)) if (t2[n2.name]) for (let A2 of n2.needs) r2[A2] = true;
      return r2;
    }
    __name(mI, "mI");
    function yI(t2, e) {
      if (!e) return t2;
      let r2 = { ...t2 };
      for (let n2 of Object.values(e)) if (!t2[n2.name]) for (let A2 of n2.needs) delete r2[A2];
      return r2;
    }
    __name(yI, "yI");
    var Ea = class {
      static {
        __name(this, "Ea");
      }
      constructor(e, r2) {
        this.extension = e;
        this.previous = r2;
      }
      computedFieldsCache = new kt();
      modelExtensionsCache = new kt();
      queryCallbacksCache = new kt();
      clientExtensions = Ti(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      batchCallbacks = Ti(() => {
        let e = this.previous?.getAllBatchQueryCallbacks() ?? [], r2 = this.extension.query?.$__internalBatch;
        return r2 ? e.concat(r2) : e;
      });
      getAllComputedFields(e) {
        return this.computedFieldsCache.getOrCreate(e, () => BI(this.previous?.getAllComputedFields(e), this.extension, e));
      }
      getAllClientExtensions() {
        return this.clientExtensions.get();
      }
      getAllModelExtensions(e) {
        return this.modelExtensionsCache.getOrCreate(e, () => {
          let r2 = Pt(e);
          return !this.extension.model || !(this.extension.model[r2] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(e) : { ...this.previous?.getAllModelExtensions(e), ...this.extension.model.$allModels, ...this.extension.model[r2] };
        });
      }
      getAllQueryCallbacks(e, r2) {
        return this.queryCallbacksCache.getOrCreate(`${e}:${r2}`, () => {
          let n2 = this.previous?.getAllQueryCallbacks(e, r2) ?? [], A2 = [], i2 = this.extension.query;
          return !i2 || !(i2[e] || i2.$allModels || i2[r2] || i2.$allOperations) ? n2 : (i2[e] !== void 0 && (i2[e][r2] !== void 0 && A2.push(i2[e][r2]), i2[e].$allOperations !== void 0 && A2.push(i2[e].$allOperations)), e !== "$none" && i2.$allModels !== void 0 && (i2.$allModels[r2] !== void 0 && A2.push(i2.$allModels[r2]), i2.$allModels.$allOperations !== void 0 && A2.push(i2.$allModels.$allOperations)), i2[r2] !== void 0 && A2.push(i2[r2]), i2.$allOperations !== void 0 && A2.push(i2.$allOperations), n2.concat(A2));
        });
      }
      getAllBatchQueryCallbacks() {
        return this.batchCallbacks.get();
      }
    };
    var hA = class t2 {
      static {
        __name(this, "t");
      }
      constructor(e) {
        this.head = e;
      }
      static empty() {
        return new t2();
      }
      static single(e) {
        return new t2(new Ea(e));
      }
      isEmpty() {
        return this.head === void 0;
      }
      append(e) {
        return new t2(new Ea(e, this.head));
      }
      getAllComputedFields(e) {
        return this.head?.getAllComputedFields(e);
      }
      getAllClientExtensions() {
        return this.head?.getAllClientExtensions();
      }
      getAllModelExtensions(e) {
        return this.head?.getAllModelExtensions(e);
      }
      getAllQueryCallbacks(e, r2) {
        return this.head?.getAllQueryCallbacks(e, r2) ?? [];
      }
      getAllBatchQueryCallbacks() {
        return this.head?.getAllBatchQueryCallbacks() ?? [];
      }
    };
    var da = class {
      static {
        __name(this, "da");
      }
      constructor(e) {
        this.name = e;
      }
    };
    function wI(t2) {
      return t2 instanceof da;
    }
    __name(wI, "wI");
    function DI(t2) {
      return new da(t2);
    }
    __name(DI, "DI");
    var RI = Symbol();
    var Oi = class {
      static {
        __name(this, "Oi");
      }
      constructor(e) {
        if (e !== RI) throw new Error("Skip instance can not be constructed directly");
      }
      ifUndefined(e) {
        return e === void 0 ? ha : e;
      }
    };
    var ha = new Oi(RI);
    function Yt(t2) {
      return t2 instanceof Oi;
    }
    __name(Yt, "Yt");
    var DU = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", createManyAndReturn: "createManyAndReturn", update: "updateOne", updateMany: "updateMany", updateManyAndReturn: "updateManyAndReturn", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
    var SI = "explicitly `undefined` values are not allowed";
    function fa({ modelName: t2, action: e, args: r2, runtimeDataModel: n2, extensions: A2 = hA.empty(), callsite: i2, clientMethod: s, errorFormat: o2, clientVersion: a2, previewFeatures: c2, globalOmit: l2 }) {
      let u2 = new Vu({ runtimeDataModel: n2, modelName: t2, action: e, rootArgs: r2, callsite: i2, extensions: A2, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: o2, clientVersion: a2, previewFeatures: c2, globalOmit: l2 });
      return { modelName: t2, action: DU[e], query: Vi(r2, u2) };
    }
    __name(fa, "fa");
    function Vi({ select: t2, include: e, ...r2 } = {}, n2) {
      let A2 = r2.omit;
      return delete r2.omit, { arguments: NI(r2, n2), selection: RU(t2, e, A2, n2) };
    }
    __name(Vi, "Vi");
    function RU(t2, e, r2, n2) {
      return t2 ? (e ? n2.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "include", secondField: "select", selectionPath: n2.getSelectionPath() }) : r2 && n2.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "omit", secondField: "select", selectionPath: n2.getSelectionPath() }), FU(t2, n2)) : SU(n2, e, r2);
    }
    __name(RU, "RU");
    function SU(t2, e, r2) {
      let n2 = {};
      return t2.modelOrType && !t2.isRawAction() && (n2.$composites = true, n2.$scalars = true), e && bU(n2, e, t2), NU(n2, r2, t2), n2;
    }
    __name(SU, "SU");
    function bU(t2, e, r2) {
      for (let [n2, A2] of Object.entries(e)) {
        if (Yt(A2)) continue;
        let i2 = r2.nestSelection(n2);
        if (Hu(A2, i2), A2 === false || A2 === void 0) {
          t2[n2] = false;
          continue;
        }
        let s = r2.findField(n2);
        if (s && s.kind !== "object" && r2.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r2.getSelectionPath().concat(n2), outputType: r2.getOutputTypeDescription() }), s) {
          t2[n2] = Vi(A2 === true ? {} : A2, i2);
          continue;
        }
        if (A2 === true) {
          t2[n2] = true;
          continue;
        }
        t2[n2] = Vi(A2, i2);
      }
    }
    __name(bU, "bU");
    function NU(t2, e, r2) {
      let n2 = r2.getComputedFields(), A2 = { ...r2.getGlobalOmit(), ...e }, i2 = yI(A2, n2);
      for (let [s, o2] of Object.entries(i2)) {
        if (Yt(o2)) continue;
        Hu(o2, r2.nestSelection(s));
        let a2 = r2.findField(s);
        n2?.[s] && !a2 || (t2[s] = !o2);
      }
    }
    __name(NU, "NU");
    function FU(t2, e) {
      let r2 = {}, n2 = e.getComputedFields(), A2 = mI(t2, n2);
      for (let [i2, s] of Object.entries(A2)) {
        if (Yt(s)) continue;
        let o2 = e.nestSelection(i2);
        Hu(s, o2);
        let a2 = e.findField(i2);
        if (!(n2?.[i2] && !a2)) {
          if (s === false || s === void 0 || Yt(s)) {
            r2[i2] = false;
            continue;
          }
          if (s === true) {
            a2?.kind === "object" ? r2[i2] = Vi({}, o2) : r2[i2] = true;
            continue;
          }
          r2[i2] = Vi(s, o2);
        }
      }
      return r2;
    }
    __name(FU, "FU");
    function bI(t2, e) {
      if (t2 === null) return null;
      if (typeof t2 == "string" || typeof t2 == "number" || typeof t2 == "boolean") return t2;
      if (typeof t2 == "bigint") return { $type: "BigInt", value: String(t2) };
      if (nA(t2)) {
        if (Jo(t2)) return { $type: "DateTime", value: t2.toISOString() };
        e.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: e.getSelectionPath(), argumentPath: e.getArgumentPath(), argument: { name: e.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
      }
      if (wI(t2)) return { $type: "Param", value: t2.name };
      if (EA(t2)) return { $type: "FieldRef", value: { _ref: t2.name, _container: t2.modelName } };
      if (Array.isArray(t2)) return TU(t2, e);
      if (ArrayBuffer.isView(t2)) {
        let { buffer: r2, byteOffset: n2, byteLength: A2 } = t2;
        return { $type: "Bytes", value: Buffer.from(r2, n2, A2).toString("base64") };
      }
      if (xU(t2)) return t2.values;
      if (sA(t2)) return { $type: "Decimal", value: t2.toFixed() };
      if (t2 instanceof cr) {
        if (t2 !== ca.instances[t2._getName()]) throw new Error("Invalid ObjectEnumValue");
        return { $type: "Enum", value: t2._getName() };
      }
      if (UU(t2)) return t2.toJSON();
      if (typeof t2 == "object") return NI(t2, e);
      e.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: e.getSelectionPath(), argumentPath: e.getArgumentPath(), argument: { name: e.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(t2)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
    }
    __name(bI, "bI");
    function NI(t2, e) {
      if (t2.$type) return { $type: "Raw", value: t2 };
      let r2 = {};
      for (let n2 in t2) {
        let A2 = t2[n2], i2 = e.nestArgument(n2);
        Yt(A2) || (A2 !== void 0 ? r2[n2] = bI(A2, i2) : e.isPreviewFeatureOn("strictUndefinedChecks") && e.throwValidationError({ kind: "InvalidArgumentValue", argumentPath: i2.getArgumentPath(), selectionPath: e.getSelectionPath(), argument: { name: e.getArgumentName(), typeNames: [] }, underlyingError: SI }));
      }
      return r2;
    }
    __name(NI, "NI");
    function TU(t2, e) {
      let r2 = [];
      for (let n2 = 0; n2 < t2.length; n2++) {
        let A2 = e.nestArgument(String(n2)), i2 = t2[n2];
        if (i2 === void 0 || Yt(i2)) {
          let s = i2 === void 0 ? "undefined" : "Prisma.skip";
          e.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: A2.getSelectionPath(), argumentPath: A2.getArgumentPath(), argument: { name: `${e.getArgumentName()}[${n2}]`, typeNames: [] }, underlyingError: `Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values` });
        }
        r2.push(bI(i2, A2));
      }
      return r2;
    }
    __name(TU, "TU");
    function xU(t2) {
      return typeof t2 == "object" && t2 !== null && t2.__prismaRawParameters__ === true;
    }
    __name(xU, "xU");
    function UU(t2) {
      return typeof t2 == "object" && t2 !== null && typeof t2.toJSON == "function";
    }
    __name(UU, "UU");
    function Hu(t2, e) {
      t2 === void 0 && e.isPreviewFeatureOn("strictUndefinedChecks") && e.throwValidationError({ kind: "InvalidSelectionValue", selectionPath: e.getSelectionPath(), underlyingError: SI });
    }
    __name(Hu, "Hu");
    var Vu = class t2 {
      static {
        __name(this, "t");
      }
      constructor(e) {
        this.params = e;
        this.params.modelName && (this.modelOrType = this.params.runtimeDataModel.models[this.params.modelName] ?? this.params.runtimeDataModel.types[this.params.modelName]);
      }
      modelOrType;
      throwValidationError(e) {
        ga({ errors: [e], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion, globalOmit: this.params.globalOmit });
      }
      getSelectionPath() {
        return this.params.selectionPath;
      }
      getArgumentPath() {
        return this.params.argumentPath;
      }
      getArgumentName() {
        return this.params.argumentPath[this.params.argumentPath.length - 1];
      }
      getOutputTypeDescription() {
        if (!(!this.params.modelName || !this.modelOrType)) return { name: this.params.modelName, fields: this.modelOrType.fields.map((e) => ({ name: e.name, typeName: "boolean", isRelation: e.kind === "object" })) };
      }
      isRawAction() {
        return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
      }
      isPreviewFeatureOn(e) {
        return this.params.previewFeatures.includes(e);
      }
      getComputedFields() {
        if (this.params.modelName) return this.params.extensions.getAllComputedFields(this.params.modelName);
      }
      findField(e) {
        return this.modelOrType?.fields.find((r2) => r2.name === e);
      }
      nestSelection(e) {
        let r2 = this.findField(e), n2 = r2?.kind === "object" ? r2.type : void 0;
        return new t2({ ...this.params, modelName: n2, selectionPath: this.params.selectionPath.concat(e) });
      }
      getGlobalOmit() {
        return this.params.modelName && this.shouldApplyGlobalOmit() ? this.params.globalOmit?.[Ur(this.params.modelName)] ?? {} : {};
      }
      shouldApplyGlobalOmit() {
        switch (this.params.action) {
          case "findFirst":
          case "findFirstOrThrow":
          case "findUniqueOrThrow":
          case "findMany":
          case "upsert":
          case "findUnique":
          case "createManyAndReturn":
          case "create":
          case "update":
          case "updateManyAndReturn":
          case "delete":
            return true;
          case "executeRaw":
          case "aggregateRaw":
          case "runCommandRaw":
          case "findRaw":
          case "createMany":
          case "deleteMany":
          case "groupBy":
          case "updateMany":
          case "count":
          case "aggregate":
          case "queryRaw":
            return false;
          default:
            ln(this.params.action, "Unknown action");
        }
      }
      nestArgument(e) {
        return new t2({ ...this.params, argumentPath: this.params.argumentPath.concat(e) });
      }
    };
    function FI(t2) {
      if (!t2._hasPreviewFlag("metrics")) throw new Ue("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: t2._clientVersion });
    }
    __name(FI, "FI");
    var fA = class {
      static {
        __name(this, "fA");
      }
      _client;
      constructor(e) {
        this._client = e;
      }
      prometheus(e) {
        return FI(this._client), this._client._engine.metrics({ format: "prometheus", ...e });
      }
      json(e) {
        return FI(this._client), this._client._engine.metrics({ format: "json", ...e });
      }
    };
    function TI(t2, e) {
      let r2 = Ti(() => kU(e));
      Object.defineProperty(t2, "dmmf", { get: /* @__PURE__ */ __name(() => r2.get(), "get") });
    }
    __name(TI, "TI");
    function kU(t2) {
      return { datamodel: { models: qu(t2.models), enums: qu(t2.enums), types: qu(t2.types) } };
    }
    __name(kU, "kU");
    function qu(t2) {
      return Object.entries(t2).map(([e, r2]) => ({ name: e, ...r2 }));
    }
    __name(qu, "qu");
    var Ju = /* @__PURE__ */ new WeakMap();
    var Qa = "$$PrismaTypedSql";
    var Hi = class {
      static {
        __name(this, "Hi");
      }
      constructor(e, r2) {
        Ju.set(this, { sql: e, values: r2 }), Object.defineProperty(this, Qa, { value: Qa });
      }
      get sql() {
        return Ju.get(this).sql;
      }
      get values() {
        return Ju.get(this).values;
      }
    };
    function xI(t2) {
      return (...e) => new Hi(t2, e);
    }
    __name(xI, "xI");
    function Ca(t2) {
      return t2 != null && t2[Qa] === Qa;
    }
    __name(Ca, "Ca");
    var hb = G2(du());
    var fb = __require("node:async_hooks");
    var Qb = __require("node:events");
    var Cb = G2(__require("node:fs"));
    var kl = G2(__require("node:path"));
    var _e = class t2 {
      static {
        __name(this, "t");
      }
      constructor(e, r2) {
        if (e.length - 1 !== r2.length) throw e.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${e.length} strings to have ${e.length - 1} values`);
        let n2 = r2.reduce((s, o2) => s + (o2 instanceof t2 ? o2.values.length : 1), 0);
        this.values = new Array(n2), this.strings = new Array(n2 + 1), this.strings[0] = e[0];
        let A2 = 0, i2 = 0;
        for (; A2 < r2.length; ) {
          let s = r2[A2++], o2 = e[A2];
          if (s instanceof t2) {
            this.strings[i2] += s.strings[0];
            let a2 = 0;
            for (; a2 < s.values.length; ) this.values[i2++] = s.values[a2++], this.strings[i2] = s.strings[a2];
            this.strings[i2] += o2;
          } else this.values[i2++] = s, this.strings[i2] = o2;
        }
      }
      get sql() {
        let e = this.strings.length, r2 = 1, n2 = this.strings[0];
        for (; r2 < e; ) n2 += `?${this.strings[r2++]}`;
        return n2;
      }
      get statement() {
        let e = this.strings.length, r2 = 1, n2 = this.strings[0];
        for (; r2 < e; ) n2 += `:${r2}${this.strings[r2++]}`;
        return n2;
      }
      get text() {
        let e = this.strings.length, r2 = 1, n2 = this.strings[0];
        for (; r2 < e; ) n2 += `$${r2}${this.strings[r2++]}`;
        return n2;
      }
      inspect() {
        return { sql: this.sql, statement: this.statement, text: this.text, values: this.values };
      }
    };
    function UI(t2, e = ",", r2 = "", n2 = "") {
      if (t2.length === 0) throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
      return new _e([r2, ...Array(t2.length - 1).fill(e), n2], t2);
    }
    __name(UI, "UI");
    function Wu(t2) {
      return new _e([t2], []);
    }
    __name(Wu, "Wu");
    var kI = Wu("");
    function _u(t2, ...e) {
      return new _e(t2, e);
    }
    __name(_u, "_u");
    function qi(t2) {
      return { getKeys() {
        return Object.keys(t2);
      }, getPropertyValue(e) {
        return t2[e];
      } };
    }
    __name(qi, "qi");
    function Oe(t2, e) {
      return { getKeys() {
        return [t2];
      }, getPropertyValue() {
        return e();
      } };
    }
    __name(Oe, "Oe");
    function gn(t2) {
      let e = new kt();
      return { getKeys() {
        return t2.getKeys();
      }, getPropertyValue(r2) {
        return e.getOrCreate(r2, () => t2.getPropertyValue(r2));
      }, getPropertyDescriptor(r2) {
        return t2.getPropertyDescriptor?.(r2);
      } };
    }
    __name(gn, "gn");
    var Ia = { enumerable: true, configurable: true, writable: true };
    function pa(t2) {
      let e = new Set(t2);
      return { getPrototypeOf: /* @__PURE__ */ __name(() => Object.prototype, "getPrototypeOf"), getOwnPropertyDescriptor: /* @__PURE__ */ __name(() => Ia, "getOwnPropertyDescriptor"), has: /* @__PURE__ */ __name((r2, n2) => e.has(n2), "has"), set: /* @__PURE__ */ __name((r2, n2, A2) => e.add(n2) && Reflect.set(r2, n2, A2), "set"), ownKeys: /* @__PURE__ */ __name(() => [...e], "ownKeys") };
    }
    __name(pa, "pa");
    var MI = Symbol.for("nodejs.util.inspect.custom");
    function mt(t2, e) {
      let r2 = MU(e), n2 = /* @__PURE__ */ new Set(), A2 = new Proxy(t2, { get(i2, s) {
        if (n2.has(s)) return i2[s];
        let o2 = r2.get(s);
        return o2 ? o2.getPropertyValue(s) : i2[s];
      }, has(i2, s) {
        if (n2.has(s)) return true;
        let o2 = r2.get(s);
        return o2 ? o2.has?.(s) ?? true : Reflect.has(i2, s);
      }, ownKeys(i2) {
        let s = LI(Reflect.ownKeys(i2), r2), o2 = LI(Array.from(r2.keys()), r2);
        return [.../* @__PURE__ */ new Set([...s, ...o2, ...n2])];
      }, set(i2, s, o2) {
        return r2.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n2.add(s), Reflect.set(i2, s, o2));
      }, getOwnPropertyDescriptor(i2, s) {
        let o2 = Reflect.getOwnPropertyDescriptor(i2, s);
        if (o2 && !o2.configurable) return o2;
        let a2 = r2.get(s);
        return a2 ? a2.getPropertyDescriptor ? { ...Ia, ...a2?.getPropertyDescriptor(s) } : Ia : o2;
      }, defineProperty(i2, s, o2) {
        return n2.add(s), Reflect.defineProperty(i2, s, o2);
      }, getPrototypeOf: /* @__PURE__ */ __name(() => Object.prototype, "getPrototypeOf") });
      return A2[MI] = function() {
        let i2 = { ...this };
        return delete i2[MI], i2;
      }, A2;
    }
    __name(mt, "mt");
    function MU(t2) {
      let e = /* @__PURE__ */ new Map();
      for (let r2 of t2) {
        let n2 = r2.getKeys();
        for (let A2 of n2) e.set(A2, r2);
      }
      return e;
    }
    __name(MU, "MU");
    function LI(t2, e) {
      return t2.filter((r2) => e.get(r2)?.has?.(r2) ?? true);
    }
    __name(LI, "LI");
    function QA(t2) {
      return { getKeys() {
        return t2;
      }, has() {
        return false;
      }, getPropertyValue() {
      } };
    }
    __name(QA, "QA");
    function CA(t2, e) {
      return { batch: t2, transaction: e?.kind === "batch" ? { isolationLevel: e.options.isolationLevel } : void 0 };
    }
    __name(CA, "CA");
    function vI(t2) {
      if (t2 === void 0) return "";
      let e = dA(t2);
      return new aA(0, { colors: sa }).write(e).toString();
    }
    __name(vI, "vI");
    var LU = "P2037";
    function Yr({ error: t2, user_facing_error: e }, r2, n2) {
      return e.error_code ? new Ne(vU(e, n2), { code: e.error_code, clientVersion: r2, meta: e.meta, batchRequestIdx: e.batch_request_idx }) : new Be(t2, { clientVersion: r2, batchRequestIdx: e.batch_request_idx });
    }
    __name(Yr, "Yr");
    function vU(t2, e) {
      let r2 = t2.message;
      return (e === "postgresql" || e === "postgres" || e === "mysql") && t2.error_code === LU && (r2 += `
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`), r2;
    }
    __name(vU, "vU");
    var Ji = "<unknown>";
    function PI(t2) {
      var e = t2.split(`
`);
      return e.reduce(function(r2, n2) {
        var A2 = GU(n2) || VU(n2) || JU(n2) || ZU(n2) || _U(n2);
        return A2 && r2.push(A2), r2;
      }, []);
    }
    __name(PI, "PI");
    var PU = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var YU = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    function GU(t2) {
      var e = PU.exec(t2);
      if (!e) return null;
      var r2 = e[2] && e[2].indexOf("native") === 0, n2 = e[2] && e[2].indexOf("eval") === 0, A2 = YU.exec(e[2]);
      return n2 && A2 != null && (e[2] = A2[1], e[3] = A2[2], e[4] = A2[3]), { file: r2 ? null : e[2], methodName: e[1] || Ji, arguments: r2 ? [e[2]] : [], lineNumber: e[3] ? +e[3] : null, column: e[4] ? +e[4] : null };
    }
    __name(GU, "GU");
    var OU = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function VU(t2) {
      var e = OU.exec(t2);
      return e ? { file: e[2], methodName: e[1] || Ji, arguments: [], lineNumber: +e[3], column: e[4] ? +e[4] : null } : null;
    }
    __name(VU, "VU");
    var HU = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    var qU = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    function JU(t2) {
      var e = HU.exec(t2);
      if (!e) return null;
      var r2 = e[3] && e[3].indexOf(" > eval") > -1, n2 = qU.exec(e[3]);
      return r2 && n2 != null && (e[3] = n2[1], e[4] = n2[2], e[5] = null), { file: e[3], methodName: e[1] || Ji, arguments: e[2] ? e[2].split(",") : [], lineNumber: e[4] ? +e[4] : null, column: e[5] ? +e[5] : null };
    }
    __name(JU, "JU");
    var WU = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
    function _U(t2) {
      var e = WU.exec(t2);
      return e ? { file: e[3], methodName: e[1] || Ji, arguments: [], lineNumber: +e[4], column: e[5] ? +e[5] : null } : null;
    }
    __name(_U, "_U");
    var jU = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function ZU(t2) {
      var e = jU.exec(t2);
      return e ? { file: e[2], methodName: e[1] || Ji, arguments: [], lineNumber: +e[3], column: e[4] ? +e[4] : null } : null;
    }
    __name(ZU, "ZU");
    var ju = class {
      static {
        __name(this, "ju");
      }
      getLocation() {
        return null;
      }
    };
    var Zu = class {
      static {
        __name(this, "Zu");
      }
      _error;
      constructor() {
        this._error = new Error();
      }
      getLocation() {
        let e = this._error.stack;
        if (!e) return null;
        let n2 = PI(e).find((A2) => {
          if (!A2.file) return false;
          let i2 = wu(A2.file);
          return i2 !== "<anonymous>" && !i2.includes("@prisma") && !i2.includes("/packages/client/src/runtime/") && !i2.endsWith("/runtime/binary.js") && !i2.endsWith("/runtime/library.js") && !i2.endsWith("/runtime/edge.js") && !i2.endsWith("/runtime/edge-esm.js") && !i2.startsWith("internal/") && !A2.methodName.includes("new ") && !A2.methodName.includes("getCallSite") && !A2.methodName.includes("Proxy.") && A2.methodName.split(".").length < 4;
        });
        return !n2 || !n2.file ? null : { fileName: n2.file, lineNumber: n2.lineNumber, columnNumber: n2.column };
      }
    };
    function Gr(t2) {
      return t2 === "minimal" ? typeof $EnabledCallSite == "function" && t2 !== "minimal" ? new $EnabledCallSite() : new ju() : new Zu();
    }
    __name(Gr, "Gr");
    var YI = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
    function IA(t2 = {}) {
      let e = KU(t2);
      return Object.entries(e).reduce((n2, [A2, i2]) => (YI[A2] !== void 0 ? n2.select[A2] = { select: i2 } : n2[A2] = i2, n2), { select: {} });
    }
    __name(IA, "IA");
    function KU(t2 = {}) {
      return typeof t2._count == "boolean" ? { ...t2, _count: { _all: t2._count } } : t2;
    }
    __name(KU, "KU");
    function Ba(t2 = {}) {
      return (e) => (typeof t2._count == "boolean" && (e._count = e._count._all), e);
    }
    __name(Ba, "Ba");
    function GI(t2, e) {
      let r2 = Ba(t2);
      return e({ action: "aggregate", unpacker: r2, argsMapper: IA })(t2);
    }
    __name(GI, "GI");
    function $U(t2 = {}) {
      let { select: e, ...r2 } = t2;
      return typeof e == "object" ? IA({ ...r2, _count: e }) : IA({ ...r2, _count: { _all: true } });
    }
    __name($U, "$U");
    function zU(t2 = {}) {
      return typeof t2.select == "object" ? (e) => Ba(t2)(e)._count : (e) => Ba(t2)(e)._count._all;
    }
    __name(zU, "zU");
    function OI(t2, e) {
      return e({ action: "count", unpacker: zU(t2), argsMapper: $U })(t2);
    }
    __name(OI, "OI");
    function ek(t2 = {}) {
      let e = IA(t2);
      if (Array.isArray(e.by)) for (let r2 of e.by) typeof r2 == "string" && (e.select[r2] = true);
      else typeof e.by == "string" && (e.select[e.by] = true);
      return e;
    }
    __name(ek, "ek");
    function tk(t2 = {}) {
      return (e) => (typeof t2?._count == "boolean" && e.forEach((r2) => {
        r2._count = r2._count._all;
      }), e);
    }
    __name(tk, "tk");
    function VI(t2, e) {
      return e({ action: "groupBy", unpacker: tk(t2), argsMapper: ek })(t2);
    }
    __name(VI, "VI");
    function HI(t2, e, r2) {
      if (e === "aggregate") return (n2) => GI(n2, r2);
      if (e === "count") return (n2) => OI(n2, r2);
      if (e === "groupBy") return (n2) => VI(n2, r2);
    }
    __name(HI, "HI");
    function qI(t2, e) {
      let r2 = e.fields.filter((A2) => !A2.relationName), n2 = LC(r2, "name");
      return new Proxy({}, { get(A2, i2) {
        if (i2 in A2 || typeof i2 == "symbol") return A2[i2];
        let s = n2[i2];
        if (s) return new Li(t2, i2, s.type, s.isList, s.kind === "enum");
      }, ...pa(Object.keys(n2)) });
    }
    __name(qI, "qI");
    var JI = /* @__PURE__ */ __name((t2) => Array.isArray(t2) ? t2 : t2.split("."), "JI");
    var Xu = /* @__PURE__ */ __name((t2, e) => JI(e).reduce((r2, n2) => r2 && r2[n2], t2), "Xu");
    var WI = /* @__PURE__ */ __name((t2, e, r2) => JI(e).reduceRight((n2, A2, i2, s) => Object.assign({}, Xu(t2, s.slice(0, i2)), { [A2]: n2 }), r2), "WI");
    function rk(t2, e) {
      return t2 === void 0 || e === void 0 ? [] : [...e, "select", t2];
    }
    __name(rk, "rk");
    function nk(t2, e, r2) {
      return e === void 0 ? t2 ?? {} : WI(e, r2, t2 || true);
    }
    __name(nk, "nk");
    function Ku(t2, e, r2, n2, A2, i2) {
      let o2 = t2._runtimeDataModel.models[e].fields.reduce((a2, c2) => ({ ...a2, [c2.name]: c2 }), {});
      return (a2) => {
        let c2 = Gr(t2._errorFormat), l2 = rk(n2, A2), u2 = nk(a2, i2, l2), g = r2({ dataPath: l2, callsite: c2 })(u2), E = Ak(t2, e);
        return new Proxy(g, { get(h, f2) {
          if (!E.includes(f2)) return h[f2];
          let Q = [o2[f2].type, r2, f2], I2 = [l2, u2];
          return Ku(t2, ...Q, ...I2);
        }, ...pa([...E, ...Object.getOwnPropertyNames(g)]) });
      };
    }
    __name(Ku, "Ku");
    function Ak(t2, e) {
      return t2._runtimeDataModel.models[e].fields.filter((r2) => r2.kind === "object").map((r2) => r2.name);
    }
    __name(Ak, "Ak");
    var ik = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
    var sk = ["aggregate", "count", "groupBy"];
    function $u(t2, e) {
      let r2 = t2._extensions.getAllModelExtensions(e) ?? {}, n2 = [ok(t2, e), ck(t2, e), qi(r2), Oe("name", () => e), Oe("$name", () => e), Oe("$parent", () => t2._appliedParent)];
      return mt({}, n2);
    }
    __name($u, "$u");
    function ok(t2, e) {
      let r2 = Pt(e), n2 = Object.keys(oA).concat("count");
      return { getKeys() {
        return n2;
      }, getPropertyValue(A2) {
        let i2 = A2, s = /* @__PURE__ */ __name((o2) => (a2) => {
          let c2 = Gr(t2._errorFormat);
          return t2._createPrismaPromise((l2) => {
            let u2 = { args: a2, dataPath: [], action: i2, model: e, clientMethod: `${r2}.${A2}`, jsModelName: r2, transaction: l2, callsite: c2 };
            return t2._request({ ...u2, ...o2 });
          }, { action: i2, args: a2, model: e });
        }, "s");
        return ik.includes(i2) ? Ku(t2, e, s) : ak(A2) ? HI(t2, A2, s) : s({});
      } };
    }
    __name(ok, "ok");
    function ak(t2) {
      return sk.includes(t2);
    }
    __name(ak, "ak");
    function ck(t2, e) {
      return gn(Oe("fields", () => {
        let r2 = t2._runtimeDataModel.models[e];
        return qI(e, r2);
      }));
    }
    __name(ck, "ck");
    function _I(t2) {
      return t2.replace(/^./, (e) => e.toUpperCase());
    }
    __name(_I, "_I");
    var zu = Symbol();
    function Wi(t2) {
      let e = [lk(t2), uk(t2), Oe(zu, () => t2), Oe("$parent", () => t2._appliedParent)], r2 = t2._extensions.getAllClientExtensions();
      return r2 && e.push(qi(r2)), mt(t2, e);
    }
    __name(Wi, "Wi");
    function lk(t2) {
      let e = Object.getPrototypeOf(t2._originalClient), r2 = [...new Set(Object.getOwnPropertyNames(e))];
      return { getKeys() {
        return r2;
      }, getPropertyValue(n2) {
        return t2[n2];
      } };
    }
    __name(lk, "lk");
    function uk(t2) {
      let e = Object.keys(t2._runtimeDataModel.models), r2 = e.map(Pt), n2 = [...new Set(e.concat(r2))];
      return gn({ getKeys() {
        return n2;
      }, getPropertyValue(A2) {
        let i2 = _I(A2);
        if (t2._runtimeDataModel.models[i2] !== void 0) return $u(t2, i2);
        if (t2._runtimeDataModel.models[A2] !== void 0) return $u(t2, A2);
      }, getPropertyDescriptor(A2) {
        if (!r2.includes(A2)) return { enumerable: false };
      } });
    }
    __name(uk, "uk");
    function jI(t2) {
      return t2[zu] ? t2[zu] : t2;
    }
    __name(jI, "jI");
    function ZI(t2) {
      if (typeof t2 == "function") return t2(this);
      if (t2.client?.__AccelerateEngine) {
        let r2 = t2.client.__AccelerateEngine;
        this._originalClient._engine = new r2(this._originalClient._accelerateEngineConfig);
      }
      let e = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(t2) }, _appliedParent: { value: this, configurable: true }, $on: { value: void 0 } });
      return Wi(e);
    }
    __name(ZI, "ZI");
    function XI({ result: t2, modelName: e, select: r2, omit: n2, extensions: A2 }) {
      let i2 = A2.getAllComputedFields(e);
      if (!i2) return t2;
      let s = [], o2 = [];
      for (let a2 of Object.values(i2)) {
        if (n2) {
          if (n2[a2.name]) continue;
          let c2 = a2.needs.filter((l2) => n2[l2]);
          c2.length > 0 && o2.push(QA(c2));
        } else if (r2) {
          if (!r2[a2.name]) continue;
          let c2 = a2.needs.filter((l2) => !r2[l2]);
          c2.length > 0 && o2.push(QA(c2));
        }
        gk(t2, a2.needs) && s.push(Ek(a2, mt(t2, s)));
      }
      return s.length > 0 || o2.length > 0 ? mt(t2, [...s, ...o2]) : t2;
    }
    __name(XI, "XI");
    function gk(t2, e) {
      return e.every((r2) => Nu(t2, r2));
    }
    __name(gk, "gk");
    function Ek(t2, e) {
      return gn(Oe(t2.name, () => t2.compute(e)));
    }
    __name(Ek, "Ek");
    function ma({ visitor: t2, result: e, args: r2, runtimeDataModel: n2, modelName: A2 }) {
      if (Array.isArray(e)) {
        for (let s = 0; s < e.length; s++) e[s] = ma({ result: e[s], args: r2, modelName: A2, runtimeDataModel: n2, visitor: t2 });
        return e;
      }
      let i2 = t2(e, A2, r2) ?? e;
      return r2.include && KI({ includeOrSelect: r2.include, result: i2, parentModelName: A2, runtimeDataModel: n2, visitor: t2 }), r2.select && KI({ includeOrSelect: r2.select, result: i2, parentModelName: A2, runtimeDataModel: n2, visitor: t2 }), i2;
    }
    __name(ma, "ma");
    function KI({ includeOrSelect: t2, result: e, parentModelName: r2, runtimeDataModel: n2, visitor: A2 }) {
      for (let [i2, s] of Object.entries(t2)) {
        if (!s || e[i2] == null || Yt(s)) continue;
        let a2 = n2.models[r2].fields.find((l2) => l2.name === i2);
        if (!a2 || a2.kind !== "object" || !a2.relationName) continue;
        let c2 = typeof s == "object" ? s : {};
        e[i2] = ma({ visitor: A2, result: e[i2], args: c2, modelName: a2.type, runtimeDataModel: n2 });
      }
    }
    __name(KI, "KI");
    function $I({ result: t2, modelName: e, args: r2, extensions: n2, runtimeDataModel: A2, globalOmit: i2 }) {
      return n2.isEmpty() || t2 == null || typeof t2 != "object" || !A2.models[e] ? t2 : ma({ result: t2, args: r2 ?? {}, modelName: e, runtimeDataModel: A2, visitor: /* @__PURE__ */ __name((o2, a2, c2) => {
        let l2 = Pt(a2);
        return XI({ result: o2, modelName: l2, select: c2.select, omit: c2.select ? void 0 : { ...i2?.[l2], ...c2.omit }, extensions: n2 });
      }, "visitor") });
    }
    __name($I, "$I");
    var dk = ["$connect", "$disconnect", "$on", "$transaction", "$extends"];
    var zI = dk;
    function ep(t2) {
      if (t2 instanceof _e) return hk(t2);
      if (Ca(t2)) return fk(t2);
      if (Array.isArray(t2)) {
        let r2 = [t2[0]];
        for (let n2 = 1; n2 < t2.length; n2++) r2[n2] = _i(t2[n2]);
        return r2;
      }
      let e = {};
      for (let r2 in t2) e[r2] = _i(t2[r2]);
      return e;
    }
    __name(ep, "ep");
    function hk(t2) {
      return new _e(t2.strings, t2.values);
    }
    __name(hk, "hk");
    function fk(t2) {
      return new Hi(t2.sql, t2.values);
    }
    __name(fk, "fk");
    function _i(t2) {
      if (typeof t2 != "object" || t2 == null || t2 instanceof cr || EA(t2)) return t2;
      if (sA(t2)) return new ar(t2.toFixed());
      if (nA(t2)) return /* @__PURE__ */ new Date(+t2);
      if (ArrayBuffer.isView(t2)) return t2.slice(0);
      if (Array.isArray(t2)) {
        let e = t2.length, r2;
        for (r2 = Array(e); e--; ) r2[e] = _i(t2[e]);
        return r2;
      }
      if (typeof t2 == "object") {
        let e = {};
        for (let r2 in t2) r2 === "__proto__" ? Object.defineProperty(e, r2, { value: _i(t2[r2]), configurable: true, enumerable: true, writable: true }) : e[r2] = _i(t2[r2]);
        return e;
      }
      ln(t2, "Unknown value");
    }
    __name(_i, "_i");
    function rp(t2, e, r2, n2 = 0) {
      return t2._createPrismaPromise((A2) => {
        let i2 = e.customDataProxyFetch;
        return "transaction" in e && A2 !== void 0 && (e.transaction?.kind === "batch" && e.transaction.lock.then(), e.transaction = A2), n2 === r2.length ? t2._executeRequest(e) : r2[n2]({ model: e.model, operation: e.model ? e.action : e.clientMethod, args: ep(e.args ?? {}), __internalParams: e, query: /* @__PURE__ */ __name((s, o2 = e) => {
          let a2 = o2.customDataProxyFetch;
          return o2.customDataProxyFetch = sp(i2, a2), o2.args = s, rp(t2, o2, r2, n2 + 1);
        }, "query") });
      });
    }
    __name(rp, "rp");
    function np(t2, e) {
      let { jsModelName: r2, action: n2, clientMethod: A2 } = e, i2 = r2 ? n2 : A2;
      if (t2._extensions.isEmpty()) return t2._executeRequest(e);
      let s = t2._extensions.getAllQueryCallbacks(r2 ?? "$none", i2);
      return rp(t2, e, s);
    }
    __name(np, "np");
    function Ap(t2) {
      return (e) => {
        let r2 = { requests: e }, n2 = e[0].extensions.getAllBatchQueryCallbacks();
        return n2.length ? ip(r2, n2, 0, t2) : t2(r2);
      };
    }
    __name(Ap, "Ap");
    function ip(t2, e, r2, n2) {
      if (r2 === e.length) return n2(t2);
      let A2 = t2.customDataProxyFetch, i2 = t2.requests[0].transaction;
      return e[r2]({ args: { queries: t2.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: i2 ? { isolationLevel: i2.kind === "batch" ? i2.isolationLevel : void 0 } : void 0 }, __internalParams: t2, query(s, o2 = t2) {
        let a2 = o2.customDataProxyFetch;
        return o2.customDataProxyFetch = sp(A2, a2), ip(o2, e, r2 + 1, n2);
      } });
    }
    __name(ip, "ip");
    var tp = /* @__PURE__ */ __name((t2) => t2, "tp");
    function sp(t2 = tp, e = tp) {
      return (r2) => t2(e(r2));
    }
    __name(sp, "sp");
    var op = ce("prisma:client");
    var ap = { Vercel: "vercel", "Netlify CI": "netlify" };
    function cp({ postinstall: t2, ciName: e, clientVersion: r2 }) {
      if (op("checkPlatformCaching:postinstall", t2), op("checkPlatformCaching:ciName", e), t2 === true && e && e in ap) {
        let n2 = `Prisma has detected that this project was built on ${e}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ap[e]}-build`;
        throw console.error(n2), new Z(n2, r2);
      }
    }
    __name(cp, "cp");
    function lp(t2, e) {
      return t2 ? t2.datasources ? t2.datasources : t2.datasourceUrl ? { [e[0]]: { url: t2.datasourceUrl } } : {} : {};
    }
    __name(lp, "lp");
    var Qk = /* @__PURE__ */ __name(() => globalThis.process?.release?.name === "node", "Qk");
    var Ck = /* @__PURE__ */ __name(() => !!globalThis.Bun || !!globalThis.process?.versions?.bun, "Ck");
    var Ik = /* @__PURE__ */ __name(() => !!globalThis.Deno, "Ik");
    var pk = /* @__PURE__ */ __name(() => typeof globalThis.Netlify == "object", "pk");
    var Bk = /* @__PURE__ */ __name(() => typeof globalThis.EdgeRuntime == "object", "Bk");
    var mk = /* @__PURE__ */ __name(() => globalThis.navigator?.userAgent === "Cloudflare-Workers", "mk");
    function yk() {
      return [[pk, "netlify"], [Bk, "edge-light"], [mk, "workerd"], [Ik, "deno"], [Ck, "bun"], [Qk, "node"]].flatMap((r2) => r2[0]() ? [r2[1]] : []).at(0) ?? "";
    }
    __name(yk, "yk");
    var wk = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)" };
    function up() {
      let t2 = yk();
      return { id: t2, prettyName: wk[t2] || t2, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(t2) };
    }
    __name(up, "up");
    var SS = __require("node:child_process");
    var bS = G2(rC());
    var js = G2(__require("node:fs"));
    var NS = G2(uC());
    var Qp = G2(__require("node:fs"), 1);
    var tg = G2(__require("node:path"), 1);
    var Cp = G2(__require("node:stream"), 1);
    var Ip = __require("node:util");
    var gp = __require("node:util");
    var ya = G2(__require("node:crypto"), 1);
    var Ep = (0, gp.promisify)(ya.default.randomBytes);
    var Dk = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~".split("");
    var Rk = "0123456789".split("");
    var Sk = "CDEHKMPRTUWXY012458".split("");
    var bk = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~".split("");
    var Nk = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
    var Fk = /* @__PURE__ */ __name((t2, e) => {
      let r2 = e.length, n2 = Math.floor(65536 / r2) * r2 - 1, A2 = 2 * Math.ceil(1.1 * t2), i2 = "", s = 0;
      for (; s < t2; ) {
        let o2 = ya.default.randomBytes(A2), a2 = 0;
        for (; a2 < A2 && s < t2; ) {
          let c2 = o2.readUInt16LE(a2);
          a2 += 2, !(c2 > n2) && (i2 += e[c2 % r2], s++);
        }
      }
      return i2;
    }, "Fk");
    var Tk = /* @__PURE__ */ __name(async (t2, e) => {
      let r2 = e.length, n2 = Math.floor(65536 / r2) * r2 - 1, A2 = 2 * Math.ceil(1.1 * t2), i2 = "", s = 0;
      for (; s < t2; ) {
        let o2 = await Ep(A2), a2 = 0;
        for (; a2 < A2 && s < t2; ) {
          let c2 = o2.readUInt16LE(a2);
          a2 += 2, !(c2 > n2) && (i2 += e[c2 % r2], s++);
        }
      }
      return i2;
    }, "Tk");
    var xk = /* @__PURE__ */ __name((t2, e, r2) => ya.default.randomBytes(t2).toString(e).slice(0, r2), "xk");
    var Uk = /* @__PURE__ */ __name(async (t2, e, r2) => (await Ep(t2)).toString(e).slice(0, r2), "Uk");
    var kk = /* @__PURE__ */ new Set([void 0, "hex", "base64", "url-safe", "numeric", "distinguishable", "ascii-printable", "alphanumeric"]);
    var dp = /* @__PURE__ */ __name((t2, e) => ({ length: r2, type: n2, characters: A2 }) => {
      if (!(r2 >= 0 && Number.isFinite(r2))) throw new TypeError("Expected a `length` to be a non-negative finite number");
      if (n2 !== void 0 && A2 !== void 0) throw new TypeError("Expected either `type` or `characters`");
      if (A2 !== void 0 && typeof A2 != "string") throw new TypeError("Expected `characters` to be string");
      if (!kk.has(n2)) throw new TypeError(`Unknown type: ${n2}`);
      if (n2 === void 0 && A2 === void 0 && (n2 = "hex"), n2 === "hex" || n2 === void 0 && A2 === void 0) return e(Math.ceil(r2 * 0.5), "hex", r2);
      if (n2 === "base64") return e(Math.ceil(r2 * 0.75), "base64", r2);
      if (n2 === "url-safe") return t2(r2, Dk);
      if (n2 === "numeric") return t2(r2, Rk);
      if (n2 === "distinguishable") return t2(r2, Sk);
      if (n2 === "ascii-printable") return t2(r2, bk);
      if (n2 === "alphanumeric") return t2(r2, Nk);
      if (A2.length === 0) throw new TypeError("Expected `characters` string length to be greater than or equal to 1");
      if (A2.length > 65536) throw new TypeError("Expected `characters` string length to be less or equal to 65536");
      return t2(r2, A2.split(""));
    }, "dp");
    var hp = dp(Fk, xk);
    hp.async = dp(Tk, Uk);
    var fp = hp;
    function eg() {
      return fp({ length: 32 });
    }
    __name(eg, "eg");
    var pp = G2(Eu(), 1);
    var Lk = G2(Eu(), 1);
    var RX = (0, Ip.promisify)(Cp.default.pipeline);
    var Bp = /* @__PURE__ */ __name((t2 = "") => tg.default.join(pp.default, t2 + eg()), "Bp");
    function mp({ name: t2, extension: e } = {}) {
      if (t2) {
        if (e != null) throw new Error("The `name` and `extension` options are mutually exclusive");
        return tg.default.join(Mk(), t2);
      }
      return Bp() + (e == null ? "" : "." + e.replace(/^\./, ""));
    }
    __name(mp, "mp");
    function Mk({ prefix: t2 = "" } = {}) {
      let e = Bp(t2);
      return Qp.default.mkdirSync(e), e;
    }
    __name(Mk, "Mk");
    function pA(t2) {
      return typeof t2 == "string" ? t2 : t2.message;
    }
    __name(pA, "pA");
    function yp(t2) {
      if (t2.fields?.message) {
        let e = t2.fields?.message;
        return t2.fields?.file && (e += ` in ${t2.fields.file}`, t2.fields?.line && (e += `:${t2.fields.line}`), t2.fields?.column && (e += `:${t2.fields.column}`)), t2.fields?.reason && (e += `
${t2.fields?.reason}`), e;
      }
      return "Unknown error";
    }
    __name(yp, "yp");
    function wp(t2) {
      return t2.fields?.message === "PANIC";
    }
    __name(wp, "wp");
    function vk(t2) {
      return t2.timestamp && typeof t2.level == "string" && typeof t2.target == "string";
    }
    __name(vk, "vk");
    function rg(t2) {
      return vk(t2) && (t2.level === "error" || t2.fields?.message?.includes("fatal error"));
    }
    __name(rg, "rg");
    function Dp(t2) {
      let r2 = Pk(t2.fields) ? "query" : t2.level.toLowerCase();
      return { ...t2, level: r2, timestamp: new Date(t2.timestamp) };
    }
    __name(Dp, "Dp");
    function Pk(t2) {
      return !!t2.query;
    }
    __name(Pk, "Pk");
    var ji = class extends Error {
      static {
        __name(this, "ji");
      }
      clientVersion;
      _isPanic;
      constructor({ clientVersion: e, error: r2 }) {
        let n2 = yp(r2);
        super(n2 ?? "Unknown error"), this._isPanic = wp(r2), this.clientVersion = e;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustError";
      }
      isPanic() {
        return this._isPanic;
      }
    };
    M2(ji, "PrismaClientRustError");
    var Fp = G2(__require("node:fs"));
    var Zi = G2(__require("node:path"));
    function wa(t2) {
      let { runtimeBinaryTarget: e } = t2;
      return `Add "${e}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Yk(t2)}`;
    }
    __name(wa, "wa");
    function Yk(t2) {
      let { generator: e, generatorBinaryTargets: r2, runtimeBinaryTarget: n2 } = t2, A2 = { fromEnvVar: null, value: n2 }, i2 = [...r2, A2];
      return Bu({ ...e, binaryTargets: i2 });
    }
    __name(Yk, "Yk");
    function Or(t2) {
      let { runtimeBinaryTarget: e } = t2;
      return `Prisma Client could not locate the Query Engine for runtime "${e}".`;
    }
    __name(Or, "Or");
    function Vr(t2) {
      let { searchedLocations: e } = t2;
      return `The following locations have been searched:
${[...new Set(e)].map((A2) => `  ${A2}`).join(`
`)}`;
    }
    __name(Vr, "Vr");
    function Rp(t2) {
      let { runtimeBinaryTarget: e } = t2;
      return `${Or(t2)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${e}".
${wa(t2)}

${Vr(t2)}`;
    }
    __name(Rp, "Rp");
    function Da(t2) {
      return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${t2}`;
    }
    __name(Da, "Da");
    function Ra(t2) {
      let { errorStack: e } = t2;
      return e?.match(/\/\.next|\/next@|\/next\//) ? `

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.` : "";
    }
    __name(Ra, "Ra");
    function Sp(t2) {
      let { queryEngineName: e } = t2;
      return `${Or(t2)}${Ra(t2)}

This is likely caused by a bundler that has not copied "${e}" next to the resulting bundle.
Ensure that "${e}" has been copied next to the bundle or in "${t2.expectedLocation}".

${Da("engine-not-found-bundler-investigation")}

${Vr(t2)}`;
    }
    __name(Sp, "Sp");
    function bp(t2) {
      let { runtimeBinaryTarget: e, generatorBinaryTargets: r2 } = t2, n2 = r2.find((A2) => A2.native);
      return `${Or(t2)}

This happened because Prisma Client was generated for "${n2?.value ?? "unknown"}", but the actual deployment required "${e}".
${wa(t2)}

${Vr(t2)}`;
    }
    __name(bp, "bp");
    function Np(t2) {
      let { queryEngineName: e } = t2;
      return `${Or(t2)}${Ra(t2)}

This is likely caused by tooling that has not copied "${e}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${e}" has been copied to "${t2.expectedLocation}".

${Da("engine-not-found-tooling-investigation")}

${Vr(t2)}`;
    }
    __name(Np, "Np");
    var Gk = ce("prisma:client:engines:resolveEnginePath");
    var Ok = /* @__PURE__ */ __name(() => new RegExp("runtime[\\\\/]binary\\.m?js$"), "Ok");
    async function ng(t2, e) {
      let r2 = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[t2] ?? e.prismaPath;
      if (r2 !== void 0) return r2;
      let { enginePath: n2, searchedLocations: A2 } = await Vk(t2, e);
      if (Gk("enginePath", n2), n2 !== void 0 && t2 === "binary" && fu(n2), n2 !== void 0) return e.prismaPath = n2;
      let i2 = await sn(), s = e.generator?.binaryTargets ?? [], o2 = s.some((g) => g.native), a2 = !s.some((g) => g.value === i2), c2 = __filename.match(Ok()) === null, l2 = { searchedLocations: A2, generatorBinaryTargets: s, generator: e.generator, runtimeBinaryTarget: i2, queryEngineName: Tp(t2, i2), expectedLocation: Zi.default.relative(process.cwd(), e.dirname), errorStack: new Error().stack }, u2;
      throw o2 && a2 ? u2 = bp(l2) : a2 ? u2 = Rp(l2) : c2 ? u2 = Sp(l2) : u2 = Np(l2), new Z(u2, e.clientVersion);
    }
    __name(ng, "ng");
    async function Vk(t2, e) {
      let r2 = await sn(), n2 = [], A2 = [e.dirname, Zi.default.resolve(__dirname, ".."), e.generator?.output?.value ?? __dirname, Zi.default.resolve(__dirname, "../../../.prisma/client"), "/tmp/prisma-engines", e.cwd];
      __filename.includes("resolveEnginePath") && A2.push(gC());
      for (let i2 of A2) {
        let s = Tp(t2, r2), o2 = Zi.default.join(i2, s);
        if (n2.push(i2), Fp.default.existsSync(o2)) return { enginePath: o2, searchedLocations: n2 };
      }
      return { enginePath: void 0, searchedLocations: n2 };
    }
    __name(Vk, "Vk");
    function Tp(t2, e) {
      return t2 === "library" ? go(e, "fs") : `query-engine-${e}${e === "windows" ? ".exe" : ""}`;
    }
    __name(Tp, "Tp");
    var Ag = G2(yu());
    function xp(t2) {
      return t2 ? t2.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (e) => `${e[0]}5`) : "";
    }
    __name(xp, "xp");
    function Up(t2) {
      return t2.split(`
`).map((e) => e.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
    }
    __name(Up, "Up");
    var kp = G2(kC());
    function Mp({ title: t2, user: e = "prisma", repo: r2 = "prisma", template: n2 = "bug_report.yml", body: A2 }) {
      return (0, kp.default)({ user: e, repo: r2, template: n2, title: t2, body: A2 });
    }
    __name(Mp, "Mp");
    function Lp({ version: t2, binaryTarget: e, title: r2, description: n2, engineVersion: A2, database: i2, query: s }) {
      let o2 = uf(6e3 - (s?.length ?? 0)), a2 = Up((0, Ag.default)(o2)), c2 = n2 ? `# Description
\`\`\`
${n2}
\`\`\`` : "", l2 = (0, Ag.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${e?.padEnd(19)}|
| Prisma Client   | ${t2?.padEnd(19)}|
| Query Engine    | ${A2?.padEnd(19)}|
| Database        | ${i2?.padEnd(19)}|

${c2}

## Logs
\`\`\`
${a2}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? xp(s) : ""}
\`\`\`
`), u2 = Mp({ title: r2, body: l2 });
      return `${r2}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${Je(u2)}

If you want the Prisma team to look into it, please open the link above 
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
    }
    __name(Lp, "Lp");
    var mS = G2(ou());
    var KW = /* @__PURE__ */ __name(() => BS(), "KW");
    function $W(t2) {
      if (t2 === void 0) throw new Error("Connection has not been opened");
    }
    __name($W, "$W");
    var tr = class {
      static {
        __name(this, "tr");
      }
      _pool;
      constructor() {
      }
      static async onHttpError(e, r2) {
        let n2 = await e;
        return n2.statusCode >= 400 ? r2(n2) : n2;
      }
      open(e, r2) {
        this._pool || (this._pool = new (KW()).Pool(e, { connections: 1e3, keepAliveMaxTimeout: 6e5, headersTimeout: 0, bodyTimeout: 0, ...r2 }));
      }
      async raw(e, r2, n2, A2, i2 = true) {
        $W(this._pool);
        let s = await this._pool.request({ path: r2, method: e, headers: { "Content-Type": "application/json", ...n2 }, body: A2 }), o2 = await (0, mS.default)(s.body);
        return { statusCode: s.statusCode, headers: s.headers, data: i2 ? JSON.parse(o2) : o2 };
      }
      post(e, r2, n2, A2) {
        return this.raw("POST", e, n2, r2, A2);
      }
      get(e, r2) {
        return this.raw("GET", e, r2);
      }
      close() {
        this._pool && this._pool.close(() => {
        }), this._pool = void 0;
      }
    };
    var Ye = ce("prisma:engine");
    var Ws = /* @__PURE__ */ __name((...t2) => {
    }, "Ws");
    var yS = [...Yl, "native"];
    var Rl = [];
    var wS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
    var DS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
    var oi = class {
      static {
        __name(this, "oi");
      }
      name = "BinaryEngine";
      config;
      logEmitter;
      showColors;
      logQueries;
      env;
      flags;
      enableDebugLogs;
      allowTriggerPanic;
      child;
      clientVersion;
      globalKillSignalReceived;
      startCount = 0;
      engineEndpoint;
      lastError;
      stopPromise;
      beforeExitListener;
      cwd;
      datamodelPath;
      stderrLogs = "";
      currentRequestPromise;
      binaryTargetPromise;
      binaryTarget;
      datasourceOverrides;
      startPromise;
      versionPromise;
      engineStartDeferred;
      engineStopDeferred;
      connection;
      lastQuery;
      lastVersion;
      lastActiveProvider;
      activeProvider;
      tracingHelper;
      constructor(e) {
        this.config = e, this.env = e.env, this.cwd = this.resolveCwd(e.cwd), this.enableDebugLogs = e.enableDebugLogs ?? false, this.allowTriggerPanic = e.allowTriggerPanic ?? false, this.tracingHelper = e.tracingHelper, this.logEmitter = e.logEmitter, this.showColors = e.showColors ?? false, this.logQueries = e.logQueries ?? false, this.clientVersion = e.clientVersion, this.flags = e.flags ?? [], this.activeProvider = e.activeProvider, this.connection = new tr(), this.datamodelPath = mp({ extension: "prisma" }), js.default.writeFileSync(this.datamodelPath, e.inlineSchema);
        let r2 = Object.keys(e.overrideDatasources)[0], n2 = e.overrideDatasources[r2]?.url;
        if (r2 !== void 0 && n2 !== void 0 && (this.datasourceOverrides = [{ name: r2, url: n2 }]), zW(), this.engineEndpoint = e.engineEndpoint, this.binaryTarget) {
          if (!yS.includes(this.binaryTarget) && !js.default.existsSync(this.binaryTarget)) throw new Z(`Unknown ${at("PRISMA_QUERY_ENGINE_BINARY")} ${at(be(this.binaryTarget))}. Possible binaryTargets: ${Sr(yS.join(", "))} or a path to the query engine binary.
You may have to run ${Sr("prisma generate")} for your changes to take effect.`, this.clientVersion);
        } else this.getCurrentBinaryTarget();
        this.enableDebugLogs && ce.enable("*"), Rl.push(this);
      }
      setError(e) {
        rg(e) && (this.lastError = new ji({ clientVersion: this.clientVersion, error: e }), this.lastError.isPanic() && (this.child && (this.stopPromise = e_(this.child)), this.currentRequestPromise?.cancel && this.currentRequestPromise.cancel()));
      }
      resolveCwd(e) {
        return js.default.existsSync(e) && js.default.lstatSync(e).isDirectory() ? e : process.cwd();
      }
      onBeforeExit(e) {
        this.beforeExitListener = e;
      }
      async emitExit() {
        if (this.beforeExitListener) try {
          await this.beforeExitListener();
        } catch (e) {
          console.error(e);
        }
      }
      async getCurrentBinaryTarget() {
        return this.binaryTargetPromise ? this.binaryTargetPromise : (this.binaryTargetPromise = this.tracingHelper.runInChildSpan("detect_platform", () => sn()), this.binaryTargetPromise);
      }
      printDatasources() {
        return this.datasourceOverrides ? JSON.stringify(this.datasourceOverrides) : "[]";
      }
      async start() {
        this.stopPromise && await this.stopPromise;
        let e = { times: 10 }, r2 = /* @__PURE__ */ __name(async () => {
          try {
            await this.tracingHelper.runInChildSpan("start_engine", () => this.startAndFetchBootSpans());
          } catch (A2) {
            throw A2.retryable === true && e.times > 0 && (e.times--, await r2()), A2;
          }
        }, "r"), n2 = /* @__PURE__ */ __name(async () => {
          if (this.startPromise || (this.startCount++, this.startPromise = r2()), await this.startPromise, !this.child && !this.engineEndpoint) throw new Be("Can't perform request, as the Engine has already been stopped", { clientVersion: this.clientVersion });
        }, "n");
        return this.startPromise ? n2() : this.tracingHelper.runInChildSpan("connect", n2);
      }
      getEngineEnvVars() {
        let e = { PRISMA_DML_PATH: this.datamodelPath };
        return this.logQueries && (e.LOG_QUERIES = "true"), this.datasourceOverrides && (e.OVERWRITE_DATASOURCES = this.printDatasources()), !process.env.NO_COLOR && this.showColors && (e.CLICOLOR_FORCE = "1"), { ...this.env, ...process.env, ...e, RUST_BACKTRACE: process.env.RUST_BACKTRACE ?? "1", RUST_LOG: process.env.RUST_LOG ?? "info" };
      }
      async startAndFetchBootSpans() {
        await this.internalStart();
        let e = await tr.onHttpError(this.connection.get("/boot_trace"), (r2) => this.httpErrorHandler(r2));
        this.tracingHelper.dispatchEngineSpans(e.data.spans);
      }
      internalStart() {
        return new Promise(async (e, r2) => {
          if (await new Promise((n2) => process.nextTick(n2)), this.stopPromise && await this.stopPromise, this.engineEndpoint) {
            try {
              this.connection.open(this.engineEndpoint), await (0, NS.default)(() => this.connection.get("/status"), { retries: 10 });
            } catch (n2) {
              return r2(n2);
            }
            return e();
          }
          try {
            (this.child?.connected || this.child && !this.child?.killed) && Ye("There is a child that still runs and we want to start again"), this.lastError = void 0, Ws("startin & resettin"), this.globalKillSignalReceived = void 0, Ye("cwd:", this.cwd);
            let n2 = await ng("binary", this.config), A2 = this.allowTriggerPanic ? ["--debug"] : [], i2 = ["--enable-raw-queries", "--enable-metrics", "--enable-open-telemetry", ...this.flags, ...A2];
            i2.push("--port", "0"), i2.push("--engine-protocol", "json"), Ye({ flags: i2 });
            let s = this.getEngineEnvVars();
            if (this.child = (0, SS.spawn)(n2, i2, { env: s, cwd: this.cwd, windowsHide: true, stdio: ["ignore", "pipe", "pipe"] }), Ri(this.child.stderr).on("data", (o2) => {
              let a2 = String(o2);
              Ye("stderr", a2);
              try {
                let c2 = JSON.parse(a2);
                if (typeof c2.is_panic < "u" && (Ye(c2), this.setError(c2), this.engineStartDeferred)) {
                  let l2 = new Z(c2.message, this.clientVersion, c2.error_code);
                  this.engineStartDeferred.reject(l2);
                }
              } catch {
                !a2.includes("Printing to stderr") && !a2.includes("Listening on ") && (this.stderrLogs += `
` + a2);
              }
            }), Ri(this.child.stdout).on("data", (o2) => {
              let a2 = String(o2);
              try {
                let c2 = JSON.parse(a2);
                if (Ye("stdout", pA(c2)), this.engineStartDeferred && c2.level === "INFO" && c2.target === "query_engine::server" && c2.fields?.message?.startsWith("Started query engine http server")) {
                  let l2 = c2.fields.ip, u2 = c2.fields.port;
                  if (l2 === void 0 || u2 === void 0) {
                    this.engineStartDeferred.reject(new Z('This version of Query Engine is not compatible with Prisma Client: "ip" and "port" fields are missing in the startup log entry', this.clientVersion));
                    return;
                  }
                  this.connection.open(`http://${l2}:${u2}`), this.engineStartDeferred.resolve(), this.engineStartDeferred = void 0;
                }
                if (typeof c2.is_panic > "u") {
                  let l2 = Dp(c2);
                  rg(l2) ? this.setError(l2) : l2.level === "query" ? this.logEmitter.emit(l2.level, { timestamp: l2.timestamp, query: l2.fields.query, params: l2.fields.params, duration: l2.fields.duration_ms, target: l2.target }) : this.logEmitter.emit(l2.level, { timestamp: l2.timestamp, message: l2.fields.message, target: l2.target });
                } else this.setError(c2);
              } catch (c2) {
                Ye(c2, a2);
              }
            }), this.child.on("exit", (o2) => {
              if (Ws("removing startPromise"), this.startPromise = void 0, this.engineStopDeferred) {
                this.engineStopDeferred.resolve(o2);
                return;
              }
              if (this.connection.close(), o2 !== 0 && this.engineStartDeferred && this.startCount === 1) {
                let a2, c2 = this.stderrLogs;
                this.lastError && (c2 = pA(this.lastError)), o2 !== null ? (a2 = new Z(`Query engine exited with code ${o2}
` + c2, this.clientVersion), a2.retryable = true) : this.child?.signalCode ? (a2 = new Z(`Query engine process killed with signal ${this.child.signalCode} for unknown reason.
Make sure that the engine binary at ${n2} is not corrupt.
` + c2, this.clientVersion), a2.retryable = true) : a2 = new Z(c2, this.clientVersion), this.engineStartDeferred.reject(a2);
              }
              this.child && (this.lastError || o2 === 126 && this.setError({ timestamp: /* @__PURE__ */ new Date(), target: "binary engine process exit", level: "error", fields: { message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.` } }));
            }), this.child.on("error", (o2) => {
              this.setError({ timestamp: /* @__PURE__ */ new Date(), target: "binary engine process error", level: "error", fields: { message: `Couldn't start query engine: ${o2}` } }), r2(o2);
            }), this.child.on("close", (o2, a2) => {
              this.connection.close();
              let c2;
              o2 === null && a2 === "SIGABRT" && this.child ? c2 = new ut(this.getErrorMessageWithLink("Panic in Query Engine with SIGABRT signal"), this.clientVersion) : o2 === 101 && a2 === null && this.lastError && (c2 = this.lastError), c2 && this.logEmitter.emit("error", { message: c2.message, timestamp: /* @__PURE__ */ new Date(), target: "binary engine process close" });
            }), this.lastError) return r2(new Z(pA(this.lastError), this.clientVersion));
            try {
              await new Promise((o2, a2) => {
                this.engineStartDeferred = { resolve: o2, reject: a2 };
              });
            } catch (o2) {
              throw this.child?.kill(), o2;
            }
            (async () => {
              try {
                let o2 = await this.version(true);
                Ye(`Client Version: ${this.clientVersion}`), Ye(`Engine Version: ${o2}`), Ye(`Active provider: ${this.activeProvider}`);
              } catch (o2) {
                Ye(o2);
              }
            })(), this.stopPromise = void 0, e();
          } catch (n2) {
            r2(n2);
          }
        });
      }
      async stop() {
        let e = /* @__PURE__ */ __name(async () => (this.stopPromise || (this.stopPromise = this._stop()), this.stopPromise), "e");
        return this.tracingHelper.runInChildSpan("disconnect", e);
      }
      async _stop() {
        if (this.startPromise && await this.startPromise, await new Promise((r2) => process.nextTick(r2)), this.currentRequestPromise) try {
          await this.currentRequestPromise;
        } catch {
        }
        let e;
        this.child && (Ye("Stopping Prisma engine"), this.startPromise && (Ye("Waiting for start promise"), await this.startPromise), Ye("Done waiting for start promise"), this.child.exitCode === null ? e = new Promise((r2, n2) => {
          this.engineStopDeferred = { resolve: r2, reject: n2 };
        }) : Ye("Child already exited with code", this.child.exitCode), this.connection.close(), this.child.kill(), this.child = void 0), e && await e, await new Promise((r2) => process.nextTick(r2)), this.startPromise = void 0, this.engineStopDeferred = void 0;
      }
      kill(e) {
        this.globalKillSignalReceived = e, this.child?.kill(), this.connection.close();
      }
      async version(e = false) {
        return this.versionPromise && !e ? this.versionPromise : (this.versionPromise = this.internalVersion(), this.versionPromise);
      }
      async internalVersion() {
        let e = await ng("binary", this.config), r2 = await (0, bS.default)(e, ["--version"]);
        return this.lastVersion = r2.stdout, this.lastVersion;
      }
      async request(e, { traceparent: r2, numTry: n2 = 1, isWrite: A2, interactiveTransaction: i2 }) {
        await this.start();
        let s = {};
        r2 && (s.traceparent = r2), i2 && (s["X-transaction-id"] = i2.id);
        let o2 = JSON.stringify(e);
        this.currentRequestPromise = tr.onHttpError(this.connection.post("/", o2, s), (a2) => this.httpErrorHandler(a2)), this.lastQuery = o2;
        try {
          let { data: a2 } = await this.currentRequestPromise;
          if (a2.extensions?.traces && this.tracingHelper.dispatchEngineSpans(a2.extensions.traces), a2.errors) throw a2.errors.length === 1 ? Yr(a2.errors[0], this.clientVersion, this.config.activeProvider) : new Be(JSON.stringify(a2.errors), { clientVersion: this.clientVersion });
          return this.startCount > 0 && (this.startCount = 0), this.currentRequestPromise = void 0, { data: a2 };
        } catch (a2) {
          Ws("req - e", a2);
          let { error: c2, shouldRetry: l2 } = await this.handleRequestError(a2);
          if (n2 <= DS && l2 && !A2) return Ws("trying a retry now"), this.request(e, { traceparent: r2, numTry: n2 + 1, isWrite: A2, interactiveTransaction: i2 });
          throw c2;
        }
      }
      async requestBatch(e, { traceparent: r2, transaction: n2, numTry: A2 = 1, containsWrite: i2 }) {
        await this.start();
        let s = {};
        r2 && (s.traceparent = r2);
        let o2 = n2?.kind === "itx" ? n2.options : void 0;
        o2 && (s["X-transaction-id"] = o2.id);
        let a2 = CA(e, n2);
        return this.lastQuery = JSON.stringify(a2), this.currentRequestPromise = tr.onHttpError(this.connection.post("/", this.lastQuery, s), (c2) => this.httpErrorHandler(c2)), this.currentRequestPromise.then(({ data: c2 }) => {
          c2.extensions?.traces && this.tracingHelper.dispatchEngineSpans(c2.extensions.traces);
          let { batchResult: l2 } = c2;
          if (Array.isArray(l2)) return l2.map((u2) => (u2.extensions?.traces && this.tracingHelper.dispatchEngineSpans(u2.extensions.traces), u2.errors && u2.errors.length > 0 ? Yr(u2.errors[0], this.clientVersion, this.config.activeProvider) : { data: u2 }));
          throw Yr(c2.errors[0], this.clientVersion, this.config.activeProvider);
        }).catch(async (c2) => {
          let { error: l2, shouldRetry: u2 } = await this.handleRequestError(c2);
          if (u2 && !i2 && A2 <= DS) return this.requestBatch(e, { traceparent: r2, transaction: n2, numTry: A2 + 1, containsWrite: i2 });
          throw l2;
        });
      }
      async transaction(e, r2, n2) {
        if (await this.start(), e === "start") {
          let A2 = JSON.stringify({ max_wait: n2.maxWait, timeout: n2.timeout, isolation_level: n2.isolationLevel }), i2 = await tr.onHttpError(this.connection.post("/transaction/start", A2, r2), (s) => this.httpErrorHandler(s));
          return i2.data.extensions?.traces && this.tracingHelper.dispatchEngineSpans(i2.data.extensions.traces), i2.data;
        } else if (e === "commit") {
          let A2 = await tr.onHttpError(this.connection.post(`/transaction/${n2.id}/commit`, void 0, r2), (i2) => this.httpErrorHandler(i2));
          A2.data.extensions?.traces && this.tracingHelper.dispatchEngineSpans(A2.data.extensions.traces);
        } else if (e === "rollback") {
          let A2 = await tr.onHttpError(this.connection.post(`/transaction/${n2.id}/rollback`, void 0, r2), (i2) => this.httpErrorHandler(i2));
          A2.data.extensions?.traces && this.tracingHelper.dispatchEngineSpans(A2.data.extensions.traces);
        }
      }
      get hasMaxRestarts() {
        return this.startCount >= wS;
      }
      throwAsyncErrorIfExists(e = false) {
        if (Ws("throwAsyncErrorIfExists", this.startCount, this.hasMaxRestarts), this.lastError && (this.hasMaxRestarts || e)) {
          let r2 = this.lastError;
          throw this.lastError = void 0, r2.isPanic() ? new ut(this.getErrorMessageWithLink(pA(r2)), this.clientVersion) : new Be(this.getErrorMessageWithLink(pA(r2)), { clientVersion: this.clientVersion });
        }
      }
      getErrorMessageWithLink(e) {
        return Lp({ binaryTarget: this.binaryTarget, title: e, version: this.clientVersion, engineVersion: this.lastVersion, database: this.lastActiveProvider, query: this.lastQuery });
      }
      handleRequestError = /* @__PURE__ */ __name(async (e) => {
        Ye({ error: e }), this.startPromise && await this.startPromise;
        let r2 = ["ECONNRESET", "ECONNREFUSED", "UND_ERR_CLOSED", "UND_ERR_SOCKET", "UND_ERR_DESTROYED", "UND_ERR_ABORTED"].includes(e.code);
        if (e instanceof Ne) return { error: e, shouldRetry: false };
        try {
          if (this.throwAsyncErrorIfExists(), this.currentRequestPromise?.isCanceled) this.throwAsyncErrorIfExists();
          else if (r2) {
            if (this.globalKillSignalReceived && !this.child?.connected) throw new Be(`The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited
  and your request can't be processed.
  You probably have some open handle that prevents your process from exiting.
  It could be an open http server or stream that didn't close yet.
  We recommend using the \`wtfnode\` package to debug open handles.`, { clientVersion: this.clientVersion });
            if (this.throwAsyncErrorIfExists(), this.startCount > wS) {
              for (let n2 = 0; n2 < 5; n2++) await new Promise((A2) => setTimeout(A2, 50)), this.throwAsyncErrorIfExists(true);
              throw new Error(`Query engine is trying to restart, but can't.
  Please look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);
            }
          }
          throw this.throwAsyncErrorIfExists(true), e;
        } catch (n2) {
          return { error: n2, shouldRetry: r2 };
        }
      }, "handleRequestError");
      async metrics({ format: e, globalLabels: r2 }) {
        await this.start();
        let n2 = e === "json";
        return (await this.connection.post(`/metrics?format=${encodeURIComponent(e)}`, JSON.stringify(r2), null, n2)).data;
      }
      httpErrorHandler(e) {
        let r2 = e.data, n2 = r2.extensions?.traces;
        throw n2 && this.tracingHelper.dispatchEngineSpans(n2), new Ne(r2.message, { code: r2.error_code, clientVersion: this.clientVersion, meta: r2.meta });
      }
      applyPendingMigrations() {
        throw new Error("Method not implemented.");
      }
    };
    function _s(t2, e = false) {
      process.once(t2, async () => {
        for (let r2 of Rl) await r2.emitExit(), r2.kill(t2);
        Rl.splice(0, Rl.length), e && process.listenerCount(t2) === 0 && process.exit();
      });
    }
    __name(_s, "_s");
    var RS = false;
    function zW() {
      RS || (_s("beforeExit"), _s("exit"), _s("SIGINT", true), _s("SIGUSR2", true), _s("SIGTERM", true), RS = true);
    }
    __name(zW, "zW");
    function e_(t2) {
      return new Promise((e) => {
        t2.once("exit", e), t2.kill();
      });
    }
    __name(e_, "e_");
    function FS(t2, e) {
      throw new Error(e);
    }
    __name(FS, "FS");
    function t_(t2) {
      return t2 !== null && typeof t2 == "object" && typeof t2.$type == "string";
    }
    __name(t_, "t_");
    function r_(t2, e) {
      let r2 = {};
      for (let n2 of Object.keys(t2)) r2[n2] = e(t2[n2], n2);
      return r2;
    }
    __name(r_, "r_");
    function ai(t2) {
      return t2 === null ? t2 : Array.isArray(t2) ? t2.map(ai) : typeof t2 == "object" ? t_(t2) ? n_(t2) : t2.constructor !== null && t2.constructor.name !== "Object" ? t2 : r_(t2, ai) : t2;
    }
    __name(ai, "ai");
    function n_({ $type: t2, value: e }) {
      switch (t2) {
        case "BigInt":
          return BigInt(e);
        case "Bytes": {
          let { buffer: r2, byteOffset: n2, byteLength: A2 } = Buffer.from(e, "base64");
          return new Uint8Array(r2, n2, A2);
        }
        case "DateTime":
          return new Date(e);
        case "Decimal":
          return new or(e);
        case "Json":
          return JSON.parse(e);
        default:
          FS(e, "Unknown tagged value");
      }
    }
    __name(n_, "n_");
    var TS = "6.15.0";
    function ci({ inlineDatasources: t2, overrideDatasources: e, env: r2, clientVersion: n2 }) {
      let A2, i2 = Object.keys(t2)[0], s = t2[i2]?.url, o2 = e[i2]?.url;
      if (i2 === void 0 ? A2 = void 0 : o2 ? A2 = o2 : s?.value ? A2 = s.value : s?.fromEnvVar && (A2 = r2[s.fromEnvVar]), s?.fromEnvVar !== void 0 && A2 === void 0) throw new Z(`error: Environment variable not found: ${s.fromEnvVar}.`, n2);
      if (A2 === void 0) throw new Z("error: Missing URL environment variable, value, or override.", n2);
      return A2;
    }
    __name(ci, "ci");
    var Sl = class extends Error {
      static {
        __name(this, "Sl");
      }
      clientVersion;
      cause;
      constructor(e, r2) {
        super(e), this.clientVersion = r2.clientVersion, this.cause = r2.cause;
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    var ze = class extends Sl {
      static {
        __name(this, "ze");
      }
      isRetryable;
      constructor(e, r2) {
        super(e, r2), this.isRetryable = r2.isRetryable ?? true;
      }
    };
    function _2(t2, e) {
      return { ...t2, isRetryable: e };
    }
    __name(_2, "_");
    var Gn = class extends ze {
      static {
        __name(this, "Gn");
      }
      name = "InvalidDatasourceError";
      code = "P6001";
      constructor(e, r2) {
        super(e, _2(r2, false));
      }
    };
    M2(Gn, "InvalidDatasourceError");
    function xS(t2) {
      let e = { clientVersion: t2.clientVersion }, r2 = Object.keys(t2.inlineDatasources)[0], n2 = ci({ inlineDatasources: t2.inlineDatasources, overrideDatasources: t2.overrideDatasources, clientVersion: t2.clientVersion, env: { ...t2.env, ...typeof process < "u" ? process.env : {} } }), A2;
      try {
        A2 = new URL(n2);
      } catch {
        throw new Gn(`Error validating datasource \`${r2}\`: the URL must start with the protocol \`prisma://\``, e);
      }
      let { protocol: i2, searchParams: s } = A2;
      if (i2 !== "prisma:" && i2 !== Po) throw new Gn(`Error validating datasource \`${r2}\`: the URL must start with the protocol \`prisma://\` or \`prisma+postgres://\``, e);
      let o2 = s.get("api_key");
      if (o2 === null || o2.length < 1) throw new Gn(`Error validating datasource \`${r2}\`: the URL must contain a valid API key`, e);
      let a2 = Cu(A2) ? "http:" : "https:", c2 = new URL(A2.href.replace(i2, a2));
      return { apiKey: o2, url: c2 };
    }
    __name(xS, "xS");
    var US = G2(vo());
    var bl = class {
      static {
        __name(this, "bl");
      }
      apiKey;
      tracingHelper;
      logLevel;
      logQueries;
      engineHash;
      constructor({ apiKey: e, tracingHelper: r2, logLevel: n2, logQueries: A2, engineHash: i2 }) {
        this.apiKey = e, this.tracingHelper = r2, this.logLevel = n2, this.logQueries = A2, this.engineHash = i2;
      }
      build({ traceparent: e, transactionId: r2 } = {}) {
        let n2 = { Accept: "application/json", Authorization: `Bearer ${this.apiKey}`, "Content-Type": "application/json", "Prisma-Engine-Hash": this.engineHash, "Prisma-Engine-Version": US.enginesVersion };
        this.tracingHelper.isEnabled() && (n2.traceparent = e ?? this.tracingHelper.getTraceParent()), r2 && (n2["X-Transaction-Id"] = r2);
        let A2 = this.#e();
        return A2.length > 0 && (n2["X-Capture-Telemetry"] = A2.join(", ")), n2;
      }
      #e() {
        let e = [];
        return this.tracingHelper.isEnabled() && e.push("tracing"), this.logLevel && e.push(this.logLevel), this.logQueries && e.push("query"), e;
      }
    };
    function i_(t2) {
      return t2[0] * 1e3 + t2[1] / 1e6;
    }
    __name(i_, "i_");
    function Yh(t2) {
      return new Date(i_(t2));
    }
    __name(Yh, "Yh");
    var li = class extends ze {
      static {
        __name(this, "li");
      }
      name = "ForcedRetryError";
      code = "P5001";
      constructor(e) {
        super("This request must be retried", _2(e, true));
      }
    };
    M2(li, "ForcedRetryError");
    var On = class extends ze {
      static {
        __name(this, "On");
      }
      name = "NotImplementedYetError";
      code = "P5004";
      constructor(e, r2) {
        super(e, _2(r2, false));
      }
    };
    M2(On, "NotImplementedYetError");
    var oe = class extends ze {
      static {
        __name(this, "oe");
      }
      response;
      constructor(e, r2) {
        super(e, r2), this.response = r2.response;
        let n2 = this.response.headers.get("prisma-request-id");
        if (n2) {
          let A2 = `(The request id was: ${n2})`;
          this.message = this.message + " " + A2;
        }
      }
    };
    var Vn = class extends oe {
      static {
        __name(this, "Vn");
      }
      name = "SchemaMissingError";
      code = "P5005";
      constructor(e) {
        super("Schema needs to be uploaded", _2(e, true));
      }
    };
    M2(Vn, "SchemaMissingError");
    var Gh = "This request could not be understood by the server";
    var Zs = class extends oe {
      static {
        __name(this, "Zs");
      }
      name = "BadRequestError";
      code = "P5000";
      constructor(e, r2, n2) {
        super(r2 || Gh, _2(e, false)), n2 && (this.code = n2);
      }
    };
    M2(Zs, "BadRequestError");
    var Xs = class extends oe {
      static {
        __name(this, "Xs");
      }
      name = "HealthcheckTimeoutError";
      code = "P5013";
      logs;
      constructor(e, r2) {
        super("Engine not started: healthcheck timeout", _2(e, true)), this.logs = r2;
      }
    };
    M2(Xs, "HealthcheckTimeoutError");
    var Ks = class extends oe {
      static {
        __name(this, "Ks");
      }
      name = "EngineStartupError";
      code = "P5014";
      logs;
      constructor(e, r2, n2) {
        super(r2, _2(e, true)), this.logs = n2;
      }
    };
    M2(Ks, "EngineStartupError");
    var $s = class extends oe {
      static {
        __name(this, "$s");
      }
      name = "EngineVersionNotSupportedError";
      code = "P5012";
      constructor(e) {
        super("Engine version is not supported", _2(e, false));
      }
    };
    M2($s, "EngineVersionNotSupportedError");
    var Oh = "Request timed out";
    var zs = class extends oe {
      static {
        __name(this, "zs");
      }
      name = "GatewayTimeoutError";
      code = "P5009";
      constructor(e, r2 = Oh) {
        super(r2, _2(e, false));
      }
    };
    M2(zs, "GatewayTimeoutError");
    var s_ = "Interactive transaction error";
    var eo = class extends oe {
      static {
        __name(this, "eo");
      }
      name = "InteractiveTransactionError";
      code = "P5015";
      constructor(e, r2 = s_) {
        super(r2, _2(e, false));
      }
    };
    M2(eo, "InteractiveTransactionError");
    var o_ = "Request parameters are invalid";
    var to = class extends oe {
      static {
        __name(this, "to");
      }
      name = "InvalidRequestError";
      code = "P5011";
      constructor(e, r2 = o_) {
        super(r2, _2(e, false));
      }
    };
    M2(to, "InvalidRequestError");
    var Vh = "Requested resource does not exist";
    var ro = class extends oe {
      static {
        __name(this, "ro");
      }
      name = "NotFoundError";
      code = "P5003";
      constructor(e, r2 = Vh) {
        super(r2, _2(e, false));
      }
    };
    M2(ro, "NotFoundError");
    var Hh = "Unknown server error";
    var ui = class extends oe {
      static {
        __name(this, "ui");
      }
      name = "ServerError";
      code = "P5006";
      logs;
      constructor(e, r2, n2) {
        super(r2 || Hh, _2(e, true)), this.logs = n2;
      }
    };
    M2(ui, "ServerError");
    var qh = "Unauthorized, check your connection string";
    var no = class extends oe {
      static {
        __name(this, "no");
      }
      name = "UnauthorizedError";
      code = "P5007";
      constructor(e, r2 = qh) {
        super(r2, _2(e, false));
      }
    };
    M2(no, "UnauthorizedError");
    var Jh = "Usage exceeded, retry again later";
    var Ao = class extends oe {
      static {
        __name(this, "Ao");
      }
      name = "UsageExceededError";
      code = "P5008";
      constructor(e, r2 = Jh) {
        super(r2, _2(e, true));
      }
    };
    M2(Ao, "UsageExceededError");
    async function a_(t2) {
      let e;
      try {
        e = await t2.text();
      } catch {
        return { type: "EmptyError" };
      }
      try {
        let r2 = JSON.parse(e);
        if (typeof r2 == "string") switch (r2) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: r2 };
          default:
            return { type: "UnknownTextError", body: r2 };
        }
        if (typeof r2 == "object" && r2 !== null) {
          if ("is_panic" in r2 && "message" in r2 && "error_code" in r2) return { type: "QueryEngineError", body: r2 };
          if ("EngineNotStarted" in r2 || "InteractiveTransactionMisrouted" in r2 || "InvalidRequestError" in r2) {
            let n2 = Object.values(r2)[0].reason;
            return typeof n2 == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n2) ? { type: "UnknownJsonError", body: r2 } : { type: "DataProxyError", body: r2 };
          }
        }
        return { type: "UnknownJsonError", body: r2 };
      } catch {
        return e === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: e };
      }
    }
    __name(a_, "a_");
    async function io(t2, e) {
      if (t2.ok) return;
      let r2 = { clientVersion: e, response: t2 }, n2 = await a_(t2);
      if (n2.type === "QueryEngineError") throw new Ne(n2.body.message, { code: n2.body.error_code, clientVersion: e });
      if (n2.type === "DataProxyError") {
        if (n2.body === "InternalDataProxyError") throw new ui(r2, "Internal Data Proxy error");
        if ("EngineNotStarted" in n2.body) {
          if (n2.body.EngineNotStarted.reason === "SchemaMissing") return new Vn(r2);
          if (n2.body.EngineNotStarted.reason === "EngineVersionNotSupported") throw new $s(r2);
          if ("EngineStartupError" in n2.body.EngineNotStarted.reason) {
            let { msg: A2, logs: i2 } = n2.body.EngineNotStarted.reason.EngineStartupError;
            throw new Ks(r2, A2, i2);
          }
          if ("KnownEngineStartupError" in n2.body.EngineNotStarted.reason) {
            let { msg: A2, error_code: i2 } = n2.body.EngineNotStarted.reason.KnownEngineStartupError;
            throw new Z(A2, e, i2);
          }
          if ("HealthcheckTimeout" in n2.body.EngineNotStarted.reason) {
            let { logs: A2 } = n2.body.EngineNotStarted.reason.HealthcheckTimeout;
            throw new Xs(r2, A2);
          }
        }
        if ("InteractiveTransactionMisrouted" in n2.body) {
          let A2 = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
          throw new eo(r2, A2[n2.body.InteractiveTransactionMisrouted.reason]);
        }
        if ("InvalidRequestError" in n2.body) throw new to(r2, n2.body.InvalidRequestError.reason);
      }
      if (t2.status === 401 || t2.status === 403) throw new no(r2, gi(qh, n2));
      if (t2.status === 404) return new ro(r2, gi(Vh, n2));
      if (t2.status === 429) throw new Ao(r2, gi(Jh, n2));
      if (t2.status === 504) throw new zs(r2, gi(Oh, n2));
      if (t2.status >= 500) throw new ui(r2, gi(Hh, n2));
      if (t2.status >= 400) throw new Zs(r2, gi(Gh, n2));
    }
    __name(io, "io");
    function gi(t2, e) {
      return e.type === "EmptyError" ? t2 : `${t2}: ${JSON.stringify(e)}`;
    }
    __name(gi, "gi");
    function kS(t2) {
      let e = Math.pow(2, t2) * 50, r2 = Math.ceil(Math.random() * e) - Math.ceil(e / 2), n2 = e + r2;
      return new Promise((A2) => setTimeout(() => A2(n2), n2));
    }
    __name(kS, "kS");
    var Dr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    function MS(t2) {
      let e = new TextEncoder().encode(t2), r2 = "", n2 = e.byteLength, A2 = n2 % 3, i2 = n2 - A2, s, o2, a2, c2, l2;
      for (let u2 = 0; u2 < i2; u2 = u2 + 3) l2 = e[u2] << 16 | e[u2 + 1] << 8 | e[u2 + 2], s = (l2 & 16515072) >> 18, o2 = (l2 & 258048) >> 12, a2 = (l2 & 4032) >> 6, c2 = l2 & 63, r2 += Dr[s] + Dr[o2] + Dr[a2] + Dr[c2];
      return A2 == 1 ? (l2 = e[i2], s = (l2 & 252) >> 2, o2 = (l2 & 3) << 4, r2 += Dr[s] + Dr[o2] + "==") : A2 == 2 && (l2 = e[i2] << 8 | e[i2 + 1], s = (l2 & 64512) >> 10, o2 = (l2 & 1008) >> 4, a2 = (l2 & 15) << 2, r2 += Dr[s] + Dr[o2] + Dr[a2] + "="), r2;
    }
    __name(MS, "MS");
    function LS(t2) {
      if (!!t2.generator?.previewFeatures.some((r2) => r2.toLowerCase().includes("metrics"))) throw new Z("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", t2.clientVersion);
    }
    __name(LS, "LS");
    var vS = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "6.15.0-5.85179d7826409ee107a6ba334b5e305ae3fba9fb", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*" };
    var so = class extends ze {
      static {
        __name(this, "so");
      }
      name = "RequestError";
      code = "P5010";
      constructor(e, r2) {
        super(`Cannot fetch data from service:
${e}`, _2(r2, true));
      }
    };
    M2(so, "RequestError");
    async function Hn(t2, e, r2 = (n2) => n2) {
      let { clientVersion: n2, ...A2 } = e, i2 = r2(fetch);
      try {
        return await i2(t2, A2);
      } catch (s) {
        let o2 = s.message ?? "Unknown error";
        throw new so(o2, { clientVersion: n2, cause: s });
      }
    }
    __name(Hn, "Hn");
    var l_ = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
    var PS = ce("prisma:client:dataproxyEngine");
    async function u_(t2, e) {
      let r2 = vS["@prisma/engines-version"], n2 = e.clientVersion ?? "unknown";
      if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION || globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION) return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION || globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
      if (t2.includes("accelerate") && n2 !== "0.0.0" && n2 !== "in-memory") return n2;
      let [A2, i2] = n2?.split("-") ?? [];
      if (i2 === void 0 && l_.test(A2)) return A2;
      if (i2 !== void 0 || n2 === "0.0.0" || n2 === "in-memory") {
        let [s] = r2.split("-") ?? [], [o2, a2, c2] = s.split("."), l2 = g_(`<=${o2}.${a2}.${c2}`), u2 = await Hn(l2, { clientVersion: n2 });
        if (!u2.ok) throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${u2.status} ${u2.statusText}, response body: ${await u2.text() || "<empty body>"}`);
        let g = await u2.text();
        PS("length of body fetched from unpkg.com", g.length);
        let E;
        try {
          E = JSON.parse(g);
        } catch (h) {
          throw console.error("JSON.parse error: body fetched from unpkg.com: ", g), h;
        }
        return E.version;
      }
      throw new On("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n2 });
    }
    __name(u_, "u_");
    async function YS(t2, e) {
      let r2 = await u_(t2, e);
      return PS("version", r2), r2;
    }
    __name(YS, "YS");
    function g_(t2) {
      return encodeURI(`https://unpkg.com/prisma@${t2}/package.json`);
    }
    __name(g_, "g_");
    var GS = 3;
    var oo = ce("prisma:client:dataproxyEngine");
    var ao = class {
      static {
        __name(this, "ao");
      }
      name = "DataProxyEngine";
      inlineSchema;
      inlineSchemaHash;
      inlineDatasources;
      config;
      logEmitter;
      env;
      clientVersion;
      engineHash;
      tracingHelper;
      remoteClientVersion;
      host;
      headerBuilder;
      startPromise;
      protocol;
      constructor(e) {
        LS(e), this.config = e, this.env = e.env, this.inlineSchema = MS(e.inlineSchema), this.inlineDatasources = e.inlineDatasources, this.inlineSchemaHash = e.inlineSchemaHash, this.clientVersion = e.clientVersion, this.engineHash = e.engineVersion, this.logEmitter = e.logEmitter, this.tracingHelper = e.tracingHelper;
      }
      apiKey() {
        return this.headerBuilder.apiKey;
      }
      version() {
        return this.engineHash;
      }
      async start() {
        this.startPromise !== void 0 && await this.startPromise, this.startPromise = (async () => {
          let { apiKey: e, url: r2 } = this.getURLAndAPIKey();
          this.host = r2.host, this.protocol = r2.protocol, this.headerBuilder = new bl({ apiKey: e, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel ?? "error", logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await YS(this.host, this.config), oo("host", this.host), oo("protocol", this.protocol);
        })(), await this.startPromise;
      }
      async stop() {
      }
      propagateResponseExtensions(e) {
        e?.logs?.length && e.logs.forEach((r2) => {
          switch (r2.level) {
            case "debug":
            case "trace":
              oo(r2);
              break;
            case "error":
            case "warn":
            case "info": {
              this.logEmitter.emit(r2.level, { timestamp: Yh(r2.timestamp), message: r2.attributes.message ?? "", target: r2.target });
              break;
            }
            case "query": {
              this.logEmitter.emit("query", { query: r2.attributes.query ?? "", timestamp: Yh(r2.timestamp), duration: r2.attributes.duration_ms ?? 0, params: r2.attributes.params ?? "", target: r2.target });
              break;
            }
            default:
              r2.level;
          }
        }), e?.traces?.length && this.tracingHelper.dispatchEngineSpans(e.traces);
      }
      onBeforeExit() {
        throw new Error('"beforeExit" hook is not applicable to the remote query engine');
      }
      async url(e) {
        return await this.start(), `${this.protocol}//${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${e}`;
      }
      async uploadSchema() {
        let e = { name: "schemaUpload", internal: true };
        return this.tracingHelper.runInChildSpan(e, async () => {
          let r2 = await Hn(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
          r2.ok || oo("schema response status", r2.status);
          let n2 = await io(r2, this.clientVersion);
          if (n2) throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${n2.message}`, timestamp: /* @__PURE__ */ new Date(), target: "" }), n2;
          this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`, timestamp: /* @__PURE__ */ new Date(), target: "" });
        });
      }
      request(e, { traceparent: r2, interactiveTransaction: n2, customDataProxyFetch: A2 }) {
        return this.requestInternal({ body: e, traceparent: r2, interactiveTransaction: n2, customDataProxyFetch: A2 });
      }
      async requestBatch(e, { traceparent: r2, transaction: n2, customDataProxyFetch: A2 }) {
        let i2 = n2?.kind === "itx" ? n2.options : void 0, s = CA(e, n2);
        return (await this.requestInternal({ body: s, customDataProxyFetch: A2, interactiveTransaction: i2, traceparent: r2 })).map((a2) => (a2.extensions && this.propagateResponseExtensions(a2.extensions), "errors" in a2 ? this.convertProtocolErrorsToClientError(a2.errors) : a2));
      }
      requestInternal({ body: e, traceparent: r2, customDataProxyFetch: n2, interactiveTransaction: A2 }) {
        return this.withRetry({ actionGerund: "querying", callback: /* @__PURE__ */ __name(async ({ logHttpCall: i2 }) => {
          let s = A2 ? `${A2.payload.endpoint}/graphql` : await this.url("graphql");
          i2(s);
          let o2 = await Hn(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: r2, transactionId: A2?.id }), body: JSON.stringify(e), clientVersion: this.clientVersion }, n2);
          o2.ok || oo("graphql response status", o2.status), await this.handleError(await io(o2, this.clientVersion));
          let a2 = await o2.json();
          if (a2.extensions && this.propagateResponseExtensions(a2.extensions), "errors" in a2) throw this.convertProtocolErrorsToClientError(a2.errors);
          return "batchResult" in a2 ? a2.batchResult : a2;
        }, "callback") });
      }
      async transaction(e, r2, n2) {
        let A2 = { start: "starting", commit: "committing", rollback: "rolling back" };
        return this.withRetry({ actionGerund: `${A2[e]} transaction`, callback: /* @__PURE__ */ __name(async ({ logHttpCall: i2 }) => {
          if (e === "start") {
            let s = JSON.stringify({ max_wait: n2.maxWait, timeout: n2.timeout, isolation_level: n2.isolationLevel }), o2 = await this.url("transaction/start");
            i2(o2);
            let a2 = await Hn(o2, { method: "POST", headers: this.headerBuilder.build({ traceparent: r2.traceparent }), body: s, clientVersion: this.clientVersion });
            await this.handleError(await io(a2, this.clientVersion));
            let c2 = await a2.json(), { extensions: l2 } = c2;
            l2 && this.propagateResponseExtensions(l2);
            let u2 = c2.id, g = c2["data-proxy"].endpoint;
            return { id: u2, payload: { endpoint: g } };
          } else {
            let s = `${n2.payload.endpoint}/${e}`;
            i2(s);
            let o2 = await Hn(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: r2.traceparent }), clientVersion: this.clientVersion });
            await this.handleError(await io(o2, this.clientVersion));
            let a2 = await o2.json(), { extensions: c2 } = a2;
            c2 && this.propagateResponseExtensions(c2);
            return;
          }
        }, "callback") });
      }
      getURLAndAPIKey() {
        return xS({ clientVersion: this.clientVersion, env: this.env, inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources });
      }
      metrics() {
        throw new On("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
      }
      async withRetry(e) {
        for (let r2 = 0; ; r2++) {
          let n2 = /* @__PURE__ */ __name((A2) => {
            this.logEmitter.emit("info", { message: `Calling ${A2} (n=${r2})`, timestamp: /* @__PURE__ */ new Date(), target: "" });
          }, "n");
          try {
            return await e.callback({ logHttpCall: n2 });
          } catch (A2) {
            if (!(A2 instanceof ze) || !A2.isRetryable) throw A2;
            if (r2 >= GS) throw A2 instanceof li ? A2.cause : A2;
            this.logEmitter.emit("warn", { message: `Attempt ${r2 + 1}/${GS} failed for ${e.actionGerund}: ${A2.message ?? "(unknown)"}`, timestamp: /* @__PURE__ */ new Date(), target: "" });
            let i2 = await kS(r2);
            this.logEmitter.emit("warn", { message: `Retrying after ${i2}ms`, timestamp: /* @__PURE__ */ new Date(), target: "" });
          }
        }
      }
      async handleError(e) {
        if (e instanceof Vn) throw await this.uploadSchema(), new li({ clientVersion: this.clientVersion, cause: e });
        if (e) throw e;
      }
      convertProtocolErrorsToClientError(e) {
        return e.length === 1 ? Yr(e[0], this.config.clientVersion, this.config.activeProvider) : new Be(JSON.stringify(e), { clientVersion: this.config.clientVersion });
      }
      applyPendingMigrations() {
        throw new Error("Method not implemented.");
      }
    };
    function OS({ url: t2, adapter: e, copyEngine: r2, targetBuildType: n2 }) {
      let A2 = [], i2 = [], s = /* @__PURE__ */ __name((f2) => {
        A2.push({ _tag: "warning", value: f2 });
      }, "s"), o2 = /* @__PURE__ */ __name((f2) => {
        let p2 = f2.join(`
`);
        i2.push({ _tag: "error", value: p2 });
      }, "o"), a2 = !!t2?.startsWith("prisma://"), c2 = Yo(t2), l2 = !!e, u2 = a2 || c2;
      !l2 && r2 && u2 && s(["recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)"]);
      let g = u2 || !r2;
      l2 && (g || n2 === "edge") && (n2 === "edge" ? o2(["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.", "Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."]) : r2 ? a2 && o2(["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.", "Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]) : o2(["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."]));
      let E = { accelerate: g, ppg: c2, driverAdapters: l2 };
      function h(f2) {
        return f2.length > 0;
      }
      __name(h, "h");
      return h(i2) ? { ok: false, diagnostics: { warnings: A2, errors: i2 }, isUsing: E } : { ok: true, diagnostics: { warnings: A2 }, isUsing: E };
    }
    __name(OS, "OS");
    function VS({ copyEngine: t2 = true }, e) {
      let r2;
      try {
        r2 = ci({ inlineDatasources: e.inlineDatasources, overrideDatasources: e.overrideDatasources, env: { ...e.env, ...process.env }, clientVersion: e.clientVersion });
      } catch {
      }
      let { ok: n2, isUsing: A2, diagnostics: i2 } = OS({ url: r2, adapter: e.adapter, copyEngine: t2, targetBuildType: "binary" });
      for (let u2 of i2.warnings) Fi(...u2.value);
      if (!n2) {
        let u2 = i2.errors[0];
        throw new Ue(u2.value, { clientVersion: e.clientVersion });
      }
      let s = tA(e.generator), o2 = s === "library", a2 = s === "binary", c2 = s === "client", l2 = (A2.accelerate || A2.ppg) && !A2.driverAdapters;
      return A2.accelerate ? new ao(e) : (A2.driverAdapters, a2 ? new oi(e) : (A2.accelerate, new oi(e)));
    }
    __name(VS, "VS");
    function Nl({ generator: t2 }) {
      return t2?.previewFeatures ?? [];
    }
    __name(Nl, "Nl");
    var HS = /* @__PURE__ */ __name((t2) => ({ command: t2 }), "HS");
    var qS = /* @__PURE__ */ __name((t2) => t2.strings.reduce((e, r2, n2) => `${e}@P${n2}${r2}`), "qS");
    function Ei(t2) {
      try {
        return JS(t2, "fast");
      } catch {
        return JS(t2, "slow");
      }
    }
    __name(Ei, "Ei");
    function JS(t2, e) {
      return JSON.stringify(t2.map((r2) => _S(r2, e)));
    }
    __name(JS, "JS");
    function _S(t2, e) {
      if (Array.isArray(t2)) return t2.map((r2) => _S(r2, e));
      if (typeof t2 == "bigint") return { prisma__type: "bigint", prisma__value: t2.toString() };
      if (nA(t2)) return { prisma__type: "date", prisma__value: t2.toJSON() };
      if (ar.isDecimal(t2)) return { prisma__type: "decimal", prisma__value: t2.toJSON() };
      if (Buffer.isBuffer(t2)) return { prisma__type: "bytes", prisma__value: t2.toString("base64") };
      if (E_(t2)) return { prisma__type: "bytes", prisma__value: Buffer.from(t2).toString("base64") };
      if (ArrayBuffer.isView(t2)) {
        let { buffer: r2, byteOffset: n2, byteLength: A2 } = t2;
        return { prisma__type: "bytes", prisma__value: Buffer.from(r2, n2, A2).toString("base64") };
      }
      return typeof t2 == "object" && e === "slow" ? jS(t2) : t2;
    }
    __name(_S, "_S");
    function E_(t2) {
      return t2 instanceof ArrayBuffer || t2 instanceof SharedArrayBuffer ? true : typeof t2 == "object" && t2 !== null ? t2[Symbol.toStringTag] === "ArrayBuffer" || t2[Symbol.toStringTag] === "SharedArrayBuffer" : false;
    }
    __name(E_, "E_");
    function jS(t2) {
      if (typeof t2 != "object" || t2 === null) return t2;
      if (typeof t2.toJSON == "function") return t2.toJSON();
      if (Array.isArray(t2)) return t2.map(WS);
      let e = {};
      for (let r2 of Object.keys(t2)) e[r2] = WS(t2[r2]);
      return e;
    }
    __name(jS, "jS");
    function WS(t2) {
      return typeof t2 == "bigint" ? t2.toString() : jS(t2);
    }
    __name(WS, "WS");
    var d_ = /^(\s*alter\s)/i;
    var ZS = ce("prisma:client");
    function Wh(t2, e, r2, n2) {
      if (!(t2 !== "postgresql" && t2 !== "cockroachdb") && r2.length > 0 && d_.exec(e)) throw new Error(`Running ALTER using ${n2} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
    }
    __name(Wh, "Wh");
    var _h = /* @__PURE__ */ __name(({ clientMethod: t2, activeProvider: e }) => (r2) => {
      let n2 = "", A2;
      if (Ca(r2)) n2 = r2.sql, A2 = { values: Ei(r2.values), __prismaRawParameters__: true };
      else if (Array.isArray(r2)) {
        let [i2, ...s] = r2;
        n2 = i2, A2 = { values: Ei(s || []), __prismaRawParameters__: true };
      } else switch (e) {
        case "sqlite":
        case "mysql": {
          n2 = r2.sql, A2 = { values: Ei(r2.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          n2 = r2.text, A2 = { values: Ei(r2.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n2 = qS(r2), A2 = { values: Ei(r2.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${e} provider does not support ${t2}`);
      }
      return A2?.values ? ZS(`prisma.${t2}(${n2}, ${A2.values})`) : ZS(`prisma.${t2}(${n2})`), { query: n2, parameters: A2 };
    }, "_h");
    var XS = { requestArgsToMiddlewareArgs(t2) {
      return [t2.strings, ...t2.values];
    }, middlewareArgsToRequestArgs(t2) {
      let [e, ...r2] = t2;
      return new _e(e, r2);
    } };
    var KS = { requestArgsToMiddlewareArgs(t2) {
      return [t2];
    }, middlewareArgsToRequestArgs(t2) {
      return t2[0];
    } };
    function jh(t2) {
      return function(r2, n2) {
        let A2, i2 = /* @__PURE__ */ __name((s = t2) => {
          try {
            return s === void 0 || s?.kind === "itx" ? A2 ??= $S(r2(s)) : $S(r2(s));
          } catch (o2) {
            return Promise.reject(o2);
          }
        }, "i");
        return { get spec() {
          return n2;
        }, then(s, o2) {
          return i2().then(s, o2);
        }, catch(s) {
          return i2().catch(s);
        }, finally(s) {
          return i2().finally(s);
        }, requestTransaction(s) {
          let o2 = i2(s);
          return o2.requestTransaction ? o2.requestTransaction(s) : o2;
        }, [Symbol.toStringTag]: "PrismaPromise" };
      };
    }
    __name(jh, "jh");
    function $S(t2) {
      return typeof t2.then == "function" ? t2 : Promise.resolve(t2);
    }
    __name($S, "$S");
    var h_ = uu.split(".")[0];
    var f_ = { isEnabled() {
      return false;
    }, getTraceParent() {
      return "00-10-10-00";
    }, dispatchEngineSpans() {
    }, getActiveContext() {
    }, runInChildSpan(t2, e) {
      return e();
    } };
    var Zh = class {
      static {
        __name(this, "Zh");
      }
      isEnabled() {
        return this.getGlobalTracingHelper().isEnabled();
      }
      getTraceParent(e) {
        return this.getGlobalTracingHelper().getTraceParent(e);
      }
      dispatchEngineSpans(e) {
        return this.getGlobalTracingHelper().dispatchEngineSpans(e);
      }
      getActiveContext() {
        return this.getGlobalTracingHelper().getActiveContext();
      }
      runInChildSpan(e, r2) {
        return this.getGlobalTracingHelper().runInChildSpan(e, r2);
      }
      getGlobalTracingHelper() {
        let e = globalThis[`V${h_}_PRISMA_INSTRUMENTATION`], r2 = globalThis.PRISMA_INSTRUMENTATION;
        return e?.helper ?? r2?.helper ?? f_;
      }
    };
    function zS() {
      return new Zh();
    }
    __name(zS, "zS");
    function eb(t2, e = () => {
    }) {
      let r2, n2 = new Promise((A2) => r2 = A2);
      return { then(A2) {
        return --t2 === 0 && r2(e()), A2?.(n2);
      } };
    }
    __name(eb, "eb");
    function tb(t2) {
      return typeof t2 == "string" ? t2 : t2.reduce((e, r2) => {
        let n2 = typeof r2 == "string" ? r2 : r2.level;
        return n2 === "query" ? e : e && (r2 === "info" || e === "info") ? "info" : n2;
      }, void 0);
    }
    __name(tb, "tb");
    var nb = G2(yu());
    function Fl(t2) {
      return typeof t2.batchRequestIdx == "number";
    }
    __name(Fl, "Fl");
    function rb(t2) {
      if (t2.action !== "findUnique" && t2.action !== "findUniqueOrThrow") return;
      let e = [];
      return t2.modelName && e.push(t2.modelName), t2.query.arguments && e.push(Xh(t2.query.arguments)), e.push(Xh(t2.query.selection)), e.join("");
    }
    __name(rb, "rb");
    function Xh(t2) {
      return `(${Object.keys(t2).sort().map((r2) => {
        let n2 = t2[r2];
        return typeof n2 == "object" && n2 !== null ? `(${r2} ${Xh(n2)})` : r2;
      }).join(" ")})`;
    }
    __name(Xh, "Xh");
    var Q_ = { aggregate: false, aggregateRaw: false, createMany: true, createManyAndReturn: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateManyAndReturn: true, updateOne: true, upsertOne: true };
    function Kh(t2) {
      return Q_[t2];
    }
    __name(Kh, "Kh");
    var Tl = class {
      static {
        __name(this, "Tl");
      }
      constructor(e) {
        this.options = e;
        this.batches = {};
      }
      batches;
      tickActive = false;
      request(e) {
        let r2 = this.options.batchBy(e);
        return r2 ? (this.batches[r2] || (this.batches[r2] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
          this.dispatchBatches(), this.tickActive = false;
        }))), new Promise((n2, A2) => {
          this.batches[r2].push({ request: e, resolve: n2, reject: A2 });
        })) : this.options.singleLoader(e);
      }
      dispatchBatches() {
        for (let e in this.batches) {
          let r2 = this.batches[e];
          delete this.batches[e], r2.length === 1 ? this.options.singleLoader(r2[0].request).then((n2) => {
            n2 instanceof Error ? r2[0].reject(n2) : r2[0].resolve(n2);
          }).catch((n2) => {
            r2[0].reject(n2);
          }) : (r2.sort((n2, A2) => this.options.batchOrder(n2.request, A2.request)), this.options.batchLoader(r2.map((n2) => n2.request)).then((n2) => {
            if (n2 instanceof Error) for (let A2 = 0; A2 < r2.length; A2++) r2[A2].reject(n2);
            else for (let A2 = 0; A2 < r2.length; A2++) {
              let i2 = n2[A2];
              i2 instanceof Error ? r2[A2].reject(i2) : r2[A2].resolve(i2);
            }
          }).catch((n2) => {
            for (let A2 = 0; A2 < r2.length; A2++) r2[A2].reject(n2);
          }));
        }
      }
      get [Symbol.toStringTag]() {
        return "DataLoader";
      }
    };
    function qn(t2, e) {
      if (e === null) return e;
      switch (t2) {
        case "bigint":
          return BigInt(e);
        case "bytes": {
          let { buffer: r2, byteOffset: n2, byteLength: A2 } = Buffer.from(e, "base64");
          return new Uint8Array(r2, n2, A2);
        }
        case "decimal":
          return new ar(e);
        case "datetime":
        case "date":
          return new Date(e);
        case "time":
          return /* @__PURE__ */ new Date(`1970-01-01T${e}Z`);
        case "bigint-array":
          return e.map((r2) => qn("bigint", r2));
        case "bytes-array":
          return e.map((r2) => qn("bytes", r2));
        case "decimal-array":
          return e.map((r2) => qn("decimal", r2));
        case "datetime-array":
          return e.map((r2) => qn("datetime", r2));
        case "date-array":
          return e.map((r2) => qn("date", r2));
        case "time-array":
          return e.map((r2) => qn("time", r2));
        default:
          return e;
      }
    }
    __name(qn, "qn");
    function xl(t2) {
      let e = [], r2 = C_(t2);
      for (let n2 = 0; n2 < t2.rows.length; n2++) {
        let A2 = t2.rows[n2], i2 = { ...r2 };
        for (let s = 0; s < A2.length; s++) i2[t2.columns[s]] = qn(t2.types[s], A2[s]);
        e.push(i2);
      }
      return e;
    }
    __name(xl, "xl");
    function C_(t2) {
      let e = {};
      for (let r2 = 0; r2 < t2.columns.length; r2++) e[t2.columns[r2]] = null;
      return e;
    }
    __name(C_, "C_");
    var I_ = ce("prisma:client:request_handler");
    var Ul = class {
      static {
        __name(this, "Ul");
      }
      client;
      dataloader;
      logEmitter;
      constructor(e, r2) {
        this.logEmitter = r2, this.client = e, this.dataloader = new Tl({ batchLoader: Ap(async ({ requests: n2, customDataProxyFetch: A2 }) => {
          let { transaction: i2, otelParentCtx: s } = n2[0], o2 = n2.map((u2) => u2.protocolQuery), a2 = this.client._tracingHelper.getTraceParent(s), c2 = n2.some((u2) => Kh(u2.protocolQuery.action));
          return (await this.client._engine.requestBatch(o2, { traceparent: a2, transaction: p_(i2), containsWrite: c2, customDataProxyFetch: A2 })).map((u2, g) => {
            if (u2 instanceof Error) return u2;
            try {
              return this.mapQueryEngineResult(n2[g], u2);
            } catch (E) {
              return E;
            }
          });
        }), singleLoader: /* @__PURE__ */ __name(async (n2) => {
          let A2 = n2.transaction?.kind === "itx" ? Ab(n2.transaction) : void 0, i2 = await this.client._engine.request(n2.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: A2, isWrite: Kh(n2.protocolQuery.action), customDataProxyFetch: n2.customDataProxyFetch });
          return this.mapQueryEngineResult(n2, i2);
        }, "singleLoader"), batchBy: /* @__PURE__ */ __name((n2) => n2.transaction?.id ? `transaction-${n2.transaction.id}` : rb(n2.protocolQuery), "batchBy"), batchOrder(n2, A2) {
          return n2.transaction?.kind === "batch" && A2.transaction?.kind === "batch" ? n2.transaction.index - A2.transaction.index : 0;
        } });
      }
      async request(e) {
        try {
          return await this.dataloader.request(e);
        } catch (r2) {
          let { clientMethod: n2, callsite: A2, transaction: i2, args: s, modelName: o2 } = e;
          this.handleAndLogRequestError({ error: r2, clientMethod: n2, callsite: A2, transaction: i2, args: s, modelName: o2, globalOmit: e.globalOmit });
        }
      }
      mapQueryEngineResult({ dataPath: e, unpacker: r2 }, n2) {
        let A2 = n2?.data, i2 = this.unpack(A2, e, r2);
        return process.env.PRISMA_CLIENT_GET_TIME ? { data: i2 } : i2;
      }
      handleAndLogRequestError(e) {
        try {
          this.handleRequestError(e);
        } catch (r2) {
          throw this.logEmitter && this.logEmitter.emit("error", { message: r2.message, target: e.clientMethod, timestamp: /* @__PURE__ */ new Date() }), r2;
        }
      }
      handleRequestError({ error: e, clientMethod: r2, callsite: n2, transaction: A2, args: i2, modelName: s, globalOmit: o2 }) {
        if (I_(e), B_(e, A2)) throw e;
        if (e instanceof Ne && m_(e)) {
          let c2 = ib(e.meta);
          ga({ args: i2, errors: [c2], callsite: n2, errorFormat: this.client._errorFormat, originalMethod: r2, clientVersion: this.client._clientVersion, globalOmit: o2 });
        }
        let a2 = e.message;
        if (n2 && (a2 = ra({ callsite: n2, originalMethod: r2, isPanic: e.isPanic, showColors: this.client._errorFormat === "pretty", message: a2 })), a2 = this.sanitizeMessage(a2), e.code) {
          let c2 = s ? { modelName: s, ...e.meta } : e.meta;
          throw new Ne(a2, { code: e.code, clientVersion: this.client._clientVersion, meta: c2, batchRequestIdx: e.batchRequestIdx });
        } else {
          if (e.isPanic) throw new ut(a2, this.client._clientVersion);
          if (e instanceof Be) throw new Be(a2, { clientVersion: this.client._clientVersion, batchRequestIdx: e.batchRequestIdx });
          if (e instanceof Z) throw new Z(a2, this.client._clientVersion);
          if (e instanceof ut) throw new ut(a2, this.client._clientVersion);
        }
        throw e.clientVersion = this.client._clientVersion, e;
      }
      sanitizeMessage(e) {
        return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, nb.default)(e) : e;
      }
      unpack(e, r2, n2) {
        if (!e || (e.data && (e = e.data), !e)) return e;
        let A2 = Object.keys(e)[0], i2 = Object.values(e)[0], s = r2.filter((c2) => c2 !== "select" && c2 !== "include"), o2 = Xu(i2, s), a2 = A2 === "queryRaw" ? xl(o2) : ai(o2);
        return n2 ? n2(a2) : a2;
      }
      get [Symbol.toStringTag]() {
        return "RequestHandler";
      }
    };
    function p_(t2) {
      if (t2) {
        if (t2.kind === "batch") return { kind: "batch", options: { isolationLevel: t2.isolationLevel } };
        if (t2.kind === "itx") return { kind: "itx", options: Ab(t2) };
        ln(t2, "Unknown transaction kind");
      }
    }
    __name(p_, "p_");
    function Ab(t2) {
      return { id: t2.id, payload: t2.payload };
    }
    __name(Ab, "Ab");
    function B_(t2, e) {
      return Fl(t2) && e?.kind === "batch" && t2.batchRequestIdx !== e.index;
    }
    __name(B_, "B_");
    function m_(t2) {
      return t2.code === "P2009" || t2.code === "P2012";
    }
    __name(m_, "m_");
    function ib(t2) {
      if (t2.kind === "Union") return { kind: "Union", errors: t2.errors.map(ib) };
      if (Array.isArray(t2.selectionPath)) {
        let [, ...e] = t2.selectionPath;
        return { ...t2, selectionPath: e };
      }
      return t2;
    }
    __name(ib, "ib");
    var sb = TS;
    var ub = G2(vu());
    var z = class extends Error {
      static {
        __name(this, "z");
      }
      constructor(e) {
        super(e + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientConstructorValidationError";
      }
    };
    M2(z, "PrismaClientConstructorValidationError");
    var ob = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "transactionOptions", "omit", "__internal"];
    var ab = ["pretty", "colorless", "minimal"];
    var cb = ["info", "query", "warn", "error"];
    var y_ = { datasources: /* @__PURE__ */ __name((t2, { datasourceNames: e }) => {
      if (t2) {
        if (typeof t2 != "object" || Array.isArray(t2)) throw new z(`Invalid value ${JSON.stringify(t2)} for "datasources" provided to PrismaClient constructor`);
        for (let [r2, n2] of Object.entries(t2)) {
          if (!e.includes(r2)) {
            let A2 = di(r2, e) || ` Available datasources: ${e.join(", ")}`;
            throw new z(`Unknown datasource ${r2} provided to PrismaClient constructor.${A2}`);
          }
          if (typeof n2 != "object" || Array.isArray(n2)) throw new z(`Invalid value ${JSON.stringify(t2)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          if (n2 && typeof n2 == "object") for (let [A2, i2] of Object.entries(n2)) {
            if (A2 !== "url") throw new z(`Invalid value ${JSON.stringify(t2)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof i2 != "string") throw new z(`Invalid value ${JSON.stringify(i2)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
        }
      }
    }, "datasources"), adapter: /* @__PURE__ */ __name((t2, e) => {
      if (!t2 && tA(e.generator) === "client") throw new z('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');
      if (t2 === null) return;
      if (t2 === void 0) throw new z('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
      if (!Nl(e).includes("driverAdapters")) throw new z('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
      if (tA(e.generator) === "binary") throw new z('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
    }, "adapter"), datasourceUrl: /* @__PURE__ */ __name((t2) => {
      if (typeof t2 < "u" && typeof t2 != "string") throw new z(`Invalid value ${JSON.stringify(t2)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
    }, "datasourceUrl"), errorFormat: /* @__PURE__ */ __name((t2) => {
      if (t2) {
        if (typeof t2 != "string") throw new z(`Invalid value ${JSON.stringify(t2)} for "errorFormat" provided to PrismaClient constructor.`);
        if (!ab.includes(t2)) {
          let e = di(t2, ab);
          throw new z(`Invalid errorFormat ${t2} provided to PrismaClient constructor.${e}`);
        }
      }
    }, "errorFormat"), log: /* @__PURE__ */ __name((t2) => {
      if (!t2) return;
      if (!Array.isArray(t2)) throw new z(`Invalid value ${JSON.stringify(t2)} for "log" provided to PrismaClient constructor.`);
      function e(r2) {
        if (typeof r2 == "string" && !cb.includes(r2)) {
          let n2 = di(r2, cb);
          throw new z(`Invalid log level "${r2}" provided to PrismaClient constructor.${n2}`);
        }
      }
      __name(e, "e");
      for (let r2 of t2) {
        e(r2);
        let n2 = { level: e, emit: /* @__PURE__ */ __name((A2) => {
          let i2 = ["stdout", "event"];
          if (!i2.includes(A2)) {
            let s = di(A2, i2);
            throw new z(`Invalid value ${JSON.stringify(A2)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
          }
        }, "emit") };
        if (r2 && typeof r2 == "object") for (let [A2, i2] of Object.entries(r2)) if (n2[A2]) n2[A2](i2);
        else throw new z(`Invalid property ${A2} for "log" provided to PrismaClient constructor`);
      }
    }, "log"), transactionOptions: /* @__PURE__ */ __name((t2) => {
      if (!t2) return;
      let e = t2.maxWait;
      if (e != null && e <= 0) throw new z(`Invalid value ${e} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
      let r2 = t2.timeout;
      if (r2 != null && r2 <= 0) throw new z(`Invalid value ${r2} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
    }, "transactionOptions"), omit: /* @__PURE__ */ __name((t2, e) => {
      if (typeof t2 != "object") throw new z('"omit" option is expected to be an object.');
      if (t2 === null) throw new z('"omit" option can not be `null`');
      let r2 = [];
      for (let [n2, A2] of Object.entries(t2)) {
        let i2 = D_(n2, e.runtimeDataModel);
        if (!i2) {
          r2.push({ kind: "UnknownModel", modelKey: n2 });
          continue;
        }
        for (let [s, o2] of Object.entries(A2)) {
          let a2 = i2.fields.find((c2) => c2.name === s);
          if (!a2) {
            r2.push({ kind: "UnknownField", modelKey: n2, fieldName: s });
            continue;
          }
          if (a2.relationName) {
            r2.push({ kind: "RelationInOmit", modelKey: n2, fieldName: s });
            continue;
          }
          typeof o2 != "boolean" && r2.push({ kind: "InvalidFieldValue", modelKey: n2, fieldName: s });
        }
      }
      if (r2.length > 0) throw new z(R_(t2, r2));
    }, "omit"), __internal: /* @__PURE__ */ __name((t2) => {
      if (!t2) return;
      let e = ["debug", "engine", "configOverride"];
      if (typeof t2 != "object") throw new z(`Invalid value ${JSON.stringify(t2)} for "__internal" to PrismaClient constructor`);
      for (let [r2] of Object.entries(t2)) if (!e.includes(r2)) {
        let n2 = di(r2, e);
        throw new z(`Invalid property ${JSON.stringify(r2)} for "__internal" provided to PrismaClient constructor.${n2}`);
      }
    }, "__internal") };
    function gb(t2, e) {
      for (let [r2, n2] of Object.entries(t2)) {
        if (!ob.includes(r2)) {
          let A2 = di(r2, ob);
          throw new z(`Unknown property ${r2} provided to PrismaClient constructor.${A2}`);
        }
        y_[r2](n2, e);
      }
      if (t2.datasourceUrl && t2.datasources) throw new z('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
    }
    __name(gb, "gb");
    function di(t2, e) {
      if (e.length === 0 || typeof t2 != "string") return "";
      let r2 = w_(t2, e);
      return r2 ? ` Did you mean "${r2}"?` : "";
    }
    __name(di, "di");
    function w_(t2, e) {
      if (e.length === 0) return null;
      let r2 = e.map((A2) => ({ value: A2, distance: (0, ub.default)(t2, A2) }));
      r2.sort((A2, i2) => A2.distance < i2.distance ? -1 : 1);
      let n2 = r2[0];
      return n2.distance < 3 ? n2.value : null;
    }
    __name(w_, "w_");
    function D_(t2, e) {
      return lb(e.models, t2) ?? lb(e.types, t2);
    }
    __name(D_, "D_");
    function lb(t2, e) {
      let r2 = Object.keys(t2).find((n2) => Ur(n2) === e);
      if (r2) return t2[r2];
    }
    __name(lb, "lb");
    function R_(t2, e) {
      let r2 = dA(t2);
      for (let i2 of e) switch (i2.kind) {
        case "UnknownModel":
          r2.arguments.getField(i2.modelKey)?.markAsError(), r2.addErrorMessage(() => `Unknown model name: ${i2.modelKey}.`);
          break;
        case "UnknownField":
          r2.arguments.getDeepField([i2.modelKey, i2.fieldName])?.markAsError(), r2.addErrorMessage(() => `Model "${i2.modelKey}" does not have a field named "${i2.fieldName}".`);
          break;
        case "RelationInOmit":
          r2.arguments.getDeepField([i2.modelKey, i2.fieldName])?.markAsError(), r2.addErrorMessage(() => 'Relations are already excluded by default and can not be specified in "omit".');
          break;
        case "InvalidFieldValue":
          r2.arguments.getDeepFieldValue([i2.modelKey, i2.fieldName])?.markAsError(), r2.addErrorMessage(() => "Omit field option value must be a boolean.");
          break;
      }
      let { message: n2, args: A2 } = ua(r2, "colorless");
      return `Error validating "omit" option:

${A2}

${n2}`;
    }
    __name(R_, "R_");
    function Eb(t2) {
      return t2.length === 0 ? Promise.resolve([]) : new Promise((e, r2) => {
        let n2 = new Array(t2.length), A2 = null, i2 = false, s = 0, o2 = /* @__PURE__ */ __name(() => {
          i2 || (s++, s === t2.length && (i2 = true, A2 ? r2(A2) : e(n2)));
        }, "o"), a2 = /* @__PURE__ */ __name((c2) => {
          i2 || (i2 = true, r2(c2));
        }, "a");
        for (let c2 = 0; c2 < t2.length; c2++) t2[c2].then((l2) => {
          n2[c2] = l2, o2();
        }, (l2) => {
          if (!Fl(l2)) {
            a2(l2);
            return;
          }
          l2.batchRequestIdx === c2 ? a2(l2) : (A2 || (A2 = l2), o2());
        });
      });
    }
    __name(Eb, "Eb");
    var tn = ce("prisma:client");
    typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
    var S_ = { requestArgsToMiddlewareArgs: /* @__PURE__ */ __name((t2) => t2, "requestArgsToMiddlewareArgs"), middlewareArgsToRequestArgs: /* @__PURE__ */ __name((t2) => t2, "middlewareArgsToRequestArgs") };
    var b_ = Symbol.for("prisma.client.transaction.id");
    var N_ = { id: 0, nextId() {
      return ++this.id;
    } };
    function Ib(t2) {
      class e {
        static {
          __name(this, "e");
        }
        _originalClient = this;
        _runtimeDataModel;
        _requestHandler;
        _connectionPromise;
        _disconnectionPromise;
        _engineConfig;
        _accelerateEngineConfig;
        _clientVersion;
        _errorFormat;
        _tracingHelper;
        _previewFeatures;
        _activeProvider;
        _globalOmit;
        _extensions;
        _engine;
        _appliedParent;
        _createPrismaPromise = jh();
        constructor(n2) {
          t2 = n2?.__internal?.configOverride?.(t2) ?? t2, cp(t2), n2 && gb(n2, t2);
          let A2 = new Qb.EventEmitter().on("error", () => {
          });
          this._extensions = hA.empty(), this._previewFeatures = Nl(t2), this._clientVersion = t2.clientVersion ?? sb, this._activeProvider = t2.activeProvider, this._globalOmit = n2?.omit, this._tracingHelper = zS();
          let i2 = t2.relativeEnvPaths && { rootEnvPath: t2.relativeEnvPaths.rootEnvPath && kl.default.resolve(t2.dirname, t2.relativeEnvPaths.rootEnvPath), schemaEnvPath: t2.relativeEnvPaths.schemaEnvPath && kl.default.resolve(t2.dirname, t2.relativeEnvPaths.schemaEnvPath) }, s;
          if (n2?.adapter) {
            s = n2.adapter;
            let a2 = t2.activeProvider === "postgresql" || t2.activeProvider === "cockroachdb" ? "postgres" : t2.activeProvider;
            if (s.provider !== a2) throw new Z(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${a2}\` specified in the Prisma schema.`, this._clientVersion);
            if (n2.datasources || n2.datasourceUrl !== void 0) throw new Z("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.", this._clientVersion);
          }
          let o2 = !s && i2 && Ni(i2, { conflictCheck: "none" }) || t2.injectableEdgeEnv?.();
          try {
            let a2 = n2 ?? {}, c2 = a2.__internal ?? {}, l2 = c2.debug === true;
            l2 && ce.enable("prisma:client");
            let u2 = kl.default.resolve(t2.dirname, t2.relativePath);
            Cb.default.existsSync(u2) || (u2 = t2.dirname), tn("dirname", t2.dirname), tn("relativePath", t2.relativePath), tn("cwd", u2);
            let g = c2.engine || {};
            if (a2.errorFormat ? this._errorFormat = a2.errorFormat : process.env.NODE_ENV === "production" ? this._errorFormat = "minimal" : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = t2.runtimeDataModel, this._engineConfig = { cwd: u2, dirname: t2.dirname, enableDebugLogs: l2, allowTriggerPanic: g.allowTriggerPanic, prismaPath: g.binaryPath ?? void 0, engineEndpoint: g.endpoint, generator: t2.generator, showColors: this._errorFormat === "pretty", logLevel: a2.log && tb(a2.log), logQueries: a2.log && !!(typeof a2.log == "string" ? a2.log === "query" : a2.log.find((E) => typeof E == "string" ? E === "query" : E.level === "query")), env: o2?.parsed ?? {}, flags: [], engineWasm: t2.engineWasm, compilerWasm: t2.compilerWasm, clientVersion: t2.clientVersion, engineVersion: t2.engineVersion, previewFeatures: this._previewFeatures, activeProvider: t2.activeProvider, inlineSchema: t2.inlineSchema, overrideDatasources: lp(a2, t2.datasourceNames), inlineDatasources: t2.inlineDatasources, inlineSchemaHash: t2.inlineSchemaHash, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: a2.transactionOptions?.maxWait ?? 2e3, timeout: a2.transactionOptions?.timeout ?? 5e3, isolationLevel: a2.transactionOptions?.isolationLevel }, logEmitter: A2, isBundled: t2.isBundled, adapter: s }, this._accelerateEngineConfig = { ...this._engineConfig, accelerateUtils: { resolveDatasourceUrl: ci, getBatchRequestPayload: CA, prismaGraphQLToJSError: Yr, PrismaClientUnknownRequestError: Be, PrismaClientInitializationError: Z, PrismaClientKnownRequestError: Ne, debug: ce("prisma:client:accelerateEngine"), engineVersion: hb.version, clientVersion: t2.clientVersion } }, tn("clientVersion", t2.clientVersion), this._engine = VS(t2, this._engineConfig), this._requestHandler = new Ul(this, A2), a2.log) for (let E of a2.log) {
              let h = typeof E == "string" ? E : E.emit === "stdout" ? E.level : null;
              h && this.$on(h, (f2) => {
                Di.log(`${Di.tags[h] ?? ""}`, f2.message || f2.query);
              });
            }
          } catch (a2) {
            throw a2.clientVersion = this._clientVersion, a2;
          }
          return this._appliedParent = Wi(this);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClient";
        }
        $on(n2, A2) {
          return n2 === "beforeExit" ? this._engine.onBeforeExit(A2) : n2 && this._engineConfig.logEmitter.on(n2, A2), this;
        }
        $connect() {
          try {
            return this._engine.start();
          } catch (n2) {
            throw n2.clientVersion = this._clientVersion, n2;
          }
        }
        async $disconnect() {
          try {
            await this._engine.stop();
          } catch (n2) {
            throw n2.clientVersion = this._clientVersion, n2;
          } finally {
            gf();
          }
        }
        $executeRawInternal(n2, A2, i2, s) {
          let o2 = this._activeProvider;
          return this._request({ action: "executeRaw", args: i2, transaction: n2, clientMethod: A2, argsMapper: _h({ clientMethod: A2, activeProvider: o2 }), callsite: Gr(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
        }
        $executeRaw(n2, ...A2) {
          return this._createPrismaPromise((i2) => {
            if (n2.raw !== void 0 || n2.sql !== void 0) {
              let [s, o2] = db(n2, A2);
              return Wh(this._activeProvider, s.text, s.values, Array.isArray(n2) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(i2, "$executeRaw", s, o2);
            }
            throw new Ue("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
          });
        }
        $executeRawUnsafe(n2, ...A2) {
          return this._createPrismaPromise((i2) => (Wh(this._activeProvider, n2, A2, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(i2, "$executeRawUnsafe", [n2, ...A2])));
        }
        $runCommandRaw(n2) {
          if (t2.activeProvider !== "mongodb") throw new Ue(`The ${t2.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
          return this._createPrismaPromise((A2) => this._request({ args: n2, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: HS, callsite: Gr(this._errorFormat), transaction: A2 }));
        }
        async $queryRawInternal(n2, A2, i2, s) {
          let o2 = this._activeProvider;
          return this._request({ action: "queryRaw", args: i2, transaction: n2, clientMethod: A2, argsMapper: _h({ clientMethod: A2, activeProvider: o2 }), callsite: Gr(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
        }
        $queryRaw(n2, ...A2) {
          return this._createPrismaPromise((i2) => {
            if (n2.raw !== void 0 || n2.sql !== void 0) return this.$queryRawInternal(i2, "$queryRaw", ...db(n2, A2));
            throw new Ue("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
          });
        }
        $queryRawTyped(n2) {
          return this._createPrismaPromise((A2) => {
            if (!this._hasPreviewFlag("typedSql")) throw new Ue("`typedSql` preview feature must be enabled in order to access $queryRawTyped API", { clientVersion: this._clientVersion });
            return this.$queryRawInternal(A2, "$queryRawTyped", n2);
          });
        }
        $queryRawUnsafe(n2, ...A2) {
          return this._createPrismaPromise((i2) => this.$queryRawInternal(i2, "$queryRawUnsafe", [n2, ...A2]));
        }
        _transactionWithArray({ promises: n2, options: A2 }) {
          let i2 = N_.nextId(), s = eb(n2.length), o2 = n2.map((a2, c2) => {
            if (a2?.[Symbol.toStringTag] !== "PrismaPromise") throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
            let l2 = A2?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, u2 = { kind: "batch", id: i2, index: c2, isolationLevel: l2, lock: s };
            return a2.requestTransaction?.(u2) ?? a2;
          });
          return Eb(o2);
        }
        async _transactionWithCallback({ callback: n2, options: A2 }) {
          let i2 = { traceparent: this._tracingHelper.getTraceParent() }, s = { maxWait: A2?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: A2?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: A2?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, o2 = await this._engine.transaction("start", i2, s), a2;
          try {
            let c2 = { kind: "itx", ...o2 };
            a2 = await n2(this._createItxClient(c2)), await this._engine.transaction("commit", i2, o2);
          } catch (c2) {
            throw await this._engine.transaction("rollback", i2, o2).catch(() => {
            }), c2;
          }
          return a2;
        }
        _createItxClient(n2) {
          return mt(Wi(mt(jI(this), [Oe("_appliedParent", () => this._appliedParent._createItxClient(n2)), Oe("_createPrismaPromise", () => jh(n2)), Oe(b_, () => n2.id)])), [QA(zI)]);
        }
        $transaction(n2, A2) {
          let i2;
          typeof n2 == "function" ? this._engineConfig.adapter?.adapterName === "@prisma/adapter-d1" ? i2 = /* @__PURE__ */ __name(() => {
            throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.");
          }, "i") : i2 = /* @__PURE__ */ __name(() => this._transactionWithCallback({ callback: n2, options: A2 }), "i") : i2 = /* @__PURE__ */ __name(() => this._transactionWithArray({ promises: n2, options: A2 }), "i");
          let s = { name: "transaction", attributes: { method: "$transaction" } };
          return this._tracingHelper.runInChildSpan(s, i2);
        }
        _request(n2) {
          n2.otelParentCtx = this._tracingHelper.getActiveContext();
          let A2 = n2.middlewareArgsMapper ?? S_, i2 = { args: A2.requestArgsToMiddlewareArgs(n2.args), dataPath: n2.dataPath, runInTransaction: !!n2.transaction, action: n2.action, model: n2.model }, s = { operation: { name: "operation", attributes: { method: i2.action, model: i2.model, name: i2.model ? `${i2.model}.${i2.action}` : i2.action } } }, o2 = /* @__PURE__ */ __name(async (a2) => {
            let { runInTransaction: c2, args: l2, ...u2 } = a2, g = { ...n2, ...u2 };
            l2 && (g.args = A2.middlewareArgsToRequestArgs(l2)), n2.transaction !== void 0 && c2 === false && delete g.transaction;
            let E = await np(this, g);
            return g.model ? $I({ result: E, modelName: g.model, args: g.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel, globalOmit: this._globalOmit }) : E;
          }, "o");
          return this._tracingHelper.runInChildSpan(s.operation, () => new fb.AsyncResource("prisma-client-request").runInAsyncScope(() => o2(i2)));
        }
        async _executeRequest({ args: n2, clientMethod: A2, dataPath: i2, callsite: s, action: o2, model: a2, argsMapper: c2, transaction: l2, unpacker: u2, otelParentCtx: g, customDataProxyFetch: E }) {
          try {
            n2 = c2 ? c2(n2) : n2;
            let h = { name: "serialize" }, f2 = this._tracingHelper.runInChildSpan(h, () => fa({ modelName: a2, runtimeDataModel: this._runtimeDataModel, action: o2, args: n2, clientMethod: A2, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion, previewFeatures: this._previewFeatures, globalOmit: this._globalOmit }));
            return ce.enabled("prisma:client") && (tn("Prisma Client call:"), tn(`prisma.${A2}(${vI(n2)})`), tn("Generated request:"), tn(JSON.stringify(f2, null, 2) + `
`)), l2?.kind === "batch" && await l2.lock, this._requestHandler.request({ protocolQuery: f2, modelName: a2, action: o2, clientMethod: A2, dataPath: i2, callsite: s, args: n2, extensions: this._extensions, transaction: l2, unpacker: u2, otelParentCtx: g, otelChildCtx: this._tracingHelper.getActiveContext(), globalOmit: this._globalOmit, customDataProxyFetch: E });
          } catch (h) {
            throw h.clientVersion = this._clientVersion, h;
          }
        }
        $metrics = new fA(this);
        _hasPreviewFlag(n2) {
          return !!this._engineConfig.previewFeatures?.includes(n2);
        }
        $applyPendingMigrations() {
          return this._engine.applyPendingMigrations();
        }
        $extends = ZI;
      }
      return e;
    }
    __name(Ib, "Ib");
    function db(t2, e) {
      return F_(t2) ? [new _e(t2, e), XS] : [t2, KS];
    }
    __name(db, "db");
    function F_(t2) {
      return Array.isArray(t2) && Array.isArray(t2.raw);
    }
    __name(F_, "F_");
    var T_ = /* @__PURE__ */ new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
    function pb(t2) {
      return new Proxy(t2, { get(e, r2) {
        if (r2 in e) return e[r2];
        if (!T_.has(r2)) throw new TypeError(`Invalid enum value: ${String(r2)}`);
      } });
    }
    __name(pb, "pb");
    function Bb(t2) {
      Ni(t2, { conflictCheck: "warn" });
    }
    __name(Bb, "Bb");
  }
});

// node_modules/.prisma/client/index.js
var require_client = __commonJS({
  "node_modules/.prisma/client/index.js"(exports) {
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    var {
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError: PrismaClientValidationError2,
      getPrismaClient: getPrismaClient2,
      sqltag: sqltag2,
      empty: empty2,
      join: join2,
      raw: raw2,
      skip: skip2,
      Decimal: Decimal2,
      Debug: Debug2,
      objectEnumValues: objectEnumValues2,
      makeStrictEnum: makeStrictEnum2,
      Extensions: Extensions2,
      warnOnce: warnOnce2,
      defineDmmfProperty: defineDmmfProperty2,
      Public: Public2,
      getRuntime: getRuntime2,
      createParam: createParam2
    } = require_binary();
    var Prisma = {};
    exports.Prisma = Prisma;
    exports.$Enums = {};
    Prisma.prismaVersion = {
      client: "6.19.0",
      engine: "2ba551f319ab1df4bc874a89965d8b3641056773"
    };
    Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
    Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
    Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
    Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
    Prisma.PrismaClientValidationError = PrismaClientValidationError2;
    Prisma.Decimal = Decimal2;
    Prisma.sql = sqltag2;
    Prisma.empty = empty2;
    Prisma.join = join2;
    Prisma.raw = raw2;
    Prisma.validator = Public2.validator;
    Prisma.getExtensionContext = Extensions2.getExtensionContext;
    Prisma.defineExtension = Extensions2.defineExtension;
    Prisma.DbNull = objectEnumValues2.instances.DbNull;
    Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
    Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
    Prisma.NullTypes = {
      DbNull: objectEnumValues2.classes.DbNull,
      JsonNull: objectEnumValues2.classes.JsonNull,
      AnyNull: objectEnumValues2.classes.AnyNull
    };
    var path = __require("path");
    exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
      ReadUncommitted: "ReadUncommitted",
      ReadCommitted: "ReadCommitted",
      RepeatableRead: "RepeatableRead",
      Serializable: "Serializable"
    });
    exports.Prisma.UserScalarFieldEnum = {
      id: "id",
      email: "email",
      name: "name",
      image: "image",
      public_cover_image_url: "public_cover_image_url",
      doctor_slug: "doctor_slug",
      role: "role",
      is_active: "is_active",
      created_at: "created_at",
      updated_at: "updated_at",
      email_verified: "email_verified",
      password: "password",
      reset_token: "reset_token",
      reset_token_expiry: "reset_token_expiry",
      verification_code: "verification_code",
      verification_code_expiry: "verification_code_expiry",
      doctor_id: "doctor_id",
      referral_code: "referral_code",
      phone: "phone",
      birth_date: "birth_date",
      gender: "gender",
      address: "address",
      emergency_contact: "emergency_contact",
      emergency_phone: "emergency_phone",
      medical_history: "medical_history",
      allergies: "allergies",
      medications: "medications",
      notes: "notes",
      google_review_link: "google_review_link",
      stripe_connect_id: "stripe_connect_id",
      accessGranted: "accessGranted"
    };
    exports.Prisma.AccountScalarFieldEnum = {
      id: "id",
      userId: "userId",
      type: "type",
      provider: "provider",
      providerAccountId: "providerAccountId",
      refresh_token: "refresh_token",
      access_token: "access_token",
      expires_at: "expires_at",
      token_type: "token_type",
      scope: "scope",
      id_token: "id_token",
      session_state: "session_state"
    };
    exports.Prisma.SessionScalarFieldEnum = {
      id: "id",
      sessionToken: "sessionToken",
      userId: "userId",
      expires: "expires"
    };
    exports.Prisma.VerificationTokenScalarFieldEnum = {
      identifier: "identifier",
      token: "token",
      expires: "expires"
    };
    exports.Prisma.VerificationCodeScalarFieldEnum = {
      id: "id",
      code: "code",
      user_id: "user_id",
      doctor_id: "doctor_id",
      type: "type",
      created_at: "created_at",
      expires_at: "expires_at",
      used_at: "used_at"
    };
    exports.Prisma.PatientProfileScalarFieldEnum = {
      id: "id",
      doctorId: "doctorId",
      userId: "userId",
      name: "name",
      phone: "phone",
      address: "address",
      emergency_contact: "emergency_contact",
      emergency_phone: "emergency_phone",
      medical_history: "medical_history",
      allergies: "allergies",
      medications: "medications",
      notes: "notes",
      isActive: "isActive",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      totalPoints: "totalPoints",
      currentPoints: "currentPoints"
    };
    exports.Prisma.PointsLedgerScalarFieldEnum = {
      id: "id",
      userId: "userId",
      patientProfileId: "patientProfileId",
      sourceType: "sourceType",
      sourceId: "sourceId",
      amount: "amount",
      description: "description",
      createdAt: "createdAt"
    };
    exports.Prisma.ClinicScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      ownerId: "ownerId",
      isActive: "isActive",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      email: "email",
      phone: "phone",
      address: "address",
      city: "city",
      state: "state",
      zipCode: "zipCode",
      country: "country",
      website: "website",
      logo: "logo",
      slug: "slug",
      subdomain: "subdomain",
      monthlyRevenueRange: "monthlyRevenueRange",
      currentGateway: "currentGateway",
      theme: "theme",
      buttonColor: "buttonColor",
      buttonTextColor: "buttonTextColor"
    };
    exports.Prisma.ClinicMemberScalarFieldEnum = {
      id: "id",
      clinicId: "clinicId",
      userId: "userId",
      role: "role",
      isActive: "isActive",
      joinedAt: "joinedAt"
    };
    exports.Prisma.MerchantScalarFieldEnum = {
      id: "id",
      clinicId: "clinicId",
      status: "status",
      recipientId: "recipientId",
      externalAccountId: "externalAccountId",
      onboardingState: "onboardingState",
      splitPercent: "splitPercent",
      platformFeeBps: "platformFeeBps",
      transactionFeeCents: "transactionFeeCents",
      transactionFeeType: "transactionFeeType",
      lastSyncAt: "lastSyncAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.MerchantApplicationScalarFieldEnum = {
      id: "id",
      clinicId: "clinicId",
      type: "type",
      businessName: "businessName",
      fullName: "fullName",
      documentNumber: "documentNumber",
      email: "email",
      phone: "phone",
      address: "address",
      bankAccount: "bankAccount",
      recipientId: "recipientId",
      status: "status",
      reviewNotes: "reviewNotes",
      reviewedBy: "reviewedBy",
      reviewedAt: "reviewedAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.MerchantDocumentScalarFieldEnum = {
      id: "id",
      applicationId: "applicationId",
      type: "type",
      fileUrl: "fileUrl",
      status: "status",
      notes: "notes",
      uploadedAt: "uploadedAt",
      reviewedAt: "reviewedAt"
    };
    exports.Prisma.MerchantIntegrationScalarFieldEnum = {
      id: "id",
      merchantId: "merchantId",
      provider: "provider",
      credentials: "credentials",
      config: "config",
      isActive: "isActive",
      isPrimary: "isPrimary",
      connectedAt: "connectedAt",
      lastUsedAt: "lastUsedAt",
      lastError: "lastError",
      lastErrorAt: "lastErrorAt"
    };
    exports.Prisma.PaymentRoutingRuleScalarFieldEnum = {
      id: "id",
      merchantId: "merchantId",
      productId: "productId",
      offerId: "offerId",
      country: "country",
      method: "method",
      provider: "provider",
      priority: "priority",
      isActive: "isActive",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.ClinicPlanScalarFieldEnum = {
      id: "id",
      name: "name",
      tier: "tier",
      description: "description",
      monthlyPrice: "monthlyPrice",
      monthlyTxLimit: "monthlyTxLimit",
      features: "features",
      trialDays: "trialDays",
      requireCard: "requireCard",
      isActive: "isActive",
      isPublic: "isPublic",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.ClinicAddOnScalarFieldEnum = {
      id: "id",
      type: "type",
      name: "name",
      description: "description",
      monthlyPrice: "monthlyPrice",
      quantity: "quantity",
      isActive: "isActive",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.ClinicSubscriptionScalarFieldEnum = {
      id: "id",
      clinicId: "clinicId",
      planId: "planId",
      status: "status",
      startDate: "startDate",
      trialEndsAt: "trialEndsAt",
      currentPeriodStart: "currentPeriodStart",
      currentPeriodEnd: "currentPeriodEnd",
      stripeCustomerId: "stripeCustomerId",
      stripeSubscriptionId: "stripeSubscriptionId",
      canceledAt: "canceledAt",
      cancelReason: "cancelReason",
      currentDoctorsCount: "currentDoctorsCount",
      currentPatientsCount: "currentPatientsCount",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.ClinicAddOnSubscriptionScalarFieldEnum = {
      id: "id",
      subscriptionId: "subscriptionId",
      addOnId: "addOnId",
      quantity: "quantity",
      startDate: "startDate",
      endDate: "endDate",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.ProductCategoryScalarFieldEnum = {
      id: "id",
      name: "name",
      slug: "slug",
      doctorId: "doctorId",
      isActive: "isActive",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.ProductScalarFieldEnum = {
      id: "id",
      name: "name",
      subtitle: "subtitle",
      description: "description",
      price: "price",
      creditsPerUnit: "creditsPerUnit",
      category: "category",
      isActive: "isActive",
      priority: "priority",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      doctorId: "doctorId",
      clinicId: "clinicId",
      imageUrl: "imageUrl",
      confirmationUrl: "confirmationUrl",
      categoryId: "categoryId",
      type: "type",
      interval: "interval",
      intervalCount: "intervalCount",
      trialDays: "trialDays",
      providerPlanId: "providerPlanId",
      providerPlanData: "providerPlanData",
      autoRenew: "autoRenew"
    };
    exports.Prisma.CategoriesOnProductsScalarFieldEnum = {
      productId: "productId",
      categoryId: "categoryId",
      assignedAt: "assignedAt"
    };
    exports.Prisma.OfferScalarFieldEnum = {
      id: "id",
      productId: "productId",
      name: "name",
      description: "description",
      currency: "currency",
      priceCents: "priceCents",
      preferredProvider: "preferredProvider",
      maxInstallments: "maxInstallments",
      installmentMinCents: "installmentMinCents",
      active: "active",
      isSubscription: "isSubscription",
      intervalCount: "intervalCount",
      intervalUnit: "intervalUnit",
      trialDays: "trialDays",
      checkoutUrl: "checkoutUrl",
      providerConfig: "providerConfig",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.OfferPriceScalarFieldEnum = {
      id: "id",
      offerId: "offerId",
      country: "country",
      currency: "currency",
      provider: "provider",
      amountCents: "amountCents",
      externalPriceId: "externalPriceId",
      active: "active",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.OfferPaymentMethodScalarFieldEnum = {
      id: "id",
      offerId: "offerId",
      method: "method",
      active: "active",
      feePercent: "feePercent"
    };
    exports.Prisma.ProductIntegrationScalarFieldEnum = {
      id: "id",
      productId: "productId",
      provider: "provider",
      externalProductId: "externalProductId",
      metadata: "metadata",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.CheckoutSessionScalarFieldEnum = {
      id: "id",
      resumeToken: "resumeToken",
      clinicId: "clinicId",
      productId: "productId",
      offerId: "offerId",
      slug: "slug",
      provider: "provider",
      country: "country",
      locale: "locale",
      status: "status",
      paymentMethod: "paymentMethod",
      orderId: "orderId",
      pixOrderId: "pixOrderId",
      pixExpiresAt: "pixExpiresAt",
      paymentTransactionId: "paymentTransactionId",
      email: "email",
      phone: "phone",
      document: "document",
      utmSource: "utmSource",
      utmMedium: "utmMedium",
      utmCampaign: "utmCampaign",
      utmTerm: "utmTerm",
      utmContent: "utmContent",
      referrer: "referrer",
      ip: "ip",
      userAgent: "userAgent",
      selectedInstallments: "selectedInstallments",
      selectedBank: "selectedBank",
      paymentMethodsAllowed: "paymentMethodsAllowed",
      metadata: "metadata",
      startedAt: "startedAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      lastHeartbeatAt: "lastHeartbeatAt",
      lastStep: "lastStep",
      reminders: "reminders",
      reminderExpiringSentAt: "reminderExpiringSentAt",
      reminderExpiredSentAt: "reminderExpiredSentAt",
      conversionLikelihood: "conversionLikelihood",
      origin: "origin",
      createdBy: "createdBy"
    };
    exports.Prisma.PaymentTransactionScalarFieldEnum = {
      id: "id",
      provider: "provider",
      providerOrderId: "providerOrderId",
      providerChargeId: "providerChargeId",
      doctorId: "doctorId",
      patientProfileId: "patientProfileId",
      clinicId: "clinicId",
      merchantId: "merchantId",
      productId: "productId",
      amountCents: "amountCents",
      currency: "currency",
      installments: "installments",
      paymentMethodType: "paymentMethodType",
      status: "status",
      status_v2: "status_v2",
      rawPayload: "rawPayload",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      paidAt: "paidAt",
      capturedAt: "capturedAt",
      refundStatus: "refundStatus",
      refundedAt: "refundedAt",
      routedProvider: "routedProvider",
      customerId: "customerId",
      customerProviderId: "customerProviderId",
      customerPaymentMethodId: "customerPaymentMethodId",
      customerSubscriptionId: "customerSubscriptionId",
      billingPeriodStart: "billingPeriodStart",
      billingPeriodEnd: "billingPeriodEnd",
      provider_v2: "provider_v2"
    };
    exports.Prisma.PurchaseScalarFieldEnum = {
      id: "id",
      userId: "userId",
      doctorId: "doctorId",
      productId: "productId",
      quantity: "quantity",
      unitPrice: "unitPrice",
      totalPrice: "totalPrice",
      pointsAwarded: "pointsAwarded",
      status: "status",
      externalIdempotencyKey: "externalIdempotencyKey",
      notes: "notes",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.CustomerScalarFieldEnum = {
      id: "id",
      merchantId: "merchantId",
      name: "name",
      email: "email",
      phone: "phone",
      document: "document",
      address: "address",
      metadata: "metadata",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.CustomerProviderScalarFieldEnum = {
      id: "id",
      customerId: "customerId",
      provider: "provider",
      accountId: "accountId",
      providerCustomerId: "providerCustomerId",
      metadata: "metadata",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.CustomerPaymentMethodScalarFieldEnum = {
      id: "id",
      customerId: "customerId",
      customerProviderId: "customerProviderId",
      provider: "provider",
      accountId: "accountId",
      providerPaymentMethodId: "providerPaymentMethodId",
      brand: "brand",
      last4: "last4",
      expMonth: "expMonth",
      expYear: "expYear",
      isDefault: "isDefault",
      status: "status",
      fingerprint: "fingerprint",
      metadata: "metadata",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.CustomerSubscriptionScalarFieldEnum = {
      id: "id",
      customerId: "customerId",
      merchantId: "merchantId",
      productId: "productId",
      offerId: "offerId",
      provider: "provider",
      accountId: "accountId",
      isNative: "isNative",
      customerProviderId: "customerProviderId",
      providerSubscriptionId: "providerSubscriptionId",
      vaultPaymentMethodId: "vaultPaymentMethodId",
      status: "status",
      startAt: "startAt",
      trialEndsAt: "trialEndsAt",
      currentPeriodStart: "currentPeriodStart",
      currentPeriodEnd: "currentPeriodEnd",
      cancelAt: "cancelAt",
      canceledAt: "canceledAt",
      priceCents: "priceCents",
      currency: "currency",
      metadata: "metadata",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.PaymentCustomerScalarFieldEnum = {
      id: "id",
      userId: "userId",
      clinicId: "clinicId",
      email: "email",
      document: "document",
      fullName: "fullName",
      phones: "phones",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.MessageTemplateScalarFieldEnum = {
      id: "id",
      doctorId: "doctorId",
      name: "name",
      channel: "channel",
      subject: "subject",
      html: "html",
      text: "text",
      mjml: "mjml",
      renderStrategy: "renderStrategy",
      fromName: "fromName",
      fromEmail: "fromEmail",
      replyTo: "replyTo",
      provider: "provider",
      waTemplateName: "waTemplateName",
      waLanguage: "waLanguage",
      waCategory: "waCategory",
      waComponents: "waComponents",
      waStatus: "waStatus",
      waProviderId: "waProviderId",
      isActive: "isActive",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      variablesSchema: "variablesSchema",
      sampleVariables: "sampleVariables",
      tags: "tags",
      smsMaxSegments: "smsMaxSegments"
    };
    exports.Prisma.MessageSequenceScalarFieldEnum = {
      id: "id",
      doctorId: "doctorId",
      name: "name",
      description: "description",
      isActive: "isActive",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.MessageSequenceStepScalarFieldEnum = {
      id: "id",
      sequenceId: "sequenceId",
      orderIndex: "orderIndex",
      delayAmount: "delayAmount",
      delayUnit: "delayUnit",
      templateId: "templateId",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.CampaignJobScalarFieldEnum = {
      id: "id",
      doctorId: "doctorId",
      campaignId: "campaignId",
      channel: "channel",
      trigger: "trigger",
      scheduleAt: "scheduleAt",
      createdAt: "createdAt",
      status: "status",
      lastError: "lastError"
    };
    exports.Prisma.OpenFinanceLinkScalarFieldEnum = {
      id: "id",
      userId: "userId",
      clinicId: "clinicId",
      organisationId: "organisationId",
      authorisationServerId: "authorisationServerId",
      enrollmentId: "enrollmentId",
      status: "status",
      deviceBinding: "deviceBinding",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.OpenFinanceConsentScalarFieldEnum = {
      id: "id",
      linkId: "linkId",
      consentId: "consentId",
      contractId: "contractId",
      status: "status",
      amountCents: "amountCents",
      periodicity: "periodicity",
      nextExecutionAt: "nextExecutionAt",
      metadata: "metadata",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.OpenBankingPaymentScalarFieldEnum = {
      id: "id",
      providerPaymentId: "providerPaymentId",
      consentId: "consentId",
      amountCents: "amountCents",
      currency: "currency",
      status: "status",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      enrollmentId: "enrollmentId",
      transactionIdentification: "transactionIdentification",
      payerId: "payerId",
      payerDocument: "payerDocument",
      payerEmail: "payerEmail",
      payerName: "payerName",
      creditorName: "creditorName",
      creditorCpfCnpj: "creditorCpfCnpj",
      clinicId: "clinicId",
      productId: "productId",
      purchaseId: "purchaseId",
      type: "type",
      executedAt: "executedAt",
      settledAt: "settledAt",
      recurrenceType: "recurrenceType",
      subscriptionId: "subscriptionId",
      executionOrder: "executionOrder",
      providerResponse: "providerResponse",
      fidoAssertion: "fidoAssertion",
      riskSignals: "riskSignals",
      paymentLinkId: "paymentLinkId",
      userId: "userId",
      orderRef: "orderRef",
      redirectUri: "redirectUri",
      transactionId: "transactionId",
      expiresAt: "expiresAt",
      metadata: "metadata"
    };
    exports.Prisma.OpenBankingConsentScalarFieldEnum = {
      id: "id",
      enrollmentId: "enrollmentId",
      consentId: "consentId",
      amountCents: "amountCents",
      currency: "currency",
      creditorName: "creditorName",
      creditorCpfCnpj: "creditorCpfCnpj",
      productId: "productId",
      clinicId: "clinicId",
      status: "status",
      providerResponse: "providerResponse",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.EnrollmentContextScalarFieldEnum = {
      id: "id",
      userId: "userId",
      sessionId: "sessionId",
      enrollmentId: "enrollmentId",
      organisationId: "organisationId",
      authorisationServerId: "authorisationServerId",
      fallbackUsed: "fallbackUsed",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      status: "status",
      deviceRegistered: "deviceRegistered",
      expiresAt: "expiresAt",
      clinicId: "clinicId",
      payerEmail: "payerEmail",
      payerDocument: "payerDocument",
      payerName: "payerName",
      recurringEnabled: "recurringEnabled",
      deviceBinding: "deviceBinding",
      providerResponse: "providerResponse"
    };
    exports.Prisma.PaymentConsentScalarFieldEnum = {
      id: "id",
      tenantId: "tenantId",
      consentId: "consentId",
      status: "status",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.OAuthStateScalarFieldEnum = {
      id: "id",
      state: "state",
      nonce: "nonce",
      codeVerifier: "codeVerifier",
      tenantId: "tenantId",
      createdAt: "createdAt",
      usedAt: "usedAt"
    };
    exports.Prisma.OAuthStateMetaScalarFieldEnum = {
      state: "state",
      organisationId: "organisationId",
      authorisationServerId: "authorisationServerId",
      createdAt: "createdAt",
      productId: "productId",
      amountCents: "amountCents",
      currency: "currency",
      orderRef: "orderRef"
    };
    exports.Prisma.OAuthTokenScalarFieldEnum = {
      id: "id",
      tenantId: "tenantId",
      provider: "provider",
      accessToken: "accessToken",
      refreshToken: "refreshToken",
      scope: "scope",
      expiresAt: "expiresAt",
      createdAt: "createdAt"
    };
    exports.Prisma.EventScalarFieldEnum = {
      id: "id",
      eventId: "eventId",
      eventType: "eventType",
      customerId: "customerId",
      clinicId: "clinicId",
      actor: "actor",
      timestamp: "timestamp",
      metadata: "metadata",
      createdAt: "createdAt"
    };
    exports.Prisma.WebhookEventScalarFieldEnum = {
      id: "id",
      provider: "provider",
      hook_id: "hook_id",
      type: "type",
      resource_order_id: "resource_order_id",
      resource_charge_id: "resource_charge_id",
      status: "status",
      received_at: "received_at",
      processed_at: "processed_at",
      attempts: "attempts",
      raw: "raw",
      provider_event_id: "provider_event_id",
      processed: "processed",
      processing_error: "processing_error",
      retry_count: "retry_count",
      max_retries: "max_retries",
      next_retry_at: "next_retry_at",
      last_retry_at: "last_retry_at",
      error_type: "error_type",
      is_retryable: "is_retryable",
      moved_dead_letter: "moved_dead_letter",
      dead_letter_reason: "dead_letter_reason"
    };
    exports.Prisma.SortOrder = {
      asc: "asc",
      desc: "desc"
    };
    exports.Prisma.NullableJsonNullValueInput = {
      DbNull: Prisma.DbNull,
      JsonNull: Prisma.JsonNull
    };
    exports.Prisma.JsonNullValueInput = {
      JsonNull: Prisma.JsonNull
    };
    exports.Prisma.QueryMode = {
      default: "default",
      insensitive: "insensitive"
    };
    exports.Prisma.NullsOrder = {
      first: "first",
      last: "last"
    };
    exports.Prisma.JsonNullValueFilter = {
      DbNull: Prisma.DbNull,
      JsonNull: Prisma.JsonNull,
      AnyNull: Prisma.AnyNull
    };
    exports.ClinicRole = exports.$Enums.ClinicRole = {
      OWNER: "OWNER",
      MANAGER: "MANAGER",
      PROVIDER: "PROVIDER",
      STAFF: "STAFF"
    };
    exports.ClinicTheme = exports.$Enums.ClinicTheme = {
      LIGHT: "LIGHT",
      DARK: "DARK"
    };
    exports.MerchantStatus = exports.$Enums.MerchantStatus = {
      PENDING: "PENDING",
      ACTIVE: "ACTIVE",
      REJECTED: "REJECTED",
      DISABLED: "DISABLED"
    };
    exports.MerchantType = exports.$Enums.MerchantType = {
      INDIVIDUAL: "INDIVIDUAL",
      COMPANY: "COMPANY"
    };
    exports.MerchantAppStatus = exports.$Enums.MerchantAppStatus = {
      DRAFT: "DRAFT",
      PENDING_DOCUMENTS: "PENDING_DOCUMENTS",
      UNDER_REVIEW: "UNDER_REVIEW",
      APPROVED: "APPROVED",
      REJECTED: "REJECTED"
    };
    exports.DocumentType = exports.$Enums.DocumentType = {
      ID_FRONT: "ID_FRONT",
      ID_BACK: "ID_BACK",
      SELFIE: "SELFIE",
      CNPJ_CARD: "CNPJ_CARD",
      ADDRESS_PROOF: "ADDRESS_PROOF",
      CONTRACT_SOCIAL: "CONTRACT_SOCIAL",
      BANK_STATEMENT: "BANK_STATEMENT",
      OTHER: "OTHER"
    };
    exports.DocumentStatus = exports.$Enums.DocumentStatus = {
      PENDING: "PENDING",
      APPROVED: "APPROVED",
      REJECTED: "REJECTED"
    };
    exports.SubscriptionStatus = exports.$Enums.SubscriptionStatus = {
      TRIAL: "TRIAL",
      PENDING: "PENDING",
      ACTIVE: "ACTIVE",
      PAST_DUE: "PAST_DUE",
      CANCELED: "CANCELED",
      EXPIRED: "EXPIRED"
    };
    exports.PlanTier = exports.$Enums.PlanTier = {
      STARTER: "STARTER",
      GROWTH: "GROWTH",
      ENTERPRISE: "ENTERPRISE"
    };
    exports.AddOnType = exports.$Enums.AddOnType = {
      EXTRA_DOCTOR: "EXTRA_DOCTOR",
      EXTRA_PATIENTS: "EXTRA_PATIENTS",
      ADVANCED_REPORTS: "ADVANCED_REPORTS",
      CUSTOM_BRANDING: "CUSTOM_BRANDING",
      WHITE_LABEL: "WHITE_LABEL",
      API_ACCESS: "API_ACCESS"
    };
    exports.ProductType = exports.$Enums.ProductType = {
      PRODUCT: "PRODUCT",
      SUBSCRIPTION: "SUBSCRIPTION"
    };
    exports.SubscriptionInterval = exports.$Enums.SubscriptionInterval = {
      DAY: "DAY",
      WEEK: "WEEK",
      MONTH: "MONTH",
      YEAR: "YEAR"
    };
    exports.Currency = exports.$Enums.Currency = {
      BRL: "BRL",
      USD: "USD",
      EUR: "EUR",
      MXN: "MXN"
    };
    exports.PaymentMethod = exports.$Enums.PaymentMethod = {
      CARD: "CARD",
      PIX: "PIX",
      BOLETO: "BOLETO",
      PAYPAL: "PAYPAL",
      OPEN_FINANCE: "OPEN_FINANCE",
      OPEN_FINANCE_AUTOMATIC: "OPEN_FINANCE_AUTOMATIC"
    };
    exports.PaymentProvider = exports.$Enums.PaymentProvider = {
      KRXPAY: "KRXPAY",
      STRIPE: "STRIPE",
      ADYEN: "ADYEN",
      APPMAX: "APPMAX",
      PAYPAL: "PAYPAL",
      MERCADOPAGO: "MERCADOPAGO",
      PAGARME: "PAGARME",
      OPENFINANCE: "OPENFINANCE"
    };
    exports.PaymentStatus = exports.$Enums.PaymentStatus = {
      PENDING: "PENDING",
      PROCESSING: "PROCESSING",
      REQUIRES_ACTION: "REQUIRES_ACTION",
      SUCCEEDED: "SUCCEEDED",
      FAILED: "FAILED",
      CANCELED: "CANCELED",
      EXPIRED: "EXPIRED",
      REFUNDING: "REFUNDING",
      REFUNDED: "REFUNDED",
      PARTIALLY_REFUNDED: "PARTIALLY_REFUNDED",
      CHARGEBACK: "CHARGEBACK",
      DISPUTED: "DISPUTED"
    };
    exports.CheckoutSessionStatus = exports.$Enums.CheckoutSessionStatus = {
      started: "started",
      pix_generated: "pix_generated",
      paid: "paid",
      abandoned: "abandoned",
      canceled: "canceled"
    };
    exports.CheckoutPaymentMethod = exports.$Enums.CheckoutPaymentMethod = {
      pix: "pix",
      card: "card",
      pix_ob: "pix_ob",
      unknown: "unknown"
    };
    exports.PaymentTypeOB = exports.$Enums.PaymentTypeOB = {
      SINGLE: "SINGLE",
      RECURRING: "RECURRING"
    };
    exports.PaymentStatusOB = exports.$Enums.PaymentStatusOB = {
      PENDING: "PENDING",
      PROCESSING: "PROCESSING",
      COMPLETED: "COMPLETED",
      REJECTED: "REJECTED",
      CANCELLED: "CANCELLED",
      EXPIRED: "EXPIRED",
      ACCP: "ACCP",
      PAGO: "PAGO",
      RJCT: "RJCT",
      CANC: "CANC"
    };
    exports.EnrollmentStatusOB = exports.$Enums.EnrollmentStatusOB = {
      PENDING: "PENDING",
      AUTHORISED: "AUTHORISED",
      REJECTED: "REJECTED",
      REVOKED: "REVOKED",
      EXPIRED: "EXPIRED"
    };
    exports.ConsentStatusOB = exports.$Enums.ConsentStatusOB = {
      AWAITING_AUTHORISATION: "AWAITING_AUTHORISATION",
      AUTHORISED: "AUTHORISED",
      REJECTED: "REJECTED",
      CONSUMED: "CONSUMED",
      EXPIRED: "EXPIRED"
    };
    exports.EventType = exports.$Enums.EventType = {
      customer_created: "customer_created",
      customer_updated: "customer_updated",
      customer_visit: "customer_visit",
      lead_created: "lead_created",
      lead_converted: "lead_converted",
      review_submitted: "review_submitted",
      feedback_negative: "feedback_negative",
      purchase_made: "purchase_made",
      purchase_refund: "purchase_refund",
      payment_processed: "payment_processed",
      subscription_billed: "subscription_billed",
      subscription_canceled: "subscription_canceled",
      chargeback_reported: "chargeback_reported",
      reward_created: "reward_created",
      reward_offered: "reward_offered",
      reward_viewed: "reward_viewed",
      reward_claimed: "reward_claimed",
      reward_redeemed: "reward_redeemed",
      reward_expired: "reward_expired",
      points_earned: "points_earned",
      points_spent: "points_spent",
      campaign_sent: "campaign_sent",
      campaign_opened: "campaign_opened",
      campaign_clicked: "campaign_clicked",
      campaign_replied: "campaign_replied",
      conversation_started: "conversation_started",
      conversation_closed: "conversation_closed",
      membership_started: "membership_started",
      membership_renewed: "membership_renewed",
      membership_canceled: "membership_canceled",
      membership_upgraded: "membership_upgraded",
      prediction_made: "prediction_made",
      action_taken: "action_taken",
      outcome_recorded: "outcome_recorded",
      user_logged_in: "user_logged_in",
      config_changed: "config_changed",
      integration_added: "integration_added"
    };
    exports.EventActor = exports.$Enums.EventActor = {
      customer: "customer",
      clinic: "clinic",
      system: "system",
      ai: "ai"
    };
    exports.Prisma.ModelName = {
      User: "User",
      Account: "Account",
      Session: "Session",
      VerificationToken: "VerificationToken",
      VerificationCode: "VerificationCode",
      PatientProfile: "PatientProfile",
      PointsLedger: "PointsLedger",
      Clinic: "Clinic",
      ClinicMember: "ClinicMember",
      Merchant: "Merchant",
      MerchantApplication: "MerchantApplication",
      MerchantDocument: "MerchantDocument",
      MerchantIntegration: "MerchantIntegration",
      PaymentRoutingRule: "PaymentRoutingRule",
      ClinicPlan: "ClinicPlan",
      ClinicAddOn: "ClinicAddOn",
      ClinicSubscription: "ClinicSubscription",
      ClinicAddOnSubscription: "ClinicAddOnSubscription",
      ProductCategory: "ProductCategory",
      Product: "Product",
      CategoriesOnProducts: "CategoriesOnProducts",
      Offer: "Offer",
      OfferPrice: "OfferPrice",
      OfferPaymentMethod: "OfferPaymentMethod",
      ProductIntegration: "ProductIntegration",
      CheckoutSession: "CheckoutSession",
      PaymentTransaction: "PaymentTransaction",
      Purchase: "Purchase",
      Customer: "Customer",
      CustomerProvider: "CustomerProvider",
      CustomerPaymentMethod: "CustomerPaymentMethod",
      CustomerSubscription: "CustomerSubscription",
      PaymentCustomer: "PaymentCustomer",
      MessageTemplate: "MessageTemplate",
      MessageSequence: "MessageSequence",
      MessageSequenceStep: "MessageSequenceStep",
      CampaignJob: "CampaignJob",
      OpenFinanceLink: "OpenFinanceLink",
      OpenFinanceConsent: "OpenFinanceConsent",
      OpenBankingPayment: "OpenBankingPayment",
      OpenBankingConsent: "OpenBankingConsent",
      EnrollmentContext: "EnrollmentContext",
      PaymentConsent: "PaymentConsent",
      OAuthState: "OAuthState",
      OAuthStateMeta: "OAuthStateMeta",
      OAuthToken: "OAuthToken",
      Event: "Event",
      WebhookEvent: "WebhookEvent"
    };
    var config = {
      "generator": {
        "name": "client",
        "provider": {
          "fromEnvVar": null,
          "value": "prisma-client-js"
        },
        "output": {
          "value": "/Users/albertalves/krxscale-saas/node_modules/@prisma/client",
          "fromEnvVar": null
        },
        "config": {
          "engineType": "binary"
        },
        "binaryTargets": [
          {
            "fromEnvVar": null,
            "value": "darwin-arm64",
            "native": true
          },
          {
            "fromEnvVar": null,
            "value": "debian-openssl-3.0.x"
          }
        ],
        "previewFeatures": [],
        "sourceFilePath": "/Users/albertalves/krxscale-saas/prisma/schema.prisma"
      },
      "relativeEnvPaths": {
        "rootEnvPath": null,
        "schemaEnvPath": "../../../.env"
      },
      "relativePath": "../../../prisma",
      "clientVersion": "6.19.0",
      "engineVersion": "2ba551f319ab1df4bc874a89965d8b3641056773",
      "datasourceNames": [
        "db"
      ],
      "activeProvider": "postgresql",
      "postinstall": false,
      "inlineDatasources": {
        "db": {
          "url": {
            "fromEnvVar": "DATABASE_URL",
            "value": null
          }
        }
      },
      "inlineSchema": '// -----------------------------------------------------------------------------\n// 1. CONFIGURAO E DATASOURCE\n// -----------------------------------------------------------------------------\n\ngenerator client {\n  provider      = "prisma-client-js"\n  engineType    = "binary"\n  binaryTargets = ["native", "debian-openssl-3.0.x"]\n}\n\ndatasource db {\n  provider = "postgresql"\n  url      = env("DATABASE_URL")\n}\n\n// -----------------------------------------------------------------------------\n// 2. ENUMS (TIPOS)\n// -----------------------------------------------------------------------------\n\n// --- Enums de Usurio e Clnica ---\nenum ClinicRole {\n  OWNER\n  MANAGER\n  PROVIDER\n  STAFF\n}\n\nenum ClinicTheme {\n  LIGHT\n  DARK\n}\n\nenum MerchantStatus {\n  PENDING\n  ACTIVE\n  REJECTED\n  DISABLED\n}\n\nenum MerchantType {\n  INDIVIDUAL\n  COMPANY\n}\n\nenum MerchantAppStatus {\n  DRAFT\n  PENDING_DOCUMENTS\n  UNDER_REVIEW\n  APPROVED\n  REJECTED\n}\n\nenum DocumentType {\n  ID_FRONT\n  ID_BACK\n  SELFIE\n  CNPJ_CARD\n  ADDRESS_PROOF\n  CONTRACT_SOCIAL\n  BANK_STATEMENT\n  OTHER\n}\n\nenum DocumentStatus {\n  PENDING\n  APPROVED\n  REJECTED\n}\n\n// --- Enums de Assinatura e Planos ---\nenum SubscriptionStatus {\n  TRIAL\n  PENDING\n  ACTIVE\n  PAST_DUE\n  CANCELED\n  EXPIRED\n\n  @@map("SubscriptionStatus")\n}\n\nenum PlanTier {\n  STARTER\n  GROWTH\n  ENTERPRISE\n}\n\nenum AddOnType {\n  EXTRA_DOCTOR\n  EXTRA_PATIENTS\n  ADVANCED_REPORTS\n  CUSTOM_BRANDING\n  WHITE_LABEL\n  API_ACCESS\n}\n\n// --- Enums de Pagamento e Vendas ---\nenum ProductType {\n  PRODUCT\n  SUBSCRIPTION\n}\n\nenum SubscriptionInterval {\n  DAY\n  WEEK\n  MONTH\n  YEAR\n}\n\nenum Currency {\n  BRL\n  USD\n  EUR\n  MXN\n}\n\nenum PaymentMethod {\n  CARD\n  PIX\n  BOLETO\n  PAYPAL\n  OPEN_FINANCE\n  OPEN_FINANCE_AUTOMATIC\n}\n\nenum PaymentProvider {\n  KRXPAY\n  STRIPE\n  ADYEN\n  APPMAX\n  PAYPAL\n  MERCADOPAGO\n  PAGARME\n  OPENFINANCE\n}\n\nenum PaymentStatus {\n  PENDING\n  PROCESSING\n  REQUIRES_ACTION\n  SUCCEEDED\n  FAILED\n  CANCELED\n  EXPIRED\n  REFUNDING\n  REFUNDED\n  PARTIALLY_REFUNDED\n  CHARGEBACK\n  DISPUTED\n}\n\n// --- Enums de Checkout e Open Finance ---\nenum CheckoutSessionStatus {\n  started\n  pix_generated\n  paid\n  abandoned\n  canceled\n}\n\nenum CheckoutPaymentMethod {\n  pix\n  card\n  pix_ob\n  unknown\n}\n\nenum PaymentTypeOB {\n  SINGLE\n  RECURRING\n}\n\nenum PaymentStatusOB {\n  PENDING\n  PROCESSING\n  COMPLETED\n  REJECTED\n  CANCELLED\n  EXPIRED\n  ACCP\n  PAGO\n  RJCT\n  CANC\n}\n\nenum EnrollmentStatusOB {\n  PENDING\n  AUTHORISED\n  REJECTED\n  REVOKED\n  EXPIRED\n}\n\nenum ConsentStatusOB {\n  AWAITING_AUTHORISATION\n  AUTHORISED\n  REJECTED\n  CONSUMED\n  EXPIRED\n}\n\n// --- Enums de Eventos ---\nenum EventType {\n  customer_created\n  customer_updated\n  customer_visit\n  lead_created\n  lead_converted\n  review_submitted\n  feedback_negative\n  purchase_made\n  purchase_refund\n  payment_processed\n  subscription_billed\n  subscription_canceled\n  chargeback_reported\n  reward_created\n  reward_offered\n  reward_viewed\n  reward_claimed\n  reward_redeemed\n  reward_expired\n  points_earned\n  points_spent\n  campaign_sent\n  campaign_opened\n  campaign_clicked\n  campaign_replied\n  conversation_started\n  conversation_closed\n  membership_started\n  membership_renewed\n  membership_canceled\n  membership_upgraded\n  prediction_made\n  action_taken\n  outcome_recorded\n  user_logged_in\n  config_changed\n  integration_added\n}\n\nenum EventActor {\n  customer\n  clinic\n  system\n  ai\n\n  @@map("event_actor_enum")\n}\n\n// -----------------------------------------------------------------------------\n// 3. AUTENTICAO E USURIOS\n// -----------------------------------------------------------------------------\n\nmodel User {\n  id                       String    @id\n  email                    String    @unique\n  name                     String?\n  image                    String?\n  public_cover_image_url   String?\n  public_page_template     String?   @ignore\n  doctor_slug              String?   @unique\n  role                     String    @default("PATIENT")\n  is_active                Boolean   @default(true)\n  created_at               DateTime  @default(now())\n  updated_at               DateTime  @default(now()) @updatedAt\n  email_verified           DateTime?\n  password                 String?\n  reset_token              String?\n  reset_token_expiry       DateTime?\n  verification_code        String?\n  verification_code_expiry DateTime?\n  doctor_id                String?\n  referral_code            String?   @unique\n  phone                    String?\n  birth_date               DateTime? @db.Date\n  gender                   String?\n  address                  String?\n  emergency_contact        String?\n  emergency_phone          String?\n  medical_history          String?\n  allergies                String?\n  medications              String?\n  notes                    String?\n  google_review_link       String?\n  stripe_connect_id        String?\n  accessGranted            Boolean   @default(false) @map("access_granted")\n\n  // Auth Relations\n  accounts Account[]\n  sessions Session[]\n\n  // User-to-User Relations\n  User        User?  @relation("UserToUser", fields: [doctor_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n  other_users User[] @relation("UserToUser")\n\n  // Clinic Relations\n  clinic_memberships ClinicMember[]\n  owned_clinics      Clinic[]       @relation("ClinicOwner")\n\n  // Product & Category Relations\n  created_products   Product[]         @relation("DoctorProducts")\n  created_categories ProductCategory[] @relation("DoctorCategories")\n\n  // Verification Relations\n  user_verification_codes   VerificationCode[] @relation("UserVerificationCodes")\n  doctor_verification_codes VerificationCode[] @relation("DoctorVerificationCodes")\n\n  // Purchase & Points Relations\n  purchases       Purchase[]     @relation("UserPurchases")\n  doctorPurchases Purchase[]     @relation("DoctorPurchases")\n  pointsLedger    PointsLedger[] @relation("UserPointsLedger")\n\n  // Profile Relations\n  doctor_profiles  PatientProfile[] @relation("ProfileDoctor")\n  patient_profiles PatientProfile[] @relation("ProfilePatient")\n\n  // Messaging Relations\n  message_templates MessageTemplate[] @relation("DoctorMessageTemplates")\n  message_sequences MessageSequence[] @relation("DoctorMessageSequences")\n}\n\nmodel Account {\n  id                String  @id @default(cuid())\n  userId            String\n  type              String\n  provider          String\n  providerAccountId String\n  refresh_token     String?\n  access_token      String?\n  expires_at        Int?\n  token_type        String?\n  scope             String?\n  id_token          String?\n  session_state     String?\n  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([provider, providerAccountId])\n}\n\nmodel Session {\n  id           String   @id @default(cuid())\n  sessionToken String   @unique\n  userId       String\n  expires      DateTime\n  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\nmodel VerificationToken {\n  identifier String\n  token      String   @unique\n  expires    DateTime\n\n  @@unique([identifier, token])\n}\n\nmodel VerificationCode {\n  id         String    @id @default(cuid())\n  code       String\n  user_id    String\n  doctor_id  String\n  type       String\n  created_at DateTime  @default(now())\n  expires_at DateTime\n  used_at    DateTime?\n\n  user   User @relation("UserVerificationCodes", fields: [user_id], references: [id], onDelete: Cascade)\n  doctor User @relation("DoctorVerificationCodes", fields: [doctor_id], references: [id], onDelete: Cascade)\n}\n\nmodel PatientProfile {\n  id                String   @id @default(cuid())\n  doctorId          String   @map("doctor_id")\n  userId            String   @map("user_id")\n  // Tenant-scoped profile fields\n  name              String?\n  phone             String?\n  address           String?\n  emergency_contact String?\n  emergency_phone   String?\n  medical_history   String?\n  allergies         String?\n  medications       String?\n  notes             String?\n  isActive          Boolean  @default(true) @map("is_active")\n  createdAt         DateTime @default(now()) @map("created_at")\n  updatedAt         DateTime @updatedAt @map("updated_at")\n\n  // Membership snapshots\n  totalPoints   Int @default(0) @map("total_points")\n  currentPoints Int @default(0) @map("current_points")\n\n  doctor       User           @relation("ProfileDoctor", fields: [doctorId], references: [id], onDelete: Cascade)\n  patient      User           @relation("ProfilePatient", fields: [userId], references: [id], onDelete: Cascade)\n  pointsLedger PointsLedger[]\n\n  @@unique([doctorId, userId])\n  @@index([doctorId])\n  @@index([userId])\n  @@map("patient_profiles")\n}\n\nmodel PointsLedger {\n  id               String   @id @default(cuid())\n  userId           String\n  patientProfileId String?  @map("patient_profile_id")\n  sourceType       String\n  sourceId         String\n  amount           Decimal  @db.Decimal(10, 2)\n  description      String?\n  createdAt        DateTime @default(now())\n\n  user           User            @relation("UserPointsLedger", fields: [userId], references: [id], onDelete: Cascade)\n  patientProfile PatientProfile? @relation(fields: [patientProfileId], references: [id])\n\n  @@index([userId])\n  @@index([patientProfileId])\n  @@index([sourceType])\n  @@index([sourceId])\n  @@index([createdAt])\n  @@map("points_ledger")\n}\n\n// -----------------------------------------------------------------------------\n// 4. CLNICAS E MERCHANTS\n// -----------------------------------------------------------------------------\n\nmodel Clinic {\n  id          String   @id @default(cuid())\n  name        String\n  description String?\n  ownerId     String\n  isActive    Boolean  @default(true)\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @default(now()) @updatedAt\n  email       String?\n  phone       String?\n  address     String?\n  city        String?\n  state       String?\n  zipCode     String?\n  country     String?\n  website     String?\n  logo        String?\n  slug        String?  @unique @db.VarChar(255)\n  subdomain   String?  @unique @db.VarChar(255)\n\n  // Business metadata\n  monthlyRevenueRange String? @map("monthly_revenue_range")\n  currentGateway      String? @map("current_gateway")\n\n  // Branding / Theming\n  theme           ClinicTheme @default(LIGHT)\n  buttonColor     String?\n  buttonTextColor String?\n\n  // Relations\n  members             ClinicMember[]\n  owner               User                 @relation("ClinicOwner", fields: [ownerId], references: [id])\n  subscriptions       ClinicSubscription[]\n  products            Product[]\n  merchant            Merchant?\n  merchantApplication MerchantApplication?\n\n  @@index([ownerId])\n  @@index([slug])\n  @@map("clinics")\n}\n\nmodel ClinicMember {\n  id       String     @id @default(cuid())\n  clinicId String\n  userId   String\n  role     ClinicRole @default(STAFF)\n  isActive Boolean    @default(true)\n  joinedAt DateTime   @default(now())\n  clinic   Clinic     @relation(fields: [clinicId], references: [id], onDelete: Cascade)\n  user     User       @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([clinicId, userId])\n  @@index([role])\n  @@map("clinic_members")\n}\n\nmodel Merchant {\n  id                  String         @id @default(cuid())\n  clinicId            String         @unique @map("clinic_id")\n  status              MerchantStatus @default(PENDING)\n  recipientId         String?        @map("recipient_id")\n  externalAccountId   String?        @map("external_account_id")\n  onboardingState     Json?          @map("onboarding_state")\n  splitPercent        Int            @default(100) @map("split_percent")\n  platformFeeBps      Int            @default(0) @map("platform_fee_bps")\n  transactionFeeCents Int?           @default(0) @map("transaction_fee_cents")\n  transactionFeeType  String?        @default("flat") @map("transaction_fee_type")\n  lastSyncAt          DateTime?      @map("last_sync_at")\n  createdAt           DateTime       @default(now()) @map("created_at")\n  updatedAt           DateTime       @default(now()) @updatedAt @map("updated_at")\n\n  clinic       Clinic                @relation(fields: [clinicId], references: [id], onDelete: Cascade)\n  integrations MerchantIntegration[]\n\n  @@map("merchants")\n}\n\nmodel MerchantApplication {\n  id             String            @id @default(cuid())\n  clinicId       String            @unique @map("clinic_id")\n  type           MerchantType      @default(INDIVIDUAL)\n  businessName   String?\n  fullName       String?\n  documentNumber String?\n  email          String?\n  phone          String?\n  address        Json?\n  bankAccount    Json?\n  recipientId    String?           @map("recipient_id")\n  status         MerchantAppStatus @default(DRAFT)\n  reviewNotes    String?\n  reviewedBy     String?\n  reviewedAt     DateTime?\n  createdAt      DateTime          @default(now())\n  updatedAt      DateTime          @updatedAt\n\n  clinic    Clinic             @relation(fields: [clinicId], references: [id], onDelete: Cascade)\n  documents MerchantDocument[]\n\n  @@map("merchant_applications")\n}\n\nmodel MerchantDocument {\n  id            String         @id @default(cuid())\n  applicationId String         @map("application_id")\n  type          DocumentType\n  fileUrl       String         @map("file_url")\n  status        DocumentStatus @default(PENDING)\n  notes         String?\n  uploadedAt    DateTime       @default(now()) @map("uploaded_at")\n  reviewedAt    DateTime?      @map("reviewed_at")\n\n  application MerchantApplication @relation(fields: [applicationId], references: [id], onDelete: Cascade)\n\n  @@index([applicationId])\n  @@map("merchant_documents")\n}\n\nmodel MerchantIntegration {\n  id          String          @id @default(cuid())\n  merchantId  String          @map("merchant_id")\n  provider    PaymentProvider\n  credentials Json\n  config      Json?\n  isActive    Boolean         @default(true) @map("is_active")\n  isPrimary   Boolean         @default(false) @map("is_primary")\n  connectedAt DateTime        @default(now()) @map("connected_at")\n  lastUsedAt  DateTime?       @map("last_used_at")\n  lastError   String?         @map("last_error")\n  lastErrorAt DateTime?       @map("last_error_at")\n\n  merchant Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)\n\n  @@unique([merchantId, provider])\n  @@index([merchantId, isActive])\n  @@index([provider, isActive])\n  @@map("merchant_integrations")\n}\n\nmodel PaymentRoutingRule {\n  id         String          @id @default(cuid())\n  merchantId String          @map("merchant_id")\n  productId  String?         @map("product_id")\n  offerId    String?         @map("offer_id")\n  country    String?         @db.VarChar(2)\n  method     PaymentMethod?\n  provider   PaymentProvider\n  priority   Int             @default(100)\n  isActive   Boolean         @default(true) @map("is_active")\n  createdAt  DateTime        @default(now()) @map("created_at")\n  updatedAt  DateTime        @updatedAt @map("updated_at")\n\n  @@index([merchantId, isActive, priority])\n  @@index([merchantId, country, method])\n  @@index([productId])\n  @@index([offerId])\n  @@map("payment_routing_rules")\n}\n\n// -----------------------------------------------------------------------------\n// 5. ASSINATURAS DA CLNICA (SAAS)\n// -----------------------------------------------------------------------------\n\nmodel ClinicPlan {\n  id             String   @id @default(cuid())\n  name           String\n  tier           PlanTier\n  description    String?\n  monthlyPrice   Decimal  @map("monthly_price") @db.Decimal(10, 2)\n  monthlyTxLimit Int      @default(1000) @map("monthly_tx_limit")\n  features       Json     @default("{}")\n  trialDays      Int      @default(30) @map("trial_days")\n  requireCard    Boolean  @default(false) @map("require_card")\n  isActive       Boolean  @default(true) @map("is_active")\n  isPublic       Boolean  @default(true) @map("is_public")\n  createdAt      DateTime @default(now()) @map("created_at")\n  updatedAt      DateTime @updatedAt @map("updated_at")\n\n  subscriptions ClinicSubscription[]\n\n  @@index([tier])\n  @@index([isActive])\n  @@map("clinic_plans")\n}\n\nmodel ClinicAddOn {\n  id           String    @id @default(cuid())\n  type         AddOnType\n  name         String\n  description  String?\n  monthlyPrice Decimal   @map("monthly_price") @db.Decimal(10, 2)\n  quantity     Int\n  isActive     Boolean   @default(true)\n  createdAt    DateTime  @default(now())\n  updatedAt    DateTime  @updatedAt\n\n  subscriptions ClinicAddOnSubscription[]\n\n  @@index([type])\n  @@index([isActive])\n  @@map("clinic_add_ons")\n}\n\nmodel ClinicSubscription {\n  id                   String             @id @default(cuid()) @map("id")\n  clinicId             String             @map("clinic_id")\n  planId               String             @map("plan_id")\n  status               SubscriptionStatus @default(TRIAL) @map("status")\n  startDate            DateTime           @default(now()) @map("start_date")\n  trialEndsAt          DateTime           @map("trial_ends_at")\n  currentPeriodStart   DateTime           @default(now()) @map("current_period_start")\n  currentPeriodEnd     DateTime           @map("current_period_end")\n  stripeCustomerId     String?            @map("stripe_customer_id")\n  stripeSubscriptionId String?            @map("stripe_subscription_id")\n  canceledAt           DateTime?          @map("canceled_at")\n  cancelReason         String?            @map("cancel_reason")\n  currentDoctorsCount  Int                @default(0) @map("current_doctors_count")\n  currentPatientsCount Int                @default(0) @map("current_patients_count")\n  createdAt            DateTime           @default(now()) @map("created_at")\n  updatedAt            DateTime           @updatedAt @map("updated_at")\n\n  clinic Clinic                    @relation(fields: [clinicId], references: [id])\n  plan   ClinicPlan                @relation(fields: [planId], references: [id])\n  addOns ClinicAddOnSubscription[]\n\n  @@index([clinicId])\n  @@index([status])\n  @@map("clinic_subscriptions")\n}\n\nmodel ClinicAddOnSubscription {\n  id             String    @id @default(cuid())\n  subscriptionId String\n  addOnId        String\n  quantity       Int\n  startDate      DateTime  @default(now())\n  endDate        DateTime?\n  createdAt      DateTime  @default(now())\n  updatedAt      DateTime  @updatedAt\n\n  subscription ClinicSubscription @relation(fields: [subscriptionId], references: [id])\n  addOn        ClinicAddOn        @relation(fields: [addOnId], references: [id])\n\n  @@index([subscriptionId])\n  @@index([addOnId])\n  @@map("clinic_add_on_subscriptions")\n}\n\n// -----------------------------------------------------------------------------\n// 6. CATLOGO DE PRODUTOS E OFERTAS\n// -----------------------------------------------------------------------------\n\nmodel ProductCategory {\n  id        String   @id @default(cuid())\n  name      String\n  slug      String?  @unique\n  doctorId  String?\n  isActive  Boolean  @default(true)\n  createdAt DateTime @default(now())\n  updatedAt DateTime @default(now()) @updatedAt\n\n  doctor     User?                  @relation("DoctorCategories", fields: [doctorId], references: [id])\n  products   Product[]\n  categories CategoriesOnProducts[]\n\n  @@unique([doctorId, name])\n  @@map("product_categories")\n}\n\nmodel Product {\n  id              String   @id\n  name            String\n  subtitle        String?\n  description     String?\n  price           Decimal  @db.Decimal(10, 2)\n  creditsPerUnit  Decimal  @default(0) @db.Decimal(10, 2)\n  category        String\n  isActive        Boolean  @default(true)\n  priority        Int      @default(0)\n  createdAt       DateTime @default(now())\n  updatedAt       DateTime @default(now())\n  doctorId        String?\n  clinicId        String?  @map("clinic_id")\n  imageUrl        String?\n  confirmationUrl String?\n  categoryId      String?\n\n  // Configurao do Produto\n  type             ProductType           @default(PRODUCT)\n  interval         SubscriptionInterval?\n  intervalCount    Int?                  @default(1) @map("intervalcount")\n  trialDays        Int?                  @map("trialdays")\n  providerPlanId   String?               @map("providerplanid")\n  providerPlanData Json?                 @map("providerplandata")\n  autoRenew        Boolean?              @default(true) @map("autorenew")\n\n  // Relaes\n  doctor          User?                  @relation("DoctorProducts", fields: [doctorId], references: [id], onDelete: Cascade, onUpdate: NoAction)\n  clinic          Clinic?                @relation(fields: [clinicId], references: [id])\n  productCategory ProductCategory?       @relation(fields: [categoryId], references: [id])\n  purchases       Purchase[]\n  categories      CategoriesOnProducts[]\n  offers          Offer[]\n  integrations    ProductIntegration[]\n\n  @@index([doctorId])\n  @@index([categoryId])\n  @@index([clinicId])\n  @@index([type])\n  @@map("products")\n}\n\nmodel CategoriesOnProducts {\n  productId  String   @map("product_id")\n  categoryId String   @map("category_id")\n  assignedAt DateTime @default(now()) @map("assigned_at")\n\n  product  Product         @relation(fields: [productId], references: [id], onDelete: Cascade)\n  category ProductCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)\n\n  @@id([productId, categoryId])\n  @@map("categories_on_products")\n}\n\nmodel Offer {\n  id                  String                @id @default(cuid())\n  productId           String                @map("productid")\n  name                String\n  description         String?\n  currency            Currency              @default(BRL)\n  priceCents          Int                   @map("pricecents")\n  preferredProvider   PaymentProvider?      @map("preferred_provider")\n  maxInstallments     Int?                  @default(1) @map("maxinstallments")\n  installmentMinCents Int?                  @map("installmentmincents")\n  active              Boolean               @default(true)\n  isSubscription      Boolean               @default(false) @map("issubscription")\n  intervalCount       Int?                  @map("intervalcount")\n  intervalUnit        SubscriptionInterval? @map("intervalunit")\n  trialDays           Int?                  @map("trialdays")\n  checkoutUrl         String?               @map("checkouturl")\n  providerConfig      Json?                 @map("provider_config")\n  createdAt           DateTime              @default(now()) @map("createdat")\n  updatedAt           DateTime              @updatedAt @map("updatedat")\n\n  product        Product              @relation(fields: [productId], references: [id], onDelete: Cascade)\n  paymentMethods OfferPaymentMethod[]\n  prices         OfferPrice[]\n\n  @@index([productId])\n  @@index([isSubscription])\n  @@map("offers")\n}\n\nmodel OfferPrice {\n  id              String          @id @default(cuid())\n  offerId         String          @map("offer_id")\n  country         String          @db.VarChar(2)\n  currency        Currency\n  provider        PaymentProvider\n  amountCents     Int             @default(0) @map("amount_cents")\n  externalPriceId String?         @map("external_price_id")\n  active          Boolean         @default(true)\n  createdAt       DateTime        @default(now()) @map("created_at")\n  updatedAt       DateTime        @updatedAt @map("updated_at")\n\n  offer Offer @relation(fields: [offerId], references: [id], onDelete: Cascade)\n\n  @@unique([offerId, country, currency, provider])\n  @@index([offerId])\n  @@index([country, currency])\n  @@map("offer_prices")\n}\n\nmodel OfferPaymentMethod {\n  id         String        @id @default(cuid())\n  offerId    String        @map("offerid")\n  method     PaymentMethod\n  active     Boolean       @default(true)\n  feePercent Float?        @map("feepercent")\n\n  offer Offer @relation(fields: [offerId], references: [id])\n\n  @@unique([offerId, method])\n  @@map("offer_payment_methods")\n}\n\nmodel ProductIntegration {\n  id                String          @id @default(cuid())\n  productId         String          @map("product_id")\n  provider          PaymentProvider\n  externalProductId String          @map("external_product_id")\n  metadata          Json?\n  createdAt         DateTime        @default(now()) @map("created_at")\n  updatedAt         DateTime        @updatedAt @map("updated_at")\n\n  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)\n\n  @@unique([productId, provider])\n  @@index([provider])\n  @@map("product_integrations")\n}\n\n// -----------------------------------------------------------------------------\n// 7. CHECKOUT E PAGAMENTOS (TRANSAES)\n// -----------------------------------------------------------------------------\n\nmodel CheckoutSession {\n  id          String @id @default(cuid())\n  resumeToken String @unique @map("resume_token")\n\n  // Contexto\n  clinicId  String?          @map("clinic_id")\n  productId String?          @map("product_id")\n  offerId   String?          @map("offer_id")\n  slug      String?\n  provider  PaymentProvider?\n  country   String?          @db.VarChar(2)\n  locale    String?          @db.VarChar(10)\n\n  // Estado\n  status               CheckoutSessionStatus  @default(started)\n  paymentMethod        CheckoutPaymentMethod? @default(unknown) @map("payment_method")\n  orderId              String?                @map("order_id")\n  pixOrderId           String?                @map("pix_order_id")\n  pixExpiresAt         DateTime?              @map("pix_expires_at")\n  paymentTransactionId String?                @unique @map("payment_transaction_id")\n\n  // Dados de Contato\n  email    String?\n  phone    String?\n  document String?\n\n  // Analytics / Rastreio\n  utmSource   String? @map("utm_source")\n  utmMedium   String? @map("utm_medium")\n  utmCampaign String? @map("utm_campaign")\n  utmTerm     String? @map("utm_term")\n  utmContent  String? @map("utm_content")\n  referrer    String?\n  ip          String?\n  userAgent   String? @map("user_agent")\n\n  // Snapshots\n  selectedInstallments  Int?    @map("selected_installments")\n  selectedBank          String? @map("selected_bank")\n  paymentMethodsAllowed Json?   @map("payment_methods_allowed")\n  metadata              Json?\n\n  // Datas\n  startedAt       DateTime  @default(now()) @map("started_at")\n  createdAt       DateTime  @default(now()) @map("created_at")\n  updatedAt       DateTime  @updatedAt @map("updated_at")\n  lastHeartbeatAt DateTime? @map("last_heartbeat_at")\n  lastStep        String?   @map("last_step")\n\n  // Recuperao\n  reminders              Json?\n  reminderExpiringSentAt DateTime? @map("reminder_expiring_sent_at")\n  reminderExpiredSentAt  DateTime? @map("reminder_expired_sent_at")\n  conversionLikelihood   Float?    @map("conversion_likelihood")\n  origin                 String?\n  createdBy              String?   @map("created_by")\n\n  paymentTransaction PaymentTransaction? @relation("SessionPayment", fields: [paymentTransactionId], references: [id])\n\n  @@index([status, clinicId, updatedAt])\n  @@index([status, pixExpiresAt])\n  @@index([orderId])\n  @@index([pixOrderId])\n  @@index([paymentTransactionId])\n  @@map("checkout_sessions")\n}\n\nmodel PaymentTransaction {\n  id                String         @id\n  provider          String\n  providerOrderId   String?        @map("provider_order_id")\n  providerChargeId  String?        @map("provider_charge_id")\n  doctorId          String?        @map("doctor_id")\n  patientProfileId  String?        @map("patient_profile_id")\n  clinicId          String?        @map("clinic_id")\n  merchantId        String?        @map("merchant_id")\n  productId         String?        @map("product_id")\n  amountCents       Int            @default(0) @map("amount_cents")\n  currency          String         @default("BRL")\n  installments      Int?\n  paymentMethodType String?        @map("payment_method_type")\n  status            String         @default("processing")\n  status_v2         PaymentStatus?\n  rawPayload        Json?          @map("raw_payload")\n  createdAt         DateTime       @default(now()) @map("created_at")\n  updatedAt         DateTime       @updatedAt @map("updated_at")\n  paidAt            DateTime?      @map("paid_at")\n  capturedAt        DateTime?      @map("captured_at")\n  refundStatus      String?        @map("refund_status")\n  refundedAt        DateTime?      @map("refunded_at")\n  routedProvider    String?        @map("routed_provider")\n\n  // Dados de Cobrana Recorrente\n  customerId              String?   @map("customer_id")\n  customerProviderId      String?   @map("customer_provider_id")\n  customerPaymentMethodId String?   @map("customer_payment_method_id")\n  customerSubscriptionId  String?   @map("customer_subscription_id")\n  billingPeriodStart      DateTime? @map("billing_period_start")\n  billingPeriodEnd        DateTime? @map("billing_period_end")\n\n  provider_v2     PaymentProvider?\n  checkoutSession CheckoutSession? @relation("SessionPayment")\n\n  @@index([doctorId])\n  @@index([productId])\n  @@index([createdAt])\n  @@index([providerOrderId])\n  @@index([provider, providerChargeId])\n  @@index([updatedAt])\n  @@index([merchantId])\n  @@index([status])\n  @@index([paidAt])\n  @@index([routedProvider])\n  @@index([customerId])\n  @@index([customerProviderId])\n  @@index([customerPaymentMethodId])\n  @@index([customerSubscriptionId])\n  @@index([provider_v2])\n  @@index([status_v2])\n  @@index([clinicId])\n  @@index([clinicId, createdAt])\n  @@map("payment_transactions")\n}\n\nmodel Purchase {\n  id                     String   @id @default(cuid())\n  userId                 String\n  doctorId               String\n  productId              String\n  quantity               Int      @default(1)\n  unitPrice              Decimal  @db.Decimal(10, 2)\n  totalPrice             Decimal  @db.Decimal(10, 2)\n  pointsAwarded          Decimal  @default(0) @db.Decimal(10, 2)\n  status                 String   @default("COMPLETED")\n  externalIdempotencyKey String?\n  notes                  String?\n  createdAt              DateTime @default(now())\n  updatedAt              DateTime @default(now()) @updatedAt\n\n  user    User    @relation("UserPurchases", fields: [userId], references: [id], onDelete: Cascade)\n  doctor  User    @relation("DoctorPurchases", fields: [doctorId], references: [id], onDelete: Cascade)\n  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)\n\n  @@index([userId])\n  @@index([doctorId])\n  @@index([productId])\n  @@index([status])\n  @@index([createdAt])\n  @@map("purchases")\n}\n\nmodel Customer {\n  id         String   @id @default(cuid())\n  merchantId String   @map("merchant_id")\n  name       String?\n  email      String?\n  phone      String?\n  document   String?\n  address    Json?\n  metadata   Json?\n  createdAt  DateTime @default(now())\n  updatedAt  DateTime @updatedAt\n\n  providers      CustomerProvider[]\n  paymentMethods CustomerPaymentMethod[]\n  subscriptions  CustomerSubscription[]\n\n  @@unique([merchantId, email])\n  @@index([merchantId, email])\n  @@index([merchantId, phone])\n  @@map("customers")\n}\n\nmodel CustomerProvider {\n  id                 String          @id @default(cuid())\n  customerId         String          @map("customer_id")\n  provider           PaymentProvider\n  accountId          String?         @map("account_id")\n  providerCustomerId String?         @map("provider_customer_id")\n  metadata           Json?\n  createdAt          DateTime        @default(now()) @map("created_at")\n  updatedAt          DateTime        @updatedAt @map("updated_at")\n\n  customer       Customer                @relation(fields: [customerId], references: [id], onDelete: Cascade)\n  paymentMethods CustomerPaymentMethod[]\n  subscriptions  CustomerSubscription[]\n\n  @@unique([provider, accountId, providerCustomerId])\n  @@unique([customerId, provider, accountId])\n  @@index([customerId, provider, accountId])\n  @@map("customer_providers")\n}\n\nmodel CustomerPaymentMethod {\n  id                      String          @id @default(cuid())\n  customerId              String          @map("customer_id")\n  customerProviderId      String?         @map("customer_provider_id")\n  provider                PaymentProvider\n  accountId               String?         @map("account_id")\n  providerPaymentMethodId String?         @map("provider_payment_method_id")\n  brand                   String?\n  last4                   String?\n  expMonth                Int?            @map("exp_month")\n  expYear                 Int?            @map("exp_year")\n  isDefault               Boolean         @default(false) @map("is_default")\n  status                  String?\n  fingerprint             String?\n  metadata                Json?\n  createdAt               DateTime        @default(now()) @map("created_at")\n  updatedAt               DateTime        @updatedAt @map("updated_at")\n\n  customer         Customer          @relation(fields: [customerId], references: [id], onDelete: Cascade)\n  customerProvider CustomerProvider? @relation(fields: [customerProviderId], references: [id])\n\n  @@unique([provider, accountId, providerPaymentMethodId])\n  @@index([customerId, provider, accountId])\n  @@map("customer_payment_methods")\n}\n\nmodel CustomerSubscription {\n  id                     String             @id @default(cuid())\n  customerId             String             @map("customer_id")\n  merchantId             String             @map("merchant_id")\n  productId              String             @map("product_id")\n  offerId                String?            @map("offer_id")\n  provider               PaymentProvider\n  accountId              String?            @map("account_id")\n  isNative               Boolean            @default(true) @map("is_native")\n  customerProviderId     String?            @map("customer_provider_id")\n  providerSubscriptionId String?            @map("provider_subscription_id")\n  vaultPaymentMethodId   String?            @map("vault_payment_method_id")\n  status                 SubscriptionStatus @default(TRIAL) @map("status")\n  startAt                DateTime           @default(now()) @map("start_at")\n  trialEndsAt            DateTime?          @map("trial_ends_at")\n  currentPeriodStart     DateTime?          @map("current_period_start")\n  currentPeriodEnd       DateTime?          @map("current_period_end")\n  cancelAt               DateTime?          @map("cancel_at")\n  canceledAt             DateTime?          @map("canceled_at")\n  priceCents             Int                @map("price_cents")\n  currency               Currency\n  metadata               Json?              @map("metadata")\n  createdAt              DateTime           @default(now()) @map("created_at")\n  updatedAt              DateTime           @updatedAt @map("updated_at")\n\n  customer         Customer          @relation(fields: [customerId], references: [id], onDelete: Cascade)\n  customerProvider CustomerProvider? @relation(fields: [customerProviderId], references: [id])\n\n  @@index([merchantId, status])\n  @@index([provider, accountId, providerSubscriptionId])\n  @@map("customer_subscriptions")\n}\n\nmodel PaymentCustomer {\n  id        String   @id @default(cuid())\n  userId    String?\n  clinicId  String?\n  email     String?\n  document  String?  @map("document")\n  fullName  String?\n  phones    String?  @map("phones_json")\n  createdAt DateTime @default(now()) @map("created_at")\n  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")\n\n  @@index([userId])\n  @@index([clinicId])\n  @@index([document])\n  @@map("payment_customers")\n}\n\n// -----------------------------------------------------------------------------\n// 9. MENSAGERIA E CAMPANHAS\n// -----------------------------------------------------------------------------\n\nmodel MessageTemplate {\n  id              String   @id @default(cuid())\n  doctorId        String\n  name            String\n  channel         String   @db.VarChar(20)\n  subject         String?\n  html            String?\n  text            String?\n  mjml            String?\n  renderStrategy  String?  @default("raw_html") @db.VarChar(20)\n  fromName        String?\n  fromEmail       String?\n  replyTo         String?\n  provider        String?\n  waTemplateName  String?\n  waLanguage      String?  @default("pt_BR")\n  waCategory      String?\n  waComponents    Json?\n  waStatus        String?\n  waProviderId    String?\n  isActive        Boolean  @default(true)\n  createdAt       DateTime @default(now())\n  updatedAt       DateTime @default(now()) @updatedAt\n  variablesSchema Json?\n  sampleVariables Json?\n  tags            String[] @default([])\n  smsMaxSegments  Int?\n\n  doctor User                  @relation("DoctorMessageTemplates", fields: [doctorId], references: [id], onDelete: Cascade)\n  steps  MessageSequenceStep[]\n\n  @@unique([doctorId, name])\n  @@unique([doctorId, channel, waTemplateName, waLanguage])\n  @@index([doctorId])\n  @@map("message_templates")\n}\n\nmodel MessageSequence {\n  id          String   @id @default(cuid())\n  doctorId    String\n  name        String\n  description String?\n  isActive    Boolean  @default(true)\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @default(now()) @updatedAt\n\n  doctor User                  @relation("DoctorMessageSequences", fields: [doctorId], references: [id], onDelete: Cascade)\n  steps  MessageSequenceStep[]\n\n  @@unique([doctorId, name])\n  @@index([doctorId])\n  @@map("message_sequences")\n}\n\nmodel MessageSequenceStep {\n  id          String   @id @default(cuid())\n  sequenceId  String\n  orderIndex  Int      @default(0)\n  delayAmount Int      @default(0)\n  delayUnit   String   @default("hours") @db.VarChar(16)\n  templateId  String\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @default(now()) @updatedAt\n\n  sequence MessageSequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)\n  template MessageTemplate @relation(fields: [templateId], references: [id], onDelete: Restrict)\n\n  @@unique([sequenceId, orderIndex])\n  @@index([sequenceId])\n  @@index([templateId])\n  @@map("message_sequence_steps")\n}\n\nmodel CampaignJob {\n  id         String   @id\n  doctorId   String   @map("doctor_id")\n  campaignId String   @map("campaign_id")\n  channel    String\n  trigger    String?\n  scheduleAt DateTime @map("schedule_at") @db.Timestamptz(6)\n  createdAt  DateTime @default(now()) @map("created_at")\n  status     String\n  lastError  String?  @map("last_error")\n\n  @@index([doctorId])\n  @@index([scheduleAt])\n  @@index([status])\n  @@map("campaign_jobs")\n}\n\n// -----------------------------------------------------------------------------\n// 10. OPEN FINANCE\n// -----------------------------------------------------------------------------\n\nmodel OpenFinanceLink {\n  id                    String   @id @default(cuid())\n  userId                String   @map("user_id")\n  clinicId              String?  @map("clinic_id")\n  organisationId        String   @map("organisation_id")\n  authorisationServerId String   @map("authorisation_server_id")\n  enrollmentId          String   @map("enrollment_id")\n  status                String   @default("PENDING")\n  deviceBinding         Json?    @map("device_binding")\n  createdAt             DateTime @default(now()) @map("created_at")\n  updatedAt             DateTime @updatedAt @map("updated_at")\n\n  consent OpenFinanceConsent?\n\n  @@index([userId])\n  @@index([clinicId])\n  @@index([status])\n  @@map("open_finance_links")\n}\n\nmodel OpenFinanceConsent {\n  id              String    @id @default(cuid())\n  linkId          String    @unique\n  consentId       String\n  contractId      String\n  status          String    @default("ACTIVE")\n  amountCents     Int\n  periodicity     String\n  nextExecutionAt DateTime?\n  metadata        Json?\n  createdAt       DateTime  @default(now())\n  updatedAt       DateTime  @updatedAt\n\n  link OpenFinanceLink @relation(fields: [linkId], references: [id])\n\n  @@index([status])\n  @@index([nextExecutionAt])\n  @@map("open_finance_consents")\n}\n\nmodel OpenBankingPayment {\n  id                        String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid\n  providerPaymentId         String?          @map("provider_payment_id")\n  consentId                 String?\n  amountCents               Int?\n  currency                  String?\n  status                    PaymentStatusOB?\n  createdAt                 DateTime         @default(now()) @map("created_at")\n  updatedAt                 DateTime         @default(now()) @updatedAt @map("updated_at")\n  enrollmentId              String?          @map("enrollment_id")\n  transactionIdentification String?          @map("transaction_identification")\n  payerId                   String?          @map("payer_id")\n  payerDocument             String?          @map("payer_document")\n  payerEmail                String?          @map("payer_email")\n  payerName                 String?          @map("payer_name")\n  creditorName              String?          @map("creditor_name")\n  creditorCpfCnpj           String?          @map("creditor_cpf_cnpj")\n  clinicId                  String?          @map("clinic_id")\n  productId                 String?          @map("product_id")\n  purchaseId                String?          @map("purchase_id")\n  type                      PaymentTypeOB?   @map("type")\n  executedAt                DateTime?        @map("executed_at")\n  settledAt                 DateTime?        @map("settled_at")\n  recurrenceType            String?          @map("recurrence_type")\n  subscriptionId            String?          @map("subscription_id")\n  executionOrder            Int?             @map("execution_order")\n  providerResponse          Json?            @map("provider_response_json")\n  fidoAssertion             Json?            @map("fido_assertion_json")\n  riskSignals               Json?            @map("risk_signals_json")\n  paymentLinkId             String?          @unique @map("payment_link_id")\n  userId                    String?          @map("user_id")\n  orderRef                  String?          @map("order_ref")\n  redirectUri               String?          @map("redirect_uri")\n  transactionId             String?          @map("transaction_id")\n  expiresAt                 DateTime?        @map("expires_at")\n  metadata                  Json?            @map("metadata")\n\n  @@index([enrollmentId])\n  @@index([payerId])\n  @@index([clinicId])\n  @@index([status])\n  @@index([executedAt])\n  @@index([providerPaymentId])\n  @@index([type])\n  @@index([createdAt])\n  @@map("openbanking_payments")\n}\n\nmodel OpenBankingConsent {\n  id               String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid\n  enrollmentId     String?          @map("enrollment_id")\n  consentId        String           @unique @map("consent_id")\n  amountCents      Int?             @map("amount_cents")\n  currency         String?          @map("currency")\n  creditorName     String?          @map("creditor_name")\n  creditorCpfCnpj  String?          @map("creditor_cpf_cnpj")\n  productId        String?          @map("product_id")\n  clinicId         String?          @map("clinic_id")\n  status           ConsentStatusOB? @map("status")\n  providerResponse Json?            @map("provider_response_json")\n  createdAt        DateTime         @default(now()) @map("created_at")\n  updatedAt        DateTime         @default(now()) @updatedAt @map("updated_at")\n\n  @@index([consentId])\n  @@index([enrollmentId])\n  @@index([status])\n  @@index([productId])\n  @@map("openbanking_consents")\n}\n\nmodel EnrollmentContext {\n  id                    String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid\n  userId                String              @map("user_id")\n  sessionId             String?             @map("session_id")\n  enrollmentId          String              @map("enrollment_id")\n  organisationId        String              @map("organisation_id")\n  authorisationServerId String              @map("authorisation_server_id")\n  fallbackUsed          Boolean             @default(false) @map("fallback_used")\n  createdAt             DateTime            @default(now()) @map("created_at")\n  updatedAt             DateTime            @default(now()) @updatedAt @map("updated_at")\n  status                EnrollmentStatusOB? @map("status")\n  deviceRegistered      Boolean             @default(false) @map("device_registered")\n  expiresAt             DateTime?           @map("expires_at")\n  clinicId              String?             @map("clinic_id")\n  payerEmail            String?             @map("payer_email")\n  payerDocument         String?             @map("payer_document")\n  payerName             String?             @map("payer_name")\n  recurringEnabled      Boolean?            @map("recurring_enabled")\n  deviceBinding         Json?               @map("device_binding_json")\n  providerResponse      Json?               @map("provider_response_json")\n\n  @@unique([userId, organisationId])\n  @@index([userId, createdAt])\n  @@index([sessionId, createdAt])\n  @@index([enrollmentId])\n  @@index([clinicId])\n  @@index([status])\n  @@index([deviceRegistered])\n  @@index([recurringEnabled])\n  @@map("enrollment_contexts")\n}\n\nmodel PaymentConsent {\n  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid\n  tenantId  String?  @map("tenant_id")\n  consentId String   @unique @map("consent_id")\n  status    String?\n  createdAt DateTime @default(now()) @map("created_at")\n  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")\n\n  @@map("payment_consents")\n}\n\nmodel OAuthState {\n  id           String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid\n  state        String    @unique\n  nonce        String?\n  codeVerifier String?   @map("code_verifier")\n  tenantId     String?   @map("tenant_id")\n  createdAt    DateTime  @default(now()) @map("created_at")\n  usedAt       DateTime? @map("used_at")\n\n  @@map("oauth_states")\n}\n\nmodel OAuthStateMeta {\n  state                 String   @id\n  organisationId        String?  @map("organisation_id")\n  authorisationServerId String?  @map("authorisation_server_id")\n  createdAt             DateTime @default(now()) @map("created_at")\n  productId             String?  @map("product_id")\n  amountCents           Int?     @map("amount_cents")\n  currency              String?  @map("currency")\n  orderRef              String?  @map("order_ref")\n\n  @@map("oauth_state_meta")\n}\n\nmodel OAuthToken {\n  id           String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid\n  tenantId     String?   @map("tenant_id")\n  provider     String    @default("mockbank")\n  accessToken  String    @map("access_token")\n  refreshToken String?   @map("refresh_token")\n  scope        String?\n  expiresAt    DateTime? @map("expires_at")\n  createdAt    DateTime  @default(now()) @map("created_at")\n\n  @@map("oauth_tokens")\n}\n\n// -----------------------------------------------------------------------------\n// 11. SISTEMA, AUDITORIA E LOGS\n// -----------------------------------------------------------------------------\n\nmodel Event {\n  id         String     @id @default(cuid())\n  eventId    String?    @unique @map("event_id")\n  eventType  EventType  @map("event_type")\n  customerId String?    @map("customer_id")\n  clinicId   String     @map("clinic_id")\n  actor      EventActor\n  timestamp  DateTime   @default(now())\n  metadata   Json       @default("{}")\n  createdAt  DateTime   @default(now()) @map("created_at")\n\n  @@index([clinicId, timestamp], map: "idx_events_clinic_ts")\n  @@index([eventType, timestamp], map: "idx_events_type_ts")\n  @@index([customerId, timestamp], map: "idx_events_customer_ts")\n  @@map("events")\n}\n\nmodel WebhookEvent {\n  id                 String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid\n  provider           String\n  hook_id            String    @map("hook_id")\n  type               String\n  resource_order_id  String?   @map("resource_order_id")\n  resource_charge_id String?   @map("resource_charge_id")\n  status             String?\n  received_at        DateTime  @default(now()) @map("received_at")\n  processed_at       DateTime? @map("processed_at")\n  attempts           Int?\n  raw                Json\n  provider_event_id  String?   @map("provider_event_id")\n  processed          Boolean   @default(false) @map("processed")\n  processing_error   String?   @map("processing_error")\n  retry_count        Int       @default(0) @map("retry_count")\n  max_retries        Int       @default(3) @map("max_retries")\n  next_retry_at      DateTime? @map("next_retry_at")\n  last_retry_at      DateTime? @map("last_retry_at")\n  error_type         String?   @map("error_type")\n  is_retryable       Boolean   @default(true) @map("is_retryable")\n  moved_dead_letter  Boolean   @default(false) @map("moved_dead_letter")\n  dead_letter_reason String?   @map("dead_letter_reason")\n\n  @@unique([provider, hook_id], map: "webhook_events_provider_hook_id_key")\n  @@unique([provider, provider_event_id], map: "webhook_events_provider_event_unique")\n  @@index([type], map: "idx_webhook_events_type")\n  @@index([resource_order_id], map: "idx_webhook_events_order")\n  @@index([resource_charge_id], map: "idx_webhook_events_charge")\n  @@index([received_at], map: "idx_webhook_events_received")\n  @@index([provider, type, processed], map: "idx_webhook_events_processing")\n  @@index([processed, received_at], map: "idx_webhook_events_unprocessed")\n  @@map("webhook_events")\n}\n',
      "inlineSchemaHash": "c35361be39251aef739e3ea5fd95291e2fb8d19ce589b72d82d82ece94fdc1ce",
      "copyEngine": true
    };
    var fs = __require("fs");
    config.dirname = __dirname;
    if (!fs.existsSync(path.join(__dirname, "schema.prisma"))) {
      const alternativePaths = [
        "node_modules/.prisma/client",
        ".prisma/client"
      ];
      const alternativePath = alternativePaths.find((altPath) => {
        return fs.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
      }) ?? alternativePaths[0];
      config.dirname = path.join(process.cwd(), alternativePath);
      config.isBundled = true;
    }
    config.runtimeDataModel = JSON.parse('{"models":{"User":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"image","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"public_cover_image_url","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"doctor_slug","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"role","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"PATIENT","isGenerated":false,"isUpdatedAt":false},{"name":"is_active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true},{"name":"email_verified","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reset_token","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reset_token_expiry","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"verification_code","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"verification_code_expiry","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"doctor_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"referral_code","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"birth_date","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":["Date",[]],"isGenerated":false,"isUpdatedAt":false},{"name":"gender","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"address","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"emergency_contact","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"emergency_phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"medical_history","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"allergies","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"medications","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"notes","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"google_review_link","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"stripe_connect_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"accessGranted","dbName":"access_granted","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"accounts","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Account","nativeType":null,"relationName":"AccountToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"sessions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Session","nativeType":null,"relationName":"SessionToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"User","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserToUser","relationFromFields":["doctor_id"],"relationToFields":["id"],"relationOnDelete":"NoAction","relationOnUpdate":"NoAction","isGenerated":false,"isUpdatedAt":false},{"name":"other_users","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"clinic_memberships","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ClinicMember","nativeType":null,"relationName":"ClinicMemberToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"owned_clinics","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Clinic","nativeType":null,"relationName":"ClinicOwner","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"created_products","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"DoctorProducts","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"created_categories","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductCategory","nativeType":null,"relationName":"DoctorCategories","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"user_verification_codes","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"VerificationCode","nativeType":null,"relationName":"UserVerificationCodes","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"doctor_verification_codes","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"VerificationCode","nativeType":null,"relationName":"DoctorVerificationCodes","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"purchases","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Purchase","nativeType":null,"relationName":"UserPurchases","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"doctorPurchases","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Purchase","nativeType":null,"relationName":"DoctorPurchases","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"pointsLedger","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PointsLedger","nativeType":null,"relationName":"UserPointsLedger","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"doctor_profiles","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PatientProfile","nativeType":null,"relationName":"ProfileDoctor","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"patient_profiles","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PatientProfile","nativeType":null,"relationName":"ProfilePatient","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"message_templates","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MessageTemplate","nativeType":null,"relationName":"DoctorMessageTemplates","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"message_sequences","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MessageSequence","nativeType":null,"relationName":"DoctorMessageSequences","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Account":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerAccountId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"refresh_token","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"access_token","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expires_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"token_type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"scope","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"id_token","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"session_state","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"AccountToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["provider","providerAccountId"]],"uniqueIndexes":[{"name":null,"fields":["provider","providerAccountId"]}],"isGenerated":false},"Session":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"sessionToken","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expires","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"SessionToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"VerificationToken":{"dbName":null,"schema":null,"fields":[{"name":"identifier","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"token","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expires","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["identifier","token"]],"uniqueIndexes":[{"name":null,"fields":["identifier","token"]}],"isGenerated":false},"VerificationCode":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"code","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"doctor_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"expires_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"used_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserVerificationCodes","relationFromFields":["user_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"doctor","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"DoctorVerificationCodes","relationFromFields":["doctor_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"PatientProfile":{"dbName":"patient_profiles","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"doctorId","dbName":"doctor_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userId","dbName":"user_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"address","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"emergency_contact","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"emergency_phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"medical_history","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"allergies","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"medications","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"notes","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isActive","dbName":"is_active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"totalPoints","dbName":"total_points","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"currentPoints","dbName":"current_points","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"doctor","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"ProfileDoctor","relationFromFields":["doctorId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"patient","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"ProfilePatient","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"pointsLedger","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PointsLedger","nativeType":null,"relationName":"PatientProfileToPointsLedger","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["doctorId","userId"]],"uniqueIndexes":[{"name":null,"fields":["doctorId","userId"]}],"isGenerated":false},"PointsLedger":{"dbName":"points_ledger","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"patientProfileId","dbName":"patient_profile_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"sourceType","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"sourceId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserPointsLedger","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"patientProfile","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PatientProfile","nativeType":null,"relationName":"PatientProfileToPointsLedger","relationFromFields":["patientProfileId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Clinic":{"dbName":"clinics","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"ownerId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isActive","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"address","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"city","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"state","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"zipCode","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"country","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"website","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"logo","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"slug","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":["VarChar",["255"]],"isGenerated":false,"isUpdatedAt":false},{"name":"subdomain","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":["VarChar",["255"]],"isGenerated":false,"isUpdatedAt":false},{"name":"monthlyRevenueRange","dbName":"monthly_revenue_range","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"currentGateway","dbName":"current_gateway","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"theme","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"ClinicTheme","nativeType":null,"default":"LIGHT","isGenerated":false,"isUpdatedAt":false},{"name":"buttonColor","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"buttonTextColor","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"members","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ClinicMember","nativeType":null,"relationName":"ClinicToClinicMember","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"owner","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"ClinicOwner","relationFromFields":["ownerId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"subscriptions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ClinicSubscription","nativeType":null,"relationName":"ClinicToClinicSubscription","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"products","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ClinicToProduct","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"merchant","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Merchant","nativeType":null,"relationName":"ClinicToMerchant","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"merchantApplication","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MerchantApplication","nativeType":null,"relationName":"ClinicToMerchantApplication","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ClinicMember":{"dbName":"clinic_members","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"role","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"ClinicRole","nativeType":null,"default":"STAFF","isGenerated":false,"isUpdatedAt":false},{"name":"isActive","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"joinedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"clinic","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Clinic","nativeType":null,"relationName":"ClinicToClinicMember","relationFromFields":["clinicId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"ClinicMemberToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["clinicId","userId"]],"uniqueIndexes":[{"name":null,"fields":["clinicId","userId"]}],"isGenerated":false},"Merchant":{"dbName":"merchants","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","dbName":"clinic_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"MerchantStatus","nativeType":null,"default":"PENDING","isGenerated":false,"isUpdatedAt":false},{"name":"recipientId","dbName":"recipient_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"externalAccountId","dbName":"external_account_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"onboardingState","dbName":"onboarding_state","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"splitPercent","dbName":"split_percent","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":100,"isGenerated":false,"isUpdatedAt":false},{"name":"platformFeeBps","dbName":"platform_fee_bps","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"transactionFeeCents","dbName":"transaction_fee_cents","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"transactionFeeType","dbName":"transaction_fee_type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"flat","isGenerated":false,"isUpdatedAt":false},{"name":"lastSyncAt","dbName":"last_sync_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true},{"name":"clinic","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Clinic","nativeType":null,"relationName":"ClinicToMerchant","relationFromFields":["clinicId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"integrations","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MerchantIntegration","nativeType":null,"relationName":"MerchantToMerchantIntegration","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"MerchantApplication":{"dbName":"merchant_applications","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","dbName":"clinic_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"MerchantType","nativeType":null,"default":"INDIVIDUAL","isGenerated":false,"isUpdatedAt":false},{"name":"businessName","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"fullName","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"documentNumber","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"address","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"bankAccount","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"recipientId","dbName":"recipient_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"MerchantAppStatus","nativeType":null,"default":"DRAFT","isGenerated":false,"isUpdatedAt":false},{"name":"reviewNotes","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reviewedBy","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reviewedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"clinic","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Clinic","nativeType":null,"relationName":"ClinicToMerchantApplication","relationFromFields":["clinicId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"documents","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MerchantDocument","nativeType":null,"relationName":"MerchantApplicationToMerchantDocument","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"MerchantDocument":{"dbName":"merchant_documents","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"applicationId","dbName":"application_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DocumentType","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"fileUrl","dbName":"file_url","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DocumentStatus","nativeType":null,"default":"PENDING","isGenerated":false,"isUpdatedAt":false},{"name":"notes","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"uploadedAt","dbName":"uploaded_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"reviewedAt","dbName":"reviewed_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"application","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MerchantApplication","nativeType":null,"relationName":"MerchantApplicationToMerchantDocument","relationFromFields":["applicationId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"MerchantIntegration":{"dbName":"merchant_integrations","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"merchantId","dbName":"merchant_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"credentials","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"config","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isActive","dbName":"is_active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"isPrimary","dbName":"is_primary","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"connectedAt","dbName":"connected_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"lastUsedAt","dbName":"last_used_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastError","dbName":"last_error","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastErrorAt","dbName":"last_error_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"merchant","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Merchant","nativeType":null,"relationName":"MerchantToMerchantIntegration","relationFromFields":["merchantId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["merchantId","provider"]],"uniqueIndexes":[{"name":null,"fields":["merchantId","provider"]}],"isGenerated":false},"PaymentRoutingRule":{"dbName":"payment_routing_rules","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"merchantId","dbName":"merchant_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productId","dbName":"product_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"offerId","dbName":"offer_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"country","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":["VarChar",["2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"method","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentMethod","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"priority","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":100,"isGenerated":false,"isUpdatedAt":false},{"name":"isActive","dbName":"is_active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ClinicPlan":{"dbName":"clinic_plans","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"tier","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PlanTier","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"monthlyPrice","dbName":"monthly_price","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"monthlyTxLimit","dbName":"monthly_tx_limit","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":1000,"isGenerated":false,"isUpdatedAt":false},{"name":"features","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Json","nativeType":null,"default":"{}","isGenerated":false,"isUpdatedAt":false},{"name":"trialDays","dbName":"trial_days","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":30,"isGenerated":false,"isUpdatedAt":false},{"name":"requireCard","dbName":"require_card","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"isActive","dbName":"is_active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"isPublic","dbName":"is_public","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"subscriptions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ClinicSubscription","nativeType":null,"relationName":"ClinicPlanToClinicSubscription","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ClinicAddOn":{"dbName":"clinic_add_ons","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"AddOnType","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"monthlyPrice","dbName":"monthly_price","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"quantity","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isActive","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"subscriptions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ClinicAddOnSubscription","nativeType":null,"relationName":"ClinicAddOnToClinicAddOnSubscription","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ClinicSubscription":{"dbName":"clinic_subscriptions","schema":null,"fields":[{"name":"id","dbName":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","dbName":"clinic_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"planId","dbName":"plan_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","dbName":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"SubscriptionStatus","nativeType":null,"default":"TRIAL","isGenerated":false,"isUpdatedAt":false},{"name":"startDate","dbName":"start_date","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"trialEndsAt","dbName":"trial_ends_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"currentPeriodStart","dbName":"current_period_start","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"currentPeriodEnd","dbName":"current_period_end","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"stripeCustomerId","dbName":"stripe_customer_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"stripeSubscriptionId","dbName":"stripe_subscription_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"canceledAt","dbName":"canceled_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cancelReason","dbName":"cancel_reason","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"currentDoctorsCount","dbName":"current_doctors_count","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"currentPatientsCount","dbName":"current_patients_count","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"clinic","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Clinic","nativeType":null,"relationName":"ClinicToClinicSubscription","relationFromFields":["clinicId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"plan","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ClinicPlan","nativeType":null,"relationName":"ClinicPlanToClinicSubscription","relationFromFields":["planId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"addOns","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ClinicAddOnSubscription","nativeType":null,"relationName":"ClinicAddOnSubscriptionToClinicSubscription","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ClinicAddOnSubscription":{"dbName":"clinic_add_on_subscriptions","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"subscriptionId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"addOnId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"quantity","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"startDate","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"endDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"subscription","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ClinicSubscription","nativeType":null,"relationName":"ClinicAddOnSubscriptionToClinicSubscription","relationFromFields":["subscriptionId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"addOn","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ClinicAddOn","nativeType":null,"relationName":"ClinicAddOnToClinicAddOnSubscription","relationFromFields":["addOnId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ProductCategory":{"dbName":"product_categories","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"slug","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"doctorId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isActive","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true},{"name":"doctor","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"DoctorCategories","relationFromFields":["doctorId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"products","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToProductCategory","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"categories","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CategoriesOnProducts","nativeType":null,"relationName":"CategoriesOnProductsToProductCategory","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["doctorId","name"]],"uniqueIndexes":[{"name":null,"fields":["doctorId","name"]}],"isGenerated":false},"Product":{"dbName":"products","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"subtitle","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"price","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"creditsPerUnit","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Decimal","nativeType":["Decimal",["10","2"]],"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"category","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isActive","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"priority","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"doctorId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","dbName":"clinic_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"imageUrl","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"confirmationUrl","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"categoryId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"ProductType","nativeType":null,"default":"PRODUCT","isGenerated":false,"isUpdatedAt":false},{"name":"interval","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"SubscriptionInterval","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"intervalCount","dbName":"intervalcount","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":1,"isGenerated":false,"isUpdatedAt":false},{"name":"trialDays","dbName":"trialdays","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerPlanId","dbName":"providerplanid","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerPlanData","dbName":"providerplandata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"autoRenew","dbName":"autorenew","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"doctor","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"DoctorProducts","relationFromFields":["doctorId"],"relationToFields":["id"],"relationOnDelete":"Cascade","relationOnUpdate":"NoAction","isGenerated":false,"isUpdatedAt":false},{"name":"clinic","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Clinic","nativeType":null,"relationName":"ClinicToProduct","relationFromFields":["clinicId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"productCategory","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductCategory","nativeType":null,"relationName":"ProductToProductCategory","relationFromFields":["categoryId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"purchases","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Purchase","nativeType":null,"relationName":"ProductToPurchase","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"categories","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CategoriesOnProducts","nativeType":null,"relationName":"CategoriesOnProductsToProduct","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"offers","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Offer","nativeType":null,"relationName":"OfferToProduct","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"integrations","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductIntegration","nativeType":null,"relationName":"ProductToProductIntegration","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"CategoriesOnProducts":{"dbName":"categories_on_products","schema":null,"fields":[{"name":"productId","dbName":"product_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"categoryId","dbName":"category_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"assignedAt","dbName":"assigned_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"CategoriesOnProductsToProduct","relationFromFields":["productId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"category","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductCategory","nativeType":null,"relationName":"CategoriesOnProductsToProductCategory","relationFromFields":["categoryId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":{"name":null,"fields":["productId","categoryId"]},"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Offer":{"dbName":"offers","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"productId","dbName":"productid","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Currency","nativeType":null,"default":"BRL","isGenerated":false,"isUpdatedAt":false},{"name":"priceCents","dbName":"pricecents","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"preferredProvider","dbName":"preferred_provider","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"maxInstallments","dbName":"maxinstallments","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":1,"isGenerated":false,"isUpdatedAt":false},{"name":"installmentMinCents","dbName":"installmentmincents","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"isSubscription","dbName":"issubscription","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"intervalCount","dbName":"intervalcount","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"intervalUnit","dbName":"intervalunit","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"SubscriptionInterval","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"trialDays","dbName":"trialdays","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"checkoutUrl","dbName":"checkouturl","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerConfig","dbName":"provider_config","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"createdat","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updatedat","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"OfferToProduct","relationFromFields":["productId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"paymentMethods","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"OfferPaymentMethod","nativeType":null,"relationName":"OfferToOfferPaymentMethod","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"prices","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"OfferPrice","nativeType":null,"relationName":"OfferToOfferPrice","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"OfferPrice":{"dbName":"offer_prices","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"offerId","dbName":"offer_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"country","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":["VarChar",["2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Currency","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amountCents","dbName":"amount_cents","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"externalPriceId","dbName":"external_price_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"offer","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Offer","nativeType":null,"relationName":"OfferToOfferPrice","relationFromFields":["offerId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["offerId","country","currency","provider"]],"uniqueIndexes":[{"name":null,"fields":["offerId","country","currency","provider"]}],"isGenerated":false},"OfferPaymentMethod":{"dbName":"offer_payment_methods","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"offerId","dbName":"offerid","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"method","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentMethod","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"feePercent","dbName":"feepercent","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"offer","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Offer","nativeType":null,"relationName":"OfferToOfferPaymentMethod","relationFromFields":["offerId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["offerId","method"]],"uniqueIndexes":[{"name":null,"fields":["offerId","method"]}],"isGenerated":false},"ProductIntegration":{"dbName":"product_integrations","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"productId","dbName":"product_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"externalProductId","dbName":"external_product_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToProductIntegration","relationFromFields":["productId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["productId","provider"]],"uniqueIndexes":[{"name":null,"fields":["productId","provider"]}],"isGenerated":false},"CheckoutSession":{"dbName":"checkout_sessions","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"resumeToken","dbName":"resume_token","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","dbName":"clinic_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productId","dbName":"product_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"offerId","dbName":"offer_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"slug","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"country","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":["VarChar",["2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"locale","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":["VarChar",["10"]],"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"CheckoutSessionStatus","nativeType":null,"default":"started","isGenerated":false,"isUpdatedAt":false},{"name":"paymentMethod","dbName":"payment_method","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"CheckoutPaymentMethod","nativeType":null,"default":"unknown","isGenerated":false,"isUpdatedAt":false},{"name":"orderId","dbName":"order_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"pixOrderId","dbName":"pix_order_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"pixExpiresAt","dbName":"pix_expires_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"paymentTransactionId","dbName":"payment_transaction_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"document","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"utmSource","dbName":"utm_source","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"utmMedium","dbName":"utm_medium","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"utmCampaign","dbName":"utm_campaign","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"utmTerm","dbName":"utm_term","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"utmContent","dbName":"utm_content","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"referrer","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"ip","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userAgent","dbName":"user_agent","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"selectedInstallments","dbName":"selected_installments","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"selectedBank","dbName":"selected_bank","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"paymentMethodsAllowed","dbName":"payment_methods_allowed","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"startedAt","dbName":"started_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"lastHeartbeatAt","dbName":"last_heartbeat_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastStep","dbName":"last_step","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reminders","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reminderExpiringSentAt","dbName":"reminder_expiring_sent_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reminderExpiredSentAt","dbName":"reminder_expired_sent_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"conversionLikelihood","dbName":"conversion_likelihood","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"origin","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdBy","dbName":"created_by","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"paymentTransaction","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentTransaction","nativeType":null,"relationName":"SessionPayment","relationFromFields":["paymentTransactionId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"PaymentTransaction":{"dbName":"payment_transactions","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerOrderId","dbName":"provider_order_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerChargeId","dbName":"provider_charge_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"doctorId","dbName":"doctor_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"patientProfileId","dbName":"patient_profile_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","dbName":"clinic_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"merchantId","dbName":"merchant_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productId","dbName":"product_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amountCents","dbName":"amount_cents","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"BRL","isGenerated":false,"isUpdatedAt":false},{"name":"installments","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"paymentMethodType","dbName":"payment_method_type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"processing","isGenerated":false,"isUpdatedAt":false},{"name":"status_v2","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentStatus","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"rawPayload","dbName":"raw_payload","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"paidAt","dbName":"paid_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"capturedAt","dbName":"captured_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"refundStatus","dbName":"refund_status","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"refundedAt","dbName":"refunded_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"routedProvider","dbName":"routed_provider","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customerId","dbName":"customer_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customerProviderId","dbName":"customer_provider_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customerPaymentMethodId","dbName":"customer_payment_method_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customerSubscriptionId","dbName":"customer_subscription_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"billingPeriodStart","dbName":"billing_period_start","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"billingPeriodEnd","dbName":"billing_period_end","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider_v2","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"checkoutSession","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CheckoutSession","nativeType":null,"relationName":"SessionPayment","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Purchase":{"dbName":"purchases","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"doctorId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"quantity","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":1,"isGenerated":false,"isUpdatedAt":false},{"name":"unitPrice","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"totalPrice","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"pointsAwarded","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Decimal","nativeType":["Decimal",["10","2"]],"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"COMPLETED","isGenerated":false,"isUpdatedAt":false},{"name":"externalIdempotencyKey","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"notes","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserPurchases","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"doctor","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"DoctorPurchases","relationFromFields":["doctorId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToPurchase","relationFromFields":["productId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Customer":{"dbName":"customers","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"merchantId","dbName":"merchant_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"document","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"address","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"providers","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CustomerProvider","nativeType":null,"relationName":"CustomerToCustomerProvider","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"paymentMethods","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CustomerPaymentMethod","nativeType":null,"relationName":"CustomerToCustomerPaymentMethod","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"subscriptions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CustomerSubscription","nativeType":null,"relationName":"CustomerToCustomerSubscription","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["merchantId","email"]],"uniqueIndexes":[{"name":null,"fields":["merchantId","email"]}],"isGenerated":false},"CustomerProvider":{"dbName":"customer_providers","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"customerId","dbName":"customer_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"accountId","dbName":"account_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerCustomerId","dbName":"provider_customer_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"customer","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Customer","nativeType":null,"relationName":"CustomerToCustomerProvider","relationFromFields":["customerId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"paymentMethods","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CustomerPaymentMethod","nativeType":null,"relationName":"CustomerPaymentMethodToCustomerProvider","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"subscriptions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CustomerSubscription","nativeType":null,"relationName":"CustomerProviderToCustomerSubscription","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["provider","accountId","providerCustomerId"],["customerId","provider","accountId"]],"uniqueIndexes":[{"name":null,"fields":["provider","accountId","providerCustomerId"]},{"name":null,"fields":["customerId","provider","accountId"]}],"isGenerated":false},"CustomerPaymentMethod":{"dbName":"customer_payment_methods","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"customerId","dbName":"customer_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customerProviderId","dbName":"customer_provider_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"accountId","dbName":"account_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerPaymentMethodId","dbName":"provider_payment_method_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"brand","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"last4","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expMonth","dbName":"exp_month","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expYear","dbName":"exp_year","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isDefault","dbName":"is_default","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"fingerprint","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"customer","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Customer","nativeType":null,"relationName":"CustomerToCustomerPaymentMethod","relationFromFields":["customerId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"customerProvider","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CustomerProvider","nativeType":null,"relationName":"CustomerPaymentMethodToCustomerProvider","relationFromFields":["customerProviderId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["provider","accountId","providerPaymentMethodId"]],"uniqueIndexes":[{"name":null,"fields":["provider","accountId","providerPaymentMethodId"]}],"isGenerated":false},"CustomerSubscription":{"dbName":"customer_subscriptions","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"customerId","dbName":"customer_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"merchantId","dbName":"merchant_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productId","dbName":"product_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"offerId","dbName":"offer_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"accountId","dbName":"account_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isNative","dbName":"is_native","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"customerProviderId","dbName":"customer_provider_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerSubscriptionId","dbName":"provider_subscription_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"vaultPaymentMethodId","dbName":"vault_payment_method_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","dbName":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"SubscriptionStatus","nativeType":null,"default":"TRIAL","isGenerated":false,"isUpdatedAt":false},{"name":"startAt","dbName":"start_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"trialEndsAt","dbName":"trial_ends_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"currentPeriodStart","dbName":"current_period_start","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"currentPeriodEnd","dbName":"current_period_end","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cancelAt","dbName":"cancel_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"canceledAt","dbName":"canceled_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"priceCents","dbName":"price_cents","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Currency","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","dbName":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"customer","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Customer","nativeType":null,"relationName":"CustomerToCustomerSubscription","relationFromFields":["customerId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"customerProvider","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CustomerProvider","nativeType":null,"relationName":"CustomerProviderToCustomerSubscription","relationFromFields":["customerProviderId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"PaymentCustomer":{"dbName":"payment_customers","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"document","dbName":"document","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"fullName","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phones","dbName":"phones_json","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"MessageTemplate":{"dbName":"message_templates","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"doctorId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"channel","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":["VarChar",["20"]],"isGenerated":false,"isUpdatedAt":false},{"name":"subject","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"html","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"text","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"mjml","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"renderStrategy","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":["VarChar",["20"]],"default":"raw_html","isGenerated":false,"isUpdatedAt":false},{"name":"fromName","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"fromEmail","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"replyTo","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"waTemplateName","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"waLanguage","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"pt_BR","isGenerated":false,"isUpdatedAt":false},{"name":"waCategory","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"waComponents","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"waStatus","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"waProviderId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isActive","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true},{"name":"variablesSchema","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"sampleVariables","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":[],"isGenerated":false,"isUpdatedAt":false},{"name":"smsMaxSegments","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"doctor","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"DoctorMessageTemplates","relationFromFields":["doctorId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"steps","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MessageSequenceStep","nativeType":null,"relationName":"MessageSequenceStepToMessageTemplate","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["doctorId","name"],["doctorId","channel","waTemplateName","waLanguage"]],"uniqueIndexes":[{"name":null,"fields":["doctorId","name"]},{"name":null,"fields":["doctorId","channel","waTemplateName","waLanguage"]}],"isGenerated":false},"MessageSequence":{"dbName":"message_sequences","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"doctorId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isActive","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true},{"name":"doctor","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"DoctorMessageSequences","relationFromFields":["doctorId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"steps","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MessageSequenceStep","nativeType":null,"relationName":"MessageSequenceToMessageSequenceStep","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["doctorId","name"]],"uniqueIndexes":[{"name":null,"fields":["doctorId","name"]}],"isGenerated":false},"MessageSequenceStep":{"dbName":"message_sequence_steps","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"sequenceId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"orderIndex","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"delayAmount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"delayUnit","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":["VarChar",["16"]],"default":"hours","isGenerated":false,"isUpdatedAt":false},{"name":"templateId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true},{"name":"sequence","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MessageSequence","nativeType":null,"relationName":"MessageSequenceToMessageSequenceStep","relationFromFields":["sequenceId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"template","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MessageTemplate","nativeType":null,"relationName":"MessageSequenceStepToMessageTemplate","relationFromFields":["templateId"],"relationToFields":["id"],"relationOnDelete":"Restrict","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["sequenceId","orderIndex"]],"uniqueIndexes":[{"name":null,"fields":["sequenceId","orderIndex"]}],"isGenerated":false},"CampaignJob":{"dbName":"campaign_jobs","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"doctorId","dbName":"doctor_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"campaignId","dbName":"campaign_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"channel","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"trigger","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"scheduleAt","dbName":"schedule_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":["Timestamptz",["6"]],"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastError","dbName":"last_error","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"OpenFinanceLink":{"dbName":"open_finance_links","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","dbName":"user_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","dbName":"clinic_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"organisationId","dbName":"organisation_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"authorisationServerId","dbName":"authorisation_server_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"enrollmentId","dbName":"enrollment_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"PENDING","isGenerated":false,"isUpdatedAt":false},{"name":"deviceBinding","dbName":"device_binding","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"consent","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"OpenFinanceConsent","nativeType":null,"relationName":"OpenFinanceConsentToOpenFinanceLink","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"OpenFinanceConsent":{"dbName":"open_finance_consents","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"linkId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"consentId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"contractId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"ACTIVE","isGenerated":false,"isUpdatedAt":false},{"name":"amountCents","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"periodicity","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"nextExecutionAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"link","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"OpenFinanceLink","nativeType":null,"relationName":"OpenFinanceConsentToOpenFinanceLink","relationFromFields":["linkId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"OpenBankingPayment":{"dbName":"openbanking_payments","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":["Uuid",[]],"default":{"name":"dbgenerated","args":["gen_random_uuid()"]},"isGenerated":false,"isUpdatedAt":false},{"name":"providerPaymentId","dbName":"provider_payment_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"consentId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amountCents","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentStatusOB","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true},{"name":"enrollmentId","dbName":"enrollment_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"transactionIdentification","dbName":"transaction_identification","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"payerId","dbName":"payer_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"payerDocument","dbName":"payer_document","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"payerEmail","dbName":"payer_email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"payerName","dbName":"payer_name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"creditorName","dbName":"creditor_name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"creditorCpfCnpj","dbName":"creditor_cpf_cnpj","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","dbName":"clinic_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productId","dbName":"product_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"purchaseId","dbName":"purchase_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","dbName":"type","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentTypeOB","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"executedAt","dbName":"executed_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"settledAt","dbName":"settled_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"recurrenceType","dbName":"recurrence_type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"subscriptionId","dbName":"subscription_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"executionOrder","dbName":"execution_order","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerResponse","dbName":"provider_response_json","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"fidoAssertion","dbName":"fido_assertion_json","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"riskSignals","dbName":"risk_signals_json","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"paymentLinkId","dbName":"payment_link_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userId","dbName":"user_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"orderRef","dbName":"order_ref","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"redirectUri","dbName":"redirect_uri","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"transactionId","dbName":"transaction_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expiresAt","dbName":"expires_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","dbName":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"OpenBankingConsent":{"dbName":"openbanking_consents","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":["Uuid",[]],"default":{"name":"dbgenerated","args":["gen_random_uuid()"]},"isGenerated":false,"isUpdatedAt":false},{"name":"enrollmentId","dbName":"enrollment_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"consentId","dbName":"consent_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amountCents","dbName":"amount_cents","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"currency","dbName":"currency","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"creditorName","dbName":"creditor_name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"creditorCpfCnpj","dbName":"creditor_cpf_cnpj","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productId","dbName":"product_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","dbName":"clinic_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","dbName":"status","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ConsentStatusOB","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerResponse","dbName":"provider_response_json","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"EnrollmentContext":{"dbName":"enrollment_contexts","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":["Uuid",[]],"default":{"name":"dbgenerated","args":["gen_random_uuid()"]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","dbName":"user_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"sessionId","dbName":"session_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"enrollmentId","dbName":"enrollment_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"organisationId","dbName":"organisation_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"authorisationServerId","dbName":"authorisation_server_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"fallbackUsed","dbName":"fallback_used","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true},{"name":"status","dbName":"status","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"EnrollmentStatusOB","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"deviceRegistered","dbName":"device_registered","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"expiresAt","dbName":"expires_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","dbName":"clinic_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"payerEmail","dbName":"payer_email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"payerDocument","dbName":"payer_document","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"payerName","dbName":"payer_name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"recurringEnabled","dbName":"recurring_enabled","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Boolean","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"deviceBinding","dbName":"device_binding_json","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerResponse","dbName":"provider_response_json","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["userId","organisationId"]],"uniqueIndexes":[{"name":null,"fields":["userId","organisationId"]}],"isGenerated":false},"PaymentConsent":{"dbName":"payment_consents","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":["Uuid",[]],"default":{"name":"dbgenerated","args":["gen_random_uuid()"]},"isGenerated":false,"isUpdatedAt":false},{"name":"tenantId","dbName":"tenant_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"consentId","dbName":"consent_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","dbName":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"OAuthState":{"dbName":"oauth_states","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":["Uuid",[]],"default":{"name":"dbgenerated","args":["gen_random_uuid()"]},"isGenerated":false,"isUpdatedAt":false},{"name":"state","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"nonce","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"codeVerifier","dbName":"code_verifier","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"tenantId","dbName":"tenant_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"usedAt","dbName":"used_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"OAuthStateMeta":{"dbName":"oauth_state_meta","schema":null,"fields":[{"name":"state","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"organisationId","dbName":"organisation_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"authorisationServerId","dbName":"authorisation_server_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"productId","dbName":"product_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amountCents","dbName":"amount_cents","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"currency","dbName":"currency","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"orderRef","dbName":"order_ref","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"OAuthToken":{"dbName":"oauth_tokens","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":["Uuid",[]],"default":{"name":"dbgenerated","args":["gen_random_uuid()"]},"isGenerated":false,"isUpdatedAt":false},{"name":"tenantId","dbName":"tenant_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"mockbank","isGenerated":false,"isUpdatedAt":false},{"name":"accessToken","dbName":"access_token","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"refreshToken","dbName":"refresh_token","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"scope","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expiresAt","dbName":"expires_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Event":{"dbName":"events","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"eventId","dbName":"event_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"eventType","dbName":"event_type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"EventType","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customerId","dbName":"customer_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"clinicId","dbName":"clinic_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"actor","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"EventActor","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"timestamp","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Json","nativeType":null,"default":"{}","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","dbName":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"WebhookEvent":{"dbName":"webhook_events","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":["Uuid",[]],"default":{"name":"dbgenerated","args":["gen_random_uuid()"]},"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"hook_id","dbName":"hook_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"resource_order_id","dbName":"resource_order_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"resource_charge_id","dbName":"resource_charge_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"received_at","dbName":"received_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"processed_at","dbName":"processed_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"attempts","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"raw","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider_event_id","dbName":"provider_event_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"processed","dbName":"processed","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"processing_error","dbName":"processing_error","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"retry_count","dbName":"retry_count","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"max_retries","dbName":"max_retries","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":3,"isGenerated":false,"isUpdatedAt":false},{"name":"next_retry_at","dbName":"next_retry_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"last_retry_at","dbName":"last_retry_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"error_type","dbName":"error_type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"is_retryable","dbName":"is_retryable","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"moved_dead_letter","dbName":"moved_dead_letter","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"dead_letter_reason","dbName":"dead_letter_reason","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["provider","hook_id"],["provider","provider_event_id"]],"uniqueIndexes":[{"name":null,"fields":["provider","hook_id"]},{"name":null,"fields":["provider","provider_event_id"]}],"isGenerated":false}},"enums":{"ClinicRole":{"values":[{"name":"OWNER","dbName":null},{"name":"MANAGER","dbName":null},{"name":"PROVIDER","dbName":null},{"name":"STAFF","dbName":null}],"dbName":null},"ClinicTheme":{"values":[{"name":"LIGHT","dbName":null},{"name":"DARK","dbName":null}],"dbName":null},"MerchantStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"ACTIVE","dbName":null},{"name":"REJECTED","dbName":null},{"name":"DISABLED","dbName":null}],"dbName":null},"MerchantType":{"values":[{"name":"INDIVIDUAL","dbName":null},{"name":"COMPANY","dbName":null}],"dbName":null},"MerchantAppStatus":{"values":[{"name":"DRAFT","dbName":null},{"name":"PENDING_DOCUMENTS","dbName":null},{"name":"UNDER_REVIEW","dbName":null},{"name":"APPROVED","dbName":null},{"name":"REJECTED","dbName":null}],"dbName":null},"DocumentType":{"values":[{"name":"ID_FRONT","dbName":null},{"name":"ID_BACK","dbName":null},{"name":"SELFIE","dbName":null},{"name":"CNPJ_CARD","dbName":null},{"name":"ADDRESS_PROOF","dbName":null},{"name":"CONTRACT_SOCIAL","dbName":null},{"name":"BANK_STATEMENT","dbName":null},{"name":"OTHER","dbName":null}],"dbName":null},"DocumentStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"APPROVED","dbName":null},{"name":"REJECTED","dbName":null}],"dbName":null},"SubscriptionStatus":{"values":[{"name":"TRIAL","dbName":null},{"name":"PENDING","dbName":null},{"name":"ACTIVE","dbName":null},{"name":"PAST_DUE","dbName":null},{"name":"CANCELED","dbName":null},{"name":"EXPIRED","dbName":null}],"dbName":"SubscriptionStatus"},"PlanTier":{"values":[{"name":"STARTER","dbName":null},{"name":"GROWTH","dbName":null},{"name":"ENTERPRISE","dbName":null}],"dbName":null},"AddOnType":{"values":[{"name":"EXTRA_DOCTOR","dbName":null},{"name":"EXTRA_PATIENTS","dbName":null},{"name":"ADVANCED_REPORTS","dbName":null},{"name":"CUSTOM_BRANDING","dbName":null},{"name":"WHITE_LABEL","dbName":null},{"name":"API_ACCESS","dbName":null}],"dbName":null},"ProductType":{"values":[{"name":"PRODUCT","dbName":null},{"name":"SUBSCRIPTION","dbName":null}],"dbName":null},"SubscriptionInterval":{"values":[{"name":"DAY","dbName":null},{"name":"WEEK","dbName":null},{"name":"MONTH","dbName":null},{"name":"YEAR","dbName":null}],"dbName":null},"Currency":{"values":[{"name":"BRL","dbName":null},{"name":"USD","dbName":null},{"name":"EUR","dbName":null},{"name":"MXN","dbName":null}],"dbName":null},"PaymentMethod":{"values":[{"name":"CARD","dbName":null},{"name":"PIX","dbName":null},{"name":"BOLETO","dbName":null},{"name":"PAYPAL","dbName":null},{"name":"OPEN_FINANCE","dbName":null},{"name":"OPEN_FINANCE_AUTOMATIC","dbName":null}],"dbName":null},"PaymentProvider":{"values":[{"name":"KRXPAY","dbName":null},{"name":"STRIPE","dbName":null},{"name":"ADYEN","dbName":null},{"name":"APPMAX","dbName":null},{"name":"PAYPAL","dbName":null},{"name":"MERCADOPAGO","dbName":null},{"name":"PAGARME","dbName":null},{"name":"OPENFINANCE","dbName":null}],"dbName":null},"PaymentStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"PROCESSING","dbName":null},{"name":"REQUIRES_ACTION","dbName":null},{"name":"SUCCEEDED","dbName":null},{"name":"FAILED","dbName":null},{"name":"CANCELED","dbName":null},{"name":"EXPIRED","dbName":null},{"name":"REFUNDING","dbName":null},{"name":"REFUNDED","dbName":null},{"name":"PARTIALLY_REFUNDED","dbName":null},{"name":"CHARGEBACK","dbName":null},{"name":"DISPUTED","dbName":null}],"dbName":null},"CheckoutSessionStatus":{"values":[{"name":"started","dbName":null},{"name":"pix_generated","dbName":null},{"name":"paid","dbName":null},{"name":"abandoned","dbName":null},{"name":"canceled","dbName":null}],"dbName":null},"CheckoutPaymentMethod":{"values":[{"name":"pix","dbName":null},{"name":"card","dbName":null},{"name":"pix_ob","dbName":null},{"name":"unknown","dbName":null}],"dbName":null},"PaymentTypeOB":{"values":[{"name":"SINGLE","dbName":null},{"name":"RECURRING","dbName":null}],"dbName":null},"PaymentStatusOB":{"values":[{"name":"PENDING","dbName":null},{"name":"PROCESSING","dbName":null},{"name":"COMPLETED","dbName":null},{"name":"REJECTED","dbName":null},{"name":"CANCELLED","dbName":null},{"name":"EXPIRED","dbName":null},{"name":"ACCP","dbName":null},{"name":"PAGO","dbName":null},{"name":"RJCT","dbName":null},{"name":"CANC","dbName":null}],"dbName":null},"EnrollmentStatusOB":{"values":[{"name":"PENDING","dbName":null},{"name":"AUTHORISED","dbName":null},{"name":"REJECTED","dbName":null},{"name":"REVOKED","dbName":null},{"name":"EXPIRED","dbName":null}],"dbName":null},"ConsentStatusOB":{"values":[{"name":"AWAITING_AUTHORISATION","dbName":null},{"name":"AUTHORISED","dbName":null},{"name":"REJECTED","dbName":null},{"name":"CONSUMED","dbName":null},{"name":"EXPIRED","dbName":null}],"dbName":null},"EventType":{"values":[{"name":"customer_created","dbName":null},{"name":"customer_updated","dbName":null},{"name":"customer_visit","dbName":null},{"name":"lead_created","dbName":null},{"name":"lead_converted","dbName":null},{"name":"review_submitted","dbName":null},{"name":"feedback_negative","dbName":null},{"name":"purchase_made","dbName":null},{"name":"purchase_refund","dbName":null},{"name":"payment_processed","dbName":null},{"name":"subscription_billed","dbName":null},{"name":"subscription_canceled","dbName":null},{"name":"chargeback_reported","dbName":null},{"name":"reward_created","dbName":null},{"name":"reward_offered","dbName":null},{"name":"reward_viewed","dbName":null},{"name":"reward_claimed","dbName":null},{"name":"reward_redeemed","dbName":null},{"name":"reward_expired","dbName":null},{"name":"points_earned","dbName":null},{"name":"points_spent","dbName":null},{"name":"campaign_sent","dbName":null},{"name":"campaign_opened","dbName":null},{"name":"campaign_clicked","dbName":null},{"name":"campaign_replied","dbName":null},{"name":"conversation_started","dbName":null},{"name":"conversation_closed","dbName":null},{"name":"membership_started","dbName":null},{"name":"membership_renewed","dbName":null},{"name":"membership_canceled","dbName":null},{"name":"membership_upgraded","dbName":null},{"name":"prediction_made","dbName":null},{"name":"action_taken","dbName":null},{"name":"outcome_recorded","dbName":null},{"name":"user_logged_in","dbName":null},{"name":"config_changed","dbName":null},{"name":"integration_added","dbName":null}],"dbName":null},"EventActor":{"values":[{"name":"customer","dbName":null},{"name":"clinic","dbName":null},{"name":"system","dbName":null},{"name":"ai","dbName":null}],"dbName":"event_actor_enum"}},"types":{}}');
    defineDmmfProperty2(exports.Prisma, config.runtimeDataModel);
    config.engineWasm = void 0;
    config.compilerWasm = void 0;
    var { warnEnvConflicts: warnEnvConflicts2 } = require_binary();
    warnEnvConflicts2({
      rootEnvPath: config.relativeEnvPaths.rootEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.rootEnvPath),
      schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.schemaEnvPath)
    });
    var PrismaClient2 = getPrismaClient2(config);
    exports.PrismaClient = PrismaClient2;
    Object.assign(exports, Prisma);
    path.join(__dirname, "query-engine-darwin-arm64");
    path.join(process.cwd(), "node_modules/.prisma/client/query-engine-darwin-arm64");
    path.join(__dirname, "query-engine-debian-openssl-3.0.x");
    path.join(process.cwd(), "node_modules/.prisma/client/query-engine-debian-openssl-3.0.x");
    path.join(__dirname, "schema.prisma");
    path.join(process.cwd(), "node_modules/.prisma/client/schema.prisma");
  }
});

// node_modules/.prisma/client/default.js
var require_default = __commonJS({
  "node_modules/.prisma/client/default.js"(exports, module) {
    init_esm();
    module.exports = { ...require_client() };
  }
});

// node_modules/@prisma/client/default.js
var require_default2 = __commonJS({
  "node_modules/@prisma/client/default.js"(exports, module) {
    init_esm();
    module.exports = {
      ...require_default()
    };
  }
});

// node_modules/@trigger.dev/sdk/dist/esm/v3/tasks.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/hooks.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/index.js
init_esm();

// node_modules/zod/index.js
init_esm();

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
init_esm();

// node_modules/zod/v3/errors.js
init_esm();

// node_modules/zod/v3/locales/en.js
init_esm();

// node_modules/zod/v3/ZodError.js
init_esm();

// node_modules/zod/v3/helpers/util.js
init_esm();
var util;
(function(util2) {
  util2.assertEqual = (_2) => {
  };
  function assertIs(_arg) {
  }
  __name(assertIs, "assertIs");
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  __name(assertNever, "assertNever");
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues, "joinValues");
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var ZodError = class _ZodError extends Error {
  static {
    __name(this, "ZodError");
  }
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, "errorMap");
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");

// node_modules/zod/v3/helpers/parseUtil.js
init_esm();
var makeIssue = /* @__PURE__ */ __name((params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var ParseStatus = class _ParseStatus {
  static {
    __name(this, "ParseStatus");
  }
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");

// node_modules/zod/v3/types.js
init_esm();

// node_modules/zod/v3/helpers/errorUtil.js
init_esm();
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  static {
    __name(this, "ParseInputLazyPath");
  }
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
var ZodType = class {
  static {
    __name(this, "ZodType");
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT, "isValidJWT");
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidCidr, "isValidCidr");
var ZodString = class _ZodString extends ZodType {
  static {
    __name(this, "ZodString");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder, "floatSafeRemainder");
var ZodNumber = class _ZodNumber extends ZodType {
  static {
    __name(this, "ZodNumber");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  static {
    __name(this, "ZodBigInt");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  static {
    __name(this, "ZodBoolean");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  static {
    __name(this, "ZodDate");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  static {
    __name(this, "ZodSymbol");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  static {
    __name(this, "ZodUndefined");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  static {
    __name(this, "ZodNull");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  static {
    __name(this, "ZodAny");
  }
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  static {
    __name(this, "ZodUnknown");
  }
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  static {
    __name(this, "ZodNever");
  }
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  static {
    __name(this, "ZodVoid");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  static {
    __name(this, "ZodArray");
  }
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var ZodObject = class _ZodObject extends ZodType {
  static {
    __name(this, "ZodObject");
  }
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: /* @__PURE__ */ __name((issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }, "errorMap")
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...augmentation
      }), "shape")
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }), "shape"),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  static {
    __name(this, "ZodUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  static {
    __name(this, "ZodDiscriminatedUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var ZodIntersection = class extends ZodType {
  static {
    __name(this, "ZodIntersection");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  static {
    __name(this, "ZodTuple");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  static {
    __name(this, "ZodRecord");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  static {
    __name(this, "ZodMap");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  static {
    __name(this, "ZodSet");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  static {
    __name(this, "ZodFunction");
  }
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  static {
    __name(this, "ZodLazy");
  }
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  static {
    __name(this, "ZodLiteral");
  }
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
var ZodEnum = class _ZodEnum extends ZodType {
  static {
    __name(this, "ZodEnum");
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  static {
    __name(this, "ZodNativeEnum");
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  static {
    __name(this, "ZodPromise");
  }
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  static {
    __name(this, "ZodEffects");
  }
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  static {
    __name(this, "ZodOptional");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  static {
    __name(this, "ZodNullable");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  static {
    __name(this, "ZodDefault");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  static {
    __name(this, "ZodCatch");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  static {
    __name(this, "ZodNaN");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  static {
    __name(this, "ZodBranded");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  static {
    __name(this, "ZodPipeline");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new _ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  static {
    __name(this, "ZodReadonly");
  }
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = /* @__PURE__ */ __name((data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    }, "freeze");
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p22 = typeof p2 === "string" ? { message: p2 } : p2;
  return p22;
}
__name(cleanParams, "cleanParams");
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r2 = check(data);
      if (r2 instanceof Promise) {
        return r2.then((r3) => {
          if (!r3) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r2) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
__name(custom, "custom");
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var coerce = {
  string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
  number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
  boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }), "boolean"),
  bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
  date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
};
var NEVER = INVALID;

// node_modules/zod/index.js
var zod_default = external_exports;

// node_modules/@trigger.dev/core/dist/esm/version.js
init_esm();
var VERSION = "4.1.2";

// node_modules/@trigger.dev/core/dist/esm/v3/jwt.js
init_esm();
var JWT_ALGORITHM = "HS256";
var JWT_ISSUER = "https://id.trigger.dev";
var JWT_AUDIENCE = "https://api.trigger.dev";
async function generateJWT(options) {
  const { SignJWT } = await import("./esm-75W7SDLT.mjs");
  const secret = new TextEncoder().encode(options.secretKey);
  return new SignJWT(options.payload).setIssuer(JWT_ISSUER).setAudience(JWT_AUDIENCE).setProtectedHeader({ alg: JWT_ALGORITHM }).setIssuedAt().setExpirationTime(options.expirationTime ?? "15m").sign(secret);
}
__name(generateJWT, "generateJWT");

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/tokens.js
init_esm();
var CreateAuthorizationCodeResponseSchema = external_exports.object({
  url: external_exports.string().url(),
  authorizationCode: external_exports.string()
});
var GetPersonalAccessTokenRequestSchema = external_exports.object({
  authorizationCode: external_exports.string()
});
var GetPersonalAccessTokenResponseSchema = external_exports.object({
  token: external_exports.object({
    token: external_exports.string(),
    obfuscatedToken: external_exports.string()
  }).nullable()
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/schemas/json.js
init_esm();
var LiteralSchema = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean(), external_exports.null()]);
var DeserializedJsonSchema = external_exports.lazy(() => external_exports.union([LiteralSchema, external_exports.array(DeserializedJsonSchema), external_exports.record(DeserializedJsonSchema)]));
var SerializableSchema = external_exports.union([
  external_exports.string(),
  external_exports.number(),
  external_exports.boolean(),
  external_exports.null(),
  external_exports.date(),
  external_exports.undefined(),
  external_exports.symbol()
]);
var SerializableJsonSchema = external_exports.lazy(() => external_exports.union([SerializableSchema, external_exports.array(SerializableJsonSchema), external_exports.record(SerializableJsonSchema)]));

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/common.js
init_esm();
var RunMetadataUpdateOperation = external_exports.object({
  type: external_exports.literal("update"),
  value: external_exports.record(external_exports.unknown())
});
var RunMetadataSetKeyOperation = external_exports.object({
  type: external_exports.literal("set"),
  key: external_exports.string(),
  value: DeserializedJsonSchema
});
var RunMetadataDeleteKeyOperation = external_exports.object({
  type: external_exports.literal("delete"),
  key: external_exports.string()
});
var RunMetadataAppendKeyOperation = external_exports.object({
  type: external_exports.literal("append"),
  key: external_exports.string(),
  value: DeserializedJsonSchema
});
var RunMetadataRemoveFromKeyOperation = external_exports.object({
  type: external_exports.literal("remove"),
  key: external_exports.string(),
  value: DeserializedJsonSchema
});
var RunMetadataIncrementKeyOperation = external_exports.object({
  type: external_exports.literal("increment"),
  key: external_exports.string(),
  value: external_exports.number()
});
var RunMetadataChangeOperation = external_exports.discriminatedUnion("type", [
  RunMetadataUpdateOperation,
  RunMetadataSetKeyOperation,
  RunMetadataDeleteKeyOperation,
  RunMetadataAppendKeyOperation,
  RunMetadataRemoveFromKeyOperation,
  RunMetadataIncrementKeyOperation
]);
var FlushedRunMetadata = external_exports.object({
  metadata: external_exports.record(DeserializedJsonSchema).optional(),
  operations: external_exports.array(RunMetadataChangeOperation).optional(),
  parentOperations: external_exports.array(RunMetadataChangeOperation).optional(),
  rootOperations: external_exports.array(RunMetadataChangeOperation).optional()
});
var MachineCpu = external_exports.union([
  external_exports.literal(0.25),
  external_exports.literal(0.5),
  external_exports.literal(1),
  external_exports.literal(2),
  external_exports.literal(4)
]);
var MachineMemory = external_exports.union([
  external_exports.literal(0.25),
  external_exports.literal(0.5),
  external_exports.literal(1),
  external_exports.literal(2),
  external_exports.literal(4),
  external_exports.literal(8)
]);
var MachinePresetName = external_exports.enum([
  "micro",
  "small-1x",
  "small-2x",
  "medium-1x",
  "medium-2x",
  "large-1x",
  "large-2x"
]);
var MachineConfig = external_exports.object({
  cpu: MachineCpu.optional(),
  memory: MachineMemory.optional(),
  preset: MachinePresetName.optional()
});
var MachinePreset = external_exports.object({
  name: MachinePresetName,
  /** unit: vCPU */
  cpu: external_exports.number(),
  /** unit: GB */
  memory: external_exports.number(),
  centsPerMs: external_exports.number()
});
var TaskRunBuiltInError = external_exports.object({
  type: external_exports.literal("BUILT_IN_ERROR"),
  name: external_exports.string(),
  message: external_exports.string(),
  stackTrace: external_exports.string()
});
var TaskRunCustomErrorObject = external_exports.object({
  type: external_exports.literal("CUSTOM_ERROR"),
  raw: external_exports.string()
});
var TaskRunStringError = external_exports.object({
  type: external_exports.literal("STRING_ERROR"),
  raw: external_exports.string()
});
var TaskRunInternalError = external_exports.object({
  type: external_exports.literal("INTERNAL_ERROR"),
  code: external_exports.enum([
    "COULD_NOT_FIND_EXECUTOR",
    "COULD_NOT_FIND_TASK",
    "COULD_NOT_IMPORT_TASK",
    "CONFIGURED_INCORRECTLY",
    "TASK_ALREADY_RUNNING",
    "TASK_EXECUTION_FAILED",
    "TASK_EXECUTION_ABORTED",
    "TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE",
    "TASK_PROCESS_SIGKILL_TIMEOUT",
    "TASK_PROCESS_SIGSEGV",
    "TASK_PROCESS_SIGTERM",
    "TASK_PROCESS_OOM_KILLED",
    "TASK_PROCESS_MAYBE_OOM_KILLED",
    "TASK_RUN_CANCELLED",
    "TASK_INPUT_ERROR",
    "TASK_OUTPUT_ERROR",
    "TASK_MIDDLEWARE_ERROR",
    "HANDLE_ERROR_ERROR",
    "GRACEFUL_EXIT_TIMEOUT",
    "TASK_RUN_HEARTBEAT_TIMEOUT",
    "TASK_RUN_CRASHED",
    "MAX_DURATION_EXCEEDED",
    "DISK_SPACE_EXCEEDED",
    "POD_EVICTED",
    "POD_UNKNOWN_ERROR",
    "TASK_HAS_N0_EXECUTION_SNAPSHOT",
    "TASK_DEQUEUED_INVALID_STATE",
    "TASK_DEQUEUED_QUEUE_NOT_FOUND",
    "TASK_RUN_DEQUEUED_MAX_RETRIES",
    "TASK_RUN_STALLED_EXECUTING",
    "TASK_RUN_STALLED_EXECUTING_WITH_WAITPOINTS",
    "OUTDATED_SDK_VERSION",
    "TASK_DID_CONCURRENT_WAIT",
    "RECURSIVE_WAIT_DEADLOCK"
  ]),
  message: external_exports.string().optional(),
  stackTrace: external_exports.string().optional()
});
var TaskRunErrorCodes = TaskRunInternalError.shape.code.enum;
var TaskRunError = external_exports.discriminatedUnion("type", [
  TaskRunBuiltInError,
  TaskRunCustomErrorObject,
  TaskRunStringError,
  TaskRunInternalError
]);
var TaskRun = external_exports.object({
  id: external_exports.string(),
  payload: external_exports.string(),
  payloadType: external_exports.string(),
  tags: external_exports.array(external_exports.string()),
  isTest: external_exports.boolean().default(false),
  createdAt: external_exports.coerce.date(),
  startedAt: external_exports.coerce.date().default(() => /* @__PURE__ */ new Date()),
  idempotencyKey: external_exports.string().optional(),
  maxAttempts: external_exports.number().optional(),
  version: external_exports.string().optional(),
  metadata: external_exports.record(DeserializedJsonSchema).optional(),
  maxDuration: external_exports.number().optional(),
  /** The priority of the run. Wih a value of 10 it will be dequeued before runs that were triggered 9 seconds before it (assuming they had no priority set).  */
  priority: external_exports.number().optional(),
  baseCostInCents: external_exports.number().optional(),
  parentTaskRunId: external_exports.string().optional(),
  rootTaskRunId: external_exports.string().optional(),
  // These are only used during execution, not in run.ctx
  durationMs: external_exports.number().optional(),
  costInCents: external_exports.number().optional(),
  region: external_exports.string().optional()
});
var GitMeta = external_exports.object({
  provider: external_exports.string().optional(),
  source: external_exports.enum(["trigger_github_app", "github_actions", "local"]).optional(),
  ghUsername: external_exports.string().optional(),
  ghUserAvatarUrl: external_exports.string().optional(),
  commitAuthorName: external_exports.string().optional(),
  commitMessage: external_exports.string().optional(),
  commitRef: external_exports.string().optional(),
  commitSha: external_exports.string().optional(),
  dirty: external_exports.boolean().optional(),
  remoteUrl: external_exports.string().optional(),
  pullRequestNumber: external_exports.number().optional(),
  pullRequestTitle: external_exports.string().optional(),
  pullRequestState: external_exports.enum(["open", "closed", "merged"]).optional()
});
var TaskRunExecutionTask = external_exports.object({
  id: external_exports.string(),
  filePath: external_exports.string()
});
var TaskRunExecutionAttempt = external_exports.object({
  number: external_exports.number(),
  startedAt: external_exports.coerce.date()
});
var TaskRunExecutionEnvironment = external_exports.object({
  id: external_exports.string(),
  slug: external_exports.string(),
  type: external_exports.enum(["PRODUCTION", "STAGING", "DEVELOPMENT", "PREVIEW"]),
  branchName: external_exports.string().optional(),
  git: GitMeta.optional()
});
var TaskRunExecutionOrganization = external_exports.object({
  id: external_exports.string(),
  slug: external_exports.string(),
  name: external_exports.string()
});
var TaskRunExecutionProject = external_exports.object({
  id: external_exports.string(),
  ref: external_exports.string(),
  slug: external_exports.string(),
  name: external_exports.string()
});
var TaskRunExecutionQueue = external_exports.object({
  id: external_exports.string(),
  name: external_exports.string()
});
var TaskRunExecutionBatch = external_exports.object({
  id: external_exports.string()
});
var TaskRunExecutionDeployment = external_exports.object({
  id: external_exports.string(),
  shortCode: external_exports.string(),
  version: external_exports.string(),
  runtime: external_exports.string(),
  runtimeVersion: external_exports.string(),
  git: GitMeta.optional()
});
var StaticTaskRunExecutionShape = {
  // Passthrough needed for backwards compatibility
  task: TaskRunExecutionTask.passthrough(),
  queue: TaskRunExecutionQueue,
  environment: TaskRunExecutionEnvironment,
  organization: TaskRunExecutionOrganization,
  project: TaskRunExecutionProject,
  machine: MachinePreset,
  batch: TaskRunExecutionBatch.optional(),
  deployment: TaskRunExecutionDeployment.optional()
};
var StaticTaskRunExecution = external_exports.object(StaticTaskRunExecutionShape);
var TaskRunExecution = external_exports.object({
  // Passthrough needed for backwards compatibility
  attempt: TaskRunExecutionAttempt.passthrough(),
  run: TaskRun.and(external_exports.object({
    traceContext: external_exports.record(external_exports.unknown()).optional(),
    realtimeStreamsVersion: external_exports.string().optional()
  })),
  ...StaticTaskRunExecutionShape
});
var V3TaskRunExecutionTask = external_exports.object({
  id: external_exports.string(),
  filePath: external_exports.string(),
  exportName: external_exports.string().optional()
});
var V3TaskRunExecutionAttempt = external_exports.object({
  number: external_exports.number(),
  startedAt: external_exports.coerce.date(),
  id: external_exports.string(),
  backgroundWorkerId: external_exports.string(),
  backgroundWorkerTaskId: external_exports.string(),
  status: external_exports.string()
});
var V3TaskRun = external_exports.object({
  id: external_exports.string(),
  payload: external_exports.string(),
  payloadType: external_exports.string(),
  tags: external_exports.array(external_exports.string()),
  isTest: external_exports.boolean().default(false),
  createdAt: external_exports.coerce.date(),
  startedAt: external_exports.coerce.date().default(() => /* @__PURE__ */ new Date()),
  idempotencyKey: external_exports.string().optional(),
  maxAttempts: external_exports.number().optional(),
  version: external_exports.string().optional(),
  metadata: external_exports.record(DeserializedJsonSchema).optional(),
  maxDuration: external_exports.number().optional(),
  context: external_exports.unknown(),
  durationMs: external_exports.number(),
  costInCents: external_exports.number(),
  baseCostInCents: external_exports.number()
});
var V3TaskRunExecution = external_exports.object({
  task: V3TaskRunExecutionTask,
  attempt: V3TaskRunExecutionAttempt,
  run: V3TaskRun.and(external_exports.object({
    traceContext: external_exports.record(external_exports.unknown()).optional()
  })),
  queue: TaskRunExecutionQueue,
  environment: TaskRunExecutionEnvironment,
  organization: TaskRunExecutionOrganization,
  project: TaskRunExecutionProject,
  machine: MachinePreset,
  batch: TaskRunExecutionBatch.optional()
});
var TaskRunContext = external_exports.object({
  attempt: TaskRunExecutionAttempt,
  run: TaskRun.omit({
    payload: true,
    payloadType: true,
    metadata: true,
    durationMs: true,
    costInCents: true
  }),
  ...StaticTaskRunExecutionShape
});
var V3TaskRunExecutionEnvironment = external_exports.object({
  id: external_exports.string(),
  slug: external_exports.string(),
  type: external_exports.enum(["PRODUCTION", "STAGING", "DEVELOPMENT", "PREVIEW"])
});
var V3TaskRunContext = external_exports.object({
  attempt: V3TaskRunExecutionAttempt.omit({
    backgroundWorkerId: true,
    backgroundWorkerTaskId: true
  }),
  run: V3TaskRun.omit({
    payload: true,
    payloadType: true,
    metadata: true
  }),
  task: V3TaskRunExecutionTask,
  queue: TaskRunExecutionQueue,
  environment: V3TaskRunExecutionEnvironment,
  organization: TaskRunExecutionOrganization,
  project: TaskRunExecutionProject,
  batch: TaskRunExecutionBatch.optional(),
  machine: MachinePreset.optional()
});
var TaskRunExecutionRetry = external_exports.object({
  timestamp: external_exports.number(),
  /** Retry delay in milliseconds */
  delay: external_exports.number(),
  error: external_exports.unknown().optional()
});
var TaskRunExecutionUsage = external_exports.object({
  durationMs: external_exports.number()
});
var TaskRunFailedExecutionResult = external_exports.object({
  ok: external_exports.literal(false),
  id: external_exports.string(),
  error: TaskRunError,
  retry: TaskRunExecutionRetry.optional(),
  skippedRetrying: external_exports.boolean().optional(),
  usage: TaskRunExecutionUsage.optional(),
  // Optional for now for backwards compatibility
  taskIdentifier: external_exports.string().optional(),
  // This is deprecated, use flushedMetadata instead
  metadata: FlushedRunMetadata.optional(),
  // This is the new way to flush metadata
  flushedMetadata: external_exports.object({
    data: external_exports.string().optional(),
    dataType: external_exports.string()
  }).optional()
});
var TaskRunSuccessfulExecutionResult = external_exports.object({
  ok: external_exports.literal(true),
  id: external_exports.string(),
  output: external_exports.string().optional(),
  outputType: external_exports.string(),
  usage: TaskRunExecutionUsage.optional(),
  // Optional for now for backwards compatibility
  taskIdentifier: external_exports.string().optional(),
  // This is deprecated, use flushedMetadata instead
  metadata: FlushedRunMetadata.optional(),
  // This is the new way to flush metadata
  flushedMetadata: external_exports.object({
    data: external_exports.string().optional(),
    dataType: external_exports.string()
  }).optional()
});
var TaskRunExecutionResult = external_exports.discriminatedUnion("ok", [
  TaskRunSuccessfulExecutionResult,
  TaskRunFailedExecutionResult
]);
var BatchTaskRunExecutionResult = external_exports.object({
  id: external_exports.string(),
  items: TaskRunExecutionResult.array()
});
var WaitpointTokenResult = external_exports.object({
  ok: external_exports.boolean(),
  output: external_exports.string().optional(),
  outputType: external_exports.string().optional()
});
var SerializedError = external_exports.object({
  message: external_exports.string(),
  name: external_exports.string().optional(),
  stackTrace: external_exports.string().optional()
});
var RuntimeEnvironmentType = {
  PRODUCTION: "PRODUCTION",
  STAGING: "STAGING",
  DEVELOPMENT: "DEVELOPMENT",
  PREVIEW: "PREVIEW"
};
var RuntimeEnvironmentTypeSchema = external_exports.enum(Object.values(RuntimeEnvironmentType));

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/resources.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/schemas.js
init_esm();
var EnvironmentType = external_exports.enum(["PRODUCTION", "STAGING", "DEVELOPMENT", "PREVIEW"]);
var RunEngineVersionSchema = external_exports.enum(["V1", "V2"]);
var TaskRunExecutionMetric = external_exports.object({
  name: external_exports.string(),
  event: external_exports.string(),
  timestamp: external_exports.number(),
  duration: external_exports.number()
});
var TaskRunExecutionMetrics = external_exports.array(TaskRunExecutionMetric);
var TaskRunExecutionPayload = external_exports.object({
  execution: TaskRunExecution,
  traceContext: external_exports.record(external_exports.unknown()),
  environment: external_exports.record(external_exports.string()).optional(),
  metrics: TaskRunExecutionMetrics.optional()
});
var V3ProdTaskRunExecution = V3TaskRunExecution.extend({
  worker: external_exports.object({
    id: external_exports.string(),
    contentHash: external_exports.string(),
    version: external_exports.string(),
    type: RunEngineVersionSchema.optional()
  }),
  machine: MachinePreset.default({ name: "small-1x", cpu: 1, memory: 1, centsPerMs: 0 })
});
var V3ProdTaskRunExecutionPayload = external_exports.object({
  execution: V3ProdTaskRunExecution,
  traceContext: external_exports.record(external_exports.unknown()),
  environment: external_exports.record(external_exports.string()).optional(),
  metrics: TaskRunExecutionMetrics.optional()
});
var FixedWindowRateLimit = external_exports.object({
  type: external_exports.literal("fixed-window"),
  limit: external_exports.number(),
  window: external_exports.union([
    external_exports.object({
      seconds: external_exports.number()
    }),
    external_exports.object({
      minutes: external_exports.number()
    }),
    external_exports.object({
      hours: external_exports.number()
    })
  ])
});
var SlidingWindowRateLimit = external_exports.object({
  type: external_exports.literal("sliding-window"),
  limit: external_exports.number(),
  window: external_exports.union([
    external_exports.object({
      seconds: external_exports.number()
    }),
    external_exports.object({
      minutes: external_exports.number()
    }),
    external_exports.object({
      hours: external_exports.number()
    })
  ])
});
var RateLimitOptions = external_exports.discriminatedUnion("type", [
  FixedWindowRateLimit,
  SlidingWindowRateLimit
]);
var RetryOptions = external_exports.object({
  /** The number of attempts before giving up */
  maxAttempts: external_exports.number().int().optional(),
  /** The exponential factor to use when calculating the next retry time.
   *
   * Each subsequent retry will be calculated as `previousTimeout * factor`
   */
  factor: external_exports.number().optional(),
  /** The minimum time to wait before retrying */
  minTimeoutInMs: external_exports.number().int().optional(),
  /** The maximum time to wait before retrying */
  maxTimeoutInMs: external_exports.number().int().optional(),
  /** Randomize the timeout between retries.
   *
   * This can be useful to prevent the thundering herd problem where all retries happen at the same time.
   */
  randomize: external_exports.boolean().optional(),
  /** If a run fails with an Out Of Memory (OOM) error and you have this set, it will retry with the machine you specify.
   * Note: it will not default to this [machine](https://trigger.dev/docs/machines) for new runs, only for failures caused by OOM errors.
   * So if you frequently have attempts failing with OOM errors, you should set the [default machine](https://trigger.dev/docs/machines) to be higher.
   */
  outOfMemory: external_exports.object({
    machine: MachinePresetName.optional()
  }).optional()
});
var QueueManifest = external_exports.object({
  /** You can define a shared queue and then pass the name in to your task.
     *
     * @example
     *
     * ```ts
     * const myQueue = queue({
        name: "my-queue",
        concurrencyLimit: 1,
      });
  
      export const task1 = task({
        id: "task-1",
        queue: {
          name: "my-queue",
        },
        run: async (payload: { message: string }) => {
          // ...
        },
      });
  
      export const task2 = task({
        id: "task-2",
        queue: {
          name: "my-queue",
        },
        run: async (payload: { message: string }) => {
          // ...
        },
      });
     * ```
     */
  name: external_exports.string(),
  /** An optional property that specifies the maximum number of concurrent run executions.
   *
   * If this property is omitted, the task can potentially use up the full concurrency of an environment */
  concurrencyLimit: external_exports.number().int().min(0).max(1e5).optional().nullable()
});
var ScheduleMetadata = external_exports.object({
  cron: external_exports.string(),
  timezone: external_exports.string(),
  environments: external_exports.array(EnvironmentType).optional()
});
var taskMetadata = {
  id: external_exports.string(),
  description: external_exports.string().optional(),
  queue: QueueManifest.extend({ name: external_exports.string().optional() }).optional(),
  retry: RetryOptions.optional(),
  machine: MachineConfig.optional(),
  triggerSource: external_exports.string().optional(),
  schedule: ScheduleMetadata.optional(),
  maxDuration: external_exports.number().optional(),
  payloadSchema: external_exports.unknown().optional()
};
var TaskMetadata = external_exports.object(taskMetadata);
var TaskFile = external_exports.object({
  entry: external_exports.string(),
  out: external_exports.string()
});
var taskFileMetadata = {
  filePath: external_exports.string(),
  exportName: external_exports.string().optional(),
  entryPoint: external_exports.string()
};
var TaskFileMetadata = external_exports.object(taskFileMetadata);
var TaskManifest = external_exports.object({
  ...taskMetadata,
  ...taskFileMetadata
});
var PostStartCauses = external_exports.enum(["index", "create", "restore"]);
var PreStopCauses = external_exports.enum(["terminate"]);
var RegexSchema = external_exports.custom((val) => {
  try {
    return typeof val.test === "function";
  } catch {
    return false;
  }
});
var Config = external_exports.object({
  project: external_exports.string(),
  triggerDirectories: external_exports.string().array().optional(),
  triggerUrl: external_exports.string().optional(),
  projectDir: external_exports.string().optional(),
  tsconfigPath: external_exports.string().optional(),
  retries: external_exports.object({
    enabledInDev: external_exports.boolean().default(true),
    default: RetryOptions.optional()
  }).optional(),
  additionalPackages: external_exports.string().array().optional(),
  additionalFiles: external_exports.string().array().optional(),
  dependenciesToBundle: external_exports.array(external_exports.union([external_exports.string(), RegexSchema])).optional(),
  logLevel: external_exports.string().optional(),
  enableConsoleLogging: external_exports.boolean().optional(),
  postInstall: external_exports.string().optional(),
  extraCACerts: external_exports.string().optional()
});
var WaitReason = external_exports.enum(["WAIT_FOR_DURATION", "WAIT_FOR_TASK", "WAIT_FOR_BATCH"]);
var TaskRunExecutionLazyAttemptPayload = external_exports.object({
  runId: external_exports.string(),
  attemptCount: external_exports.number().optional(),
  messageId: external_exports.string(),
  isTest: external_exports.boolean(),
  traceContext: external_exports.record(external_exports.unknown()),
  environment: external_exports.record(external_exports.string()).optional(),
  metrics: TaskRunExecutionMetrics.optional()
});
var ManualCheckpointMetadata = external_exports.object({
  /** NOT a friendly ID */
  attemptId: external_exports.string(),
  previousRunStatus: external_exports.string(),
  previousAttemptStatus: external_exports.string()
});
var RunChainState = external_exports.object({
  concurrency: external_exports.object({
    queues: external_exports.array(external_exports.object({ id: external_exports.string(), name: external_exports.string(), holding: external_exports.number() })),
    environment: external_exports.number().optional()
  }).optional()
});
var TriggerTraceContext = external_exports.object({
  traceparent: external_exports.string().optional(),
  tracestate: external_exports.string().optional(),
  external: external_exports.object({
    traceparent: external_exports.string().optional(),
    tracestate: external_exports.string().optional()
  }).optional()
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/resources.js
var TaskResource = external_exports.object({
  id: external_exports.string(),
  description: external_exports.string().optional(),
  filePath: external_exports.string(),
  exportName: external_exports.string().optional(),
  queue: QueueManifest.extend({ name: external_exports.string().optional() }).optional(),
  retry: RetryOptions.optional(),
  machine: MachineConfig.optional(),
  triggerSource: external_exports.string().optional(),
  schedule: ScheduleMetadata.optional(),
  maxDuration: external_exports.number().optional(),
  // JSONSchema type - using z.unknown() for runtime validation to accept JSONSchema7
  payloadSchema: external_exports.unknown().optional()
});
var BackgroundWorkerSourceFileMetadata = external_exports.object({
  filePath: external_exports.string(),
  contents: external_exports.string(),
  contentHash: external_exports.string(),
  taskIds: external_exports.array(external_exports.string())
});
var BackgroundWorkerMetadata = external_exports.object({
  packageVersion: external_exports.string(),
  contentHash: external_exports.string(),
  cliPackageVersion: external_exports.string().optional(),
  tasks: external_exports.array(TaskResource),
  queues: external_exports.array(QueueManifest).optional(),
  sourceFiles: external_exports.array(BackgroundWorkerSourceFileMetadata).optional(),
  runtime: external_exports.string().optional(),
  runtimeVersion: external_exports.string().optional()
});
var ImageDetailsMetadata = external_exports.object({
  contentHash: external_exports.string(),
  imageTag: external_exports.string()
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/runEngine.js
init_esm();
var TaskRunExecutionStatus = {
  RUN_CREATED: "RUN_CREATED",
  QUEUED: "QUEUED",
  QUEUED_EXECUTING: "QUEUED_EXECUTING",
  PENDING_EXECUTING: "PENDING_EXECUTING",
  EXECUTING: "EXECUTING",
  EXECUTING_WITH_WAITPOINTS: "EXECUTING_WITH_WAITPOINTS",
  SUSPENDED: "SUSPENDED",
  PENDING_CANCEL: "PENDING_CANCEL",
  FINISHED: "FINISHED"
};
var TaskRunStatus = {
  DELAYED: "DELAYED",
  PENDING: "PENDING",
  PENDING_VERSION: "PENDING_VERSION",
  WAITING_FOR_DEPLOY: "WAITING_FOR_DEPLOY",
  DEQUEUED: "DEQUEUED",
  EXECUTING: "EXECUTING",
  WAITING_TO_RESUME: "WAITING_TO_RESUME",
  RETRYING_AFTER_FAILURE: "RETRYING_AFTER_FAILURE",
  PAUSED: "PAUSED",
  CANCELED: "CANCELED",
  INTERRUPTED: "INTERRUPTED",
  COMPLETED_SUCCESSFULLY: "COMPLETED_SUCCESSFULLY",
  COMPLETED_WITH_ERRORS: "COMPLETED_WITH_ERRORS",
  SYSTEM_FAILURE: "SYSTEM_FAILURE",
  CRASHED: "CRASHED",
  EXPIRED: "EXPIRED",
  TIMED_OUT: "TIMED_OUT"
};
var WaitpointType = {
  RUN: "RUN",
  DATETIME: "DATETIME",
  MANUAL: "MANUAL",
  BATCH: "BATCH"
};
var WaitpointStatusValues = {
  PENDING: "PENDING",
  COMPLETED: "COMPLETED"
};
var WaitpointStatus = external_exports.enum(Object.values(WaitpointStatusValues));
var CompletedWaitpoint = external_exports.object({
  id: external_exports.string(),
  index: external_exports.number().optional(),
  friendlyId: external_exports.string(),
  type: external_exports.enum(Object.values(WaitpointType)),
  completedAt: external_exports.coerce.date(),
  idempotencyKey: external_exports.string().optional(),
  /** For type === "RUN" */
  completedByTaskRun: external_exports.object({
    id: external_exports.string(),
    friendlyId: external_exports.string(),
    /** If the run has an associated batch */
    batch: external_exports.object({
      id: external_exports.string(),
      friendlyId: external_exports.string()
    }).optional()
  }).optional(),
  /** For type === "DATETIME" */
  completedAfter: external_exports.coerce.date().optional(),
  /** For type === "BATCH" */
  completedByBatch: external_exports.object({
    id: external_exports.string(),
    friendlyId: external_exports.string()
  }).optional(),
  output: external_exports.string().optional(),
  outputType: external_exports.string().optional(),
  outputIsError: external_exports.boolean()
});
var ExecutionSnapshot = external_exports.object({
  id: external_exports.string(),
  friendlyId: external_exports.string(),
  executionStatus: external_exports.enum(Object.values(TaskRunExecutionStatus)),
  description: external_exports.string(),
  createdAt: external_exports.coerce.date()
});
var BaseRunMetadata = external_exports.object({
  id: external_exports.string(),
  friendlyId: external_exports.string(),
  status: external_exports.enum(Object.values(TaskRunStatus)),
  attemptNumber: external_exports.number().nullish(),
  taskEventStore: external_exports.string().optional()
});
var ExecutionResult = external_exports.object({
  snapshot: ExecutionSnapshot,
  run: BaseRunMetadata
});
var StartRunAttemptResult = ExecutionResult.and(external_exports.object({
  execution: TaskRunExecution
}));
var CompleteAttemptStatus = external_exports.enum([
  "RUN_FINISHED",
  "RUN_PENDING_CANCEL",
  "RETRY_QUEUED",
  "RETRY_IMMEDIATELY"
]);
var CompleteRunAttemptResult = external_exports.object({
  attemptStatus: CompleteAttemptStatus
}).and(ExecutionResult);
var CheckpointTypeEnum = {
  DOCKER: "DOCKER",
  KUBERNETES: "KUBERNETES"
};
var CheckpointType = external_exports.enum(Object.values(CheckpointTypeEnum));
var CheckpointInput = external_exports.object({
  type: CheckpointType,
  location: external_exports.string(),
  imageRef: external_exports.string().nullish(),
  reason: external_exports.string().nullish()
});
var TaskRunCheckpoint = CheckpointInput.merge(external_exports.object({
  id: external_exports.string(),
  friendlyId: external_exports.string()
}));
var RunExecutionData = external_exports.object({
  version: external_exports.literal("1"),
  snapshot: ExecutionSnapshot,
  run: BaseRunMetadata,
  batch: external_exports.object({
    id: external_exports.string(),
    friendlyId: external_exports.string()
  }).optional(),
  checkpoint: TaskRunCheckpoint.optional(),
  completedWaitpoints: external_exports.array(CompletedWaitpoint)
});
var CreateCheckpointResult = external_exports.discriminatedUnion("ok", [
  external_exports.object({
    ok: external_exports.literal(true),
    checkpoint: TaskRunCheckpoint
  }).merge(ExecutionResult),
  external_exports.object({
    ok: external_exports.literal(false),
    error: external_exports.string()
  })
]);
var MachineResources = external_exports.object({
  cpu: external_exports.number(),
  memory: external_exports.number()
});
var DequeueMessageCheckpoint = external_exports.object({
  id: external_exports.string(),
  type: CheckpointType,
  location: external_exports.string(),
  imageRef: external_exports.string().nullish(),
  reason: external_exports.string().nullish()
});
var PlacementTag = external_exports.object({
  key: external_exports.string(),
  values: external_exports.array(external_exports.string()).optional()
});
var DequeuedMessage = external_exports.object({
  version: external_exports.literal("1"),
  snapshot: ExecutionSnapshot,
  dequeuedAt: external_exports.coerce.date(),
  workerQueueLength: external_exports.number().optional(),
  image: external_exports.string().optional(),
  checkpoint: DequeueMessageCheckpoint.optional(),
  completedWaitpoints: external_exports.array(CompletedWaitpoint),
  backgroundWorker: external_exports.object({
    id: external_exports.string(),
    friendlyId: external_exports.string(),
    version: external_exports.string()
  }),
  deployment: external_exports.object({
    id: external_exports.string().optional(),
    friendlyId: external_exports.string().optional(),
    imagePlatform: external_exports.string().optional()
  }),
  run: external_exports.object({
    id: external_exports.string(),
    friendlyId: external_exports.string(),
    isTest: external_exports.boolean(),
    machine: MachinePreset,
    attemptNumber: external_exports.number(),
    masterQueue: external_exports.string(),
    traceContext: external_exports.record(external_exports.unknown())
  }),
  environment: external_exports.object({
    id: external_exports.string(),
    type: EnvironmentType
  }),
  organization: external_exports.object({
    id: external_exports.string()
  }),
  project: external_exports.object({
    id: external_exports.string()
  }),
  placementTags: external_exports.array(PlacementTag).optional()
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/api.js
var RunEngineVersion = external_exports.union([external_exports.literal("V1"), external_exports.literal("V2")]);
var WhoAmIResponseSchema = external_exports.object({
  userId: external_exports.string(),
  email: external_exports.string().email(),
  dashboardUrl: external_exports.string(),
  project: external_exports.object({
    name: external_exports.string(),
    url: external_exports.string(),
    orgTitle: external_exports.string()
  }).optional()
});
var GetProjectResponseBody = external_exports.object({
  id: external_exports.string(),
  externalRef: external_exports.string().describe("The external reference for the project, also known as the project ref, a unique identifier starting with proj_"),
  name: external_exports.string(),
  slug: external_exports.string(),
  createdAt: external_exports.coerce.date(),
  organization: external_exports.object({
    id: external_exports.string(),
    title: external_exports.string(),
    slug: external_exports.string(),
    createdAt: external_exports.coerce.date()
  })
});
var GetProjectsResponseBody = external_exports.array(GetProjectResponseBody);
var GetOrgsResponseBody = external_exports.array(external_exports.object({
  id: external_exports.string(),
  title: external_exports.string(),
  slug: external_exports.string(),
  createdAt: external_exports.coerce.date()
}));
var CreateProjectRequestBody = external_exports.object({
  name: external_exports.string().trim().min(1, "Name is required").max(255, "Name must be less than 255 characters")
});
var GetProjectEnvResponse = external_exports.object({
  apiKey: external_exports.string(),
  name: external_exports.string(),
  apiUrl: external_exports.string(),
  projectId: external_exports.string()
});
var GetWorkerTaskResponse = external_exports.object({
  id: external_exports.string(),
  slug: external_exports.string(),
  filePath: external_exports.string(),
  triggerSource: external_exports.string(),
  createdAt: external_exports.coerce.date(),
  payloadSchema: external_exports.any().nullish()
});
var GetWorkerByTagResponse = external_exports.object({
  worker: external_exports.object({
    id: external_exports.string(),
    version: external_exports.string(),
    engine: external_exports.string().nullish(),
    sdkVersion: external_exports.string().nullish(),
    cliVersion: external_exports.string().nullish(),
    tasks: external_exports.array(GetWorkerTaskResponse)
  }),
  urls: external_exports.object({
    runs: external_exports.string()
  })
});
var GetJWTRequestBody = external_exports.object({
  claims: external_exports.object({
    scopes: external_exports.array(external_exports.string()).default([])
  }).optional(),
  expirationTime: external_exports.union([external_exports.number(), external_exports.string()]).optional()
});
var GetJWTResponse = external_exports.object({
  token: external_exports.string()
});
var CreateBackgroundWorkerRequestBody = external_exports.object({
  localOnly: external_exports.boolean(),
  metadata: BackgroundWorkerMetadata,
  engine: RunEngineVersion.optional(),
  supportsLazyAttempts: external_exports.boolean().optional(),
  buildPlatform: external_exports.string().optional(),
  targetPlatform: external_exports.string().optional()
});
var CreateBackgroundWorkerResponse = external_exports.object({
  id: external_exports.string(),
  version: external_exports.string(),
  contentHash: external_exports.string()
});
var RunTag = external_exports.string().max(128, "Tags must be less than 128 characters");
var RunTags = external_exports.union([RunTag, RunTag.array()]);
var TriggerTaskRequestBody = external_exports.object({
  payload: external_exports.any(),
  context: external_exports.any(),
  options: external_exports.object({
    /** @deprecated engine v1 only */
    dependentAttempt: external_exports.string().optional(),
    /** @deprecated engine v1 only */
    parentAttempt: external_exports.string().optional(),
    /** @deprecated engine v1 only */
    dependentBatch: external_exports.string().optional(),
    /**
     * If triggered in a batch, this is the BatchTaskRun id
     */
    parentBatch: external_exports.string().optional(),
    /**
     * RunEngine v2
     * If triggered inside another run, the parentRunId is the friendly ID of the parent run.
     */
    parentRunId: external_exports.string().optional(),
    /**
     * RunEngine v2
     * Should be `true` if `triggerAndWait` or `batchTriggerAndWait`
     */
    resumeParentOnCompletion: external_exports.boolean().optional(),
    /**
     * Locks the version to the passed value.
     * Automatically set when using `triggerAndWait` or `batchTriggerAndWait`
     */
    lockToVersion: external_exports.string().optional(),
    queue: external_exports.object({
      name: external_exports.string(),
      // @deprecated, this is now specified on the queue
      concurrencyLimit: external_exports.number().int().optional()
    }).optional(),
    concurrencyKey: external_exports.string().optional(),
    delay: external_exports.string().or(external_exports.coerce.date()).optional(),
    idempotencyKey: external_exports.string().optional(),
    idempotencyKeyTTL: external_exports.string().optional(),
    machine: MachinePresetName.optional(),
    maxAttempts: external_exports.number().int().optional(),
    maxDuration: external_exports.number().optional(),
    metadata: external_exports.any(),
    metadataType: external_exports.string().optional(),
    payloadType: external_exports.string().optional(),
    tags: RunTags.optional(),
    test: external_exports.boolean().optional(),
    ttl: external_exports.string().or(external_exports.number().nonnegative().int()).optional(),
    priority: external_exports.number().optional(),
    bulkActionId: external_exports.string().optional(),
    region: external_exports.string().optional()
  }).optional()
});
var TriggerTaskResponse = external_exports.object({
  id: external_exports.string(),
  isCached: external_exports.boolean().optional()
});
var BatchTriggerTaskRequestBody = external_exports.object({
  items: TriggerTaskRequestBody.array(),
  dependentAttempt: external_exports.string().optional()
});
var BatchTriggerTaskItem = external_exports.object({
  task: external_exports.string(),
  payload: external_exports.any(),
  context: external_exports.any(),
  options: external_exports.object({
    concurrencyKey: external_exports.string().optional(),
    delay: external_exports.string().or(external_exports.coerce.date()).optional(),
    idempotencyKey: external_exports.string().optional(),
    idempotencyKeyTTL: external_exports.string().optional(),
    lockToVersion: external_exports.string().optional(),
    machine: MachinePresetName.optional(),
    maxAttempts: external_exports.number().int().optional(),
    maxDuration: external_exports.number().optional(),
    metadata: external_exports.any(),
    metadataType: external_exports.string().optional(),
    parentAttempt: external_exports.string().optional(),
    payloadType: external_exports.string().optional(),
    queue: external_exports.object({
      name: external_exports.string()
    }).optional(),
    tags: RunTags.optional(),
    test: external_exports.boolean().optional(),
    ttl: external_exports.string().or(external_exports.number().nonnegative().int()).optional(),
    priority: external_exports.number().optional(),
    region: external_exports.string().optional()
  }).optional()
});
var BatchTriggerTaskV2RequestBody = external_exports.object({
  items: BatchTriggerTaskItem.array(),
  /** @deprecated engine v1 only */
  dependentAttempt: external_exports.string().optional(),
  /**
   * RunEngine v2
   * If triggered inside another run, the parentRunId is the friendly ID of the parent run.
   */
  parentRunId: external_exports.string().optional(),
  /**
   * RunEngine v2
   * Should be `true` if `triggerAndWait` or `batchTriggerAndWait`
   */
  resumeParentOnCompletion: external_exports.boolean().optional()
});
var BatchTriggerTaskV2Response = external_exports.object({
  id: external_exports.string(),
  isCached: external_exports.boolean(),
  idempotencyKey: external_exports.string().optional(),
  runs: external_exports.array(external_exports.object({
    id: external_exports.string(),
    taskIdentifier: external_exports.string(),
    isCached: external_exports.boolean(),
    idempotencyKey: external_exports.string().optional()
  }))
});
var BatchTriggerTaskV3RequestBody = external_exports.object({
  items: BatchTriggerTaskItem.array(),
  /**
   * RunEngine v2
   * If triggered inside another run, the parentRunId is the friendly ID of the parent run.
   */
  parentRunId: external_exports.string().optional(),
  /**
   * RunEngine v2
   * Should be `true` if `triggerAndWait` or `batchTriggerAndWait`
   */
  resumeParentOnCompletion: external_exports.boolean().optional()
});
var BatchTriggerTaskV3Response = external_exports.object({
  id: external_exports.string(),
  runCount: external_exports.number()
});
var BatchTriggerTaskResponse = external_exports.object({
  batchId: external_exports.string(),
  runs: external_exports.string().array()
});
var GetBatchResponseBody = external_exports.object({
  id: external_exports.string(),
  items: external_exports.array(external_exports.object({
    id: external_exports.string(),
    taskRunId: external_exports.string(),
    status: external_exports.enum(["PENDING", "CANCELED", "COMPLETED", "FAILED"])
  }))
});
var AddTagsRequestBody = external_exports.object({
  tags: RunTags
});
var RescheduleRunRequestBody = external_exports.object({
  delay: external_exports.string().or(external_exports.coerce.date())
});
var GetEnvironmentVariablesResponseBody = external_exports.object({
  variables: external_exports.record(external_exports.string())
});
var StartDeploymentIndexingRequestBody = external_exports.object({
  imageReference: external_exports.string(),
  selfHosted: external_exports.boolean().optional()
});
var StartDeploymentIndexingResponseBody = external_exports.object({
  id: external_exports.string(),
  contentHash: external_exports.string()
});
var FinalizeDeploymentRequestBody = external_exports.object({
  skipPromotion: external_exports.boolean().optional(),
  imageDigest: external_exports.string().optional(),
  skipPushToRegistry: external_exports.boolean().optional()
});
var ProgressDeploymentRequestBody = external_exports.object({
  contentHash: external_exports.string().optional(),
  gitMeta: GitMeta.optional(),
  runtime: external_exports.string().optional()
});
var CancelDeploymentRequestBody = external_exports.object({
  reason: external_exports.string().max(200, "Reason must be less than 200 characters").optional()
});
var ExternalBuildData = external_exports.object({
  buildId: external_exports.string(),
  buildToken: external_exports.string(),
  projectId: external_exports.string()
});
var UpsertBranchRequestBody = external_exports.object({
  git: GitMeta.optional(),
  env: external_exports.enum(["preview"]),
  branch: external_exports.string()
});
var UpsertBranchResponseBody = external_exports.object({
  id: external_exports.string()
});
var InitializeDeploymentResponseBody = external_exports.object({
  id: external_exports.string(),
  contentHash: external_exports.string(),
  shortCode: external_exports.string(),
  version: external_exports.string(),
  imageTag: external_exports.string(),
  imagePlatform: external_exports.string(),
  externalBuildData: ExternalBuildData.optional().nullable()
});
var InitializeDeploymentRequestBody = external_exports.object({
  contentHash: external_exports.string(),
  userId: external_exports.string().optional(),
  /** @deprecated This is now determined by the webapp. This is only used to warn users with old CLI versions. */
  selfHosted: external_exports.boolean().optional(),
  gitMeta: GitMeta.optional(),
  type: external_exports.enum(["MANAGED", "UNMANAGED", "V1"]).optional(),
  runtime: external_exports.string().optional(),
  initialStatus: external_exports.enum(["PENDING", "BUILDING"]).optional()
});
var RemoteBuildProviderStatusResponseBody = external_exports.object({
  status: external_exports.enum(["operational", "degraded", "unknown"]),
  message: external_exports.string()
});
var GenerateRegistryCredentialsResponseBody = external_exports.object({
  username: external_exports.string(),
  password: external_exports.string(),
  expiresAt: external_exports.string(),
  repositoryUri: external_exports.string()
});
var DeploymentErrorData = external_exports.object({
  name: external_exports.string(),
  message: external_exports.string(),
  stack: external_exports.string().optional(),
  stderr: external_exports.string().optional()
});
var FailDeploymentRequestBody = external_exports.object({
  error: DeploymentErrorData
});
var FailDeploymentResponseBody = external_exports.object({
  id: external_exports.string()
});
var PromoteDeploymentResponseBody = external_exports.object({
  id: external_exports.string(),
  version: external_exports.string(),
  shortCode: external_exports.string()
});
var GetDeploymentResponseBody = external_exports.object({
  id: external_exports.string(),
  status: external_exports.enum([
    "PENDING",
    "INSTALLING",
    "BUILDING",
    "DEPLOYING",
    "DEPLOYED",
    "FAILED",
    "CANCELED",
    "TIMED_OUT"
  ]),
  contentHash: external_exports.string(),
  shortCode: external_exports.string(),
  version: external_exports.string(),
  imageReference: external_exports.string().nullish(),
  imagePlatform: external_exports.string(),
  externalBuildData: ExternalBuildData.optional().nullable(),
  errorData: DeploymentErrorData.nullish(),
  worker: external_exports.object({
    id: external_exports.string(),
    version: external_exports.string(),
    tasks: external_exports.array(external_exports.object({
      id: external_exports.string(),
      slug: external_exports.string(),
      filePath: external_exports.string(),
      exportName: external_exports.string().optional()
    }))
  }).optional()
});
var GetLatestDeploymentResponseBody = GetDeploymentResponseBody.omit({
  worker: true
});
var CreateUploadPayloadUrlResponseBody = external_exports.object({
  presignedUrl: external_exports.string()
});
var WorkersListResponseBody = external_exports.object({
  type: external_exports.string(),
  name: external_exports.string(),
  description: external_exports.string().nullish(),
  latestVersion: external_exports.string().nullish(),
  lastHeartbeatAt: external_exports.string().nullish(),
  isDefault: external_exports.boolean(),
  updatedAt: external_exports.coerce.date()
}).array();
var WorkersCreateRequestBody = external_exports.object({
  name: external_exports.string().optional(),
  description: external_exports.string().optional()
});
var WorkersCreateResponseBody = external_exports.object({
  workerGroup: external_exports.object({
    name: external_exports.string(),
    description: external_exports.string().nullish()
  }),
  token: external_exports.object({
    plaintext: external_exports.string()
  })
});
var DevConfigResponseBody = external_exports.object({
  environmentId: external_exports.string(),
  dequeueIntervalWithRun: external_exports.number(),
  dequeueIntervalWithoutRun: external_exports.number(),
  maxConcurrentRuns: external_exports.number(),
  engineUrl: external_exports.string()
});
var DevDequeueRequestBody = external_exports.object({
  currentWorker: external_exports.string(),
  oldWorkers: external_exports.string().array(),
  maxResources: MachineResources.optional()
});
var DevDequeueResponseBody = external_exports.object({
  dequeuedMessages: DequeuedMessage.array()
});
var ReplayRunResponse = external_exports.object({
  id: external_exports.string()
});
var CanceledRunResponse = external_exports.object({
  id: external_exports.string()
});
var ScheduleType = external_exports.union([external_exports.literal("DECLARATIVE"), external_exports.literal("IMPERATIVE")]);
var ScheduledTaskPayload = external_exports.object({
  /** The schedule id associated with this run (you can have many schedules for the same task).
    You can use this to remove the schedule, update it, etc */
  scheduleId: external_exports.string(),
  /** The type of schedule  `"DECLARATIVE"` or `"IMPERATIVE"`.
   *
   * **DECLARATIVE**  defined inline on your `schedules.task` using the `cron` property. They can only be created, updated or deleted by modifying the `cron` property on your task.
   *
   * **IMPERATIVE**  created using the `schedules.create` functions or in the dashboard.
   */
  type: ScheduleType,
  /** When the task was scheduled to run.
   * Note this will be slightly different from `new Date()` because it takes a few ms to run the task.
   *
   * This date is UTC. To output it as a string with a timezone you would do this:
   * ```ts
   * const formatted = payload.timestamp.toLocaleString("en-US", {
        timeZone: payload.timezone,
    });
    ```  */
  timestamp: external_exports.date(),
  /** When the task was last run (it has been).
    This can be undefined if it's never been run. This date is UTC. */
  lastTimestamp: external_exports.date().optional(),
  /** You can optionally provide an external id when creating the schedule.
    Usually you would use a userId or some other unique identifier.
    This defaults to undefined if you didn't provide one. */
  externalId: external_exports.string().optional(),
  /** The IANA timezone the schedule is set to. The default is UTC.
   * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones
   */
  timezone: external_exports.string(),
  /** The next 5 dates this task is scheduled to run */
  upcoming: external_exports.array(external_exports.date())
});
var CreateScheduleOptions = external_exports.object({
  /** The id of the task you want to attach to. */
  task: external_exports.string(),
  /**  The schedule in CRON format.
     *
     * ```txt
  *    *    *    *    *    *
                  
                  |
                   day of week (0 - 7, 1L - 7L) (0 or 7 is Sun)
               month (1 - 12)
           day of month (1 - 31, L)
       hour (0 - 23)
   minute (0 - 59)
     * ```
  
  "L" means the last. In the "day of week" field, 1L means the last Monday of the month. In the day of month field, L means the last day of the month.
  
     */
  cron: external_exports.string(),
  /** You can only create one schedule with this key. If you use it twice, the second call will update the schedule.
   *
   * This is required to prevent you from creating duplicate schedules. */
  deduplicationKey: external_exports.string(),
  /** Optionally, you can specify your own IDs (like a user ID) and then use it inside the run function of your task.
   *
   * This allows you to have per-user CRON tasks.
   */
  externalId: external_exports.string().optional(),
  /** Optionally, you can specify a timezone in the IANA format. If unset it will use UTC.
   * If specified then the CRON will be evaluated in that timezone and will respect daylight savings.
   *
   * If you set the CRON to `0 0 * * *` and the timezone to `America/New_York` then the task will run at midnight in New York time, no matter whether it's daylight savings or not.
   *
   * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones
   *
   * @example "America/New_York", "Europe/London", "Asia/Tokyo", "Africa/Cairo"
   *
   */
  timezone: external_exports.string().optional()
});
var UpdateScheduleOptions = CreateScheduleOptions.omit({ deduplicationKey: true });
var ScheduleGenerator = external_exports.object({
  type: external_exports.literal("CRON"),
  expression: external_exports.string(),
  description: external_exports.string()
});
var ScheduleObject = external_exports.object({
  id: external_exports.string(),
  type: ScheduleType,
  task: external_exports.string(),
  active: external_exports.boolean(),
  deduplicationKey: external_exports.string().nullish(),
  externalId: external_exports.string().nullish(),
  generator: ScheduleGenerator,
  timezone: external_exports.string(),
  nextRun: external_exports.coerce.date().nullish(),
  environments: external_exports.array(external_exports.object({
    id: external_exports.string(),
    type: external_exports.string(),
    userName: external_exports.string().nullish()
  }))
});
var DeletedScheduleObject = external_exports.object({
  id: external_exports.string()
});
var ListSchedulesResult = external_exports.object({
  data: external_exports.array(ScheduleObject),
  pagination: external_exports.object({
    currentPage: external_exports.number(),
    totalPages: external_exports.number(),
    count: external_exports.number()
  })
});
var ListScheduleOptions = external_exports.object({
  page: external_exports.number().optional(),
  perPage: external_exports.number().optional()
});
var TimezonesResult = external_exports.object({
  timezones: external_exports.array(external_exports.string())
});
var RunStatus = external_exports.enum([
  /// Task is waiting for a version update because it cannot execute without additional information (task, queue, etc.)
  "PENDING_VERSION",
  /// Task is waiting to be executed by a worker
  "QUEUED",
  /// Task is waiting to be executed by a worker
  "DEQUEUED",
  /// Task is currently being executed by a worker
  "EXECUTING",
  /// Task has been paused by the system, and will be resumed by the system
  "WAITING",
  /// Task has been completed successfully
  "COMPLETED",
  /// Task has been canceled by the user
  "CANCELED",
  /// Task has been completed with errors
  "FAILED",
  /// Task has crashed and won't be retried, most likely the worker ran out of resources, e.g. memory or storage
  "CRASHED",
  /// Task has failed to complete, due to an error in the system
  "SYSTEM_FAILURE",
  /// Task has been scheduled to run at a specific time
  "DELAYED",
  /// Task has expired and won't be executed
  "EXPIRED",
  /// Task has reached it's maxDuration and has been stopped
  "TIMED_OUT"
]);
var AttemptStatus = external_exports.enum([
  "PENDING",
  "EXECUTING",
  "PAUSED",
  "COMPLETED",
  "FAILED",
  "CANCELED"
]);
var RunEnvironmentDetails = external_exports.object({
  id: external_exports.string(),
  name: external_exports.string(),
  user: external_exports.string().optional()
});
var RunScheduleDetails = external_exports.object({
  id: external_exports.string(),
  externalId: external_exports.string().optional(),
  deduplicationKey: external_exports.string().optional(),
  generator: ScheduleGenerator
});
var TriggerFunction = external_exports.enum([
  "triggerAndWait",
  "trigger",
  "batchTriggerAndWait",
  "batchTrigger"
]);
var CommonRunFields = {
  id: external_exports.string(),
  status: RunStatus,
  taskIdentifier: external_exports.string(),
  idempotencyKey: external_exports.string().optional(),
  version: external_exports.string().optional(),
  isQueued: external_exports.boolean(),
  isExecuting: external_exports.boolean(),
  isWaiting: external_exports.boolean(),
  isCompleted: external_exports.boolean(),
  isSuccess: external_exports.boolean(),
  isFailed: external_exports.boolean(),
  isCancelled: external_exports.boolean(),
  isTest: external_exports.boolean(),
  createdAt: external_exports.coerce.date(),
  updatedAt: external_exports.coerce.date(),
  startedAt: external_exports.coerce.date().optional(),
  finishedAt: external_exports.coerce.date().optional(),
  delayedUntil: external_exports.coerce.date().optional(),
  ttl: external_exports.string().optional(),
  expiredAt: external_exports.coerce.date().optional(),
  tags: external_exports.string().array(),
  costInCents: external_exports.number(),
  baseCostInCents: external_exports.number(),
  durationMs: external_exports.number(),
  metadata: external_exports.record(external_exports.any()).optional()
};
var RetrieveRunCommandFields = {
  ...CommonRunFields,
  depth: external_exports.number(),
  triggerFunction: external_exports.enum(["triggerAndWait", "trigger", "batchTriggerAndWait", "batchTrigger"]),
  batchId: external_exports.string().optional()
};
var RelatedRunDetails = external_exports.object(RetrieveRunCommandFields);
var RetrieveRunResponse = external_exports.object({
  ...RetrieveRunCommandFields,
  payload: external_exports.any().optional(),
  payloadPresignedUrl: external_exports.string().optional(),
  output: external_exports.any().optional(),
  outputPresignedUrl: external_exports.string().optional(),
  error: SerializedError.optional(),
  schedule: RunScheduleDetails.optional(),
  relatedRuns: external_exports.object({
    root: RelatedRunDetails.optional(),
    parent: RelatedRunDetails.optional(),
    children: external_exports.array(RelatedRunDetails).optional()
  }),
  attemptCount: external_exports.number().default(0)
});
var ListRunResponseItem = external_exports.object({
  ...CommonRunFields,
  env: RunEnvironmentDetails
});
var ListRunResponse = external_exports.object({
  data: external_exports.array(ListRunResponseItem),
  pagination: external_exports.object({
    next: external_exports.string().optional(),
    previous: external_exports.string().optional()
  })
});
var CreateEnvironmentVariableRequestBody = external_exports.object({
  name: external_exports.string(),
  value: external_exports.string()
});
var UpdateEnvironmentVariableRequestBody = external_exports.object({
  value: external_exports.string()
});
var ImportEnvironmentVariablesRequestBody = external_exports.object({
  variables: external_exports.record(external_exports.string()),
  parentVariables: external_exports.record(external_exports.string()).optional(),
  override: external_exports.boolean().optional()
});
var EnvironmentVariableResponseBody = external_exports.object({
  success: external_exports.boolean()
});
var EnvironmentVariableValue = external_exports.object({
  value: external_exports.string()
});
var EnvironmentVariable = external_exports.object({
  name: external_exports.string(),
  value: external_exports.string()
});
var EnvironmentVariables = external_exports.array(EnvironmentVariable);
var EnvironmentVariableWithSecret = external_exports.object({
  /** The name of the env var, e.g. `DATABASE_URL` */
  name: external_exports.string(),
  /** The value of the env var. If it's a secret, this will be a redacted value, not the real value.  */
  value: external_exports.string(),
  /**
   * Whether the env var is a secret or not.
   * When you create env vars you can mark them as secrets.
   *
   * You can't view the value of a secret env var after setting it initially.
   * For a secret env var, the value will be redacted.
   */
  isSecret: external_exports.boolean()
});
var UpdateMetadataResponseBody = external_exports.object({
  metadata: external_exports.record(DeserializedJsonSchema)
});
var RawShapeDate = external_exports.string().transform((val) => `${val}Z`).pipe(external_exports.coerce.date());
var RawOptionalShapeDate = external_exports.string().nullish().transform((val) => val ? /* @__PURE__ */ new Date(`${val}Z`) : val);
var SubscribeRunRawShape = external_exports.object({
  id: external_exports.string(),
  taskIdentifier: external_exports.string(),
  friendlyId: external_exports.string(),
  status: external_exports.string(),
  createdAt: RawShapeDate,
  updatedAt: RawShapeDate,
  startedAt: RawOptionalShapeDate,
  delayUntil: RawOptionalShapeDate,
  queuedAt: RawOptionalShapeDate,
  expiredAt: RawOptionalShapeDate,
  completedAt: RawOptionalShapeDate,
  idempotencyKey: external_exports.string().nullish(),
  number: external_exports.number().default(0),
  isTest: external_exports.boolean().default(false),
  usageDurationMs: external_exports.number().default(0),
  costInCents: external_exports.number().default(0),
  baseCostInCents: external_exports.number().default(0),
  ttl: external_exports.string().nullish(),
  payload: external_exports.string().nullish(),
  payloadType: external_exports.string().nullish(),
  metadata: external_exports.string().nullish(),
  metadataType: external_exports.string().nullish(),
  output: external_exports.string().nullish(),
  outputType: external_exports.string().nullish(),
  runTags: external_exports.array(external_exports.string()).nullish().default([]),
  error: TaskRunError.nullish(),
  realtimeStreams: external_exports.array(external_exports.string()).nullish().default([])
});
var BatchStatus = external_exports.enum(["PENDING", "COMPLETED"]);
var RetrieveBatchResponse = external_exports.object({
  id: external_exports.string(),
  status: BatchStatus,
  idempotencyKey: external_exports.string().optional(),
  createdAt: external_exports.coerce.date(),
  updatedAt: external_exports.coerce.date(),
  runCount: external_exports.number(),
  runs: external_exports.array(external_exports.string())
});
var RetrieveBatchV2Response = external_exports.object({
  id: external_exports.string(),
  status: BatchStatus,
  idempotencyKey: external_exports.string().optional(),
  createdAt: external_exports.coerce.date(),
  updatedAt: external_exports.coerce.date(),
  runCount: external_exports.number(),
  runs: external_exports.array(external_exports.string())
});
var SubscribeRealtimeStreamChunkRawShape = external_exports.object({
  id: external_exports.string(),
  runId: external_exports.string(),
  sequence: external_exports.number(),
  key: external_exports.string(),
  value: external_exports.string(),
  createdAt: external_exports.coerce.date()
});
var TimePeriod = external_exports.string().or(external_exports.coerce.date());
var CreateWaitpointTokenRequestBody = external_exports.object({
  /**
   * An optional idempotency key for the waitpoint.
   * If you use the same key twice (and the key hasn't expired), you will get the original waitpoint back.
   *
   * Note: This waitpoint may already be complete, in which case when you wait for it, it will immediately continue.
   */
  idempotencyKey: external_exports.string().optional(),
  /**
   * When set, this means the passed in idempotency key will expire after this time.
   * This means after that time if you pass the same idempotency key again, you will get a new waitpoint.
   */
  idempotencyKeyTTL: external_exports.string().optional(),
  /** The resume token will timeout after this time.
   * If you are waiting for the token in a run, the token will return a result where `ok` is false.
   *
   * You can pass a `Date` object, or a string in this format: "30s", "1m", "2h", "3d", "4w".
   */
  timeout: TimePeriod.optional(),
  /**
   * Tags to attach to the waitpoint. Tags can be used to filter waitpoints in the dashboard.
   *
   * You can set up to 10 tags per waitpoint, they must be less than 128 characters each.
   *
   * We recommend prefixing tags with a namespace using an underscore or colon, like `user_1234567` or `org:9876543`.
   *
   * @example
   *
   * ```ts
   * await wait.createToken({ tags: ["user:1234567", "org:9876543"] });
   * ```
   */
  tags: RunTags.optional()
});
var CreateWaitpointTokenResponseBody = external_exports.object({
  id: external_exports.string(),
  isCached: external_exports.boolean(),
  url: external_exports.string()
});
var waitpointTokenStatuses = ["WAITING", "COMPLETED", "TIMED_OUT"];
var WaitpointTokenStatus = external_exports.enum(waitpointTokenStatuses);
var WaitpointTokenItem = external_exports.object({
  id: external_exports.string(),
  /** If you make a POST request to this URL, it will complete the waitpoint. */
  url: external_exports.string(),
  status: WaitpointTokenStatus,
  completedAt: external_exports.coerce.date().optional(),
  completedAfter: external_exports.coerce.date().optional(),
  timeoutAt: external_exports.coerce.date().optional(),
  idempotencyKey: external_exports.string().optional(),
  idempotencyKeyExpiresAt: external_exports.coerce.date().optional(),
  tags: external_exports.array(external_exports.string()),
  createdAt: external_exports.coerce.date()
});
var WaitpointListTokenItem = WaitpointTokenItem.omit({
  completedAfter: true
});
var WaitpointRetrieveTokenResponse = WaitpointListTokenItem.and(external_exports.object({
  output: external_exports.string().optional(),
  outputType: external_exports.string().optional(),
  outputIsError: external_exports.boolean().optional()
}));
var CompleteWaitpointTokenRequestBody = external_exports.object({
  data: external_exports.any().nullish()
});
var CompleteWaitpointTokenResponseBody = external_exports.object({
  success: external_exports.literal(true)
});
var WaitForWaitpointTokenResponseBody = external_exports.object({
  success: external_exports.boolean()
});
var WaitForDurationRequestBody = external_exports.object({
  /**
   * An optional idempotency key for the waitpoint.
   * If you use the same key twice (and the key hasn't expired), you will get the original waitpoint back.
   *
   * Note: This waitpoint may already be complete, in which case when you wait for it, it will immediately continue.
   */
  idempotencyKey: external_exports.string().optional(),
  /**
   * When set, this means the passed in idempotency key will expire after this time.
   * This means after that time if you pass the same idempotency key again, you will get a new waitpoint.
   */
  idempotencyKeyTTL: external_exports.string().optional(),
  /**
   * The date that the waitpoint will complete.
   */
  date: external_exports.coerce.date()
});
var WaitForDurationResponseBody = external_exports.object({
  /**
      If you pass an idempotencyKey, you may actually not need to wait.
      Use this date to determine when to continue.
  */
  waitUntil: external_exports.coerce.date(),
  waitpoint: external_exports.object({
    id: external_exports.string()
  })
});
var ApiDeploymentCommonShape = {
  from: external_exports.string().describe("The date to start the search from, in ISO 8601 format").optional(),
  to: external_exports.string().describe("The date to end the search, in ISO 8601 format").optional(),
  period: external_exports.string().describe("The period to search within (e.g. 1d, 7d, 3h, etc.)").optional(),
  status: external_exports.enum(["PENDING", "BUILDING", "DEPLOYING", "DEPLOYED", "FAILED", "CANCELED", "TIMED_OUT"]).describe("Filter deployments that are in this status").optional()
};
var ApiDeploymentListPaginationCursor = external_exports.string().describe("The deployment ID to start the search from, to get the next page").optional();
var ApiDeploymentListPaginationLimit = external_exports.coerce.number().describe("The number of deployments to return, defaults to 20 (max 100)").min(1, "Limit must be at least 1").max(100, "Limit must be less than 100").optional();
var ApiDeploymentListParams = {
  ...ApiDeploymentCommonShape,
  cursor: ApiDeploymentListPaginationCursor,
  limit: ApiDeploymentListPaginationLimit
};
var ApiDeploymentListOptions = external_exports.object(ApiDeploymentListParams);
var ApiDeploymentListSearchParams = external_exports.object({
  ...ApiDeploymentCommonShape,
  "page[after]": ApiDeploymentListPaginationCursor,
  "page[size]": ApiDeploymentListPaginationLimit
});
var ApiDeploymentListResponseItem = external_exports.object({
  id: external_exports.string(),
  createdAt: external_exports.coerce.date(),
  shortCode: external_exports.string(),
  version: external_exports.string(),
  runtime: external_exports.string(),
  runtimeVersion: external_exports.string(),
  status: external_exports.enum([
    "PENDING",
    "BUILDING",
    "DEPLOYING",
    "DEPLOYED",
    "FAILED",
    "CANCELED",
    "TIMED_OUT"
  ]),
  deployedAt: external_exports.coerce.date().optional(),
  git: external_exports.record(external_exports.any()).optional(),
  error: DeploymentErrorData.optional()
});
var ApiBranchListResponseBody = external_exports.object({
  branches: external_exports.array(external_exports.object({
    id: external_exports.string(),
    name: external_exports.string(),
    createdAt: external_exports.coerce.date(),
    updatedAt: external_exports.coerce.date(),
    git: external_exports.record(external_exports.any()).optional(),
    isPaused: external_exports.boolean()
  }))
});
var RetrieveRunTraceSpanSchema = external_exports.object({
  id: external_exports.string(),
  parentId: external_exports.string().optional(),
  runId: external_exports.string(),
  data: external_exports.object({
    message: external_exports.string(),
    taskSlug: external_exports.string().optional(),
    taskPath: external_exports.string().optional(),
    events: external_exports.array(external_exports.any()).optional(),
    startTime: external_exports.coerce.date(),
    duration: external_exports.number(),
    isError: external_exports.boolean(),
    isPartial: external_exports.boolean(),
    isCancelled: external_exports.boolean(),
    level: external_exports.string(),
    workerVersion: external_exports.string().optional(),
    queueName: external_exports.string().optional(),
    machinePreset: external_exports.string().optional(),
    properties: external_exports.record(external_exports.any()).optional(),
    output: external_exports.unknown().optional()
  })
});
var RetrieveRunTraceSpan = RetrieveRunTraceSpanSchema.extend({
  children: external_exports.lazy(() => RetrieveRunTraceSpan.array())
});
var RetrieveRunTraceResponseBody = external_exports.object({
  trace: external_exports.object({
    traceId: external_exports.string(),
    rootSpan: RetrieveRunTraceSpan
  })
});
var CreateStreamResponseBody = external_exports.object({
  version: external_exports.string()
});
var AppendToStreamResponseBody = external_exports.object({
  ok: external_exports.boolean(),
  message: external_exports.string().optional()
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/messages.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/build.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/config.js
init_esm();
var ConfigManifest = external_exports.object({
  project: external_exports.string(),
  dirs: external_exports.string().array()
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/build.js
var BuildExternal = external_exports.object({
  name: external_exports.string(),
  version: external_exports.string()
});
var BuildTarget = external_exports.enum(["dev", "deploy", "unmanaged"]);
var BuildRuntime = external_exports.enum(["node", "node-22", "bun"]);
var BuildManifest = external_exports.object({
  target: BuildTarget,
  packageVersion: external_exports.string(),
  cliPackageVersion: external_exports.string(),
  contentHash: external_exports.string(),
  runtime: BuildRuntime,
  environment: external_exports.string(),
  branch: external_exports.string().optional(),
  config: ConfigManifest,
  files: external_exports.array(TaskFile),
  sources: external_exports.record(external_exports.object({
    contents: external_exports.string(),
    contentHash: external_exports.string()
  })),
  outputPath: external_exports.string(),
  runWorkerEntryPoint: external_exports.string(),
  // Dev & Deploy has a runWorkerEntryPoint
  runControllerEntryPoint: external_exports.string().optional(),
  // Only deploy has a runControllerEntryPoint
  indexWorkerEntryPoint: external_exports.string(),
  // Dev & Deploy has a indexWorkerEntryPoint
  indexControllerEntryPoint: external_exports.string().optional(),
  // Only deploy has a indexControllerEntryPoint
  loaderEntryPoint: external_exports.string().optional(),
  initEntryPoint: external_exports.string().optional(),
  // Optional init.ts entry point
  configPath: external_exports.string(),
  externals: BuildExternal.array().optional(),
  build: external_exports.object({
    env: external_exports.record(external_exports.string()).optional(),
    commands: external_exports.array(external_exports.string()).optional()
  }),
  customConditions: external_exports.array(external_exports.string()).optional(),
  deploy: external_exports.object({
    env: external_exports.record(external_exports.string()).optional(),
    sync: external_exports.object({
      env: external_exports.record(external_exports.string()).optional(),
      parentEnv: external_exports.record(external_exports.string()).optional()
    }).optional()
  }),
  image: external_exports.object({
    pkgs: external_exports.array(external_exports.string()).optional(),
    instructions: external_exports.array(external_exports.string()).optional()
  }).optional(),
  otelImportHook: external_exports.object({
    include: external_exports.array(external_exports.string()).optional(),
    exclude: external_exports.array(external_exports.string()).optional()
  }).optional()
});
var IndexMessage = external_exports.object({
  type: external_exports.literal("index"),
  data: external_exports.object({
    build: BuildManifest
  })
});
var WorkerManifest = external_exports.object({
  configPath: external_exports.string(),
  tasks: TaskManifest.array(),
  queues: QueueManifest.array().optional(),
  workerEntryPoint: external_exports.string(),
  controllerEntryPoint: external_exports.string().optional(),
  loaderEntryPoint: external_exports.string().optional(),
  initEntryPoint: external_exports.string().optional(),
  // Optional init.ts entry point
  runtime: BuildRuntime,
  runtimeVersion: external_exports.string().optional(),
  customConditions: external_exports.array(external_exports.string()).optional(),
  timings: external_exports.record(external_exports.number()).optional(),
  processKeepAlive: external_exports.object({
    enabled: external_exports.boolean(),
    maxExecutionsPerProcess: external_exports.number().int().positive().optional()
  }).optional(),
  otelImportHook: external_exports.object({
    include: external_exports.array(external_exports.string()).optional(),
    exclude: external_exports.array(external_exports.string()).optional()
  }).optional()
});
var WorkerManifestMessage = external_exports.object({
  type: external_exports.literal("worker-manifest"),
  data: external_exports.object({
    manifest: WorkerManifest
  })
});
var ImportError = external_exports.object({
  message: external_exports.string(),
  file: external_exports.string(),
  stack: external_exports.string().optional(),
  name: external_exports.string().optional()
});
var ImportTaskFileErrors = external_exports.array(ImportError);

// node_modules/@trigger.dev/core/dist/esm/v3/runEngineWorker/supervisor/schemas.js
init_esm();
var WorkerApiHeartbeatRequestBody = external_exports.object({
  cpu: external_exports.object({
    used: external_exports.number(),
    available: external_exports.number()
  }),
  memory: external_exports.object({
    used: external_exports.number(),
    available: external_exports.number()
  }),
  tasks: external_exports.array(external_exports.string())
});
var WorkerApiHeartbeatResponseBody = external_exports.object({
  ok: external_exports.literal(true)
});
var WorkerApiSuspendRunRequestBody = external_exports.discriminatedUnion("success", [
  external_exports.object({
    success: external_exports.literal(true),
    checkpoint: CheckpointInput
  }),
  external_exports.object({
    success: external_exports.literal(false),
    error: external_exports.string()
  })
]);
var WorkerApiSuspendRunResponseBody = external_exports.object({
  ok: external_exports.literal(true)
});
var WorkerApiConnectRequestBody = external_exports.object({
  metadata: external_exports.record(external_exports.any())
});
var WorkerApiConnectResponseBody = external_exports.object({
  ok: external_exports.literal(true),
  workerGroup: external_exports.object({
    type: external_exports.string(),
    name: external_exports.string()
  })
});
var WorkerApiDequeueRequestBody = external_exports.object({
  maxResources: MachineResources.optional(),
  maxRunCount: external_exports.number().optional()
});
var WorkerApiDequeueResponseBody = DequeuedMessage.array();
var WorkerApiRunHeartbeatRequestBody = external_exports.object({
  cpu: external_exports.number().optional(),
  memory: external_exports.number().optional()
});
var WorkerApiRunHeartbeatResponseBody = external_exports.object({
  ok: external_exports.literal(true)
});
var WorkerApiRunAttemptStartRequestBody = external_exports.object({
  isWarmStart: external_exports.boolean().optional()
});
var WorkerApiRunAttemptStartResponseBody = StartRunAttemptResult.and(external_exports.object({
  envVars: external_exports.record(external_exports.string())
}));
var WorkerApiRunAttemptCompleteRequestBody = external_exports.object({
  completion: TaskRunExecutionResult
});
var WorkerApiRunAttemptCompleteResponseBody = external_exports.object({
  result: CompleteRunAttemptResult
});
var WorkerApiRunLatestSnapshotResponseBody = external_exports.object({
  execution: RunExecutionData
});
var WorkerApiDequeueFromVersionResponseBody = DequeuedMessage.array();
var DebugLogPropertiesValue = external_exports.union([
  external_exports.string(),
  external_exports.number(),
  external_exports.boolean(),
  external_exports.array(external_exports.string().nullish()),
  external_exports.array(external_exports.number().nullish()),
  external_exports.array(external_exports.boolean().nullish())
]);
var DebugLogProperties = external_exports.record(external_exports.string(), DebugLogPropertiesValue.optional());
var DebugLogPropertiesInput = external_exports.record(external_exports.string(), external_exports.unknown());
var WorkerApiDebugLogBodyInput = external_exports.object({
  time: external_exports.coerce.date(),
  message: external_exports.string(),
  properties: DebugLogPropertiesInput.optional()
});
var WorkerApiDebugLogBody = external_exports.object({
  time: external_exports.coerce.date(),
  message: external_exports.string(),
  properties: DebugLogProperties.optional()
});
var WorkerApiSuspendCompletionResponseBody = external_exports.object({
  success: external_exports.boolean(),
  error: external_exports.string().optional()
});
var WorkerApiRunSnapshotsSinceResponseBody = external_exports.object({
  snapshots: external_exports.array(RunExecutionData)
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/messages.js
var AckCallbackResult = external_exports.discriminatedUnion("success", [
  external_exports.object({
    success: external_exports.literal(false),
    error: external_exports.object({
      name: external_exports.string(),
      message: external_exports.string(),
      stack: external_exports.string().optional(),
      stderr: external_exports.string().optional()
    })
  }),
  external_exports.object({
    success: external_exports.literal(true)
  })
]);
var BackgroundWorkerServerMessages = external_exports.discriminatedUnion("type", [
  external_exports.object({
    type: external_exports.literal("CANCEL_ATTEMPT"),
    taskAttemptId: external_exports.string(),
    taskRunId: external_exports.string()
  }),
  external_exports.object({
    type: external_exports.literal("SCHEDULE_ATTEMPT"),
    image: external_exports.string(),
    version: external_exports.string(),
    machine: MachinePreset,
    nextAttemptNumber: external_exports.number().optional(),
    // identifiers
    id: external_exports.string().optional(),
    // TODO: Remove this completely in a future release
    envId: external_exports.string(),
    envType: EnvironmentType,
    orgId: external_exports.string(),
    projectId: external_exports.string(),
    runId: external_exports.string(),
    dequeuedAt: external_exports.number().optional()
  }),
  external_exports.object({
    type: external_exports.literal("EXECUTE_RUN_LAZY_ATTEMPT"),
    payload: TaskRunExecutionLazyAttemptPayload
  })
]);
var serverWebsocketMessages = {
  SERVER_READY: external_exports.object({
    version: external_exports.literal("v1").default("v1"),
    id: external_exports.string()
  }),
  BACKGROUND_WORKER_MESSAGE: external_exports.object({
    version: external_exports.literal("v1").default("v1"),
    backgroundWorkerId: external_exports.string(),
    data: BackgroundWorkerServerMessages
  })
};
var BackgroundWorkerClientMessages = external_exports.discriminatedUnion("type", [
  external_exports.object({
    version: external_exports.literal("v1").default("v1"),
    type: external_exports.literal("TASK_RUN_COMPLETED"),
    completion: TaskRunExecutionResult,
    execution: V3TaskRunExecution
  }),
  external_exports.object({
    version: external_exports.literal("v1").default("v1"),
    type: external_exports.literal("TASK_RUN_FAILED_TO_RUN"),
    completion: TaskRunFailedExecutionResult
  }),
  external_exports.object({
    version: external_exports.literal("v1").default("v1"),
    type: external_exports.literal("TASK_HEARTBEAT"),
    id: external_exports.string()
  }),
  external_exports.object({
    version: external_exports.literal("v1").default("v1"),
    type: external_exports.literal("TASK_RUN_HEARTBEAT"),
    id: external_exports.string()
  })
]);
var ServerBackgroundWorker = external_exports.object({
  id: external_exports.string(),
  version: external_exports.string(),
  contentHash: external_exports.string(),
  engine: RunEngineVersionSchema.optional()
});
var clientWebsocketMessages = {
  READY_FOR_TASKS: external_exports.object({
    version: external_exports.literal("v1").default("v1"),
    backgroundWorkerId: external_exports.string(),
    inProgressRuns: external_exports.string().array().optional()
  }),
  BACKGROUND_WORKER_DEPRECATED: external_exports.object({
    version: external_exports.literal("v1").default("v1"),
    backgroundWorkerId: external_exports.string()
  }),
  BACKGROUND_WORKER_MESSAGE: external_exports.object({
    version: external_exports.literal("v1").default("v1"),
    backgroundWorkerId: external_exports.string(),
    data: BackgroundWorkerClientMessages
  })
};
var UncaughtExceptionMessage = external_exports.object({
  version: external_exports.literal("v1").default("v1"),
  error: external_exports.object({
    name: external_exports.string(),
    message: external_exports.string(),
    stack: external_exports.string().optional()
  }),
  origin: external_exports.enum(["uncaughtException", "unhandledRejection"])
});
var TaskMetadataFailedToParseData = external_exports.object({
  version: external_exports.literal("v1").default("v1"),
  tasks: external_exports.unknown(),
  zodIssues: external_exports.custom((v2) => {
    return Array.isArray(v2) && v2.every((issue) => typeof issue === "object" && "message" in issue);
  })
});
var indexerToWorkerMessages = {
  INDEX_COMPLETE: external_exports.object({
    version: external_exports.literal("v1").default("v1"),
    manifest: WorkerManifest,
    importErrors: ImportTaskFileErrors
  }),
  TASKS_FAILED_TO_PARSE: TaskMetadataFailedToParseData,
  UNCAUGHT_EXCEPTION: UncaughtExceptionMessage
};
var ExecutorToWorkerMessageCatalog = {
  TASK_RUN_COMPLETED: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      execution: TaskRunExecution,
      result: TaskRunExecutionResult
    })
  },
  TASK_HEARTBEAT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      id: external_exports.string()
    })
  },
  UNCAUGHT_EXCEPTION: {
    message: UncaughtExceptionMessage
  },
  SEND_DEBUG_LOG: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      message: external_exports.string(),
      properties: DebugLogPropertiesInput.optional()
    })
  },
  SET_SUSPENDABLE: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      suspendable: external_exports.boolean()
    })
  },
  MAX_DURATION_EXCEEDED: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      maxDurationInSeconds: external_exports.number(),
      elapsedTimeInSeconds: external_exports.number()
    })
  }
};
var WorkerToExecutorMessageCatalog = {
  EXECUTE_TASK_RUN: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      execution: TaskRunExecution,
      traceContext: external_exports.record(external_exports.unknown()),
      metadata: ServerBackgroundWorker,
      metrics: TaskRunExecutionMetrics.optional(),
      env: external_exports.record(external_exports.string()).optional(),
      isWarmStart: external_exports.boolean().optional()
    })
  },
  FLUSH: {
    message: external_exports.object({
      timeoutInMs: external_exports.number()
    }),
    callback: external_exports.void()
  },
  CANCEL: {
    message: external_exports.object({
      timeoutInMs: external_exports.number()
    }),
    callback: external_exports.void()
  },
  RESOLVE_WAITPOINT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      waitpoint: CompletedWaitpoint
    })
  }
};
var ProviderToPlatformMessages = {
  LOG: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      data: external_exports.string()
    })
  },
  LOG_WITH_ACK: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      data: external_exports.string()
    }),
    callback: external_exports.object({
      status: external_exports.literal("ok")
    })
  },
  WORKER_CRASHED: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string(),
      reason: external_exports.string().optional(),
      exitCode: external_exports.number().optional(),
      message: external_exports.string().optional(),
      logs: external_exports.string().optional(),
      /** This means we should only update the error if one exists */
      overrideCompletion: external_exports.boolean().optional(),
      errorCode: TaskRunInternalError.shape.code.optional()
    })
  },
  INDEXING_FAILED: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      deploymentId: external_exports.string(),
      error: external_exports.object({
        name: external_exports.string(),
        message: external_exports.string(),
        stack: external_exports.string().optional(),
        stderr: external_exports.string().optional()
      }),
      overrideCompletion: external_exports.boolean().optional()
    })
  }
};
var PlatformToProviderMessages = {
  INDEX: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      imageTag: external_exports.string(),
      shortCode: external_exports.string(),
      apiKey: external_exports.string(),
      apiUrl: external_exports.string(),
      // identifiers
      envId: external_exports.string(),
      envType: EnvironmentType,
      orgId: external_exports.string(),
      projectId: external_exports.string(),
      deploymentId: external_exports.string()
    }),
    callback: AckCallbackResult
  },
  RESTORE: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      type: external_exports.enum(["DOCKER", "KUBERNETES"]),
      location: external_exports.string(),
      reason: external_exports.string().optional(),
      imageRef: external_exports.string(),
      attemptNumber: external_exports.number().optional(),
      machine: MachinePreset,
      // identifiers
      checkpointId: external_exports.string(),
      envId: external_exports.string(),
      envType: EnvironmentType,
      orgId: external_exports.string(),
      projectId: external_exports.string(),
      runId: external_exports.string()
    })
  },
  PRE_PULL_DEPLOYMENT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      imageRef: external_exports.string(),
      shortCode: external_exports.string(),
      // identifiers
      envId: external_exports.string(),
      envType: EnvironmentType,
      orgId: external_exports.string(),
      projectId: external_exports.string(),
      deploymentId: external_exports.string()
    })
  }
};
var CreateWorkerMessage = external_exports.object({
  projectRef: external_exports.string(),
  envId: external_exports.string(),
  deploymentId: external_exports.string(),
  metadata: external_exports.object({
    cliPackageVersion: external_exports.string().optional(),
    contentHash: external_exports.string(),
    packageVersion: external_exports.string(),
    tasks: TaskResource.array()
  })
});
var CoordinatorToPlatformMessages = {
  LOG: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      metadata: external_exports.any(),
      text: external_exports.string()
    })
  },
  CREATE_WORKER: {
    message: external_exports.discriminatedUnion("version", [
      CreateWorkerMessage.extend({
        version: external_exports.literal("v1")
      }),
      CreateWorkerMessage.extend({
        version: external_exports.literal("v2"),
        supportsLazyAttempts: external_exports.boolean()
      })
    ]),
    callback: external_exports.discriminatedUnion("success", [
      external_exports.object({
        success: external_exports.literal(false)
      }),
      external_exports.object({
        success: external_exports.literal(true)
      })
    ])
  },
  CREATE_TASK_RUN_ATTEMPT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string(),
      envId: external_exports.string()
    }),
    callback: external_exports.discriminatedUnion("success", [
      external_exports.object({
        success: external_exports.literal(false),
        reason: external_exports.string().optional()
      }),
      external_exports.object({
        success: external_exports.literal(true),
        executionPayload: V3ProdTaskRunExecutionPayload
      })
    ])
  },
  // Deprecated: Only workers without lazy attempt support will use this
  READY_FOR_EXECUTION: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string(),
      totalCompletions: external_exports.number()
    }),
    callback: external_exports.discriminatedUnion("success", [
      external_exports.object({
        success: external_exports.literal(false)
      }),
      external_exports.object({
        success: external_exports.literal(true),
        payload: V3ProdTaskRunExecutionPayload
      })
    ])
  },
  READY_FOR_LAZY_ATTEMPT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string(),
      envId: external_exports.string(),
      totalCompletions: external_exports.number()
    }),
    callback: external_exports.discriminatedUnion("success", [
      external_exports.object({
        success: external_exports.literal(false),
        reason: external_exports.string().optional()
      }),
      external_exports.object({
        success: external_exports.literal(true),
        lazyPayload: TaskRunExecutionLazyAttemptPayload
      })
    ])
  },
  READY_FOR_RESUME: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      attemptFriendlyId: external_exports.string(),
      type: WaitReason
    })
  },
  TASK_RUN_COMPLETED: {
    message: external_exports.object({
      version: external_exports.enum(["v1", "v2"]).default("v1"),
      execution: V3ProdTaskRunExecution,
      completion: TaskRunExecutionResult,
      checkpoint: external_exports.object({
        docker: external_exports.boolean(),
        location: external_exports.string()
      }).optional()
    })
  },
  TASK_RUN_COMPLETED_WITH_ACK: {
    message: external_exports.object({
      version: external_exports.enum(["v1", "v2"]).default("v2"),
      execution: V3ProdTaskRunExecution,
      completion: TaskRunExecutionResult,
      checkpoint: external_exports.object({
        docker: external_exports.boolean(),
        location: external_exports.string()
      }).optional()
    }),
    callback: AckCallbackResult
  },
  TASK_RUN_FAILED_TO_RUN: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      completion: TaskRunFailedExecutionResult
    })
  },
  TASK_HEARTBEAT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      attemptFriendlyId: external_exports.string()
    })
  },
  TASK_RUN_HEARTBEAT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string()
    })
  },
  CHECKPOINT_CREATED: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string().optional(),
      attemptFriendlyId: external_exports.string(),
      docker: external_exports.boolean(),
      location: external_exports.string(),
      reason: external_exports.discriminatedUnion("type", [
        external_exports.object({
          type: external_exports.literal("WAIT_FOR_DURATION"),
          ms: external_exports.number(),
          now: external_exports.number()
        }),
        external_exports.object({
          type: external_exports.literal("WAIT_FOR_BATCH"),
          batchFriendlyId: external_exports.string(),
          runFriendlyIds: external_exports.string().array()
        }),
        external_exports.object({
          type: external_exports.literal("WAIT_FOR_TASK"),
          friendlyId: external_exports.string()
        }),
        external_exports.object({
          type: external_exports.literal("RETRYING_AFTER_FAILURE"),
          attemptNumber: external_exports.number()
        }),
        external_exports.object({
          type: external_exports.literal("MANUAL"),
          /** If unspecified it will be restored immediately, e.g. for live migration */
          restoreAtUnixTimeMs: external_exports.number().optional()
        })
      ])
    }),
    callback: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      keepRunAlive: external_exports.boolean()
    })
  },
  INDEXING_FAILED: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      deploymentId: external_exports.string(),
      error: external_exports.object({
        name: external_exports.string(),
        message: external_exports.string(),
        stack: external_exports.string().optional(),
        stderr: external_exports.string().optional()
      })
    })
  },
  RUN_CRASHED: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string(),
      error: external_exports.object({
        name: external_exports.string(),
        message: external_exports.string(),
        stack: external_exports.string().optional()
      })
    })
  }
};
var PlatformToCoordinatorMessages = {
  /** @deprecated use RESUME_AFTER_DEPENDENCY_WITH_ACK instead  */
  RESUME_AFTER_DEPENDENCY: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string(),
      attemptId: external_exports.string(),
      attemptFriendlyId: external_exports.string(),
      completions: TaskRunExecutionResult.array(),
      executions: TaskRunExecution.array()
    })
  },
  RESUME_AFTER_DEPENDENCY_WITH_ACK: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string(),
      attemptId: external_exports.string(),
      attemptFriendlyId: external_exports.string(),
      completions: TaskRunExecutionResult.array(),
      executions: TaskRunExecution.array()
    }),
    callback: AckCallbackResult
  },
  RESUME_AFTER_DURATION: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      attemptId: external_exports.string(),
      attemptFriendlyId: external_exports.string()
    })
  },
  REQUEST_ATTEMPT_CANCELLATION: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      attemptId: external_exports.string(),
      attemptFriendlyId: external_exports.string()
    })
  },
  REQUEST_RUN_CANCELLATION: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string(),
      delayInMs: external_exports.number().optional()
    })
  },
  READY_FOR_RETRY: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string()
    })
  },
  DYNAMIC_CONFIG: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      checkpointThresholdInMs: external_exports.number()
    })
  }
};
var ClientToSharedQueueMessages = {
  READY_FOR_TASKS: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      backgroundWorkerId: external_exports.string()
    })
  },
  BACKGROUND_WORKER_DEPRECATED: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      backgroundWorkerId: external_exports.string()
    })
  },
  BACKGROUND_WORKER_MESSAGE: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      backgroundWorkerId: external_exports.string(),
      data: BackgroundWorkerClientMessages
    })
  }
};
var SharedQueueToClientMessages = {
  SERVER_READY: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      id: external_exports.string()
    })
  },
  BACKGROUND_WORKER_MESSAGE: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      backgroundWorkerId: external_exports.string(),
      data: BackgroundWorkerServerMessages
    })
  }
};
var IndexTasksMessage = external_exports.object({
  version: external_exports.literal("v1"),
  deploymentId: external_exports.string(),
  tasks: TaskResource.array(),
  packageVersion: external_exports.string()
});
var ProdWorkerToCoordinatorMessages = {
  TEST: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1")
    }),
    callback: external_exports.void()
  },
  INDEX_TASKS: {
    message: external_exports.discriminatedUnion("version", [
      IndexTasksMessage.extend({
        version: external_exports.literal("v1")
      }),
      IndexTasksMessage.extend({
        version: external_exports.literal("v2"),
        supportsLazyAttempts: external_exports.boolean()
      })
    ]),
    callback: external_exports.discriminatedUnion("success", [
      external_exports.object({
        success: external_exports.literal(false)
      }),
      external_exports.object({
        success: external_exports.literal(true)
      })
    ])
  },
  // Deprecated: Only workers without lazy attempt support will use this
  READY_FOR_EXECUTION: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string(),
      totalCompletions: external_exports.number()
    })
  },
  READY_FOR_LAZY_ATTEMPT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string(),
      totalCompletions: external_exports.number(),
      startTime: external_exports.number().optional()
    })
  },
  READY_FOR_RESUME: {
    message: external_exports.discriminatedUnion("version", [
      external_exports.object({
        version: external_exports.literal("v1"),
        attemptFriendlyId: external_exports.string(),
        type: WaitReason
      }),
      external_exports.object({
        version: external_exports.literal("v2"),
        attemptFriendlyId: external_exports.string(),
        attemptNumber: external_exports.number(),
        type: WaitReason
      })
    ])
  },
  READY_FOR_CHECKPOINT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1")
    })
  },
  CANCEL_CHECKPOINT: {
    message: external_exports.discriminatedUnion("version", [
      external_exports.object({
        version: external_exports.literal("v1")
      }),
      external_exports.object({
        version: external_exports.literal("v2"),
        reason: WaitReason.optional()
      })
    ]).default({ version: "v1" }),
    callback: external_exports.object({
      version: external_exports.literal("v2").default("v2"),
      checkpointCanceled: external_exports.boolean(),
      reason: WaitReason.optional()
    })
  },
  TASK_HEARTBEAT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      attemptFriendlyId: external_exports.string()
    })
  },
  TASK_RUN_HEARTBEAT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string()
    })
  },
  TASK_RUN_COMPLETED: {
    message: external_exports.object({
      version: external_exports.enum(["v1", "v2"]).default("v1"),
      execution: V3ProdTaskRunExecution,
      completion: TaskRunExecutionResult
    }),
    callback: external_exports.object({
      willCheckpointAndRestore: external_exports.boolean(),
      shouldExit: external_exports.boolean()
    })
  },
  TASK_RUN_FAILED_TO_RUN: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      completion: TaskRunFailedExecutionResult
    })
  },
  WAIT_FOR_DURATION: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      ms: external_exports.number(),
      now: external_exports.number(),
      attemptFriendlyId: external_exports.string()
    }),
    callback: external_exports.object({
      willCheckpointAndRestore: external_exports.boolean()
    })
  },
  WAIT_FOR_TASK: {
    message: external_exports.object({
      version: external_exports.enum(["v1", "v2"]).default("v1"),
      friendlyId: external_exports.string(),
      // This is the attempt that is waiting
      attemptFriendlyId: external_exports.string()
    }),
    callback: external_exports.object({
      willCheckpointAndRestore: external_exports.boolean()
    })
  },
  WAIT_FOR_BATCH: {
    message: external_exports.object({
      version: external_exports.enum(["v1", "v2"]).default("v1"),
      batchFriendlyId: external_exports.string(),
      runFriendlyIds: external_exports.string().array(),
      // This is the attempt that is waiting
      attemptFriendlyId: external_exports.string()
    }),
    callback: external_exports.object({
      willCheckpointAndRestore: external_exports.boolean()
    })
  },
  INDEXING_FAILED: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      deploymentId: external_exports.string(),
      error: external_exports.object({
        name: external_exports.string(),
        message: external_exports.string(),
        stack: external_exports.string().optional(),
        stderr: external_exports.string().optional()
      })
    })
  },
  CREATE_TASK_RUN_ATTEMPT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string()
    }),
    callback: external_exports.discriminatedUnion("success", [
      external_exports.object({
        success: external_exports.literal(false),
        reason: external_exports.string().optional()
      }),
      external_exports.object({
        success: external_exports.literal(true),
        executionPayload: V3ProdTaskRunExecutionPayload
      })
    ])
  },
  UNRECOVERABLE_ERROR: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      error: external_exports.object({
        name: external_exports.string(),
        message: external_exports.string(),
        stack: external_exports.string().optional()
      })
    })
  },
  SET_STATE: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      attemptFriendlyId: external_exports.string().optional(),
      attemptNumber: external_exports.string().optional()
    })
  }
};
var CoordinatorToProdWorkerMessages = {
  RESUME_AFTER_DEPENDENCY: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      attemptId: external_exports.string(),
      completions: TaskRunExecutionResult.array(),
      executions: TaskRunExecution.array()
    })
  },
  RESUME_AFTER_DURATION: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      attemptId: external_exports.string()
    })
  },
  // Deprecated: Only workers without lazy attempt support will use this
  EXECUTE_TASK_RUN: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      executionPayload: V3ProdTaskRunExecutionPayload
    })
  },
  EXECUTE_TASK_RUN_LAZY_ATTEMPT: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      lazyPayload: TaskRunExecutionLazyAttemptPayload
    })
  },
  REQUEST_ATTEMPT_CANCELLATION: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      attemptId: external_exports.string()
    })
  },
  REQUEST_EXIT: {
    message: external_exports.discriminatedUnion("version", [
      external_exports.object({
        version: external_exports.literal("v1")
      }),
      external_exports.object({
        version: external_exports.literal("v2"),
        delayInMs: external_exports.number().optional()
      })
    ])
  },
  READY_FOR_RETRY: {
    message: external_exports.object({
      version: external_exports.literal("v1").default("v1"),
      runId: external_exports.string()
    })
  }
};
var ProdWorkerSocketData = external_exports.object({
  contentHash: external_exports.string(),
  projectRef: external_exports.string(),
  envId: external_exports.string(),
  runId: external_exports.string(),
  attemptFriendlyId: external_exports.string().optional(),
  attemptNumber: external_exports.string().optional(),
  podName: external_exports.string(),
  deploymentId: external_exports.string(),
  deploymentVersion: external_exports.string(),
  requiresCheckpointResumeWithMessage: external_exports.string().optional()
});
var CoordinatorSocketData = external_exports.object({
  supportsDynamicConfig: external_exports.string().optional()
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/style.js
init_esm();
var PRIMARY_VARIANT = "primary";
var WARM_VARIANT = "warm";
var COLD_VARIANT = "cold";
var Variant = external_exports.enum([PRIMARY_VARIANT, WARM_VARIANT, COLD_VARIANT]);
var AccessoryItem = external_exports.object({
  text: external_exports.string(),
  variant: external_exports.string().optional(),
  url: external_exports.string().optional()
});
var Accessory = external_exports.object({
  items: external_exports.array(AccessoryItem),
  style: external_exports.enum(["codepath"]).optional()
});
var TaskEventStyle = external_exports.object({
  icon: external_exports.string().optional(),
  variant: Variant.optional(),
  accessory: Accessory.optional()
}).default({
  icon: void 0,
  variant: void 0
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/fetch.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/eventFilter.js
init_esm();
var stringPatternMatchers = [
  external_exports.object({
    $endsWith: external_exports.string()
  }),
  external_exports.object({
    $startsWith: external_exports.string()
  }),
  external_exports.object({
    $ignoreCaseEquals: external_exports.string()
  })
];
var EventMatcher = external_exports.union([
  /** Match against a string */
  external_exports.array(external_exports.string()),
  /** Match against a number */
  external_exports.array(external_exports.number()),
  /** Match against a boolean */
  external_exports.array(external_exports.boolean()),
  external_exports.array(external_exports.union([
    ...stringPatternMatchers,
    external_exports.object({
      $exists: external_exports.boolean()
    }),
    external_exports.object({
      $isNull: external_exports.boolean()
    }),
    external_exports.object({
      $anythingBut: external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()])
    }),
    external_exports.object({
      $anythingBut: external_exports.union([external_exports.array(external_exports.string()), external_exports.array(external_exports.number()), external_exports.array(external_exports.boolean())])
    }),
    external_exports.object({
      $gt: external_exports.number()
    }),
    external_exports.object({
      $lt: external_exports.number()
    }),
    external_exports.object({
      $gte: external_exports.number()
    }),
    external_exports.object({
      $lte: external_exports.number()
    }),
    external_exports.object({
      $between: external_exports.tuple([external_exports.number(), external_exports.number()])
    }),
    external_exports.object({
      $includes: external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()])
    }),
    external_exports.object({
      $not: external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()])
    })
  ]))
]);
var EventFilter = external_exports.lazy(() => external_exports.record(external_exports.union([EventMatcher, EventFilter])));

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/fetch.js
var FetchRetryHeadersStrategy = external_exports.object({
  /** The `headers` strategy retries the request using info from the response headers. */
  strategy: external_exports.literal("headers"),
  /** The header to use to determine the maximum number of times to retry the request. */
  limitHeader: external_exports.string(),
  /** The header to use to determine the number of remaining retries. */
  remainingHeader: external_exports.string(),
  /** The header to use to determine the time when the number of remaining retries will be reset. */
  resetHeader: external_exports.string(),
  /** The event filter to use to determine if the request should be retried. */
  bodyFilter: EventFilter.optional(),
  /** The format of the `resetHeader` value. */
  resetFormat: external_exports.enum([
    "unix_timestamp",
    "unix_timestamp_in_ms",
    "iso_8601",
    "iso_8601_duration_openai_variant"
  ]).default("unix_timestamp").optional()
});
var FetchRetryBackoffStrategy = RetryOptions.extend({
  /** The `backoff` strategy retries the request with an exponential backoff. */
  strategy: external_exports.literal("backoff"),
  /** The event filter to use to determine if the request should be retried. */
  bodyFilter: EventFilter.optional()
});
var FetchRetryStrategy = external_exports.discriminatedUnion("strategy", [
  FetchRetryHeadersStrategy,
  FetchRetryBackoffStrategy
]);
var FetchRetryByStatusOptions = external_exports.record(external_exports.string(), FetchRetryStrategy);
var FetchTimeoutOptions = external_exports.object({
  /** The maximum time to wait for the request to complete. */
  durationInMs: external_exports.number().optional(),
  retry: RetryOptions.optional()
});
var FetchRetryOptions = external_exports.object({
  /** The retrying strategy for specific status codes. */
  byStatus: FetchRetryByStatusOptions.optional(),
  /** The timeout options for the request. */
  timeout: RetryOptions.optional(),
  /**
   * The retrying strategy for connection errors.
   */
  connectionError: RetryOptions.optional()
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/openTelemetry.js
init_esm();
var ExceptionEventProperties = external_exports.object({
  type: external_exports.string().optional(),
  message: external_exports.string().optional(),
  stacktrace: external_exports.string().optional()
});
var ExceptionSpanEvent = external_exports.object({
  name: external_exports.literal("exception"),
  time: external_exports.coerce.date(),
  properties: external_exports.object({
    exception: ExceptionEventProperties
  })
});
var CancellationSpanEvent = external_exports.object({
  name: external_exports.literal("cancellation"),
  time: external_exports.coerce.date(),
  properties: external_exports.object({
    reason: external_exports.string()
  })
});
var AttemptFailedSpanEvent = external_exports.object({
  name: external_exports.literal("attempt_failed"),
  time: external_exports.coerce.date(),
  properties: external_exports.object({
    exception: ExceptionEventProperties,
    attemptNumber: external_exports.number(),
    runId: external_exports.string()
  })
});
var OtherSpanEvent = external_exports.object({
  name: external_exports.string(),
  time: external_exports.coerce.date(),
  properties: external_exports.record(external_exports.unknown())
});
var SpanEvent = external_exports.union([
  ExceptionSpanEvent,
  CancellationSpanEvent,
  AttemptFailedSpanEvent,
  OtherSpanEvent
]);
var SpanEvents = external_exports.array(SpanEvent);
var SpanMessagingEvent = external_exports.object({
  system: external_exports.string().optional(),
  client_id: external_exports.string().optional(),
  operation: external_exports.enum(["publish", "create", "receive", "deliver"]),
  message: external_exports.any(),
  destination: external_exports.string().optional()
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/webhooks.js
init_esm();
var AlertWebhookRunFailedObject = external_exports.object({
  /** Task information */
  task: external_exports.object({
    /** Unique identifier for the task */
    id: external_exports.string(),
    /** File path where the task is defined */
    filePath: external_exports.string(),
    /** Name of the exported task function */
    exportName: external_exports.string().optional(),
    /** Version of the task */
    version: external_exports.string(),
    /** Version of the SDK used */
    sdkVersion: external_exports.string(),
    /** Version of the CLI used */
    cliVersion: external_exports.string()
  }),
  /** Run information */
  run: external_exports.object({
    /** Unique identifier for the run */
    id: external_exports.string(),
    /** Run number */
    number: external_exports.number(),
    /** Current status of the run */
    status: RunStatus,
    /** When the run was created */
    createdAt: external_exports.coerce.date(),
    /** When the run started executing */
    startedAt: external_exports.coerce.date().optional(),
    /** When the run finished executing */
    completedAt: external_exports.coerce.date().optional(),
    /** Whether this is a test run */
    isTest: external_exports.boolean(),
    /** Idempotency key for the run */
    idempotencyKey: external_exports.string().optional(),
    /** Associated tags */
    tags: external_exports.array(external_exports.string()),
    /** Error information */
    error: TaskRunError,
    /** Whether the run was an out-of-memory error */
    isOutOfMemoryError: external_exports.boolean(),
    /** Machine preset used for the run */
    machine: external_exports.string(),
    /** URL to view the run in the dashboard */
    dashboardUrl: external_exports.string()
  }),
  /** Environment information */
  environment: external_exports.object({
    /** Environment ID */
    id: external_exports.string(),
    /** Environment type */
    type: RuntimeEnvironmentTypeSchema,
    /** Environment slug */
    slug: external_exports.string(),
    /** Environment branch name */
    branchName: external_exports.string().optional()
  }),
  /** Organization information */
  organization: external_exports.object({
    /** Organization ID */
    id: external_exports.string(),
    /** Organization slug */
    slug: external_exports.string(),
    /** Organization name */
    name: external_exports.string()
  }),
  /** Project information */
  project: external_exports.object({
    /** Project ID */
    id: external_exports.string(),
    /** Project reference */
    ref: external_exports.string(),
    /** Project slug */
    slug: external_exports.string(),
    /** Project name */
    name: external_exports.string()
  })
});
var DeployError = external_exports.object({
  /** Error name */
  name: external_exports.string(),
  /** Error message */
  message: external_exports.string(),
  /** Error stack trace */
  stack: external_exports.string().optional(),
  /** Standard error output */
  stderr: external_exports.string().optional()
});
var deploymentCommonProperties = {
  /** Environment information */
  environment: external_exports.object({
    id: external_exports.string(),
    type: RuntimeEnvironmentTypeSchema,
    slug: external_exports.string(),
    /** Environment branch name */
    branchName: external_exports.string().optional()
  }),
  /** Organization information */
  organization: external_exports.object({
    id: external_exports.string(),
    slug: external_exports.string(),
    name: external_exports.string()
  }),
  /** Project information */
  project: external_exports.object({
    id: external_exports.string(),
    ref: external_exports.string(),
    slug: external_exports.string(),
    name: external_exports.string()
  })
};
var deploymentDeploymentCommonProperties = {
  /** Deployment ID */
  id: external_exports.string(),
  /** Deployment status */
  status: external_exports.string(),
  /** Deployment version */
  version: external_exports.string(),
  /** Short code identifier */
  shortCode: external_exports.string()
};
var AlertWebhookDeploymentSuccessObject = external_exports.object({
  ...deploymentCommonProperties,
  deployment: external_exports.object({
    ...deploymentDeploymentCommonProperties,
    /** When the deployment completed */
    deployedAt: external_exports.coerce.date()
  }),
  /** Deployed tasks */
  tasks: external_exports.array(external_exports.object({
    /** Task ID */
    id: external_exports.string(),
    /** File path where the task is defined */
    filePath: external_exports.string(),
    /** Name of the exported task function */
    exportName: external_exports.string().optional(),
    /** Source of the trigger */
    triggerSource: external_exports.string()
  }))
});
var AlertWebhookDeploymentFailedObject = external_exports.object({
  ...deploymentCommonProperties,
  deployment: external_exports.object({
    ...deploymentDeploymentCommonProperties,
    /** When the deployment failed */
    failedAt: external_exports.coerce.date()
  }),
  /** Error information */
  error: DeployError
});
var commonProperties = {
  /** Webhook ID */
  id: external_exports.string(),
  /** When the webhook was created */
  created: external_exports.coerce.date(),
  /** Version of the webhook */
  webhookVersion: external_exports.string()
};
var Webhook = external_exports.discriminatedUnion("type", [
  /** Run failed alert webhook */
  external_exports.object({
    ...commonProperties,
    type: external_exports.literal("alert.run.failed"),
    object: AlertWebhookRunFailedObject
  }),
  /** Deployment success alert webhook */
  external_exports.object({
    ...commonProperties,
    type: external_exports.literal("alert.deployment.success"),
    object: AlertWebhookDeploymentSuccessObject
  }),
  /** Deployment failed alert webhook */
  external_exports.object({
    ...commonProperties,
    type: external_exports.literal("alert.deployment.failed"),
    object: AlertWebhookDeploymentFailedObject
  })
]);

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/checkpoints.js
init_esm();
var CallbackUrl = zod_default.string().url().transform((url) => new URL(url));
var CheckpointServiceSuspendRequestBody = zod_default.object({
  type: CheckpointType,
  runId: zod_default.string(),
  snapshotId: zod_default.string(),
  runnerId: zod_default.string(),
  projectRef: zod_default.string(),
  deploymentVersion: zod_default.string(),
  reason: zod_default.string().optional()
});
var CheckpointServiceSuspendResponseBody = zod_default.object({
  ok: zod_default.literal(true)
});
var CheckpointServiceRestoreRequestBody = DequeuedMessage.required({ checkpoint: true });

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/warmStart.js
init_esm();
var WarmStartConnectResponse = external_exports.object({
  connectionTimeoutMs: external_exports.number().optional(),
  keepaliveMs: external_exports.number().optional()
});

// node_modules/@trigger.dev/core/dist/esm/v3/schemas/queues.js
init_esm();
var queueTypes = ["task", "custom"];
var QueueType = external_exports.enum(queueTypes);
var RetrieveQueueType = external_exports.enum([...queueTypes, "id"]);
var QueueItem = external_exports.object({
  /** The queue id, e.g. queue_12345 */
  id: external_exports.string(),
  /** The queue name */
  name: external_exports.string(),
  /**
   * The queue type, either "task" or "custom"
   * "task" are created automatically for each task.
   * "custom" are created by you explicitly in your code.
   * */
  type: QueueType,
  /** The number of runs currently running */
  running: external_exports.number(),
  /** The number of runs currently queued */
  queued: external_exports.number(),
  /** Whether the queue is paused. If it's paused, no new runs will be started. */
  paused: external_exports.boolean(),
  /** The concurrency limit of the queue */
  concurrencyLimit: external_exports.number().nullable(),
  /** The concurrency limit of the queue */
  concurrency: external_exports.object({
    /** The effective/current concurrency limit */
    current: external_exports.number().nullable(),
    /** The base concurrency limit (default) */
    base: external_exports.number().nullable(),
    /** The effective/current concurrency limit */
    override: external_exports.number().nullable(),
    /** When the override was applied */
    overriddenAt: external_exports.coerce.date().nullable(),
    /** Who overrode the concurrency limit (will be null if overridden via the API) */
    overriddenBy: external_exports.string().nullable()
  }).optional()
});
var ListQueueOptions = external_exports.object({
  /** The page number */
  page: external_exports.number().optional(),
  /** The number of queues per page */
  perPage: external_exports.number().optional()
});
var QueueTypeName = external_exports.object({
  /** "task" or "custom" */
  type: QueueType,
  /** The name of your queue.
   * For "task" type it will be the task id, for "custom" it will be the name you specified.
   * */
  name: external_exports.string()
});
var RetrieveQueueParam = external_exports.union([external_exports.string(), QueueTypeName]);

// node_modules/@trigger.dev/core/dist/esm/v3/task-context-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/taskContext/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/semanticInternalAttributes.js
init_esm();
var SemanticInternalAttributes = {
  ENVIRONMENT_ID: "ctx.environment.id",
  ENVIRONMENT_TYPE: "ctx.environment.type",
  ORGANIZATION_ID: "ctx.organization.id",
  ORGANIZATION_SLUG: "ctx.organization.slug",
  ORGANIZATION_NAME: "ctx.organization.name",
  PROJECT_ID: "ctx.project.id",
  PROJECT_REF: "ctx.project.ref",
  PROJECT_NAME: "ctx.project.title",
  PROJECT_DIR: "project.dir",
  ATTEMPT_ID: "ctx.attempt.id",
  ATTEMPT_NUMBER: "ctx.attempt.number",
  RUN_ID: "ctx.run.id",
  RUN_IS_TEST: "ctx.run.isTest",
  ORIGINAL_RUN_ID: "$original_run_id",
  BATCH_ID: "ctx.batch.id",
  TASK_SLUG: "ctx.task.id",
  TASK_PATH: "ctx.task.filePath",
  TASK_EXPORT_NAME: "ctx.task.exportName",
  QUEUE_NAME: "ctx.queue.name",
  QUEUE_ID: "ctx.queue.id",
  MACHINE_PRESET_NAME: "ctx.machine.name",
  MACHINE_PRESET_CPU: "ctx.machine.cpu",
  MACHINE_PRESET_MEMORY: "ctx.machine.memory",
  MACHINE_PRESET_CENTS_PER_MS: "ctx.machine.centsPerMs",
  SKIP_SPAN_PARTIAL: "$span.skip_partial",
  SPAN_PARTIAL: "$span.partial",
  SPAN_ID: "$span.span_id",
  SPAN: "$span",
  ENTITY_TYPE: "$entity.type",
  ENTITY_ID: "$entity.id",
  ENTITY_METADATA: "$entity.metadata",
  OUTPUT: "$output",
  OUTPUT_TYPE: "$mime_type_output",
  STYLE: "$style",
  STYLE_ICON: "$style.icon",
  STYLE_VARIANT: "$style.variant",
  STYLE_ACCESSORY: "$style.accessory",
  COLLAPSED: "$collapsed",
  METADATA: "$metadata",
  TRIGGER: "$trigger",
  PAYLOAD: "$payload",
  PAYLOAD_TYPE: "$mime_type_payload",
  SHOW: "$show",
  SHOW_ACTIONS: "$show.actions",
  WORKER_ID: "worker.id",
  WORKER_VERSION: "worker.version",
  CLI_VERSION: "cli.version",
  SDK_VERSION: "sdk.version",
  SDK_LANGUAGE: "sdk.language",
  RETRY_AT: "retry.at",
  RETRY_DELAY: "retry.delay",
  RETRY_COUNT: "retry.count",
  LINK_TITLE: "$link.title",
  IDEMPOTENCY_KEY: "ctx.run.idempotencyKey",
  USAGE_DURATION_MS: "$usage.durationMs",
  USAGE_COST_IN_CENTS: "$usage.costInCents",
  USAGE: "$usage",
  RATE_LIMIT_LIMIT: "response.rateLimit.limit",
  RATE_LIMIT_REMAINING: "response.rateLimit.remaining",
  RATE_LIMIT_RESET: "response.rateLimit.reset",
  SPAN_ATTEMPT: "$span.attempt",
  METRIC_EVENTS: "$metrics.events",
  EXECUTION_ENVIRONMENT: "exec_env",
  WARM_START: "warm_start",
  ATTEMPT_EXECUTION_COUNT: "$trigger.executionCount",
  TASK_EVENT_STORE: "$trigger.taskEventStore"
};

// node_modules/@trigger.dev/core/dist/esm/v3/utils/globals.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/utils/platform.js
init_esm();
var _globalThis = typeof globalThis === "object" ? globalThis : global;

// node_modules/@trigger.dev/core/dist/esm/v3/utils/globals.js
var GLOBAL_TRIGGER_DOT_DEV_KEY = Symbol.for(`dev.trigger.ts.api`);
var _global = _globalThis;
function registerGlobal(type, instance, allowOverride = false) {
  const api = _global[GLOBAL_TRIGGER_DOT_DEV_KEY] = _global[GLOBAL_TRIGGER_DOT_DEV_KEY] ?? {};
  if (!allowOverride && api[type]) {
    const err = new Error(`trigger.dev: Attempted duplicate registration of API: ${type}`);
    return false;
  }
  api[type] = instance;
  return true;
}
__name(registerGlobal, "registerGlobal");
function getGlobal(type) {
  return _global[GLOBAL_TRIGGER_DOT_DEV_KEY]?.[type];
}
__name(getGlobal, "getGlobal");
function unregisterGlobal(type) {
  const api = _global[GLOBAL_TRIGGER_DOT_DEV_KEY];
  if (api) {
    delete api[type];
  }
}
__name(unregisterGlobal, "unregisterGlobal");

// node_modules/@trigger.dev/core/dist/esm/v3/taskContext/index.js
var API_NAME = "task-context";
var TaskContextAPI = class _TaskContextAPI {
  static {
    __name(this, "TaskContextAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _TaskContextAPI();
    }
    return this._instance;
  }
  get isInsideTask() {
    return this.#getTaskContext() !== void 0;
  }
  get ctx() {
    return this.#getTaskContext()?.ctx;
  }
  get worker() {
    return this.#getTaskContext()?.worker;
  }
  get isWarmStart() {
    return this.#getTaskContext()?.isWarmStart;
  }
  get attributes() {
    if (this.ctx) {
      return {
        ...this.contextAttributes,
        ...this.workerAttributes,
        [SemanticInternalAttributes.WARM_START]: !!this.isWarmStart
      };
    }
    return {};
  }
  get resourceAttributes() {
    if (this.ctx) {
      return {
        [SemanticInternalAttributes.ENVIRONMENT_ID]: this.ctx.environment.id,
        [SemanticInternalAttributes.ENVIRONMENT_TYPE]: this.ctx.environment.type,
        [SemanticInternalAttributes.ORGANIZATION_ID]: this.ctx.organization.id,
        [SemanticInternalAttributes.PROJECT_ID]: this.ctx.project.id,
        [SemanticInternalAttributes.PROJECT_REF]: this.ctx.project.ref,
        [SemanticInternalAttributes.PROJECT_NAME]: this.ctx.project.name,
        [SemanticInternalAttributes.ORGANIZATION_SLUG]: this.ctx.organization.slug,
        [SemanticInternalAttributes.ORGANIZATION_NAME]: this.ctx.organization.name,
        [SemanticInternalAttributes.MACHINE_PRESET_NAME]: this.ctx.machine?.name,
        [SemanticInternalAttributes.MACHINE_PRESET_CPU]: this.ctx.machine?.cpu,
        [SemanticInternalAttributes.MACHINE_PRESET_MEMORY]: this.ctx.machine?.memory,
        [SemanticInternalAttributes.MACHINE_PRESET_CENTS_PER_MS]: this.ctx.machine?.centsPerMs
      };
    }
    return {};
  }
  get workerAttributes() {
    if (this.worker) {
      return {
        [SemanticInternalAttributes.WORKER_ID]: this.worker.id,
        [SemanticInternalAttributes.WORKER_VERSION]: this.worker.version
      };
    }
    return {};
  }
  get contextAttributes() {
    if (this.ctx) {
      return {
        [SemanticInternalAttributes.ATTEMPT_NUMBER]: this.ctx.attempt.number,
        [SemanticInternalAttributes.TASK_SLUG]: this.ctx.task.id,
        [SemanticInternalAttributes.TASK_PATH]: this.ctx.task.filePath,
        [SemanticInternalAttributes.QUEUE_NAME]: this.ctx.queue.name,
        [SemanticInternalAttributes.QUEUE_ID]: this.ctx.queue.id,
        [SemanticInternalAttributes.RUN_ID]: this.ctx.run.id,
        [SemanticInternalAttributes.RUN_IS_TEST]: this.ctx.run.isTest,
        [SemanticInternalAttributes.BATCH_ID]: this.ctx.batch?.id,
        [SemanticInternalAttributes.IDEMPOTENCY_KEY]: this.ctx.run.idempotencyKey
      };
    }
    return {};
  }
  disable() {
    unregisterGlobal(API_NAME);
  }
  setGlobalTaskContext(taskContext2) {
    return registerGlobal(API_NAME, taskContext2);
  }
  #getTaskContext() {
    return getGlobal(API_NAME);
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/task-context-api.js
var taskContext = TaskContextAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/core.js
init_esm();
var import_zod_validation_error = __toESM(require_cjs(), 1);

// node_modules/@trigger.dev/core/dist/esm/v3/utils/retries.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/retry.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/utils/retries.js
var defaultRetryOptions = {
  maxAttempts: 3,
  factor: 2,
  minTimeoutInMs: 1e3,
  maxTimeoutInMs: 6e4,
  randomize: true
};
var defaultFetchRetryOptions = {
  byStatus: {
    "429,408,409,5xx": {
      strategy: "backoff",
      ...defaultRetryOptions
    }
  },
  connectionError: defaultRetryOptions,
  timeout: defaultRetryOptions
};
function calculateNextRetryDelay(options, attempt) {
  const opts = { ...defaultRetryOptions, ...options };
  if (attempt >= opts.maxAttempts) {
    return;
  }
  const { factor, minTimeoutInMs, maxTimeoutInMs, randomize } = opts;
  const random = randomize ? Math.random() + 1 : 1;
  const timeout3 = Math.min(maxTimeoutInMs, random * minTimeoutInMs * Math.pow(factor, attempt - 1));
  return Math.round(timeout3);
}
__name(calculateNextRetryDelay, "calculateNextRetryDelay");

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/errors.js
init_esm();
var ApiError = class _ApiError extends Error {
  static {
    __name(this, "ApiError");
  }
  status;
  headers;
  error;
  code;
  param;
  type;
  constructor(status, error, message, headers) {
    super(`${_ApiError.makeMessage(status, error, message)}`);
    this.name = "TriggerApiError";
    this.status = status;
    this.headers = headers;
    const data = error;
    this.error = data;
    this.code = data?.["code"];
    this.param = data?.["param"];
    this.type = data?.["type"];
  }
  static makeMessage(status, error, message) {
    const errorMessage = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : typeof error === "string" ? error : error ? JSON.stringify(error) : void 0;
    if (errorMessage) {
      return errorMessage;
    }
    if (status && message) {
      return `${status} ${message}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (message) {
      return message;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new ApiConnectionError({ cause: castToError(errorResponse) });
    }
    const error = errorResponse?.["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new _ApiError(status, error, message, headers);
  }
};
var ApiConnectionError = class extends ApiError {
  static {
    __name(this, "ApiConnectionError");
  }
  status = void 0;
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var BadRequestError = class extends ApiError {
  static {
    __name(this, "BadRequestError");
  }
  status = 400;
};
var AuthenticationError = class extends ApiError {
  static {
    __name(this, "AuthenticationError");
  }
  status = 401;
};
var PermissionDeniedError = class extends ApiError {
  static {
    __name(this, "PermissionDeniedError");
  }
  status = 403;
};
var NotFoundError = class extends ApiError {
  static {
    __name(this, "NotFoundError");
  }
  status = 404;
};
var ConflictError = class extends ApiError {
  static {
    __name(this, "ConflictError");
  }
  status = 409;
};
var UnprocessableEntityError = class extends ApiError {
  static {
    __name(this, "UnprocessableEntityError");
  }
  status = 422;
};
var RateLimitError = class extends ApiError {
  static {
    __name(this, "RateLimitError");
  }
  status = 429;
  get millisecondsUntilReset() {
    const resetAtUnixEpochMs = (this.headers ?? {})["x-ratelimit-reset"];
    if (typeof resetAtUnixEpochMs === "string") {
      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);
      if (isNaN(resetAtUnixEpoch)) {
        return;
      }
      return Math.max(resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 2e3), 0);
    }
    return;
  }
};
var InternalServerError = class extends ApiError {
  static {
    __name(this, "InternalServerError");
  }
};
var ApiSchemaValidationError = class extends ApiError {
  static {
    __name(this, "ApiSchemaValidationError");
  }
  status = 200;
  rawBody;
  constructor({ message, cause, status, rawBody, headers }) {
    super(status, void 0, message || "Validation error.", headers);
    if (cause)
      this.cause = cause;
    this.rawBody = rawBody;
  }
};
function castToError(err) {
  if (err instanceof Error)
    return err;
  return new Error(err);
}
__name(castToError, "castToError");

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/core.js
init_esm2();
var import_core = __toESM(require_src(), 1);

// node_modules/@trigger.dev/core/dist/esm/v3/utils/styleAttributes.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/utils/flattenAttributes.js
init_esm();
var NULL_SENTINEL = "$@null((";
var CIRCULAR_REFERENCE_SENTINEL = "$@circular((";
function flattenAttributes(obj, prefix, maxAttributeCount) {
  const flattener = new AttributeFlattener(maxAttributeCount);
  flattener.doFlatten(obj, prefix);
  return flattener.attributes;
}
__name(flattenAttributes, "flattenAttributes");
var AttributeFlattener = class {
  static {
    __name(this, "AttributeFlattener");
  }
  maxAttributeCount;
  seen = /* @__PURE__ */ new WeakSet();
  attributeCounter = 0;
  result = {};
  constructor(maxAttributeCount) {
    this.maxAttributeCount = maxAttributeCount;
  }
  get attributes() {
    return this.result;
  }
  canAddMoreAttributes() {
    return this.maxAttributeCount === void 0 || this.attributeCounter < this.maxAttributeCount;
  }
  addAttribute(key, value) {
    if (!this.canAddMoreAttributes()) {
      return false;
    }
    this.result[key] = value;
    this.attributeCounter++;
    return true;
  }
  doFlatten(obj, prefix) {
    if (!this.canAddMoreAttributes()) {
      return;
    }
    if (obj === void 0) {
      return;
    }
    if (obj === null) {
      this.addAttribute(prefix || "", NULL_SENTINEL);
      return;
    }
    if (typeof obj === "string") {
      this.addAttribute(prefix || "", obj);
      return;
    }
    if (typeof obj === "number") {
      this.addAttribute(prefix || "", obj);
      return;
    }
    if (typeof obj === "boolean") {
      this.addAttribute(prefix || "", obj);
      return;
    }
    if (obj instanceof Date) {
      this.addAttribute(prefix || "", obj.toISOString());
      return;
    }
    if (obj instanceof Error) {
      this.addAttribute(`${prefix || "error"}.name`, obj.name);
      this.addAttribute(`${prefix || "error"}.message`, obj.message);
      if (obj.stack) {
        this.addAttribute(`${prefix || "error"}.stack`, obj.stack);
      }
      return;
    }
    if (typeof obj === "function") {
      const funcName = obj.name || "anonymous";
      this.addAttribute(prefix || "", `[Function: ${funcName}]`);
      return;
    }
    if (obj instanceof Set) {
      let index = 0;
      for (const item of obj) {
        if (!this.canAddMoreAttributes())
          break;
        this.#processValue(item, `${prefix || "set"}.[${index}]`);
        index++;
      }
      return;
    }
    if (obj instanceof Map) {
      for (const [key, value] of obj) {
        if (!this.canAddMoreAttributes())
          break;
        const keyStr = typeof key === "string" ? key : String(key);
        this.#processValue(value, `${prefix || "map"}.${keyStr}`);
      }
      return;
    }
    if (typeof File !== "undefined" && obj instanceof File) {
      this.addAttribute(`${prefix || "file"}.name`, obj.name);
      this.addAttribute(`${prefix || "file"}.size`, obj.size);
      this.addAttribute(`${prefix || "file"}.type`, obj.type);
      this.addAttribute(`${prefix || "file"}.lastModified`, obj.lastModified);
      return;
    }
    if (typeof ReadableStream !== "undefined" && obj instanceof ReadableStream) {
      this.addAttribute(`${prefix || "stream"}.type`, "ReadableStream");
      this.addAttribute(`${prefix || "stream"}.locked`, obj.locked);
      return;
    }
    if (typeof WritableStream !== "undefined" && obj instanceof WritableStream) {
      this.addAttribute(`${prefix || "stream"}.type`, "WritableStream");
      this.addAttribute(`${prefix || "stream"}.locked`, obj.locked);
      return;
    }
    if (obj instanceof Promise) {
      this.addAttribute(prefix || "promise", "[Promise object]");
      return;
    }
    if (obj instanceof RegExp) {
      this.addAttribute(`${prefix || "regexp"}.source`, obj.source);
      this.addAttribute(`${prefix || "regexp"}.flags`, obj.flags);
      return;
    }
    if (typeof URL !== "undefined" && obj instanceof URL) {
      this.addAttribute(`${prefix || "url"}.href`, obj.href);
      this.addAttribute(`${prefix || "url"}.protocol`, obj.protocol);
      this.addAttribute(`${prefix || "url"}.host`, obj.host);
      this.addAttribute(`${prefix || "url"}.pathname`, obj.pathname);
      return;
    }
    if (obj instanceof ArrayBuffer) {
      this.addAttribute(`${prefix || "arraybuffer"}.byteLength`, obj.byteLength);
      return;
    }
    if (ArrayBuffer.isView(obj)) {
      const typedArray = obj;
      this.addAttribute(`${prefix || "typedarray"}.constructor`, typedArray.constructor.name);
      this.addAttribute(`${prefix || "typedarray"}.length`, typedArray.length);
      this.addAttribute(`${prefix || "typedarray"}.byteLength`, typedArray.byteLength);
      this.addAttribute(`${prefix || "typedarray"}.byteOffset`, typedArray.byteOffset);
      return;
    }
    if (obj !== null && typeof obj === "object" && this.seen.has(obj)) {
      this.addAttribute(prefix || "", CIRCULAR_REFERENCE_SENTINEL);
      return;
    }
    if (obj !== null && typeof obj === "object") {
      this.seen.add(obj);
    }
    for (const [key, value] of Object.entries(obj)) {
      if (!this.canAddMoreAttributes()) {
        break;
      }
      const newPrefix = `${prefix ? `${prefix}.` : ""}${Array.isArray(obj) ? `[${key}]` : key}`;
      if (Array.isArray(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          if (!this.canAddMoreAttributes()) {
            break;
          }
          this.#processValue(value[i2], `${newPrefix}.[${i2}]`);
        }
      } else {
        this.#processValue(value, newPrefix);
      }
    }
  }
  #processValue(value, prefix) {
    if (!this.canAddMoreAttributes()) {
      return;
    }
    if (value === void 0) {
      return;
    }
    if (value === null) {
      this.addAttribute(prefix, NULL_SENTINEL);
      return;
    }
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      this.addAttribute(prefix, value);
      return;
    }
    if (typeof value === "object" || typeof value === "function") {
      this.doFlatten(value, prefix);
    } else {
      this.addAttribute(prefix, String(value));
    }
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/utils/styleAttributes.js
function accessoryAttributes(accessory) {
  return flattenAttributes(accessory, SemanticInternalAttributes.STYLE_ACCESSORY);
}
__name(accessoryAttributes, "accessoryAttributes");

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/pagination.js
init_esm();
var CursorPage = class {
  static {
    __name(this, "CursorPage");
  }
  pageFetcher;
  data;
  pagination;
  constructor(data, pagination, pageFetcher) {
    this.pageFetcher = pageFetcher;
    this.data = data;
    this.pagination = pagination;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return !!this.pagination.next;
  }
  hasPreviousPage() {
    return !!this.pagination.previous;
  }
  getNextPage() {
    if (!this.pagination.next) {
      throw new Error("No next page available");
    }
    return this.pageFetcher({ after: this.pagination.next });
  }
  getPreviousPage() {
    if (!this.pagination.previous) {
      throw new Error("No previous page available");
    }
    return this.pageFetcher({ before: this.pagination.previous });
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[Symbol.asyncIterator]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var OffsetLimitPage = class {
  static {
    __name(this, "OffsetLimitPage");
  }
  pageFetcher;
  data;
  pagination;
  constructor(data, pagination, pageFetcher) {
    this.pageFetcher = pageFetcher;
    this.data = data;
    this.pagination = pagination;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.pagination.currentPage < this.pagination.totalPages;
  }
  hasPreviousPage() {
    return this.pagination.currentPage > 1;
  }
  getNextPage() {
    if (!this.hasNextPage()) {
      throw new Error("No next page available");
    }
    return this.pageFetcher({
      page: this.pagination.currentPage + 1
    });
  }
  getPreviousPage() {
    if (!this.hasPreviousPage()) {
      throw new Error("No previous page available");
    }
    return this.pageFetcher({
      page: this.pagination.currentPage - 1
    });
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[Symbol.asyncIterator]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};

// node_modules/eventsource-parser/dist/index.js
init_esm();
var ParseError = class extends Error {
  static {
    __name(this, "ParseError");
  }
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop(_arg) {
}
__name(noop, "noop");
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  __name(feed, "feed");
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  __name(parseLine, "parseLine");
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  __name(processField, "processField");
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  __name(dispatchEvent, "dispatchEvent");
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  __name(reset, "reset");
  return { feed, reset };
}
__name(createParser, "createParser");
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
__name(splitLines, "splitLines");

// node_modules/@trigger.dev/core/dist/esm/v3/utils/crypto.js
init_esm();
async function randomUUID() {
  const { randomUUID: randomUUID2 } = await import("./crypto.node-F4LCZAEE.mjs");
  return randomUUID2();
}
__name(randomUUID, "randomUUID");
async function digestSHA256(data) {
  const { subtle: subtle2 } = await import("./crypto.node-F4LCZAEE.mjs");
  const hash = await subtle2.digest("SHA-256", new TextEncoder().encode(data));
  return Array.from(new Uint8Array(hash)).map((byte) => byte.toString(16).padStart(2, "0")).join("");
}
__name(digestSHA256, "digestSHA256");

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/core.js
var defaultRetryOptions2 = {
  maxAttempts: 3,
  factor: 2,
  minTimeoutInMs: 1e3,
  maxTimeoutInMs: 6e4,
  randomize: false
};
function zodfetch(schema, url, requestInit, options) {
  return new ApiPromise(_doZodFetch(schema, url, requestInit, options));
}
__name(zodfetch, "zodfetch");
function zodfetchCursorPage(schema, url, params, requestInit, options) {
  const query = new URLSearchParams(params.query);
  if (params.limit) {
    query.set("page[size]", String(params.limit));
  }
  if (params.after) {
    query.set("page[after]", params.after);
  }
  if (params.before) {
    query.set("page[before]", params.before);
  }
  const cursorPageSchema = external_exports.object({
    data: external_exports.array(schema),
    pagination: external_exports.object({
      next: external_exports.string().optional(),
      previous: external_exports.string().optional()
    })
  });
  const $url = new URL(url);
  $url.search = query.toString();
  const fetchResult = _doZodFetch(cursorPageSchema, $url.href, requestInit, options);
  return new CursorPagePromise(fetchResult, schema, url, params, requestInit, options);
}
__name(zodfetchCursorPage, "zodfetchCursorPage");
function zodfetchOffsetLimitPage(schema, url, params, requestInit, options) {
  const query = new URLSearchParams(params.query);
  if (params.limit) {
    query.set("perPage", String(params.limit));
  }
  if (params.page) {
    query.set("page", String(params.page));
  }
  const offsetLimitPageSchema = external_exports.object({
    data: external_exports.array(schema),
    pagination: external_exports.object({
      currentPage: external_exports.coerce.number(),
      totalPages: external_exports.coerce.number(),
      count: external_exports.coerce.number()
    })
  });
  const $url = new URL(url);
  $url.search = query.toString();
  const fetchResult = _doZodFetch(offsetLimitPageSchema, $url.href, requestInit, options);
  return new OffsetLimitPagePromise(fetchResult, schema, url, params, requestInit, options);
}
__name(zodfetchOffsetLimitPage, "zodfetchOffsetLimitPage");
async function traceZodFetch(params, callback) {
  if (!params.options?.tracer) {
    return callback();
  }
  const url = new URL(params.url);
  const method = params.requestInit?.method ?? "GET";
  const name2 = params.options.name ?? `${method} ${url.pathname}`;
  return await params.options.tracer.startActiveSpan(name2, async (span) => {
    return await callback(span);
  }, {
    attributes: {
      [SemanticInternalAttributes.STYLE_ICON]: params.options?.icon ?? "api",
      ...params.options.attributes
    }
  });
}
__name(traceZodFetch, "traceZodFetch");
async function _doZodFetch(schema, url, requestInit, options) {
  let $requestInit = await requestInit;
  return traceZodFetch({ url, requestInit: $requestInit, options }, async (span) => {
    const requestIdempotencyKey = await randomUUID();
    $requestInit = injectPropagationHeadersIfInWorker($requestInit);
    $requestInit = injectRequestIdempotencyKey(requestIdempotencyKey, $requestInit);
    const result = await _doZodFetchWithRetries(schema, url, $requestInit, options);
    if (options?.onResponseBody && span) {
      options.onResponseBody(result.data, span);
    }
    if (options?.prepareData) {
      result.data = await options.prepareData(result.data, result.response);
    }
    return result;
  });
}
__name(_doZodFetch, "_doZodFetch");
async function _doZodFetchWithRetries(schema, url, requestInit, options, attempt = 1) {
  try {
    const response = await context.with((0, import_core.suppressTracing)(context.active()), () => fetch(url, requestInitWithCache(requestInit)));
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      const retryResult = shouldRetry(response, attempt, options?.retry);
      if (retryResult.retry) {
        await waitForRetry(url, attempt + 1, retryResult.delay, options, requestInit, response);
        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);
      } else {
        const errText = await response.text().catch((e) => castToError2(e).message);
        const errJSON = safeJsonParse(errText);
        const errMessage = errJSON ? void 0 : errText;
        throw ApiError.generate(response.status, errJSON, errMessage, responseHeaders);
      }
    }
    const jsonBody = await safeJsonFromResponse(response);
    const parsedResult = schema.safeParse(jsonBody);
    if (parsedResult.success) {
      return { data: parsedResult.data, response };
    }
    const validationError = (0, import_zod_validation_error.fromZodError)(parsedResult.error);
    throw new ApiSchemaValidationError({
      status: response.status,
      cause: validationError,
      message: validationError.message,
      rawBody: jsonBody,
      headers: responseHeaders
    });
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    }
    if (error instanceof import_zod_validation_error.ValidationError) {
    }
    if (options?.retry) {
      const retry2 = { ...defaultRetryOptions2, ...options.retry };
      const delay = calculateNextRetryDelay(retry2, attempt);
      if (delay) {
        await waitForRetry(url, attempt + 1, delay, options, requestInit);
        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);
      }
    }
    throw new ApiConnectionError({ cause: castToError2(error) });
  }
}
__name(_doZodFetchWithRetries, "_doZodFetchWithRetries");
async function safeJsonFromResponse(response) {
  try {
    return await response.clone().json();
  } catch (error) {
    return;
  }
}
__name(safeJsonFromResponse, "safeJsonFromResponse");
function castToError2(err) {
  if (err instanceof Error)
    return err;
  return new Error(err);
}
__name(castToError2, "castToError");
function shouldRetry(response, attempt, retryOptions) {
  function shouldRetryForOptions() {
    const retry2 = { ...defaultRetryOptions2, ...retryOptions };
    const delay = calculateNextRetryDelay(retry2, attempt);
    if (delay) {
      return { retry: true, delay };
    } else {
      return { retry: false };
    }
  }
  __name(shouldRetryForOptions, "shouldRetryForOptions");
  const shouldRetryHeader = response.headers.get("x-should-retry");
  if (shouldRetryHeader === "true")
    return shouldRetryForOptions();
  if (shouldRetryHeader === "false")
    return { retry: false };
  if (response.status === 408)
    return shouldRetryForOptions();
  if (response.status === 409)
    return shouldRetryForOptions();
  if (response.status === 429) {
    if (attempt >= (typeof retryOptions?.maxAttempts === "number" ? retryOptions?.maxAttempts : 3)) {
      return { retry: false };
    }
    const resetAtUnixEpochMs = response.headers.get("x-ratelimit-reset");
    if (resetAtUnixEpochMs) {
      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);
      const delay = resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 1e3);
      if (delay > 0) {
        return { retry: true, delay };
      }
    }
    return shouldRetryForOptions();
  }
  if (response.status >= 500)
    return shouldRetryForOptions();
  return { retry: false };
}
__name(shouldRetry, "shouldRetry");
function safeJsonParse(text) {
  try {
    return JSON.parse(text);
  } catch (e) {
    return void 0;
  }
}
__name(safeJsonParse, "safeJsonParse");
function createResponseHeaders(headers) {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name2) {
      const key = name2.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
}
__name(createResponseHeaders, "createResponseHeaders");
function requestInitWithCache(requestInit) {
  try {
    const withCache = {
      ...requestInit,
      cache: "no-cache"
    };
    const _2 = new Request("http://localhost", withCache);
    return withCache;
  } catch (error) {
    return requestInit ?? {};
  }
}
__name(requestInitWithCache, "requestInitWithCache");
var ApiPromise = class extends Promise {
  static {
    __name(this, "ApiPromise");
  }
  responsePromise;
  constructor(responsePromise) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   */
  asResponse() {
    return this.responsePromise.then((p2) => p2.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    return this.responsePromise.then((result) => result.data);
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var CursorPagePromise = class extends ApiPromise {
  static {
    __name(this, "CursorPagePromise");
  }
  schema;
  url;
  params;
  requestInit;
  options;
  constructor(result, schema, url, params, requestInit, options) {
    super(result.then((result2) => ({
      data: new CursorPage(result2.data.data, result2.data.pagination, this.#fetchPage.bind(this)),
      response: result2.response
    })));
    this.schema = schema;
    this.url = url;
    this.params = params;
    this.requestInit = requestInit;
    this.options = options;
  }
  #fetchPage(params) {
    return zodfetchCursorPage(this.schema, this.url, { ...this.params, ...params }, this.requestInit, this.options);
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var OffsetLimitPagePromise = class extends ApiPromise {
  static {
    __name(this, "OffsetLimitPagePromise");
  }
  schema;
  url;
  params;
  requestInit;
  options;
  constructor(result, schema, url, params, requestInit, options) {
    super(result.then((result2) => ({
      data: new OffsetLimitPage(result2.data.data, result2.data.pagination, this.#fetchPage.bind(this)),
      response: result2.response
    })));
    this.schema = schema;
    this.url = url;
    this.params = params;
    this.requestInit = requestInit;
    this.options = options;
  }
  #fetchPage(params) {
    return zodfetchOffsetLimitPage(this.schema, this.url, { ...this.params, ...params }, this.requestInit, this.options);
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
async function waitForRetry(url, attempt, delay, options, requestInit, response) {
  if (options?.tracer) {
    const method = requestInit?.method ?? "GET";
    return options.tracer.startActiveSpan(response ? `wait after ${response.status}` : `wait after error`, async (span) => {
      await new Promise((resolve) => setTimeout(resolve, delay));
    }, {
      attributes: {
        [SemanticInternalAttributes.STYLE_ICON]: "wait",
        ...accessoryAttributes({
          items: [
            {
              text: `retrying ${options?.name ?? method.toUpperCase()} in ${delay}ms`,
              variant: "normal"
            }
          ],
          style: "codepath"
        })
      }
    });
  }
  await new Promise((resolve) => setTimeout(resolve, delay));
}
__name(waitForRetry, "waitForRetry");
function injectPropagationHeadersIfInWorker(requestInit) {
  const headers = new Headers(requestInit?.headers);
  const headersObject = Object.fromEntries(headers.entries());
  propagation.inject(context.active(), headersObject);
  return {
    ...requestInit,
    headers: new Headers(headersObject)
  };
}
__name(injectPropagationHeadersIfInWorker, "injectPropagationHeadersIfInWorker");
function injectRequestIdempotencyKey(requestIdempotencyKey, requestInit) {
  const headers = new Headers(requestInit?.headers);
  headers.set("x-trigger-request-idempotency-key", requestIdempotencyKey);
  return {
    ...requestInit,
    headers
  };
}
__name(injectRequestIdempotencyKey, "injectRequestIdempotencyKey");

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/runStream.js
init_esm();

// node_modules/eventsource-parser/dist/stream.js
init_esm();
var EventSourceParserStream = class extends TransformStream {
  static {
    __name(this, "EventSourceParserStream");
  }
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: /* @__PURE__ */ __name((event) => {
            controller.enqueue(event);
          }, "onEvent"),
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/errors.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/links.js
init_esm();
var links = {
  docs: {
    config: {
      home: "https://trigger.dev/docs/config/config-file",
      additionalPackages: "https://trigger.dev/docs/config/config-file#additionalpackages",
      extensions: "https://trigger.dev/docs/config/config-file#extensions",
      prisma: "https://trigger.dev/docs/config/config-file#prisma"
    },
    machines: {
      home: "https://trigger.dev/docs/v3/machines"
    },
    upgrade: {
      beta: "https://trigger.dev/docs/upgrading-beta"
    },
    troubleshooting: {
      concurrentWaits: "https://trigger.dev/docs/troubleshooting#parallel-waits-are-not-supported",
      stalledExecution: "https://trigger.dev/docs/troubleshooting#task-run-stalled-executing"
    },
    concurrency: {
      recursiveDeadlock: "https://trigger.dev/docs/queue-concurrency#waiting-for-a-subtask-on-the-same-queue",
      deadlock: "https://trigger.dev/docs/queue-concurrency#deadlock"
    },
    gitHubActions: {
      personalAccessToken: "https://trigger.dev/docs/github-actions#creating-a-personal-access-token"
    }
  },
  site: {
    home: "https://trigger.dev",
    contact: "https://trigger.dev/contact"
  }
};

// node_modules/@trigger.dev/core/dist/esm/utils.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/errors.js
var MANUAL_OOM_KILL_ERROR_MESSAGE = "MANUAL_OOM_KILL_ERROR";
function isManualOutOfMemoryError(error) {
  if (error.type === "BUILT_IN_ERROR") {
    if (error.message && error.message === MANUAL_OOM_KILL_ERROR_MESSAGE) {
      return true;
    }
  }
  return false;
}
__name(isManualOutOfMemoryError, "isManualOutOfMemoryError");
function isCompleteTaskWithOutput(error) {
  return error instanceof Error && error.name === "CompleteTaskWithOutput";
}
__name(isCompleteTaskWithOutput, "isCompleteTaskWithOutput");
function createErrorTaskError(error) {
  switch (error.type) {
    case "BUILT_IN_ERROR": {
      const e = new Error(error.message);
      e.name = error.name;
      e.stack = error.stackTrace;
      return e;
    }
    case "STRING_ERROR": {
      return error.raw;
    }
    case "CUSTOM_ERROR": {
      return JSON.parse(error.raw);
    }
    case "INTERNAL_ERROR": {
      const e = new Error(error.message ?? `Internal error (${error.code})`);
      e.name = error.code;
      e.stack = error.stackTrace;
      return e;
    }
  }
}
__name(createErrorTaskError, "createErrorTaskError");
function createJsonErrorObject(error) {
  const enhancedError = taskRunErrorEnhancer(error);
  switch (enhancedError.type) {
    case "BUILT_IN_ERROR": {
      return {
        name: enhancedError.name,
        message: enhancedError.message,
        stackTrace: enhancedError.stackTrace
      };
    }
    case "STRING_ERROR": {
      return {
        message: enhancedError.raw
      };
    }
    case "CUSTOM_ERROR": {
      return {
        message: enhancedError.raw
      };
    }
    case "INTERNAL_ERROR": {
      return {
        message: `trigger.dev internal error (${enhancedError.code})`
      };
    }
  }
}
__name(createJsonErrorObject, "createJsonErrorObject");
var prettyInternalErrors = {
  TASK_PROCESS_OOM_KILLED: {
    message: "Your run was terminated due to exceeding the machine's memory limit. Try increasing the machine preset in your task options or replay using a larger machine.",
    link: {
      name: "Machines",
      href: links.docs.machines.home
    }
  },
  TASK_PROCESS_MAYBE_OOM_KILLED: {
    message: "Your run was terminated due to exceeding the machine's memory limit. Try increasing the machine preset in your task options or replay using a larger machine.",
    link: {
      name: "Machines",
      href: links.docs.machines.home
    }
  },
  TASK_PROCESS_SIGSEGV: {
    message: "Your task crashed with a segmentation fault (SIGSEGV). Most likely there's a bug in a package or binary you're using. If this keeps happening and you're unsure why, please get in touch.",
    link: {
      name: "Contact us",
      href: links.site.contact,
      magic: "CONTACT_FORM"
    }
  },
  TASK_PROCESS_SIGTERM: {
    message: "Your task exited after receiving SIGTERM but we don't know why. If this keeps happening, please get in touch so we can investigate.",
    link: {
      name: "Contact us",
      href: links.site.contact,
      magic: "CONTACT_FORM"
    }
  },
  OUTDATED_SDK_VERSION: {
    message: "Your task is using an outdated version of the SDK. Please upgrade to the latest version.",
    link: {
      name: "Beta upgrade guide",
      href: links.docs.upgrade.beta
    }
  },
  TASK_DID_CONCURRENT_WAIT: {
    message: "Parallel waits are not supported, e.g. using Promise.all() around our wait functions.",
    link: {
      name: "Read the docs for solutions",
      href: links.docs.troubleshooting.concurrentWaits
    }
  },
  RECURSIVE_WAIT_DEADLOCK: {
    message: "This run will never execute because it was triggered recursively and the task has no remaining concurrency available.",
    link: {
      name: "See docs for help",
      href: links.docs.concurrency.recursiveDeadlock
    }
  },
  TASK_RUN_STALLED_EXECUTING: {
    link: {
      name: "Read our troubleshooting guide",
      href: links.docs.troubleshooting.stalledExecution
    }
  }
};
var getPrettyTaskRunError = /* @__PURE__ */ __name((code) => {
  return {
    type: "INTERNAL_ERROR",
    code,
    ...prettyInternalErrors[code]
  };
}, "getPrettyTaskRunError");
var findSignalInMessage = /* @__PURE__ */ __name((message, truncateLength = 100) => {
  if (!message) {
    return;
  }
  const trunc = truncateLength ? message.slice(0, truncateLength) : message;
  if (trunc.includes("SIGTERM")) {
    return "SIGTERM";
  } else if (trunc.includes("SIGSEGV")) {
    return "SIGSEGV";
  } else if (trunc.includes("SIGKILL")) {
    return "SIGKILL";
  } else if (trunc.includes("SIGABRT")) {
    return "SIGABRT";
  } else {
    return;
  }
}, "findSignalInMessage");
function taskRunErrorEnhancer(error) {
  switch (error.type) {
    case "BUILT_IN_ERROR": {
      if (error.name === "UnexpectedExitError") {
        if (error.message.startsWith("Unexpected exit with code -1")) {
          const signal = findSignalInMessage(error.stackTrace);
          switch (signal) {
            case "SIGTERM":
              return {
                ...getPrettyTaskRunError("TASK_PROCESS_SIGTERM")
              };
            case "SIGSEGV":
              return {
                ...getPrettyTaskRunError("TASK_PROCESS_SIGSEGV")
              };
            case "SIGKILL":
              return {
                ...getPrettyTaskRunError("TASK_PROCESS_MAYBE_OOM_KILLED")
              };
            case "SIGABRT":
              return {
                ...getPrettyTaskRunError("TASK_PROCESS_MAYBE_OOM_KILLED")
              };
            default:
              return {
                ...getPrettyTaskRunError("TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE"),
                message: error.message,
                stackTrace: error.stackTrace
              };
          }
        }
      }
      if (error.name === "Error") {
        if (error.message === "ffmpeg was killed with signal SIGKILL") {
          return {
            ...getPrettyTaskRunError("TASK_PROCESS_OOM_KILLED")
          };
        }
      }
      if (isManualOutOfMemoryError(error)) {
        return {
          ...getPrettyTaskRunError("TASK_PROCESS_OOM_KILLED")
        };
      }
      if (error.name === "TriggerApiError") {
        if (error.message.startsWith("Deadlock detected:")) {
          return {
            type: "BUILT_IN_ERROR",
            name: "Concurrency Deadlock Error",
            message: error.message,
            stackTrace: "",
            link: {
              name: "Read the docs",
              href: links.docs.concurrency.deadlock
            }
          };
        }
      }
      break;
    }
    case "STRING_ERROR": {
      break;
    }
    case "CUSTOM_ERROR": {
      break;
    }
    case "INTERNAL_ERROR": {
      if (error.code === TaskRunErrorCodes.TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE) {
        const signal = findSignalInMessage(error.message);
        switch (signal) {
          case "SIGTERM":
            return {
              ...getPrettyTaskRunError("TASK_PROCESS_SIGTERM")
            };
          case "SIGSEGV":
            return {
              ...getPrettyTaskRunError("TASK_PROCESS_SIGSEGV")
            };
          case "SIGKILL":
            return {
              ...getPrettyTaskRunError("TASK_PROCESS_MAYBE_OOM_KILLED")
            };
          case "SIGABRT":
            return {
              ...getPrettyTaskRunError("TASK_PROCESS_MAYBE_OOM_KILLED")
            };
          default: {
            return {
              ...getPrettyTaskRunError("TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE"),
              message: error.message,
              stackTrace: error.stackTrace
            };
          }
        }
      }
      return {
        ...error,
        ...getPrettyTaskRunError(error.code)
      };
    }
  }
  return error;
}
__name(taskRunErrorEnhancer, "taskRunErrorEnhancer");

// node_modules/@trigger.dev/core/dist/esm/v3/streams/asyncIterableStream.js
init_esm();
function createAsyncIterableStream(source, transformer) {
  const transformedStream = source.pipeThrough(new TransformStream(transformer));
  transformedStream[Symbol.asyncIterator] = () => {
    const reader = transformedStream.getReader();
    return {
      async next() {
        const { done, value } = await reader.read();
        return done ? { done: true, value: void 0 } : { done: false, value };
      }
    };
  };
  return transformedStream;
}
__name(createAsyncIterableStream, "createAsyncIterableStream");
function createAsyncIterableReadable(source, transformer, signal) {
  return new ReadableStream({
    async start(controller) {
      const transformedStream = source.pipeThrough(new TransformStream(transformer));
      const reader = transformedStream.getReader();
      signal.addEventListener("abort", () => {
        queueMicrotask(() => {
          reader.cancel();
          controller.close();
        });
      });
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          controller.close();
          break;
        }
        controller.enqueue(value);
      }
    }
  });
}
__name(createAsyncIterableReadable, "createAsyncIterableReadable");
function createAsyncIterableStreamFromAsyncIterable(asyncIterable, transformer, signal) {
  const stream2 = new ReadableStream({
    async start(controller) {
      try {
        if (signal) {
          signal.addEventListener("abort", () => {
            controller.close();
          });
        }
        const iterator = asyncIterable[Symbol.asyncIterator]();
        while (true) {
          if (signal?.aborted) {
            break;
          }
          const { done, value } = await iterator.next();
          if (done) {
            controller.close();
            break;
          }
          controller.enqueue(value);
        }
      } catch (error) {
        controller.error(error);
      }
    },
    cancel() {
      if ("kill" in asyncIterable) {
        asyncIterable.kill();
      }
    }
  });
  const transformedStream = stream2.pipeThrough(new TransformStream(transformer));
  return transformedStream;
}
__name(createAsyncIterableStreamFromAsyncIterable, "createAsyncIterableStreamFromAsyncIterable");

// node_modules/@trigger.dev/core/dist/esm/v3/utils/getEnv.js
init_esm();

// node_modules/std-env/dist/index.mjs
init_esm();
var r = /* @__PURE__ */ Object.create(null);
var i = /* @__PURE__ */ __name((e) => globalThis.process?.env || import.meta.env || globalThis.Deno?.env.toObject() || globalThis.__env__ || (e ? r : globalThis), "i");
var o = new Proxy(r, { get(e, s) {
  return i()[s] ?? r[s];
}, has(e, s) {
  const E = i();
  return s in E || s in r;
}, set(e, s, E) {
  const B = i(true);
  return B[s] = E, true;
}, deleteProperty(e, s) {
  if (!s) return false;
  const E = i(true);
  return delete E[s], true;
}, ownKeys() {
  const e = i(true);
  return Object.keys(e);
} });
var t = typeof process < "u" && process.env && process.env.NODE_ENV || "";
var f = [["APPVEYOR"], ["AWS_AMPLIFY", "AWS_APP_ID", { ci: true }], ["AZURE_PIPELINES", "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"], ["AZURE_STATIC", "INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"], ["APPCIRCLE", "AC_APPCIRCLE"], ["BAMBOO", "bamboo_planKey"], ["BITBUCKET", "BITBUCKET_COMMIT"], ["BITRISE", "BITRISE_IO"], ["BUDDY", "BUDDY_WORKSPACE_ID"], ["BUILDKITE"], ["CIRCLE", "CIRCLECI"], ["CIRRUS", "CIRRUS_CI"], ["CLOUDFLARE_PAGES", "CF_PAGES", { ci: true }], ["CLOUDFLARE_WORKERS", "WORKERS_CI", { ci: true }], ["CODEBUILD", "CODEBUILD_BUILD_ARN"], ["CODEFRESH", "CF_BUILD_ID"], ["DRONE"], ["DRONE", "DRONE_BUILD_EVENT"], ["DSARI"], ["GITHUB_ACTIONS"], ["GITLAB", "GITLAB_CI"], ["GITLAB", "CI_MERGE_REQUEST_ID"], ["GOCD", "GO_PIPELINE_LABEL"], ["LAYERCI"], ["HUDSON", "HUDSON_URL"], ["JENKINS", "JENKINS_URL"], ["MAGNUM"], ["NETLIFY"], ["NETLIFY", "NETLIFY_LOCAL", { ci: false }], ["NEVERCODE"], ["RENDER"], ["SAIL", "SAILCI"], ["SEMAPHORE"], ["SCREWDRIVER"], ["SHIPPABLE"], ["SOLANO", "TDDIUM"], ["STRIDER"], ["TEAMCITY", "TEAMCITY_VERSION"], ["TRAVIS"], ["VERCEL", "NOW_BUILDER"], ["VERCEL", "VERCEL", { ci: false }], ["VERCEL", "VERCEL_ENV", { ci: false }], ["APPCENTER", "APPCENTER_BUILD_ID"], ["CODESANDBOX", "CODESANDBOX_SSE", { ci: false }], ["CODESANDBOX", "CODESANDBOX_HOST", { ci: false }], ["STACKBLITZ"], ["STORMKIT"], ["CLEAVR"], ["ZEABUR"], ["CODESPHERE", "CODESPHERE_APP_ID", { ci: true }], ["RAILWAY", "RAILWAY_PROJECT_ID"], ["RAILWAY", "RAILWAY_SERVICE_ID"], ["DENO-DEPLOY", "DENO_DEPLOYMENT_ID"], ["FIREBASE_APP_HOSTING", "FIREBASE_APP_HOSTING", { ci: true }]];
function b() {
  if (globalThis.process?.env) for (const e of f) {
    const s = e[1] || e[0];
    if (globalThis.process?.env[s]) return { name: e[0].toLowerCase(), ...e[2] };
  }
  return globalThis.process?.env?.SHELL === "/bin/jsh" && globalThis.process?.versions?.webcontainer ? { name: "stackblitz", ci: false } : { name: "", ci: false };
}
__name(b, "b");
var l = b();
var p = l.name;
function n(e) {
  return e ? e !== "false" : false;
}
__name(n, "n");
var I = globalThis.process?.platform || "";
var T = n(o.CI) || l.ci !== false;
var R = n(globalThis.process?.stdout && globalThis.process?.stdout.isTTY);
var d = n(o.DEBUG);
var a = t === "test" || n(o.TEST);
var v = n(o.MINIMAL) || T || a || !R;
var A = /^win/i.test(I);
var M = /^linux/i.test(I);
var m = /^darwin/i.test(I);
var Y = !n(o.NO_COLOR) && (n(o.FORCE_COLOR) || (R || A) && o.TERM !== "dumb" || T);
var C = (globalThis.process?.versions?.node || "").replace(/^v/, "") || null;
var V = Number(C?.split(".")[0]) || null;
var W = globalThis.process || /* @__PURE__ */ Object.create(null);
var _ = { versions: {} };
var y = new Proxy(W, { get(e, s) {
  if (s === "env") return o;
  if (s in e) return e[s];
  if (s in _) return _[s];
} });
var O = globalThis.process?.release?.name === "node";
var c = !!globalThis.Bun || !!globalThis.process?.versions?.bun;
var D = !!globalThis.Deno;
var L = !!globalThis.fastly;
var S = !!globalThis.Netlify;
var u = !!globalThis.EdgeRuntime;
var N = globalThis.navigator?.userAgent === "Cloudflare-Workers";
var F = [[S, "netlify"], [u, "edge-light"], [N, "workerd"], [L, "fastly"], [D, "deno"], [c, "bun"], [O, "node"]];
function G() {
  const e = F.find((s) => s[0]);
  if (e) return { name: e[1] };
}
__name(G, "G");
var P = G();
var K = P?.name || "";

// node_modules/@trigger.dev/core/dist/esm/v3/utils/getEnv.js
function getEnvVar(name2, defaultValue) {
  return o[name2] ?? defaultValue;
}
__name(getEnvVar, "getEnvVar");

// node_modules/@trigger.dev/core/dist/esm/v3/utils/ioSerialization.js
init_esm();
var import_path = __toESM(require_lib(), 1);

// node_modules/@trigger.dev/core/dist/esm/v3/apiClientManager-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/apiClientManager/index.js
init_esm();
var API_NAME7 = "api-client";
var ApiClientMissingError = class extends Error {
  static {
    __name(this, "ApiClientMissingError");
  }
  constructor(message) {
    super(message);
    this.name = "ApiClientMissingError";
  }
};
var APIClientManagerAPI = class _APIClientManagerAPI {
  static {
    __name(this, "APIClientManagerAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _APIClientManagerAPI();
    }
    return this._instance;
  }
  disable() {
    unregisterGlobal(API_NAME7);
  }
  get baseURL() {
    const config = this.#getConfig();
    return config?.baseURL ?? getEnvVar("TRIGGER_API_URL") ?? "https://api.trigger.dev";
  }
  get accessToken() {
    const config = this.#getConfig();
    return config?.secretKey ?? config?.accessToken ?? getEnvVar("TRIGGER_SECRET_KEY") ?? getEnvVar("TRIGGER_ACCESS_TOKEN");
  }
  get branchName() {
    const config = this.#getConfig();
    const value = config?.previewBranch ?? getEnvVar("TRIGGER_PREVIEW_BRANCH") ?? getEnvVar("VERCEL_GIT_COMMIT_REF") ?? void 0;
    return value ? value : void 0;
  }
  get client() {
    if (!this.baseURL || !this.accessToken) {
      return void 0;
    }
    const requestOptions = this.#getConfig()?.requestOptions;
    const futureFlags = this.#getConfig()?.future;
    return new ApiClient(this.baseURL, this.accessToken, this.branchName, requestOptions, futureFlags);
  }
  clientOrThrow(config) {
    const baseURL = config?.baseURL ?? this.baseURL;
    const accessToken = config?.accessToken ?? config?.secretKey ?? this.accessToken;
    if (!baseURL || !accessToken) {
      throw new ApiClientMissingError(this.apiClientMissingError());
    }
    const branchName = config?.previewBranch ?? this.branchName;
    const requestOptions = config?.requestOptions ?? this.#getConfig()?.requestOptions;
    const futureFlags = config?.future ?? this.#getConfig()?.future;
    return new ApiClient(baseURL, accessToken, branchName, requestOptions, futureFlags);
  }
  runWithConfig(config, fn) {
    const originalConfig = this.#getConfig();
    const $config = { ...originalConfig, ...config };
    registerGlobal(API_NAME7, $config, true);
    return fn().finally(() => {
      registerGlobal(API_NAME7, originalConfig, true);
    });
  }
  setGlobalAPIClientConfiguration(config) {
    return registerGlobal(API_NAME7, config);
  }
  #getConfig() {
    return getGlobal(API_NAME7);
  }
  apiClientMissingError() {
    const hasBaseUrl = !!this.baseURL;
    const hasAccessToken = !!this.accessToken;
    if (!hasBaseUrl && !hasAccessToken) {
      return `You need to set the TRIGGER_API_URL and TRIGGER_SECRET_KEY environment variables. See https://trigger.dev/docs/management/overview#authentication`;
    } else if (!hasBaseUrl) {
      return `You need to set the TRIGGER_API_URL environment variable. See https://trigger.dev/docs/management/overview#authentication`;
    } else if (!hasAccessToken) {
      return `You need to set the TRIGGER_SECRET_KEY environment variable. See https://trigger.dev/docs/management/overview#authentication`;
    }
    return `Unknown error`;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/apiClientManager-api.js
var apiClientManager = APIClientManagerAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/limits.js
init_esm();
function getOtelEnvVarLimit(key, defaultValue) {
  const value = getEnvVar(key);
  if (!value) {
    return defaultValue;
  }
  return parseInt(value, 10);
}
__name(getOtelEnvVarLimit, "getOtelEnvVarLimit");
var OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT = getOtelEnvVarLimit("TRIGGER_OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT", 1024);
var OTEL_LOG_ATTRIBUTE_COUNT_LIMIT = getOtelEnvVarLimit("TRIGGER_OTEL_LOG_ATTRIBUTE_COUNT_LIMIT", 1024);
var OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT = getOtelEnvVarLimit("TRIGGER_OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT", 131072);
var OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT = getOtelEnvVarLimit("TRIGGER_OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT", 131072);
var OTEL_SPAN_EVENT_COUNT_LIMIT = getOtelEnvVarLimit("TRIGGER_OTEL_SPAN_EVENT_COUNT_LIMIT", 10);
var OTEL_LINK_COUNT_LIMIT = getOtelEnvVarLimit("TRIGGER_OTEL_LINK_COUNT_LIMIT", 2);
var OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT = getOtelEnvVarLimit("TRIGGER_OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT", 10);
var OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = getOtelEnvVarLimit("TRIGGER_OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", 10);
var OFFLOAD_IO_PACKET_LENGTH_LIMIT = 128 * 1024;

// node_modules/@trigger.dev/core/dist/esm/v3/zodfetch.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/utils/ioSerialization.js
async function parsePacket(value, options) {
  if (!value.data) {
    return void 0;
  }
  switch (value.dataType) {
    case "application/json":
      return JSON.parse(value.data, makeSafeReviver(options));
    case "application/super+json":
      const { parse } = await loadSuperJSON();
      return parse(value.data);
    case "text/plain":
      return value.data;
    case "application/store":
      throw new Error(`Cannot parse an application/store packet (${value.data}). Needs to be imported first.`);
    default:
      return value.data;
  }
}
__name(parsePacket, "parsePacket");
async function conditionallyImportAndParsePacket(value, client) {
  const importedPacket = await conditionallyImportPacket(value, void 0, client);
  return await parsePacket(importedPacket);
}
__name(conditionallyImportAndParsePacket, "conditionallyImportAndParsePacket");
async function stringifyIO(value) {
  if (value === void 0) {
    return { dataType: "application/json" };
  }
  if (typeof value === "string") {
    return { data: value, dataType: "text/plain" };
  }
  try {
    const { stringify } = await loadSuperJSON();
    const data = stringify(value);
    return { data, dataType: "application/super+json" };
  } catch {
    return { data: value, dataType: "application/json" };
  }
}
__name(stringifyIO, "stringifyIO");
var ioRetryOptions = {
  minTimeoutInMs: 500,
  maxTimeoutInMs: 5e3,
  maxAttempts: 5,
  factor: 2,
  randomize: true
};
async function conditionallyImportPacket(packet, tracer2, client) {
  if (packet.dataType !== "application/store") {
    return packet;
  }
  if (!tracer2) {
    return await importPacket(packet, void 0, client);
  } else {
    const result = await tracer2.startActiveSpan("store.downloadPayload", async (span) => {
      return await importPacket(packet, span, client);
    }, {
      attributes: {
        [SemanticInternalAttributes.STYLE_ICON]: "cloud-download"
      }
    });
    return result ?? packet;
  }
}
__name(conditionallyImportPacket, "conditionallyImportPacket");
async function importPacket(packet, span, client) {
  if (!packet.data) {
    return packet;
  }
  const $client = client ?? apiClientManager.client;
  if (!$client) {
    return packet;
  }
  const presignedResponse = await $client.getPayloadUrl(packet.data);
  const response = await zodfetch(external_exports.any(), presignedResponse.presignedUrl, void 0, {
    retry: ioRetryOptions
  }).asResponse();
  if (!response.ok) {
    throw new Error(`Failed to import packet ${presignedResponse.presignedUrl}: ${response.statusText}`);
  }
  const data = await response.text();
  span?.setAttribute("size", Buffer.byteLength(data, "utf8"));
  return {
    data,
    dataType: response.headers.get("content-type") ?? "application/json"
  };
}
__name(importPacket, "importPacket");
function makeSafeReviver(options) {
  if (!options) {
    return void 0;
  }
  return /* @__PURE__ */ __name(function reviver(key, value) {
    if (options?.filteredKeys?.includes(key)) {
      return void 0;
    }
    return value;
  }, "reviver");
}
__name(makeSafeReviver, "makeSafeReviver");
async function loadSuperJSON() {
  const superjson = await import("./dist-CABZCAPS.mjs");
  superjson.registerCustom({
    isApplicable: /* @__PURE__ */ __name((v2) => typeof Buffer === "function" && Buffer.isBuffer(v2), "isApplicable"),
    serialize: /* @__PURE__ */ __name((v2) => [...v2], "serialize"),
    deserialize: /* @__PURE__ */ __name((v2) => Buffer.from(v2), "deserialize")
  }, "buffer");
  return superjson;
}
__name(loadSuperJSON, "loadSuperJSON");

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/stream.js
init_esm();

// node_modules/@electric-sql/client/dist/index.mjs
init_esm();
var import_fetch_event_source = __toESM(require_cjs2(), 1);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __typeError = /* @__PURE__ */ __name((msg) => {
  throw TypeError(msg);
}, "__typeError");
var __defNormalProp = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __spreadValues = /* @__PURE__ */ __name((a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
}, "__spreadValues");
var __spreadProps = /* @__PURE__ */ __name((a2, b2) => __defProps(a2, __getOwnPropDescs(b2)), "__spreadProps");
var __objRest = /* @__PURE__ */ __name((source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
}, "__objRest");
var __accessCheck = /* @__PURE__ */ __name((obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg), "__accessCheck");
var __privateGet = /* @__PURE__ */ __name((obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), "__privateGet");
var __privateAdd = /* @__PURE__ */ __name((obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), "__privateAdd");
var __privateSet = /* @__PURE__ */ __name((obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value), "__privateSet");
var __privateMethod = /* @__PURE__ */ __name((obj, member, method) => (__accessCheck(obj, member, "access private method"), method), "__privateMethod");
var __privateWrapper = /* @__PURE__ */ __name((obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
}), "__privateWrapper");
var __async = /* @__PURE__ */ __name((__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = /* @__PURE__ */ __name((value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }, "fulfilled");
    var rejected = /* @__PURE__ */ __name((value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }, "rejected");
    var step = /* @__PURE__ */ __name((x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected), "step");
    step((generator = generator.apply(__this, __arguments)).next());
  });
}, "__async");
var FetchError = class _FetchError extends Error {
  static {
    __name(this, "_FetchError");
  }
  constructor(status, text, json, headers, url, message) {
    super(
      message || `HTTP Error ${status} at ${url}: ${text != null ? text : JSON.stringify(json)}`
    );
    this.url = url;
    this.name = `FetchError`;
    this.status = status;
    this.text = text;
    this.json = json;
    this.headers = headers;
  }
  static fromResponse(response, url) {
    return __async(this, null, function* () {
      const status = response.status;
      const headers = Object.fromEntries([...response.headers.entries()]);
      let text = void 0;
      let json = void 0;
      const contentType = response.headers.get(`content-type`);
      if (!response.bodyUsed) {
        if (contentType && contentType.includes(`application/json`)) {
          json = yield response.json();
        } else {
          text = yield response.text();
        }
      }
      return new _FetchError(status, text, json, headers, url);
    });
  }
};
var FetchBackoffAbortError = class extends Error {
  static {
    __name(this, "FetchBackoffAbortError");
  }
  constructor() {
    super(`Fetch with backoff aborted`);
    this.name = `FetchBackoffAbortError`;
  }
};
var MissingShapeUrlError = class extends Error {
  static {
    __name(this, "MissingShapeUrlError");
  }
  constructor() {
    super(`Invalid shape options: missing required url parameter`);
    this.name = `MissingShapeUrlError`;
  }
};
var InvalidSignalError = class extends Error {
  static {
    __name(this, "InvalidSignalError");
  }
  constructor() {
    super(`Invalid signal option. It must be an instance of AbortSignal.`);
    this.name = `InvalidSignalError`;
  }
};
var MissingShapeHandleError = class extends Error {
  static {
    __name(this, "MissingShapeHandleError");
  }
  constructor() {
    super(
      `shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)`
    );
    this.name = `MissingShapeHandleError`;
  }
};
var ReservedParamError = class extends Error {
  static {
    __name(this, "ReservedParamError");
  }
  constructor(reservedParams) {
    super(
      `Cannot use reserved Electric parameter names in custom params: ${reservedParams.join(`, `)}`
    );
    this.name = `ReservedParamError`;
  }
};
var ParserNullValueError = class extends Error {
  static {
    __name(this, "ParserNullValueError");
  }
  constructor(columnName) {
    super(`Column "${columnName != null ? columnName : `unknown`}" does not allow NULL values`);
    this.name = `ParserNullValueError`;
  }
};
var MissingHeadersError = class extends Error {
  static {
    __name(this, "MissingHeadersError");
  }
  constructor(url, missingHeaders) {
    let msg = `The response for the shape request to ${url} didn't include the following required headers:
`;
    missingHeaders.forEach((h) => {
      msg += `- ${h}
`;
    });
    msg += `
This is often due to a proxy not setting CORS correctly so that all Electric headers can be read by the client.`;
    msg += `
For more information visit the troubleshooting guide: /docs/guides/troubleshooting/missing-headers`;
    super(msg);
  }
};
var parseNumber = /* @__PURE__ */ __name((value) => Number(value), "parseNumber");
var parseBool = /* @__PURE__ */ __name((value) => value === `true` || value === `t`, "parseBool");
var parseBigInt = /* @__PURE__ */ __name((value) => BigInt(value), "parseBigInt");
var parseJson = /* @__PURE__ */ __name((value) => JSON.parse(value), "parseJson");
var identityParser = /* @__PURE__ */ __name((v2) => v2, "identityParser");
var defaultParser = {
  int2: parseNumber,
  int4: parseNumber,
  int8: parseBigInt,
  bool: parseBool,
  float4: parseNumber,
  float8: parseNumber,
  json: parseJson,
  jsonb: parseJson
};
function pgArrayParser(value, parser) {
  let i2 = 0;
  let char = null;
  let str = ``;
  let quoted = false;
  let last = 0;
  let p2 = void 0;
  function extractValue(x, start, end) {
    let val = x.slice(start, end);
    val = val === `NULL` ? null : val;
    return parser ? parser(val) : val;
  }
  __name(extractValue, "extractValue");
  function loop(x) {
    const xs = [];
    for (; i2 < x.length; i2++) {
      char = x[i2];
      if (quoted) {
        if (char === `\\`) {
          str += x[++i2];
        } else if (char === `"`) {
          xs.push(parser ? parser(str) : str);
          str = ``;
          quoted = x[i2 + 1] === `"`;
          last = i2 + 2;
        } else {
          str += char;
        }
      } else if (char === `"`) {
        quoted = true;
      } else if (char === `{`) {
        last = ++i2;
        xs.push(loop(x));
      } else if (char === `}`) {
        quoted = false;
        last < i2 && xs.push(extractValue(x, last, i2));
        last = i2 + 1;
        break;
      } else if (char === `,` && p2 !== `}` && p2 !== `"`) {
        xs.push(extractValue(x, last, i2));
        last = i2 + 1;
      }
      p2 = char;
    }
    last < i2 && xs.push(xs.push(extractValue(x, last, i2 + 1)));
    return xs;
  }
  __name(loop, "loop");
  return loop(value)[0];
}
__name(pgArrayParser, "pgArrayParser");
var MessageParser = class {
  static {
    __name(this, "MessageParser");
  }
  constructor(parser, transformer) {
    this.parser = __spreadValues(__spreadValues({}, defaultParser), parser);
    this.transformer = transformer;
  }
  parse(messages, schema) {
    return JSON.parse(messages, (key, value) => {
      if ((key === `value` || key === `old_value`) && typeof value === `object` && value !== null) {
        const row = value;
        Object.keys(row).forEach((key2) => {
          row[key2] = this.parseRow(key2, row[key2], schema);
        });
        if (this.transformer) value = this.transformer(value);
      }
      return value;
    });
  }
  // Parses the message values using the provided parser based on the schema information
  parseRow(key, value, schema) {
    var _b;
    const columnInfo = schema[key];
    if (!columnInfo) {
      return value;
    }
    const _a = columnInfo, { type: typ, dims: dimensions } = _a, additionalInfo = __objRest(_a, ["type", "dims"]);
    const typeParser = (_b = this.parser[typ]) != null ? _b : identityParser;
    const parser = makeNullableParser(typeParser, columnInfo, key);
    if (dimensions && dimensions > 0) {
      const nullablePgArrayParser = makeNullableParser(
        (value2, _2) => pgArrayParser(value2, parser),
        columnInfo,
        key
      );
      return nullablePgArrayParser(value);
    }
    return parser(value, additionalInfo);
  }
};
function makeNullableParser(parser, columnInfo, columnName) {
  var _a;
  const isNullable = !((_a = columnInfo.not_null) != null ? _a : false);
  return (value) => {
    if (value === null) {
      if (!isNullable) {
        throw new ParserNullValueError(columnName != null ? columnName : `unknown`);
      }
      return null;
    }
    return parser(value, columnInfo);
  };
}
__name(makeNullableParser, "makeNullableParser");
function isChangeMessage(message) {
  return `key` in message;
}
__name(isChangeMessage, "isChangeMessage");
function isControlMessage(message) {
  return !isChangeMessage(message);
}
__name(isControlMessage, "isControlMessage");
function isUpToDateMessage(message) {
  return isControlMessage(message) && message.headers.control === `up-to-date`;
}
__name(isUpToDateMessage, "isUpToDateMessage");
function getOffset(message) {
  const lsn = message.headers.global_last_seen_lsn;
  if (!lsn) {
    return;
  }
  return `${lsn}_0`;
}
__name(getOffset, "getOffset");
function isVisibleInSnapshot(txid, snapshot) {
  const xid = BigInt(txid);
  const xmin = BigInt(snapshot.xmin);
  const xmax = BigInt(snapshot.xmax);
  const xip = snapshot.xip_list.map(BigInt);
  return xid < xmin || xid < xmax && !xip.includes(xid);
}
__name(isVisibleInSnapshot, "isVisibleInSnapshot");
var LIVE_CACHE_BUSTER_HEADER = `electric-cursor`;
var SHAPE_HANDLE_HEADER = `electric-handle`;
var CHUNK_LAST_OFFSET_HEADER = `electric-offset`;
var SHAPE_SCHEMA_HEADER = `electric-schema`;
var CHUNK_UP_TO_DATE_HEADER = `electric-up-to-date`;
var COLUMNS_QUERY_PARAM = `columns`;
var LIVE_CACHE_BUSTER_QUERY_PARAM = `cursor`;
var EXPIRED_HANDLE_QUERY_PARAM = `expired_handle`;
var SHAPE_HANDLE_QUERY_PARAM = `handle`;
var LIVE_QUERY_PARAM = `live`;
var OFFSET_QUERY_PARAM = `offset`;
var TABLE_QUERY_PARAM = `table`;
var WHERE_QUERY_PARAM = `where`;
var REPLICA_PARAM = `replica`;
var WHERE_PARAMS_PARAM = `params`;
var EXPERIMENTAL_LIVE_SSE_QUERY_PARAM = `experimental_live_sse`;
var FORCE_DISCONNECT_AND_REFRESH = `force-disconnect-and-refresh`;
var PAUSE_STREAM = `pause-stream`;
var LOG_MODE_QUERY_PARAM = `log`;
var SUBSET_PARAM_WHERE = `subset__where`;
var SUBSET_PARAM_LIMIT = `subset__limit`;
var SUBSET_PARAM_OFFSET = `subset__offset`;
var SUBSET_PARAM_ORDER_BY = `subset__order_by`;
var SUBSET_PARAM_WHERE_PARAMS = `subset__params`;
var ELECTRIC_PROTOCOL_QUERY_PARAMS = [
  LIVE_QUERY_PARAM,
  SHAPE_HANDLE_QUERY_PARAM,
  OFFSET_QUERY_PARAM,
  LIVE_CACHE_BUSTER_QUERY_PARAM,
  EXPIRED_HANDLE_QUERY_PARAM,
  LOG_MODE_QUERY_PARAM,
  SUBSET_PARAM_WHERE,
  SUBSET_PARAM_LIMIT,
  SUBSET_PARAM_OFFSET,
  SUBSET_PARAM_ORDER_BY,
  SUBSET_PARAM_WHERE_PARAMS
];
var HTTP_RETRY_STATUS_CODES = [429];
var BackoffDefaults = {
  initialDelay: 100,
  maxDelay: 1e4,
  multiplier: 1.3
};
function createFetchWithBackoff(fetchClient, backoffOptions = BackoffDefaults) {
  const {
    initialDelay,
    maxDelay,
    multiplier,
    debug = false,
    onFailedAttempt
  } = backoffOptions;
  return (...args) => __async(this, null, function* () {
    var _a;
    const url = args[0];
    const options = args[1];
    let delay = initialDelay;
    let attempt = 0;
    while (true) {
      try {
        const result = yield fetchClient(...args);
        if (result.ok) return result;
        const err = yield FetchError.fromResponse(result, url.toString());
        throw err;
      } catch (e) {
        onFailedAttempt == null ? void 0 : onFailedAttempt();
        if ((_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.aborted) {
          throw new FetchBackoffAbortError();
        } else if (e instanceof FetchError && !HTTP_RETRY_STATUS_CODES.includes(e.status) && e.status >= 400 && e.status < 500) {
          throw e;
        } else {
          yield new Promise((resolve) => setTimeout(resolve, delay));
          delay = Math.min(delay * multiplier, maxDelay);
          if (debug) {
            attempt++;
            console.log(`Retry attempt #${attempt} after ${delay}ms`);
          }
        }
      }
    }
  });
}
__name(createFetchWithBackoff, "createFetchWithBackoff");
var NO_BODY_STATUS_CODES = [201, 204, 205];
function createFetchWithConsumedMessages(fetchClient) {
  return (...args) => __async(this, null, function* () {
    const url = args[0];
    const res = yield fetchClient(...args);
    try {
      if (res.status < 200 || NO_BODY_STATUS_CODES.includes(res.status)) {
        return res;
      }
      const text = yield res.text();
      return new Response(text, res);
    } catch (err) {
      throw new FetchError(
        res.status,
        void 0,
        void 0,
        Object.fromEntries([...res.headers.entries()]),
        url.toString(),
        err instanceof Error ? err.message : typeof err === `string` ? err : `failed to read body`
      );
    }
  });
}
__name(createFetchWithConsumedMessages, "createFetchWithConsumedMessages");
var ChunkPrefetchDefaults = {
  maxChunksToPrefetch: 2
};
function createFetchWithChunkBuffer(fetchClient, prefetchOptions = ChunkPrefetchDefaults) {
  const { maxChunksToPrefetch } = prefetchOptions;
  let prefetchQueue;
  const prefetchClient = /* @__PURE__ */ __name((...args) => __async(this, null, function* () {
    const url = args[0].toString();
    const prefetchedRequest = prefetchQueue == null ? void 0 : prefetchQueue.consume(...args);
    if (prefetchedRequest) {
      return prefetchedRequest;
    }
    prefetchQueue == null ? void 0 : prefetchQueue.abort();
    const response = yield fetchClient(...args);
    const nextUrl = getNextChunkUrl(url, response);
    if (nextUrl) {
      prefetchQueue = new PrefetchQueue({
        fetchClient,
        maxPrefetchedRequests: maxChunksToPrefetch,
        url: nextUrl,
        requestInit: args[1]
      });
    }
    return response;
  }), "prefetchClient");
  return prefetchClient;
}
__name(createFetchWithChunkBuffer, "createFetchWithChunkBuffer");
var requiredElectricResponseHeaders = [
  `electric-offset`,
  `electric-handle`
];
var requiredLiveResponseHeaders = [`electric-cursor`];
var requiredNonLiveResponseHeaders = [`electric-schema`];
function createFetchWithResponseHeadersCheck(fetchClient) {
  return (...args) => __async(this, null, function* () {
    const response = yield fetchClient(...args);
    if (response.ok) {
      const headers = response.headers;
      const missingHeaders = [];
      const addMissingHeaders = /* @__PURE__ */ __name((requiredHeaders) => missingHeaders.push(...requiredHeaders.filter((h) => !headers.has(h))), "addMissingHeaders");
      const input = args[0];
      const urlString = input.toString();
      const url = new URL(urlString);
      const isSnapshotRequest = [
        SUBSET_PARAM_WHERE,
        SUBSET_PARAM_WHERE_PARAMS,
        SUBSET_PARAM_LIMIT,
        SUBSET_PARAM_OFFSET,
        SUBSET_PARAM_ORDER_BY
      ].some((p2) => url.searchParams.has(p2));
      if (isSnapshotRequest) {
        return response;
      }
      addMissingHeaders(requiredElectricResponseHeaders);
      if (url.searchParams.get(LIVE_QUERY_PARAM) === `true`) {
        addMissingHeaders(requiredLiveResponseHeaders);
      }
      if (!url.searchParams.has(LIVE_QUERY_PARAM) || url.searchParams.get(LIVE_QUERY_PARAM) === `false`) {
        addMissingHeaders(requiredNonLiveResponseHeaders);
      }
      if (missingHeaders.length > 0) {
        throw new MissingHeadersError(urlString, missingHeaders);
      }
    }
    return response;
  });
}
__name(createFetchWithResponseHeadersCheck, "createFetchWithResponseHeadersCheck");
var _fetchClient;
var _maxPrefetchedRequests;
var _prefetchQueue;
var _queueHeadUrl;
var _queueTailUrl;
var _PrefetchQueue_instances;
var prefetch_fn;
var PrefetchQueue = class {
  static {
    __name(this, "PrefetchQueue");
  }
  constructor(options) {
    __privateAdd(this, _PrefetchQueue_instances);
    __privateAdd(this, _fetchClient);
    __privateAdd(this, _maxPrefetchedRequests);
    __privateAdd(this, _prefetchQueue, /* @__PURE__ */ new Map());
    __privateAdd(this, _queueHeadUrl);
    __privateAdd(this, _queueTailUrl);
    var _a;
    __privateSet(this, _fetchClient, (_a = options.fetchClient) != null ? _a : (...args) => fetch(...args));
    __privateSet(this, _maxPrefetchedRequests, options.maxPrefetchedRequests);
    __privateSet(this, _queueHeadUrl, options.url.toString());
    __privateSet(this, _queueTailUrl, __privateGet(this, _queueHeadUrl));
    __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, options.url, options.requestInit);
  }
  abort() {
    __privateGet(this, _prefetchQueue).forEach(([_2, aborter]) => aborter.abort());
  }
  consume(...args) {
    var _a;
    const url = args[0].toString();
    const request = (_a = __privateGet(this, _prefetchQueue).get(url)) == null ? void 0 : _a[0];
    if (!request || url !== __privateGet(this, _queueHeadUrl)) return;
    __privateGet(this, _prefetchQueue).delete(url);
    request.then((response) => {
      const nextUrl = getNextChunkUrl(url, response);
      __privateSet(this, _queueHeadUrl, nextUrl);
      if (__privateGet(this, _queueTailUrl) && !__privateGet(this, _prefetchQueue).has(__privateGet(this, _queueTailUrl))) {
        __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, __privateGet(this, _queueTailUrl), args[1]);
      }
    }).catch(() => {
    });
    return request;
  }
};
_fetchClient = /* @__PURE__ */ new WeakMap();
_maxPrefetchedRequests = /* @__PURE__ */ new WeakMap();
_prefetchQueue = /* @__PURE__ */ new WeakMap();
_queueHeadUrl = /* @__PURE__ */ new WeakMap();
_queueTailUrl = /* @__PURE__ */ new WeakMap();
_PrefetchQueue_instances = /* @__PURE__ */ new WeakSet();
prefetch_fn = /* @__PURE__ */ __name(function(...args) {
  var _a, _b;
  const url = args[0].toString();
  if (__privateGet(this, _prefetchQueue).size >= __privateGet(this, _maxPrefetchedRequests)) return;
  const aborter = new AbortController();
  try {
    const { signal, cleanup } = chainAborter(aborter, (_a = args[1]) == null ? void 0 : _a.signal);
    const request = __privateGet(this, _fetchClient).call(this, url, __spreadProps(__spreadValues({}, (_b = args[1]) != null ? _b : {}), { signal }));
    __privateGet(this, _prefetchQueue).set(url, [request, aborter]);
    request.then((response) => {
      if (!response.ok || aborter.signal.aborted) return;
      const nextUrl = getNextChunkUrl(url, response);
      if (!nextUrl || nextUrl === url) {
        __privateSet(this, _queueTailUrl, void 0);
        return;
      }
      __privateSet(this, _queueTailUrl, nextUrl);
      return __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, nextUrl, args[1]);
    }).catch(() => {
    }).finally(cleanup);
  } catch (_2) {
  }
}, "prefetch_fn");
function getNextChunkUrl(url, res) {
  const shapeHandle = res.headers.get(SHAPE_HANDLE_HEADER);
  const lastOffset = res.headers.get(CHUNK_LAST_OFFSET_HEADER);
  const isUpToDate = res.headers.has(CHUNK_UP_TO_DATE_HEADER);
  if (!shapeHandle || !lastOffset || isUpToDate) return;
  const nextUrl = new URL(url);
  if (nextUrl.searchParams.has(LIVE_QUERY_PARAM)) return;
  nextUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, shapeHandle);
  nextUrl.searchParams.set(OFFSET_QUERY_PARAM, lastOffset);
  nextUrl.searchParams.sort();
  return nextUrl.toString();
}
__name(getNextChunkUrl, "getNextChunkUrl");
function chainAborter(aborter, sourceSignal) {
  let cleanup = noop2;
  if (!sourceSignal) {
  } else if (sourceSignal.aborted) {
    aborter.abort();
  } else {
    const abortParent = /* @__PURE__ */ __name(() => aborter.abort(), "abortParent");
    sourceSignal.addEventListener(`abort`, abortParent, {
      once: true,
      signal: aborter.signal
    });
    cleanup = /* @__PURE__ */ __name(() => sourceSignal.removeEventListener(`abort`, abortParent), "cleanup");
  }
  return {
    signal: aborter.signal,
    cleanup
  };
}
__name(chainAborter, "chainAborter");
function noop2() {
}
__name(noop2, "noop");
var ExpiredShapesCache = class {
  static {
    __name(this, "ExpiredShapesCache");
  }
  constructor() {
    this.data = {};
    this.max = 250;
    this.storageKey = `electric_expired_shapes`;
    this.load();
  }
  getExpiredHandle(shapeUrl) {
    const entry = this.data[shapeUrl];
    if (entry) {
      entry.lastUsed = Date.now();
      this.save();
      return entry.expiredHandle;
    }
    return null;
  }
  markExpired(shapeUrl, handle) {
    this.data[shapeUrl] = { expiredHandle: handle, lastUsed: Date.now() };
    const keys = Object.keys(this.data);
    if (keys.length > this.max) {
      const oldest = keys.reduce(
        (min, k) => this.data[k].lastUsed < this.data[min].lastUsed ? k : min
      );
      delete this.data[oldest];
    }
    this.save();
  }
  save() {
    if (typeof localStorage === `undefined`) return;
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.data));
    } catch (e) {
    }
  }
  load() {
    if (typeof localStorage === `undefined`) return;
    try {
      const stored = localStorage.getItem(this.storageKey);
      if (stored) {
        this.data = JSON.parse(stored);
      }
    } catch (e) {
      this.data = {};
    }
  }
  clear() {
    this.data = {};
    this.save();
  }
};
var expiredShapesCache = new ExpiredShapesCache();
var SnapshotTracker = class {
  static {
    __name(this, "SnapshotTracker");
  }
  constructor() {
    this.activeSnapshots = /* @__PURE__ */ new Map();
    this.xmaxSnapshots = /* @__PURE__ */ new Map();
    this.snapshotsByDatabaseLsn = /* @__PURE__ */ new Map();
  }
  /**
   * Add a new snapshot for tracking
   */
  addSnapshot(metadata2, keys) {
    var _a, _b, _c, _d;
    this.activeSnapshots.set(metadata2.snapshot_mark, {
      xmin: BigInt(metadata2.xmin),
      xmax: BigInt(metadata2.xmax),
      xip_list: metadata2.xip_list.map(BigInt),
      keys
    });
    const xmaxSet = (_b = (_a = this.xmaxSnapshots.get(BigInt(metadata2.xmax))) == null ? void 0 : _a.add(metadata2.snapshot_mark)) != null ? _b : /* @__PURE__ */ new Set([metadata2.snapshot_mark]);
    this.xmaxSnapshots.set(BigInt(metadata2.xmax), xmaxSet);
    const databaseLsnSet = (_d = (_c = this.snapshotsByDatabaseLsn.get(BigInt(metadata2.database_lsn))) == null ? void 0 : _c.add(metadata2.snapshot_mark)) != null ? _d : /* @__PURE__ */ new Set([metadata2.snapshot_mark]);
    this.snapshotsByDatabaseLsn.set(
      BigInt(metadata2.database_lsn),
      databaseLsnSet
    );
  }
  /**
   * Remove a snapshot from tracking
   */
  removeSnapshot(snapshotMark) {
    this.activeSnapshots.delete(snapshotMark);
  }
  /**
   * Check if a change message should be filtered because its already in an active snapshot
   * Returns true if the message should be filtered out (not processed)
   */
  shouldRejectMessage(message) {
    const txids = message.headers.txids || [];
    if (txids.length === 0) return false;
    const xid = Math.max(...txids);
    for (const [xmax, snapshots] of this.xmaxSnapshots.entries()) {
      if (xid >= xmax) {
        for (const snapshot of snapshots) {
          this.removeSnapshot(snapshot);
        }
      }
    }
    return [...this.activeSnapshots.values()].some(
      (x) => x.keys.has(message.key) && isVisibleInSnapshot(xid, x)
    );
  }
  lastSeenUpdate(newDatabaseLsn) {
    for (const [dbLsn, snapshots] of this.snapshotsByDatabaseLsn.entries()) {
      if (dbLsn <= newDatabaseLsn) {
        for (const snapshot of snapshots) {
          this.removeSnapshot(snapshot);
        }
      }
    }
  }
};
var RESERVED_PARAMS = /* @__PURE__ */ new Set([
  LIVE_CACHE_BUSTER_QUERY_PARAM,
  SHAPE_HANDLE_QUERY_PARAM,
  LIVE_QUERY_PARAM,
  OFFSET_QUERY_PARAM
]);
function resolveValue(value) {
  return __async(this, null, function* () {
    if (typeof value === `function`) {
      return value();
    }
    return value;
  });
}
__name(resolveValue, "resolveValue");
function toInternalParams(params) {
  return __async(this, null, function* () {
    const entries = Object.entries(params);
    const resolvedEntries = yield Promise.all(
      entries.map((_0) => __async(this, [_0], function* ([key, value]) {
        if (value === void 0) return [key, void 0];
        const resolvedValue = yield resolveValue(value);
        return [
          key,
          Array.isArray(resolvedValue) ? resolvedValue.join(`,`) : resolvedValue
        ];
      }))
    );
    return Object.fromEntries(
      resolvedEntries.filter(([_2, value]) => value !== void 0)
    );
  });
}
__name(toInternalParams, "toInternalParams");
function resolveHeaders(headers) {
  return __async(this, null, function* () {
    if (!headers) return {};
    const entries = Object.entries(headers);
    const resolvedEntries = yield Promise.all(
      entries.map((_0) => __async(this, [_0], function* ([key, value]) {
        return [key, yield resolveValue(value)];
      }))
    );
    return Object.fromEntries(resolvedEntries);
  });
}
__name(resolveHeaders, "resolveHeaders");
function canonicalShapeKey(url) {
  const cleanUrl = new URL(url.origin + url.pathname);
  for (const [key, value] of url.searchParams) {
    if (!ELECTRIC_PROTOCOL_QUERY_PARAMS.includes(key)) {
      cleanUrl.searchParams.set(key, value);
    }
  }
  cleanUrl.searchParams.sort();
  return cleanUrl.toString();
}
__name(canonicalShapeKey, "canonicalShapeKey");
var _error;
var _fetchClient2;
var _sseFetchClient;
var _messageParser;
var _subscribers;
var _started;
var _state;
var _lastOffset;
var _liveCacheBuster;
var _lastSyncedAt;
var _isUpToDate;
var _isMidStream;
var _connected;
var _shapeHandle;
var _mode;
var _schema;
var _onError;
var _requestAbortController;
var _isRefreshing;
var _tickPromise;
var _tickPromiseResolver;
var _tickPromiseRejecter;
var _messageChain;
var _snapshotTracker;
var _activeSnapshotRequests;
var _midStreamPromise;
var _midStreamPromiseResolver;
var _ShapeStream_instances;
var start_fn;
var requestShape_fn;
var constructUrl_fn;
var createAbortListener_fn;
var onInitialResponse_fn;
var onMessages_fn;
var fetchShape_fn;
var requestShapeLongPoll_fn;
var requestShapeSSE_fn;
var pause_fn;
var resume_fn;
var nextTick_fn;
var waitForStreamEnd_fn;
var publish_fn;
var sendErrorToSubscribers_fn;
var subscribeToVisibilityChanges_fn;
var reset_fn;
var fetchSnapshot_fn;
var ShapeStream = class {
  static {
    __name(this, "ShapeStream");
  }
  constructor(options) {
    __privateAdd(this, _ShapeStream_instances);
    __privateAdd(this, _error, null);
    __privateAdd(this, _fetchClient2);
    __privateAdd(this, _sseFetchClient);
    __privateAdd(this, _messageParser);
    __privateAdd(this, _subscribers, /* @__PURE__ */ new Map());
    __privateAdd(this, _started, false);
    __privateAdd(this, _state, `active`);
    __privateAdd(this, _lastOffset);
    __privateAdd(this, _liveCacheBuster);
    __privateAdd(this, _lastSyncedAt);
    __privateAdd(this, _isUpToDate, false);
    __privateAdd(this, _isMidStream, true);
    __privateAdd(this, _connected, false);
    __privateAdd(this, _shapeHandle);
    __privateAdd(this, _mode);
    __privateAdd(this, _schema);
    __privateAdd(this, _onError);
    __privateAdd(this, _requestAbortController);
    __privateAdd(this, _isRefreshing, false);
    __privateAdd(this, _tickPromise);
    __privateAdd(this, _tickPromiseResolver);
    __privateAdd(this, _tickPromiseRejecter);
    __privateAdd(this, _messageChain, Promise.resolve([]));
    __privateAdd(this, _snapshotTracker, new SnapshotTracker());
    __privateAdd(this, _activeSnapshotRequests, 0);
    __privateAdd(this, _midStreamPromise);
    __privateAdd(this, _midStreamPromiseResolver);
    var _a, _b, _c, _d;
    this.options = __spreadValues({ subscribe: true }, options);
    validateOptions(this.options);
    __privateSet(this, _lastOffset, (_a = this.options.offset) != null ? _a : `-1`);
    __privateSet(this, _liveCacheBuster, ``);
    __privateSet(this, _shapeHandle, this.options.handle);
    __privateSet(this, _messageParser, new MessageParser(
      options.parser,
      options.transformer
    ));
    __privateSet(this, _onError, this.options.onError);
    __privateSet(this, _mode, (_b = this.options.log) != null ? _b : `full`);
    const baseFetchClient = (_c = options.fetchClient) != null ? _c : (...args) => fetch(...args);
    const backOffOpts = __spreadProps(__spreadValues({}, (_d = options.backoffOptions) != null ? _d : BackoffDefaults), {
      onFailedAttempt: /* @__PURE__ */ __name(() => {
        var _a2, _b2;
        __privateSet(this, _connected, false);
        (_b2 = (_a2 = options.backoffOptions) == null ? void 0 : _a2.onFailedAttempt) == null ? void 0 : _b2.call(_a2);
      }, "onFailedAttempt")
    });
    const fetchWithBackoffClient = createFetchWithBackoff(
      baseFetchClient,
      backOffOpts
    );
    __privateSet(this, _sseFetchClient, createFetchWithResponseHeadersCheck(
      createFetchWithChunkBuffer(fetchWithBackoffClient)
    ));
    __privateSet(this, _fetchClient2, createFetchWithConsumedMessages(__privateGet(this, _sseFetchClient)));
    __privateMethod(this, _ShapeStream_instances, subscribeToVisibilityChanges_fn).call(this);
  }
  get shapeHandle() {
    return __privateGet(this, _shapeHandle);
  }
  get error() {
    return __privateGet(this, _error);
  }
  get isUpToDate() {
    return __privateGet(this, _isUpToDate);
  }
  get lastOffset() {
    return __privateGet(this, _lastOffset);
  }
  get mode() {
    return __privateGet(this, _mode);
  }
  subscribe(callback, onError = () => {
  }) {
    const subscriptionId = Math.random();
    __privateGet(this, _subscribers).set(subscriptionId, [callback, onError]);
    if (!__privateGet(this, _started)) __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
    return () => {
      __privateGet(this, _subscribers).delete(subscriptionId);
    };
  }
  unsubscribeAll() {
    __privateGet(this, _subscribers).clear();
  }
  /** Unix time at which we last synced. Undefined when `isLoading` is true. */
  lastSyncedAt() {
    return __privateGet(this, _lastSyncedAt);
  }
  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */
  lastSynced() {
    if (__privateGet(this, _lastSyncedAt) === void 0) return Infinity;
    return Date.now() - __privateGet(this, _lastSyncedAt);
  }
  /** Indicates if we are connected to the Electric sync service. */
  isConnected() {
    return __privateGet(this, _connected);
  }
  /** True during initial fetch. False afterwise.  */
  isLoading() {
    return !__privateGet(this, _isUpToDate);
  }
  hasStarted() {
    return __privateGet(this, _started);
  }
  isPaused() {
    return __privateGet(this, _state) === `paused`;
  }
  /**
   * Refreshes the shape stream.
   * This preemptively aborts any ongoing long poll and reconnects without
   * long polling, ensuring that the stream receives an up to date message with the
   * latest LSN from Postgres at that point in time.
   */
  forceDisconnectAndRefresh() {
    return __async(this, null, function* () {
      var _a, _b;
      __privateSet(this, _isRefreshing, true);
      if (__privateGet(this, _isUpToDate) && !((_a = __privateGet(this, _requestAbortController)) == null ? void 0 : _a.signal.aborted)) {
        (_b = __privateGet(this, _requestAbortController)) == null ? void 0 : _b.abort(FORCE_DISCONNECT_AND_REFRESH);
      }
      yield __privateMethod(this, _ShapeStream_instances, nextTick_fn).call(this);
      __privateSet(this, _isRefreshing, false);
    });
  }
  /**
   * Request a snapshot for subset of data.
   *
   * Only available when mode is `changes_only`.
   * Returns the insertion point & the data, but more importantly injects the data
   * into the subscribed data stream. Returned value is unlikely to be useful for the caller,
   * unless the caller has complicated additional logic.
   *
   * Data will be injected in a way that's also tracking further incoming changes, and it'll
   * skip the ones that are already in the snapshot.
   *
   * @param opts - The options for the snapshot request.
   * @returns The metadata and the data for the snapshot.
   */
  requestSnapshot(opts) {
    return __async(this, null, function* () {
      if (__privateGet(this, _mode) === `full`) {
        throw new Error(
          `Snapshot requests are not supported in ${__privateGet(this, _mode)} mode, as the consumer is guaranteed to observe all data`
        );
      }
      if (!__privateGet(this, _started)) yield __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
      yield __privateMethod(this, _ShapeStream_instances, waitForStreamEnd_fn).call(this);
      __privateWrapper(this, _activeSnapshotRequests)._++;
      try {
        if (__privateGet(this, _activeSnapshotRequests) === 1) {
          __privateMethod(this, _ShapeStream_instances, pause_fn).call(this);
        }
        const { fetchUrl, requestHeaders } = yield __privateMethod(this, _ShapeStream_instances, constructUrl_fn).call(this, this.options.url, true, opts);
        const { metadata: metadata2, data } = yield __privateMethod(this, _ShapeStream_instances, fetchSnapshot_fn).call(this, fetchUrl, requestHeaders);
        const dataWithEndBoundary = data.concat([
          { headers: __spreadValues({ control: `snapshot-end` }, metadata2) }
        ]);
        __privateGet(this, _snapshotTracker).addSnapshot(
          metadata2,
          new Set(data.map((message) => message.key))
        );
        __privateMethod(this, _ShapeStream_instances, onMessages_fn).call(this, dataWithEndBoundary, false);
        return {
          metadata: metadata2,
          data
        };
      } finally {
        __privateWrapper(this, _activeSnapshotRequests)._--;
        if (__privateGet(this, _activeSnapshotRequests) === 0) {
          __privateMethod(this, _ShapeStream_instances, resume_fn).call(this);
        }
      }
    });
  }
};
_error = /* @__PURE__ */ new WeakMap();
_fetchClient2 = /* @__PURE__ */ new WeakMap();
_sseFetchClient = /* @__PURE__ */ new WeakMap();
_messageParser = /* @__PURE__ */ new WeakMap();
_subscribers = /* @__PURE__ */ new WeakMap();
_started = /* @__PURE__ */ new WeakMap();
_state = /* @__PURE__ */ new WeakMap();
_lastOffset = /* @__PURE__ */ new WeakMap();
_liveCacheBuster = /* @__PURE__ */ new WeakMap();
_lastSyncedAt = /* @__PURE__ */ new WeakMap();
_isUpToDate = /* @__PURE__ */ new WeakMap();
_isMidStream = /* @__PURE__ */ new WeakMap();
_connected = /* @__PURE__ */ new WeakMap();
_shapeHandle = /* @__PURE__ */ new WeakMap();
_mode = /* @__PURE__ */ new WeakMap();
_schema = /* @__PURE__ */ new WeakMap();
_onError = /* @__PURE__ */ new WeakMap();
_requestAbortController = /* @__PURE__ */ new WeakMap();
_isRefreshing = /* @__PURE__ */ new WeakMap();
_tickPromise = /* @__PURE__ */ new WeakMap();
_tickPromiseResolver = /* @__PURE__ */ new WeakMap();
_tickPromiseRejecter = /* @__PURE__ */ new WeakMap();
_messageChain = /* @__PURE__ */ new WeakMap();
_snapshotTracker = /* @__PURE__ */ new WeakMap();
_activeSnapshotRequests = /* @__PURE__ */ new WeakMap();
_midStreamPromise = /* @__PURE__ */ new WeakMap();
_midStreamPromiseResolver = /* @__PURE__ */ new WeakMap();
_ShapeStream_instances = /* @__PURE__ */ new WeakSet();
start_fn = /* @__PURE__ */ __name(function() {
  return __async(this, null, function* () {
    var _a;
    __privateSet(this, _started, true);
    try {
      yield __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
    } catch (err) {
      __privateSet(this, _error, err);
      if (__privateGet(this, _onError)) {
        const retryOpts = yield __privateGet(this, _onError).call(this, err);
        if (typeof retryOpts === `object`) {
          __privateMethod(this, _ShapeStream_instances, reset_fn).call(this);
          if (`params` in retryOpts) {
            this.options.params = retryOpts.params;
          }
          if (`headers` in retryOpts) {
            this.options.headers = retryOpts.headers;
          }
          __privateSet(this, _started, false);
          __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
        }
        return;
      }
      throw err;
    } finally {
      __privateSet(this, _connected, false);
      (_a = __privateGet(this, _tickPromiseRejecter)) == null ? void 0 : _a.call(this);
    }
  });
}, "start_fn");
requestShape_fn = /* @__PURE__ */ __name(function() {
  return __async(this, null, function* () {
    var _a, _b;
    if (__privateGet(this, _state) === `pause-requested`) {
      __privateSet(this, _state, `paused`);
      return;
    }
    if (!this.options.subscribe && (((_a = this.options.signal) == null ? void 0 : _a.aborted) || __privateGet(this, _isUpToDate))) {
      return;
    }
    const resumingFromPause = __privateGet(this, _state) === `paused`;
    __privateSet(this, _state, `active`);
    const { url, signal } = this.options;
    const { fetchUrl, requestHeaders } = yield __privateMethod(this, _ShapeStream_instances, constructUrl_fn).call(this, url, resumingFromPause);
    const abortListener = yield __privateMethod(this, _ShapeStream_instances, createAbortListener_fn).call(this, signal);
    const requestAbortController = __privateGet(this, _requestAbortController);
    try {
      yield __privateMethod(this, _ShapeStream_instances, fetchShape_fn).call(this, {
        fetchUrl,
        requestAbortController,
        headers: requestHeaders,
        resumingFromPause
      });
    } catch (e) {
      if ((e instanceof FetchError || e instanceof FetchBackoffAbortError) && requestAbortController.signal.aborted && requestAbortController.signal.reason === FORCE_DISCONNECT_AND_REFRESH) {
        return __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
      }
      if (e instanceof FetchBackoffAbortError) {
        if (requestAbortController.signal.aborted && requestAbortController.signal.reason === PAUSE_STREAM) {
          __privateSet(this, _state, `paused`);
        }
        return;
      }
      if (!(e instanceof FetchError)) throw e;
      if (e.status == 409) {
        if (__privateGet(this, _shapeHandle)) {
          const shapeKey = canonicalShapeKey(fetchUrl);
          expiredShapesCache.markExpired(shapeKey, __privateGet(this, _shapeHandle));
        }
        const newShapeHandle = e.headers[SHAPE_HANDLE_HEADER] || `${__privateGet(this, _shapeHandle)}-next`;
        __privateMethod(this, _ShapeStream_instances, reset_fn).call(this, newShapeHandle);
        yield __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, e.json);
        return __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
      } else {
        __privateMethod(this, _ShapeStream_instances, sendErrorToSubscribers_fn).call(this, e);
        throw e;
      }
    } finally {
      if (abortListener && signal) {
        signal.removeEventListener(`abort`, abortListener);
      }
      __privateSet(this, _requestAbortController, void 0);
    }
    (_b = __privateGet(this, _tickPromiseResolver)) == null ? void 0 : _b.call(this);
    return __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
  });
}, "requestShape_fn");
constructUrl_fn = /* @__PURE__ */ __name(function(url, resumingFromPause, subsetParams) {
  return __async(this, null, function* () {
    const [requestHeaders, params] = yield Promise.all([
      resolveHeaders(this.options.headers),
      this.options.params ? toInternalParams(convertWhereParamsToObj(this.options.params)) : void 0
    ]);
    if (params) validateParams(params);
    const fetchUrl = new URL(url);
    if (params) {
      if (params.table) setQueryParam(fetchUrl, TABLE_QUERY_PARAM, params.table);
      if (params.where) setQueryParam(fetchUrl, WHERE_QUERY_PARAM, params.where);
      if (params.columns)
        setQueryParam(fetchUrl, COLUMNS_QUERY_PARAM, params.columns);
      if (params.replica) setQueryParam(fetchUrl, REPLICA_PARAM, params.replica);
      if (params.params)
        setQueryParam(fetchUrl, WHERE_PARAMS_PARAM, params.params);
      const customParams = __spreadValues({}, params);
      delete customParams.table;
      delete customParams.where;
      delete customParams.columns;
      delete customParams.replica;
      delete customParams.params;
      for (const [key, value] of Object.entries(customParams)) {
        setQueryParam(fetchUrl, key, value);
      }
    }
    if (subsetParams) {
      if (subsetParams.where)
        setQueryParam(fetchUrl, SUBSET_PARAM_WHERE, subsetParams.where);
      if (subsetParams.params)
        setQueryParam(fetchUrl, SUBSET_PARAM_WHERE_PARAMS, subsetParams.params);
      if (subsetParams.limit)
        setQueryParam(fetchUrl, SUBSET_PARAM_LIMIT, subsetParams.limit);
      if (subsetParams.offset)
        setQueryParam(fetchUrl, SUBSET_PARAM_OFFSET, subsetParams.offset);
      if (subsetParams.orderBy)
        setQueryParam(fetchUrl, SUBSET_PARAM_ORDER_BY, subsetParams.orderBy);
    }
    fetchUrl.searchParams.set(OFFSET_QUERY_PARAM, __privateGet(this, _lastOffset));
    fetchUrl.searchParams.set(LOG_MODE_QUERY_PARAM, __privateGet(this, _mode));
    if (__privateGet(this, _isUpToDate)) {
      if (!__privateGet(this, _isRefreshing) && !resumingFromPause) {
        fetchUrl.searchParams.set(LIVE_QUERY_PARAM, `true`);
      }
      fetchUrl.searchParams.set(
        LIVE_CACHE_BUSTER_QUERY_PARAM,
        __privateGet(this, _liveCacheBuster)
      );
    }
    if (__privateGet(this, _shapeHandle)) {
      fetchUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, __privateGet(this, _shapeHandle));
    }
    const shapeKey = canonicalShapeKey(fetchUrl);
    const expiredHandle = expiredShapesCache.getExpiredHandle(shapeKey);
    if (expiredHandle) {
      fetchUrl.searchParams.set(EXPIRED_HANDLE_QUERY_PARAM, expiredHandle);
    }
    fetchUrl.searchParams.sort();
    return {
      fetchUrl,
      requestHeaders
    };
  });
}, "constructUrl_fn");
createAbortListener_fn = /* @__PURE__ */ __name(function(signal) {
  return __async(this, null, function* () {
    var _a;
    __privateSet(this, _requestAbortController, new AbortController());
    if (signal) {
      const abortListener = /* @__PURE__ */ __name(() => {
        var _a2;
        (_a2 = __privateGet(this, _requestAbortController)) == null ? void 0 : _a2.abort(signal.reason);
      }, "abortListener");
      signal.addEventListener(`abort`, abortListener, { once: true });
      if (signal.aborted) {
        (_a = __privateGet(this, _requestAbortController)) == null ? void 0 : _a.abort(signal.reason);
      }
      return abortListener;
    }
  });
}, "createAbortListener_fn");
onInitialResponse_fn = /* @__PURE__ */ __name(function(response) {
  return __async(this, null, function* () {
    var _a;
    const { headers, status } = response;
    const shapeHandle = headers.get(SHAPE_HANDLE_HEADER);
    if (shapeHandle) {
      __privateSet(this, _shapeHandle, shapeHandle);
    }
    const lastOffset = headers.get(CHUNK_LAST_OFFSET_HEADER);
    if (lastOffset) {
      __privateSet(this, _lastOffset, lastOffset);
    }
    const liveCacheBuster = headers.get(LIVE_CACHE_BUSTER_HEADER);
    if (liveCacheBuster) {
      __privateSet(this, _liveCacheBuster, liveCacheBuster);
    }
    const getSchema = /* @__PURE__ */ __name(() => {
      const schemaHeader = headers.get(SHAPE_SCHEMA_HEADER);
      return schemaHeader ? JSON.parse(schemaHeader) : {};
    }, "getSchema");
    __privateSet(this, _schema, (_a = __privateGet(this, _schema)) != null ? _a : getSchema());
    if (status === 204) {
      __privateSet(this, _lastSyncedAt, Date.now());
    }
  });
}, "onInitialResponse_fn");
onMessages_fn = /* @__PURE__ */ __name(function(batch, isSseMessage = false) {
  return __async(this, null, function* () {
    var _a;
    if (batch.length > 0) {
      __privateSet(this, _isMidStream, true);
      const lastMessage = batch[batch.length - 1];
      if (isUpToDateMessage(lastMessage)) {
        if (isSseMessage) {
          const offset = getOffset(lastMessage);
          if (offset) {
            __privateSet(this, _lastOffset, offset);
          }
        }
        __privateSet(this, _lastSyncedAt, Date.now());
        __privateSet(this, _isUpToDate, true);
        __privateSet(this, _isMidStream, false);
        (_a = __privateGet(this, _midStreamPromiseResolver)) == null ? void 0 : _a.call(this);
      }
      const messagesToProcess = batch.filter((message) => {
        if (isChangeMessage(message)) {
          return !__privateGet(this, _snapshotTracker).shouldRejectMessage(message);
        }
        return true;
      });
      yield __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, messagesToProcess);
    }
  });
}, "onMessages_fn");
fetchShape_fn = /* @__PURE__ */ __name(function(opts) {
  return __async(this, null, function* () {
    if (__privateGet(this, _isUpToDate) && this.options.experimentalLiveSse && !__privateGet(this, _isRefreshing) && !opts.resumingFromPause) {
      opts.fetchUrl.searchParams.set(EXPERIMENTAL_LIVE_SSE_QUERY_PARAM, `true`);
      return __privateMethod(this, _ShapeStream_instances, requestShapeSSE_fn).call(this, opts);
    }
    return __privateMethod(this, _ShapeStream_instances, requestShapeLongPoll_fn).call(this, opts);
  });
}, "fetchShape_fn");
requestShapeLongPoll_fn = /* @__PURE__ */ __name(function(opts) {
  return __async(this, null, function* () {
    const { fetchUrl, requestAbortController, headers } = opts;
    const response = yield __privateGet(this, _fetchClient2).call(this, fetchUrl.toString(), {
      signal: requestAbortController.signal,
      headers
    });
    __privateSet(this, _connected, true);
    yield __privateMethod(this, _ShapeStream_instances, onInitialResponse_fn).call(this, response);
    const schema = __privateGet(this, _schema);
    const res = yield response.text();
    const messages = res || `[]`;
    const batch = __privateGet(this, _messageParser).parse(messages, schema);
    yield __privateMethod(this, _ShapeStream_instances, onMessages_fn).call(this, batch);
  });
}, "requestShapeLongPoll_fn");
requestShapeSSE_fn = /* @__PURE__ */ __name(function(opts) {
  return __async(this, null, function* () {
    const { fetchUrl, requestAbortController, headers } = opts;
    const fetch2 = __privateGet(this, _sseFetchClient);
    try {
      let buffer = [];
      yield (0, import_fetch_event_source.fetchEventSource)(fetchUrl.toString(), {
        headers,
        fetch: fetch2,
        onopen: /* @__PURE__ */ __name((response) => __async(this, null, function* () {
          __privateSet(this, _connected, true);
          yield __privateMethod(this, _ShapeStream_instances, onInitialResponse_fn).call(this, response);
        }), "onopen"),
        onmessage: /* @__PURE__ */ __name((event) => {
          if (event.data) {
            const schema = __privateGet(this, _schema);
            const message = __privateGet(this, _messageParser).parse(
              event.data,
              schema
            );
            buffer.push(message);
            if (isUpToDateMessage(message)) {
              __privateMethod(this, _ShapeStream_instances, onMessages_fn).call(this, buffer, true);
              buffer = [];
            }
          }
        }, "onmessage"),
        onerror: /* @__PURE__ */ __name((error) => {
          throw error;
        }, "onerror"),
        signal: requestAbortController.signal
      });
    } catch (error) {
      if (requestAbortController.signal.aborted) {
        throw new FetchBackoffAbortError();
      }
      throw error;
    }
  });
}, "requestShapeSSE_fn");
pause_fn = /* @__PURE__ */ __name(function() {
  var _a;
  if (__privateGet(this, _started) && __privateGet(this, _state) === `active`) {
    __privateSet(this, _state, `pause-requested`);
    (_a = __privateGet(this, _requestAbortController)) == null ? void 0 : _a.abort(PAUSE_STREAM);
  }
}, "pause_fn");
resume_fn = /* @__PURE__ */ __name(function() {
  if (__privateGet(this, _started) && __privateGet(this, _state) === `paused`) {
    __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
  }
}, "resume_fn");
nextTick_fn = /* @__PURE__ */ __name(function() {
  return __async(this, null, function* () {
    if (__privateGet(this, _tickPromise)) {
      return __privateGet(this, _tickPromise);
    }
    __privateSet(this, _tickPromise, new Promise((resolve, reject) => {
      __privateSet(this, _tickPromiseResolver, resolve);
      __privateSet(this, _tickPromiseRejecter, reject);
    }));
    __privateGet(this, _tickPromise).finally(() => {
      __privateSet(this, _tickPromise, void 0);
      __privateSet(this, _tickPromiseResolver, void 0);
      __privateSet(this, _tickPromiseRejecter, void 0);
    });
    return __privateGet(this, _tickPromise);
  });
}, "nextTick_fn");
waitForStreamEnd_fn = /* @__PURE__ */ __name(function() {
  return __async(this, null, function* () {
    if (!__privateGet(this, _isMidStream)) {
      return;
    }
    if (__privateGet(this, _midStreamPromise)) {
      return __privateGet(this, _midStreamPromise);
    }
    __privateSet(this, _midStreamPromise, new Promise((resolve) => {
      __privateSet(this, _midStreamPromiseResolver, resolve);
    }));
    __privateGet(this, _midStreamPromise).finally(() => {
      __privateSet(this, _midStreamPromise, void 0);
      __privateSet(this, _midStreamPromiseResolver, void 0);
    });
    return __privateGet(this, _midStreamPromise);
  });
}, "waitForStreamEnd_fn");
publish_fn = /* @__PURE__ */ __name(function(messages) {
  return __async(this, null, function* () {
    __privateSet(this, _messageChain, __privateGet(this, _messageChain).then(
      () => Promise.all(
        Array.from(__privateGet(this, _subscribers).values()).map((_0) => __async(this, [_0], function* ([callback, __]) {
          try {
            yield callback(messages);
          } catch (err) {
            queueMicrotask(() => {
              throw err;
            });
          }
        }))
      )
    ));
    return __privateGet(this, _messageChain);
  });
}, "publish_fn");
sendErrorToSubscribers_fn = /* @__PURE__ */ __name(function(error) {
  __privateGet(this, _subscribers).forEach(([_2, errorFn]) => {
    errorFn == null ? void 0 : errorFn(error);
  });
}, "sendErrorToSubscribers_fn");
subscribeToVisibilityChanges_fn = /* @__PURE__ */ __name(function() {
  if (typeof document === `object` && typeof document.hidden === `boolean` && typeof document.addEventListener === `function`) {
    const visibilityHandler = /* @__PURE__ */ __name(() => {
      if (document.hidden) {
        __privateMethod(this, _ShapeStream_instances, pause_fn).call(this);
      } else {
        __privateMethod(this, _ShapeStream_instances, resume_fn).call(this);
      }
    }, "visibilityHandler");
    document.addEventListener(`visibilitychange`, visibilityHandler);
  }
}, "subscribeToVisibilityChanges_fn");
reset_fn = /* @__PURE__ */ __name(function(handle) {
  __privateSet(this, _lastOffset, `-1`);
  __privateSet(this, _liveCacheBuster, ``);
  __privateSet(this, _shapeHandle, handle);
  __privateSet(this, _isUpToDate, false);
  __privateSet(this, _isMidStream, true);
  __privateSet(this, _connected, false);
  __privateSet(this, _schema, void 0);
  __privateSet(this, _activeSnapshotRequests, 0);
}, "reset_fn");
fetchSnapshot_fn = /* @__PURE__ */ __name(function(url, headers) {
  return __async(this, null, function* () {
    const response = yield __privateGet(this, _fetchClient2).call(this, url.toString(), { headers });
    if (!response.ok) {
      throw new FetchError(
        response.status,
        void 0,
        void 0,
        Object.fromEntries([...response.headers.entries()]),
        url.toString()
      );
    }
    const { metadata: metadata2, data } = yield response.json();
    const batch = __privateGet(this, _messageParser).parse(
      JSON.stringify(data),
      __privateGet(this, _schema)
    );
    return {
      metadata: metadata2,
      data: batch
    };
  });
}, "fetchSnapshot_fn");
ShapeStream.Replica = {
  FULL: `full`,
  DEFAULT: `default`
};
function validateParams(params) {
  if (!params) return;
  const reservedParams = Object.keys(params).filter(
    (key) => RESERVED_PARAMS.has(key)
  );
  if (reservedParams.length > 0) {
    throw new ReservedParamError(reservedParams);
  }
}
__name(validateParams, "validateParams");
function validateOptions(options) {
  if (!options.url) {
    throw new MissingShapeUrlError();
  }
  if (options.signal && !(options.signal instanceof AbortSignal)) {
    throw new InvalidSignalError();
  }
  if (options.offset !== void 0 && options.offset !== `-1` && options.offset !== `now` && !options.handle) {
    throw new MissingShapeHandleError();
  }
  validateParams(options.params);
  return;
}
__name(validateOptions, "validateOptions");
function setQueryParam(url, key, value) {
  if (value === void 0 || value == null) {
    return;
  } else if (typeof value === `string`) {
    url.searchParams.set(key, value);
  } else if (typeof value === `object`) {
    for (const [k, v2] of Object.entries(value)) {
      url.searchParams.set(`${key}[${k}]`, v2);
    }
  } else {
    url.searchParams.set(key, value.toString());
  }
}
__name(setQueryParam, "setQueryParam");
function convertWhereParamsToObj(allPgParams) {
  if (Array.isArray(allPgParams.params)) {
    return __spreadProps(__spreadValues({}, allPgParams), {
      params: Object.fromEntries(allPgParams.params.map((v2, i2) => [i2 + 1, v2]))
    });
  }
  return allPgParams;
}
__name(convertWhereParamsToObj, "convertWhereParamsToObj");
var _data;
var _subscribers2;
var _insertedKeys;
var _requestedSubSnapshots;
var _reexecuteSnapshotsPending;
var _status;
var _error2;
var _Shape_instances;
var process_fn;
var reexecuteSnapshots_fn;
var awaitUpToDate_fn;
var updateShapeStatus_fn;
var handleError_fn;
var notify_fn;
_data = /* @__PURE__ */ new WeakMap();
_subscribers2 = /* @__PURE__ */ new WeakMap();
_insertedKeys = /* @__PURE__ */ new WeakMap();
_requestedSubSnapshots = /* @__PURE__ */ new WeakMap();
_reexecuteSnapshotsPending = /* @__PURE__ */ new WeakMap();
_status = /* @__PURE__ */ new WeakMap();
_error2 = /* @__PURE__ */ new WeakMap();
_Shape_instances = /* @__PURE__ */ new WeakSet();
process_fn = /* @__PURE__ */ __name(function(messages) {
  let shouldNotify = false;
  messages.forEach((message) => {
    if (isChangeMessage(message)) {
      shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `syncing`);
      if (this.mode === `full`) {
        switch (message.headers.operation) {
          case `insert`:
            __privateGet(this, _data).set(message.key, message.value);
            break;
          case `update`:
            __privateGet(this, _data).set(message.key, __spreadValues(__spreadValues({}, __privateGet(this, _data).get(message.key)), message.value));
            break;
          case `delete`:
            __privateGet(this, _data).delete(message.key);
            break;
        }
      } else {
        switch (message.headers.operation) {
          case `insert`:
            __privateGet(this, _insertedKeys).add(message.key);
            __privateGet(this, _data).set(message.key, message.value);
            break;
          case `update`:
            if (__privateGet(this, _insertedKeys).has(message.key)) {
              __privateGet(this, _data).set(message.key, __spreadValues(__spreadValues({}, __privateGet(this, _data).get(message.key)), message.value));
            }
            break;
          case `delete`:
            if (__privateGet(this, _insertedKeys).has(message.key)) {
              __privateGet(this, _data).delete(message.key);
              __privateGet(this, _insertedKeys).delete(message.key);
            }
            break;
        }
      }
    }
    if (isControlMessage(message)) {
      switch (message.headers.control) {
        case `up-to-date`:
          shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `up-to-date`);
          if (__privateGet(this, _reexecuteSnapshotsPending)) {
            __privateSet(this, _reexecuteSnapshotsPending, false);
            void __privateMethod(this, _Shape_instances, reexecuteSnapshots_fn).call(this);
          }
          break;
        case `must-refetch`:
          __privateGet(this, _data).clear();
          __privateGet(this, _insertedKeys).clear();
          __privateSet(this, _error2, false);
          shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `syncing`);
          __privateSet(this, _reexecuteSnapshotsPending, true);
          break;
      }
    }
  });
  if (shouldNotify) __privateMethod(this, _Shape_instances, notify_fn).call(this);
}, "process_fn");
reexecuteSnapshots_fn = /* @__PURE__ */ __name(function() {
  return __async(this, null, function* () {
    yield __privateMethod(this, _Shape_instances, awaitUpToDate_fn).call(this);
    yield Promise.all(
      Array.from(__privateGet(this, _requestedSubSnapshots)).map((jsonParams) => __async(this, null, function* () {
        try {
          const snapshot = JSON.parse(jsonParams);
          yield this.stream.requestSnapshot(snapshot);
        } catch (_2) {
        }
      }))
    );
  });
}, "reexecuteSnapshots_fn");
awaitUpToDate_fn = /* @__PURE__ */ __name(function() {
  return __async(this, null, function* () {
    if (this.stream.isUpToDate) return;
    yield new Promise((resolve) => {
      const check = /* @__PURE__ */ __name(() => {
        if (this.stream.isUpToDate) {
          clearInterval(interval);
          unsub();
          resolve();
        }
      }, "check");
      const interval = setInterval(check, 10);
      const unsub = this.stream.subscribe(
        () => check(),
        () => check()
      );
      check();
    });
  });
}, "awaitUpToDate_fn");
updateShapeStatus_fn = /* @__PURE__ */ __name(function(status) {
  const stateChanged = __privateGet(this, _status) !== status;
  __privateSet(this, _status, status);
  return stateChanged && status === `up-to-date`;
}, "updateShapeStatus_fn");
handleError_fn = /* @__PURE__ */ __name(function(e) {
  if (e instanceof FetchError) {
    __privateSet(this, _error2, e);
    __privateMethod(this, _Shape_instances, notify_fn).call(this);
  }
}, "handleError_fn");
notify_fn = /* @__PURE__ */ __name(function() {
  __privateGet(this, _subscribers2).forEach((callback) => {
    callback({ value: this.currentValue, rows: this.currentRows });
  });
}, "notify_fn");

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/version.js
init_esm();
var API_VERSION = "2025-07-16";
var API_VERSION_HEADER_NAME = "x-trigger-api-version";

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/stream.js
function zodShapeStream(schema, url, options) {
  const abortController = new AbortController();
  options?.signal?.addEventListener("abort", () => {
    abortController.abort();
  }, { once: true });
  const shapeStream = new ShapeStream({
    url,
    headers: {
      ...options?.headers,
      "x-trigger-electric-version": "1.0.0-beta.1",
      [API_VERSION_HEADER_NAME]: API_VERSION
    },
    fetchClient: options?.fetchClient,
    signal: abortController.signal,
    onError: /* @__PURE__ */ __name((e) => {
      options?.onError?.(e);
    }, "onError")
  });
  const readableShape = new ReadableShapeStream(shapeStream);
  const stream2 = readableShape.stream.pipeThrough(new TransformStream({
    async transform(chunk, controller) {
      const result = schema.safeParse(chunk);
      if (result.success) {
        controller.enqueue(result.data);
      } else {
        controller.error(new Error(`Unable to parse shape: ${result.error.message}`));
      }
    }
  }));
  return {
    stream: stream2,
    stop: /* @__PURE__ */ __name((delay) => {
      if (delay) {
        setTimeout(() => {
          if (abortController.signal.aborted)
            return;
          abortController.abort();
        }, delay);
      } else {
        abortController.abort();
      }
    }, "stop")
  };
}
__name(zodShapeStream, "zodShapeStream");
var ReadableShapeStream = class {
  static {
    __name(this, "ReadableShapeStream");
  }
  #stream;
  #currentState = /* @__PURE__ */ new Map();
  #changeStream;
  #error = false;
  #unsubscribe;
  #isStreamClosed = false;
  stop() {
    this.#isStreamClosed = true;
    this.#unsubscribe?.();
  }
  constructor(stream2) {
    this.#stream = stream2;
    const source = new ReadableStream({
      start: /* @__PURE__ */ __name((controller) => {
        this.#unsubscribe = this.#stream.subscribe((messages) => {
          if (!this.#isStreamClosed) {
            controller.enqueue(messages);
          }
        }, this.#handleError.bind(this));
      }, "start"),
      cancel: /* @__PURE__ */ __name(() => {
        this.#isStreamClosed = true;
        this.#unsubscribe?.();
      }, "cancel")
    });
    let updatedKeys = /* @__PURE__ */ new Set();
    this.#changeStream = createAsyncIterableStream(source, {
      transform: /* @__PURE__ */ __name((messages, controller) => {
        if (this.#isStreamClosed) {
          return;
        }
        try {
          let isUpToDate = false;
          for (const message of messages) {
            if (isChangeMessage(message)) {
              const key = message.key;
              switch (message.headers.operation) {
                case "insert": {
                  this.#currentState.set(key, message.value);
                  updatedKeys.add(key);
                  break;
                }
                case "update": {
                  const existingRow = this.#currentState.get(key);
                  const updatedRow = existingRow ? { ...existingRow, ...message.value } : message.value;
                  this.#currentState.set(key, updatedRow);
                  updatedKeys.add(key);
                  break;
                }
              }
            } else if (isControlMessage(message)) {
              if (message.headers.control === "must-refetch") {
                this.#currentState.clear();
                this.#error = false;
              } else if (message.headers.control === "up-to-date") {
                isUpToDate = true;
              }
            }
          }
          if (!this.#isStreamClosed && isUpToDate) {
            for (const key of updatedKeys) {
              const finalRow = this.#currentState.get(key);
              if (finalRow) {
                controller.enqueue(finalRow);
              }
            }
            updatedKeys.clear();
          }
        } catch (error) {
          console.error("Error processing stream messages:", error);
          this.#handleError(error);
        }
      }, "transform")
    });
  }
  get stream() {
    return this.#changeStream;
  }
  get isUpToDate() {
    return this.#stream.isUpToDate;
  }
  get lastOffset() {
    return this.#stream.lastOffset;
  }
  get handle() {
    return this.#stream.shapeHandle;
  }
  get error() {
    return this.#error;
  }
  lastSyncedAt() {
    return this.#stream.lastSyncedAt();
  }
  lastSynced() {
    return this.#stream.lastSynced();
  }
  isLoading() {
    return this.#stream.isLoading();
  }
  isConnected() {
    return this.#stream.isConnected();
  }
  #handleError(e) {
    if (e instanceof FetchError) {
      this.#error = e;
    }
    this.#isStreamClosed = true;
    this.#unsubscribe?.();
  }
};
var LineTransformStream = class extends TransformStream {
  static {
    __name(this, "LineTransformStream");
  }
  buffer = "";
  constructor() {
    super({
      transform: /* @__PURE__ */ __name((chunk, controller) => {
        this.buffer += chunk;
        const lines = this.buffer.split("\n");
        this.buffer = lines.pop() || "";
        const fullLines = lines.filter((line) => line.trim().length > 0);
        if (fullLines.length > 0) {
          controller.enqueue(fullLines);
        }
      }, "transform"),
      flush: /* @__PURE__ */ __name((controller) => {
        const trimmed = this.buffer.trim();
        if (trimmed.length > 0) {
          controller.enqueue([trimmed]);
        }
      }, "flush")
    });
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/runStream.js
function runShapeStream(url, options) {
  const abortController = new AbortController();
  const streamFactory = new SSEStreamSubscriptionFactory(getEnvVar("TRIGGER_STREAM_URL", getEnvVar("TRIGGER_API_URL")) ?? "https://api.trigger.dev", {
    headers: options?.headers,
    signal: abortController.signal
  });
  options?.signal?.addEventListener("abort", () => {
    if (!abortController.signal.aborted) {
      abortController.abort();
    }
  }, { once: true });
  const runStreamInstance = zodShapeStream(SubscribeRunRawShape, url, {
    ...options,
    signal: abortController.signal,
    onError: /* @__PURE__ */ __name((e) => {
      options?.onFetchError?.(e);
    }, "onError")
  });
  const $options = {
    runShapeStream: runStreamInstance.stream,
    stopRunShapeStream: /* @__PURE__ */ __name(() => runStreamInstance.stop(30 * 1e3), "stopRunShapeStream"),
    streamFactory,
    abortController,
    ...options
  };
  return new RunSubscription($options);
}
__name(runShapeStream, "runShapeStream");
var SSEStreamSubscription = class {
  static {
    __name(this, "SSEStreamSubscription");
  }
  url;
  options;
  lastEventId;
  retryCount = 0;
  maxRetries = 5;
  retryDelayMs = 1e3;
  constructor(url, options) {
    this.url = url;
    this.options = options;
    this.lastEventId = options.lastEventId;
  }
  async subscribe() {
    const self = this;
    return new ReadableStream({
      async start(controller) {
        await self.connectStream(controller);
      },
      cancel(reason) {
        self.options.onComplete?.();
      }
    });
  }
  async connectStream(controller) {
    try {
      const headers = {
        Accept: "text/event-stream",
        ...this.options.headers
      };
      if (this.lastEventId) {
        headers["Last-Event-ID"] = this.lastEventId;
      }
      if (this.options.timeoutInSeconds) {
        headers["Timeout-Seconds"] = this.options.timeoutInSeconds.toString();
      }
      const response = await fetch(this.url, {
        headers,
        signal: this.options.signal
      });
      if (!response.ok) {
        const error = ApiError.generate(response.status, {}, "Could not subscribe to stream", Object.fromEntries(response.headers));
        this.options.onError?.(error);
        throw error;
      }
      if (!response.body) {
        const error = new Error("No response body");
        this.options.onError?.(error);
        throw error;
      }
      const streamVersion = response.headers.get("X-Stream-Version") ?? "v1";
      this.retryCount = 0;
      const seenIds = /* @__PURE__ */ new Set();
      const stream2 = response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(new TransformStream({
        transform: /* @__PURE__ */ __name((chunk, chunkController) => {
          if (streamVersion === "v1") {
            if (chunk.id) {
              this.lastEventId = chunk.id;
            }
            const timestamp = parseRedisStreamIdTimestamp(chunk.id);
            chunkController.enqueue({
              id: chunk.id ?? "unknown",
              chunk: safeParseJSON(chunk.data),
              timestamp
            });
          } else {
            if (chunk.event === "batch") {
              const data = safeParseJSON(chunk.data);
              for (const record of data.records) {
                this.lastEventId = record.seq_num.toString();
                const parsedBody = safeParseJSON(record.body);
                if (seenIds.has(parsedBody.id)) {
                  continue;
                }
                seenIds.add(parsedBody.id);
                chunkController.enqueue({
                  id: record.seq_num.toString(),
                  chunk: parsedBody.data,
                  timestamp: record.timestamp
                });
              }
            }
          }
        }, "transform")
      }));
      const reader = stream2.getReader();
      try {
        let chunkCount = 0;
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            reader.releaseLock();
            controller.close();
            this.options.onComplete?.();
            return;
          }
          if (this.options.signal?.aborted) {
            reader.cancel();
            reader.releaseLock();
            controller.close();
            this.options.onComplete?.();
            return;
          }
          chunkCount++;
          controller.enqueue(value);
        }
      } catch (error) {
        reader.releaseLock();
        throw error;
      }
    } catch (error) {
      if (this.options.signal?.aborted) {
        controller.close();
        this.options.onComplete?.();
        return;
      }
      await this.retryConnection(controller, error);
    }
  }
  async retryConnection(controller, error) {
    if (this.options.signal?.aborted) {
      controller.close();
      this.options.onComplete?.();
      return;
    }
    if (this.retryCount >= this.maxRetries) {
      const finalError = error || new Error("Max retries reached");
      controller.error(finalError);
      this.options.onError?.(finalError);
      return;
    }
    this.retryCount++;
    const delay = this.retryDelayMs * Math.pow(2, this.retryCount - 1);
    await new Promise((resolve) => setTimeout(resolve, delay));
    if (this.options.signal?.aborted) {
      controller.close();
      this.options.onComplete?.();
      return;
    }
    await this.connectStream(controller);
  }
};
var SSEStreamSubscriptionFactory = class {
  static {
    __name(this, "SSEStreamSubscriptionFactory");
  }
  baseUrl;
  options;
  constructor(baseUrl, options) {
    this.baseUrl = baseUrl;
    this.options = options;
  }
  createSubscription(runId, streamKey, options) {
    if (!runId || !streamKey) {
      throw new Error("runId and streamKey are required");
    }
    const url = `${options?.baseUrl ?? this.baseUrl}/realtime/v1/streams/${runId}/${streamKey}`;
    return new SSEStreamSubscription(url, {
      ...this.options,
      ...options
    });
  }
};
var RunSubscription = class {
  static {
    __name(this, "RunSubscription");
  }
  options;
  stream;
  packetCache = /* @__PURE__ */ new Map();
  _closeOnComplete;
  _isRunComplete = false;
  constructor(options) {
    this.options = options;
    this._closeOnComplete = typeof options.closeOnComplete === "undefined" ? true : options.closeOnComplete;
    this.stream = createAsyncIterableReadable(this.options.runShapeStream, {
      transform: /* @__PURE__ */ __name(async (chunk, controller) => {
        const run = await this.transformRunShape(chunk);
        controller.enqueue(run);
        this._isRunComplete = !!run.finishedAt;
        if (this._closeOnComplete && this._isRunComplete && !this.options.abortController.signal.aborted) {
          this.options.stopRunShapeStream();
        }
      }, "transform")
    }, this.options.abortController.signal);
  }
  unsubscribe() {
    if (!this.options.abortController.signal.aborted) {
      this.options.abortController.abort();
    }
    this.options.stopRunShapeStream();
  }
  [Symbol.asyncIterator]() {
    return this.stream[Symbol.asyncIterator]();
  }
  getReader() {
    return this.stream.getReader();
  }
  withStreams() {
    const activeStreams = /* @__PURE__ */ new Set();
    return createAsyncIterableReadable(this.stream, {
      transform: /* @__PURE__ */ __name(async (run, controller) => {
        controller.enqueue({
          type: "run",
          run
        });
        const streams2 = getStreamsFromRunShape(run);
        if (streams2.length > 0) {
          for (const streamKey of streams2) {
            if (typeof streamKey !== "string") {
              continue;
            }
            if (!activeStreams.has(streamKey)) {
              activeStreams.add(streamKey);
              const subscription = this.options.streamFactory.createSubscription(run.id, streamKey, {
                baseUrl: this.options.client?.baseUrl
              });
              subscription.subscribe().then((stream2) => {
                stream2.pipeThrough(new TransformStream({
                  transform(chunk, controller2) {
                    controller2.enqueue({
                      type: streamKey,
                      chunk: chunk.chunk,
                      run
                    });
                  }
                })).pipeTo(new WritableStream({
                  write(chunk) {
                    controller.enqueue(chunk);
                  }
                }));
              });
            }
          }
        }
      }, "transform")
    }, this.options.abortController.signal);
  }
  async transformRunShape(row) {
    const payloadPacket = row.payloadType ? { data: row.payload ?? void 0, dataType: row.payloadType } : void 0;
    const outputPacket = row.outputType ? { data: row.output ?? void 0, dataType: row.outputType } : void 0;
    const [payload, output] = await Promise.all([
      { packet: payloadPacket, key: "payload" },
      { packet: outputPacket, key: "output" }
    ].map(async ({ packet, key }) => {
      if (!packet) {
        return;
      }
      const cachedResult = this.packetCache.get(`${row.friendlyId}/${key}`);
      if (typeof cachedResult !== "undefined") {
        return cachedResult;
      }
      const result = await conditionallyImportAndParsePacket(packet, this.options.client);
      this.packetCache.set(`${row.friendlyId}/${key}`, result);
      return result;
    }));
    const metadata2 = row.metadata && row.metadataType ? await parsePacket({ data: row.metadata, dataType: row.metadataType }) : void 0;
    const status = apiStatusFromRunStatus(row.status);
    return {
      id: row.friendlyId,
      createdAt: row.createdAt,
      updatedAt: row.updatedAt,
      taskIdentifier: row.taskIdentifier,
      status,
      payload,
      output,
      durationMs: row.usageDurationMs ?? 0,
      costInCents: row.costInCents ?? 0,
      baseCostInCents: row.baseCostInCents ?? 0,
      tags: row.runTags ?? [],
      idempotencyKey: row.idempotencyKey ?? void 0,
      expiredAt: row.expiredAt ?? void 0,
      finishedAt: row.completedAt ?? void 0,
      startedAt: row.startedAt ?? void 0,
      delayedUntil: row.delayUntil ?? void 0,
      queuedAt: row.queuedAt ?? void 0,
      error: row.error ? createJsonErrorObject(row.error) : void 0,
      isTest: row.isTest ?? false,
      metadata: metadata2,
      realtimeStreams: row.realtimeStreams ?? [],
      ...booleanHelpersFromRunStatus(status)
    };
  }
};
var queuedStatuses = ["PENDING_VERSION", "QUEUED", "PENDING", "DELAYED"];
var waitingStatuses = ["WAITING"];
var executingStatuses = ["DEQUEUED", "EXECUTING"];
var failedStatuses = ["FAILED", "CRASHED", "SYSTEM_FAILURE", "EXPIRED", "TIMED_OUT"];
var successfulStatuses = ["COMPLETED"];
function booleanHelpersFromRunStatus(status) {
  return {
    isQueued: queuedStatuses.includes(status),
    isWaiting: waitingStatuses.includes(status),
    isExecuting: executingStatuses.includes(status),
    isCompleted: successfulStatuses.includes(status) || failedStatuses.includes(status),
    isFailed: failedStatuses.includes(status),
    isSuccess: successfulStatuses.includes(status),
    isCancelled: status === "CANCELED"
  };
}
__name(booleanHelpersFromRunStatus, "booleanHelpersFromRunStatus");
function apiStatusFromRunStatus(status) {
  switch (status) {
    case "DELAYED": {
      return "DELAYED";
    }
    case "WAITING_FOR_DEPLOY":
    case "PENDING_VERSION": {
      return "PENDING_VERSION";
    }
    case "PENDING": {
      return "QUEUED";
    }
    case "PAUSED":
    case "WAITING_TO_RESUME": {
      return "WAITING";
    }
    case "DEQUEUED": {
      return "DEQUEUED";
    }
    case "RETRYING_AFTER_FAILURE":
    case "EXECUTING": {
      return "EXECUTING";
    }
    case "CANCELED": {
      return "CANCELED";
    }
    case "COMPLETED_SUCCESSFULLY": {
      return "COMPLETED";
    }
    case "SYSTEM_FAILURE": {
      return "SYSTEM_FAILURE";
    }
    case "CRASHED": {
      return "CRASHED";
    }
    case "INTERRUPTED":
    case "COMPLETED_WITH_ERRORS": {
      return "FAILED";
    }
    case "EXPIRED": {
      return "EXPIRED";
    }
    case "TIMED_OUT": {
      return "TIMED_OUT";
    }
    default: {
      return "QUEUED";
    }
  }
}
__name(apiStatusFromRunStatus, "apiStatusFromRunStatus");
function safeParseJSON(data) {
  try {
    return JSON.parse(data);
  } catch (error) {
    return data;
  }
}
__name(safeParseJSON, "safeParseJSON");
var isSafari = /* @__PURE__ */ __name(() => {
  if (typeof window !== "undefined" && typeof navigator !== "undefined" && typeof navigator.userAgent === "string") {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || /iPad|iPhone|iPod/.test(navigator.userAgent);
  }
  return false;
}, "isSafari");
if (isSafari()) {
  ReadableStream.prototype.values ??= function({ preventCancel = false } = {}) {
    const reader = this.getReader();
    return {
      async next() {
        try {
          const result = await reader.read();
          if (result.done) {
            reader.releaseLock();
          }
          return {
            done: result.done,
            value: result.value
          };
        } catch (e) {
          reader.releaseLock();
          throw e;
        }
      },
      async return(value) {
        if (!preventCancel) {
          const cancelPromise = reader.cancel(value);
          reader.releaseLock();
          await cancelPromise;
        } else {
          reader.releaseLock();
        }
        return { done: true, value };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  };
  ReadableStream.prototype[Symbol.asyncIterator] ??= ReadableStream.prototype.values;
}
function getStreamsFromRunShape(run) {
  const metadataStreams = run.metadata && "$$streams" in run.metadata && Array.isArray(run.metadata.$$streams) && run.metadata.$$streams.length > 0 && run.metadata.$$streams.every((stream2) => typeof stream2 === "string") ? run.metadata.$$streams : void 0;
  if (metadataStreams) {
    return metadataStreams;
  }
  return run.realtimeStreams;
}
__name(getStreamsFromRunShape, "getStreamsFromRunShape");
function parseRedisStreamIdTimestamp(id) {
  if (!id) {
    return Date.now();
  }
  const timestamp = parseInt(id.split("-")[0], 10);
  if (isNaN(timestamp)) {
    return Date.now();
  }
  return timestamp;
}
__name(parseRedisStreamIdTimestamp, "parseRedisStreamIdTimestamp");

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/getBranch.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/index.js
var DEFAULT_ZOD_FETCH_OPTIONS = {
  retry: {
    maxAttempts: 5,
    minTimeoutInMs: 1e3,
    maxTimeoutInMs: 3e4,
    factor: 1.6,
    randomize: false
  }
};
var ApiClient = class {
  static {
    __name(this, "ApiClient");
  }
  baseUrl;
  accessToken;
  previewBranch;
  futureFlags;
  defaultRequestOptions;
  constructor(baseUrl, accessToken, previewBranch, requestOptions = {}, futureFlags = {}) {
    this.accessToken = accessToken;
    this.baseUrl = baseUrl.replace(/\/$/, "");
    this.previewBranch = previewBranch;
    this.defaultRequestOptions = mergeRequestOptions(DEFAULT_ZOD_FETCH_OPTIONS, requestOptions);
    this.futureFlags = futureFlags;
  }
  get fetchClient() {
    const headers = this.#getHeaders(false);
    const fetchClient = /* @__PURE__ */ __name((input, requestInit) => {
      const $requestInit = {
        ...requestInit,
        headers: {
          ...requestInit?.headers,
          ...headers
        }
      };
      return fetch(input, $requestInit);
    }, "fetchClient");
    return fetchClient;
  }
  getHeaders() {
    return this.#getHeaders(false);
  }
  async getRunResult(runId, requestOptions) {
    try {
      return await zodfetch(TaskRunExecutionResult, `${this.baseUrl}/api/v1/runs/${runId}/result`, {
        method: "GET",
        headers: this.#getHeaders(false)
      }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    } catch (error) {
      if (error instanceof ApiError) {
        if (error.status === 404) {
          return void 0;
        }
      }
      throw error;
    }
  }
  async getBatchResults(batchId, requestOptions) {
    return await zodfetch(BatchTaskRunExecutionResult, `${this.baseUrl}/api/v1/batches/${batchId}/results`, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  triggerTask(taskId, body, clientOptions, requestOptions) {
    const encodedTaskId = encodeURIComponent(taskId);
    return zodfetch(TriggerTaskResponse, `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/trigger`, {
      method: "POST",
      headers: this.#getHeaders(clientOptions?.spanParentAsLink ?? false),
      body: JSON.stringify(body)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions)).withResponse().then(async ({ data, response }) => {
      const jwtHeader = response.headers.get("x-trigger-jwt");
      if (typeof jwtHeader === "string") {
        return {
          ...data,
          publicAccessToken: jwtHeader
        };
      }
      const claimsHeader = response.headers.get("x-trigger-jwt-claims");
      const claims = claimsHeader ? JSON.parse(claimsHeader) : void 0;
      const jwt = await generateJWT({
        secretKey: this.accessToken,
        payload: {
          ...claims,
          scopes: [`read:runs:${data.id}`]
        },
        expirationTime: requestOptions?.publicAccessToken?.expirationTime ?? "1h"
      });
      return {
        ...data,
        publicAccessToken: jwt
      };
    });
  }
  batchTriggerV3(body, clientOptions, requestOptions) {
    return zodfetch(BatchTriggerTaskV3Response, `${this.baseUrl}/api/v2/tasks/batch`, {
      method: "POST",
      headers: this.#getHeaders(clientOptions?.spanParentAsLink ?? false, {
        "batch-processing-strategy": clientOptions?.processingStrategy
      }),
      body: JSON.stringify(body)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions)).withResponse().then(async ({ data, response }) => {
      const claimsHeader = response.headers.get("x-trigger-jwt-claims");
      const claims = claimsHeader ? JSON.parse(claimsHeader) : void 0;
      const jwt = await generateJWT({
        secretKey: this.accessToken,
        payload: {
          ...claims,
          scopes: [`read:batch:${data.id}`]
        },
        expirationTime: requestOptions?.publicAccessToken?.expirationTime ?? "1h"
      });
      return {
        ...data,
        publicAccessToken: jwt
      };
    });
  }
  createUploadPayloadUrl(filename, requestOptions) {
    return zodfetch(CreateUploadPayloadUrlResponseBody, `${this.baseUrl}/api/v1/packets/${filename}`, {
      method: "PUT",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  getPayloadUrl(filename, requestOptions) {
    return zodfetch(CreateUploadPayloadUrlResponseBody, `${this.baseUrl}/api/v1/packets/${filename}`, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  retrieveRun(runId, requestOptions) {
    return zodfetch(RetrieveRunResponse, `${this.baseUrl}/api/v3/runs/${runId}`, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  retrieveRunTrace(runId, requestOptions) {
    return zodfetch(RetrieveRunTraceResponseBody, `${this.baseUrl}/api/v1/runs/${runId}/trace`, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  listRuns(query, requestOptions) {
    const searchParams = createSearchQueryForListRuns(query);
    return zodfetchCursorPage(ListRunResponseItem, `${this.baseUrl}/api/v1/runs`, {
      query: searchParams,
      limit: query?.limit,
      after: query?.after,
      before: query?.before
    }, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  listProjectRuns(projectRef, query, requestOptions) {
    const searchParams = createSearchQueryForListRuns(query);
    if (query?.env) {
      searchParams.append("filter[env]", Array.isArray(query.env) ? query.env.join(",") : query.env);
    }
    return zodfetchCursorPage(ListRunResponseItem, `${this.baseUrl}/api/v1/projects/${projectRef}/runs`, {
      query: searchParams,
      limit: query?.limit,
      after: query?.after,
      before: query?.before
    }, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  replayRun(runId, requestOptions) {
    return zodfetch(ReplayRunResponse, `${this.baseUrl}/api/v1/runs/${runId}/replay`, {
      method: "POST",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  cancelRun(runId, requestOptions) {
    return zodfetch(CanceledRunResponse, `${this.baseUrl}/api/v2/runs/${runId}/cancel`, {
      method: "POST",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  rescheduleRun(runId, body, requestOptions) {
    return zodfetch(RetrieveRunResponse, `${this.baseUrl}/api/v1/runs/${runId}/reschedule`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: JSON.stringify(body)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  listRunEvents(runId, requestOptions) {
    return zodfetch(
      external_exports.any(),
      // TODO: define a proper schema for this
      `${this.baseUrl}/api/v1/runs/${runId}/events`,
      {
        method: "GET",
        headers: this.#getHeaders(false)
      },
      mergeRequestOptions(this.defaultRequestOptions, requestOptions)
    );
  }
  addTags(runId, body, requestOptions) {
    return zodfetch(external_exports.object({ message: external_exports.string() }), `${this.baseUrl}/api/v1/runs/${runId}/tags`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: JSON.stringify(body)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  createSchedule(options, requestOptions) {
    return zodfetch(ScheduleObject, `${this.baseUrl}/api/v1/schedules`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: JSON.stringify(options)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  listSchedules(options, requestOptions) {
    const searchParams = new URLSearchParams();
    if (options?.page) {
      searchParams.append("page", options.page.toString());
    }
    if (options?.perPage) {
      searchParams.append("perPage", options.perPage.toString());
    }
    return zodfetchOffsetLimitPage(ScheduleObject, `${this.baseUrl}/api/v1/schedules`, {
      page: options?.page,
      limit: options?.perPage
    }, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  retrieveSchedule(scheduleId, requestOptions) {
    return zodfetch(ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  updateSchedule(scheduleId, options, requestOptions) {
    return zodfetch(ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {
      method: "PUT",
      headers: this.#getHeaders(false),
      body: JSON.stringify(options)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  deactivateSchedule(scheduleId, requestOptions) {
    return zodfetch(ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}/deactivate`, {
      method: "POST",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  activateSchedule(scheduleId, requestOptions) {
    return zodfetch(ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}/activate`, {
      method: "POST",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  deleteSchedule(scheduleId, requestOptions) {
    return zodfetch(DeletedScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {
      method: "DELETE",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  listEnvVars(projectRef, slug, requestOptions) {
    return zodfetch(external_exports.array(EnvironmentVariableWithSecret), `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  importEnvVars(projectRef, slug, body, requestOptions) {
    return zodfetch(EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/import`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: JSON.stringify(body)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  retrieveEnvVar(projectRef, slug, key, requestOptions) {
    return zodfetch(EnvironmentVariableWithSecret, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  createEnvVar(projectRef, slug, body, requestOptions) {
    return zodfetch(EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: JSON.stringify(body)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  updateEnvVar(projectRef, slug, key, body, requestOptions) {
    return zodfetch(EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {
      method: "PUT",
      headers: this.#getHeaders(false),
      body: JSON.stringify(body)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  deleteEnvVar(projectRef, slug, key, requestOptions) {
    return zodfetch(EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {
      method: "DELETE",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  updateRunMetadata(runId, body, requestOptions) {
    return zodfetch(UpdateMetadataResponseBody, `${this.baseUrl}/api/v1/runs/${runId}/metadata`, {
      method: "PUT",
      headers: this.#getHeaders(false),
      body: JSON.stringify(body)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  getRunMetadata(runId, requestOptions) {
    return zodfetch(UpdateMetadataResponseBody, `${this.baseUrl}/api/v1/runs/${runId}/metadata`, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  createWaitpointToken(options, requestOptions) {
    return zodfetch(CreateWaitpointTokenResponseBody, `${this.baseUrl}/api/v1/waitpoints/tokens`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: JSON.stringify(options)
    }, {
      ...mergeRequestOptions(this.defaultRequestOptions, requestOptions),
      prepareData: /* @__PURE__ */ __name(async (data, response) => {
        const jwtHeader = response.headers.get("x-trigger-jwt");
        if (typeof jwtHeader === "string") {
          return {
            ...data,
            publicAccessToken: jwtHeader
          };
        }
        const claimsHeader = response.headers.get("x-trigger-jwt-claims");
        const claims = claimsHeader ? JSON.parse(claimsHeader) : void 0;
        const jwt = await generateJWT({
          secretKey: this.accessToken,
          payload: {
            ...claims,
            scopes: [`write:waitpoints:${data.id}`]
          },
          expirationTime: "24h"
        });
        return {
          ...data,
          publicAccessToken: jwt
        };
      }, "prepareData")
    });
  }
  listWaitpointTokens(params, requestOptions) {
    const searchParams = createSearchQueryForListWaitpointTokens(params);
    return zodfetchCursorPage(WaitpointTokenItem, `${this.baseUrl}/api/v1/waitpoints/tokens`, {
      query: searchParams,
      limit: params?.limit,
      after: params?.after,
      before: params?.before
    }, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  retrieveWaitpointToken(friendlyId, requestOptions) {
    return zodfetch(WaitpointRetrieveTokenResponse, `${this.baseUrl}/api/v1/waitpoints/tokens/${friendlyId}`, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  completeWaitpointToken(friendlyId, options, requestOptions) {
    return zodfetch(CompleteWaitpointTokenResponseBody, `${this.baseUrl}/api/v1/waitpoints/tokens/${friendlyId}/complete`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: JSON.stringify(options)
    }, {
      ...mergeRequestOptions(this.defaultRequestOptions, requestOptions)
    });
  }
  waitForWaitpointToken({ runFriendlyId, waitpointFriendlyId }, requestOptions) {
    return zodfetch(WaitForWaitpointTokenResponseBody, `${this.baseUrl}/engine/v1/runs/${runFriendlyId}/waitpoints/tokens/${waitpointFriendlyId}/wait`, {
      method: "POST",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  async waitForDuration(runId, body, requestOptions) {
    return zodfetch(WaitForDurationResponseBody, `${this.baseUrl}/engine/v1/runs/${runId}/wait/duration`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: JSON.stringify(body)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  listQueues(options, requestOptions) {
    const searchParams = new URLSearchParams();
    if (options?.page) {
      searchParams.append("page", options.page.toString());
    }
    if (options?.perPage) {
      searchParams.append("perPage", options.perPage.toString());
    }
    return zodfetchOffsetLimitPage(QueueItem, `${this.baseUrl}/api/v1/queues`, {
      page: options?.page,
      limit: options?.perPage
    }, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  retrieveQueue(queue2, requestOptions) {
    const type = typeof queue2 === "string" ? "id" : queue2.type;
    const value = typeof queue2 === "string" ? queue2 : queue2.name;
    const encodedValue = encodeURIComponent(value.replace(/\//g, "%2F"));
    return zodfetch(QueueItem, `${this.baseUrl}/api/v1/queues/${encodedValue}?type=${type}`, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  pauseQueue(queue2, action, requestOptions) {
    const type = typeof queue2 === "string" ? "id" : queue2.type;
    const value = typeof queue2 === "string" ? queue2 : queue2.name;
    const encodedValue = encodeURIComponent(value.replace(/\//g, "%2F"));
    return zodfetch(QueueItem, `${this.baseUrl}/api/v1/queues/${encodedValue}/pause`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: JSON.stringify({
        type,
        action
      })
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  overrideQueueConcurrencyLimit(queue2, concurrencyLimit, requestOptions) {
    const type = typeof queue2 === "string" ? "id" : queue2.type;
    const value = typeof queue2 === "string" ? queue2 : queue2.name;
    const encodedValue = encodeURIComponent(value.replace(/\//g, "%2F"));
    return zodfetch(QueueItem, `${this.baseUrl}/api/v1/queues/${encodedValue}/concurrency/override`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: JSON.stringify({
        type,
        concurrencyLimit
      })
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  resetQueueConcurrencyLimit(queue2, requestOptions) {
    const type = typeof queue2 === "string" ? "id" : queue2.type;
    const value = typeof queue2 === "string" ? queue2 : queue2.name;
    const encodedValue = encodeURIComponent(value.replace(/\//g, "%2F"));
    return zodfetch(QueueItem, `${this.baseUrl}/api/v1/queues/${encodedValue}/concurrency/reset`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: JSON.stringify({
        type
      })
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  subscribeToRun(runId, options) {
    const queryParams = new URLSearchParams();
    if (options?.skipColumns) {
      queryParams.append("skipColumns", options.skipColumns.join(","));
    }
    return runShapeStream(`${this.baseUrl}/realtime/v1/runs/${runId}${queryParams ? `?${queryParams}` : ""}`, {
      closeOnComplete: typeof options?.closeOnComplete === "boolean" ? options.closeOnComplete : true,
      headers: this.#getRealtimeHeaders(),
      client: this,
      signal: options?.signal,
      onFetchError: options?.onFetchError
    });
  }
  subscribeToRunsWithTag(tag, filters, options) {
    const searchParams = createSearchQueryForSubscribeToRuns({
      tags: tag,
      ...filters ? { createdAt: filters.createdAt } : {},
      ...filters?.skipColumns ? { skipColumns: filters.skipColumns } : {}
    });
    return runShapeStream(`${this.baseUrl}/realtime/v1/runs${searchParams ? `?${searchParams}` : ""}`, {
      closeOnComplete: false,
      headers: this.#getRealtimeHeaders(),
      client: this,
      signal: options?.signal,
      onFetchError: options?.onFetchError
    });
  }
  subscribeToBatch(batchId, options) {
    const queryParams = new URLSearchParams();
    if (options?.skipColumns) {
      queryParams.append("skipColumns", options.skipColumns.join(","));
    }
    return runShapeStream(`${this.baseUrl}/realtime/v1/batches/${batchId}${queryParams ? `?${queryParams}` : ""}`, {
      closeOnComplete: false,
      headers: this.#getRealtimeHeaders(),
      client: this,
      signal: options?.signal,
      onFetchError: options?.onFetchError
    });
  }
  listDeployments(options, requestOptions) {
    const searchParams = new URLSearchParams();
    if (options?.status) {
      searchParams.append("status", options.status);
    }
    if (options?.period) {
      searchParams.append("period", options.period);
    }
    if (options?.from) {
      searchParams.append("from", options.from);
    }
    if (options?.to) {
      searchParams.append("to", options.to);
    }
    return zodfetchCursorPage(ApiDeploymentListResponseItem, `${this.baseUrl}/api/v1/deployments`, {
      query: searchParams,
      after: options?.cursor,
      limit: options?.limit
    }, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  async fetchStream(runId, streamKey, options) {
    const streamFactory = new SSEStreamSubscriptionFactory(options?.baseUrl ?? this.baseUrl, {
      headers: this.getHeaders(),
      signal: options?.signal
    });
    const subscription = streamFactory.createSubscription(runId, streamKey, {
      onComplete: options?.onComplete,
      onError: options?.onError,
      timeoutInSeconds: options?.timeoutInSeconds,
      lastEventId: options?.lastEventId
    });
    const stream2 = await subscription.subscribe();
    return stream2.pipeThrough(new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(chunk.chunk);
      }
    }));
  }
  async createStream(runId, target, streamId, requestOptions) {
    return zodfetch(CreateStreamResponseBody, `${this.baseUrl}/realtime/v1/streams/${runId}/${target}/${streamId}`, {
      method: "PUT",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions)).withResponse().then(async ({ data, response }) => {
      return {
        ...data,
        headers: Object.fromEntries(response.headers.entries())
      };
    });
  }
  async appendToStream(runId, target, streamId, part, requestOptions) {
    return zodfetch(AppendToStreamResponseBody, `${this.baseUrl}/realtime/v1/streams/${runId}/${target}/${streamId}/append`, {
      method: "POST",
      headers: this.#getHeaders(false),
      body: part
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  async generateJWTClaims(requestOptions) {
    return zodfetch(external_exports.record(external_exports.any()), `${this.baseUrl}/api/v1/auth/jwt/claims`, {
      method: "POST",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  retrieveBatch(batchId, requestOptions) {
    return zodfetch(RetrieveBatchV2Response, `${this.baseUrl}/api/v2/batches/${batchId}`, {
      method: "GET",
      headers: this.#getHeaders(false)
    }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
  }
  #getHeaders(spanParentAsLink, additionalHeaders) {
    const headers = {
      "Content-Type": "application/json",
      Authorization: `Bearer ${this.accessToken}`,
      "trigger-version": VERSION,
      ...Object.entries(additionalHeaders ?? {}).reduce((acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      }, {})
    };
    if (this.previewBranch) {
      headers["x-trigger-branch"] = this.previewBranch;
    }
    if (taskContext.isInsideTask) {
      headers["x-trigger-worker"] = "true";
      headers["x-trigger-engine-version"] = "V2";
      if (spanParentAsLink) {
        headers["x-trigger-span-parent-as-link"] = "1";
      }
    }
    if (typeof window !== "undefined" && typeof window.document !== "undefined") {
      headers["x-trigger-client"] = "browser";
    }
    headers[API_VERSION_HEADER_NAME] = API_VERSION;
    const streamFlag = this.futureFlags.v2RealtimeStreams ?? true;
    if (streamFlag === false || getEnvVar("TRIGGER_V2_REALTIME_STREAMS") === "0" || getEnvVar("TRIGGER_V2_REALTIME_STREAMS") === "false" || getEnvVar("TRIGGER_REALTIME_STREAMS_V2") === "0" || getEnvVar("TRIGGER_REALTIME_STREAMS_V2") === "false") {
      headers["x-trigger-realtime-streams-version"] = "v1";
    } else {
      headers["x-trigger-realtime-streams-version"] = "v2";
    }
    return headers;
  }
  #getRealtimeHeaders() {
    let headers = {
      Authorization: `Bearer ${this.accessToken}`,
      "trigger-version": VERSION
    };
    if (this.previewBranch) {
      headers["x-trigger-branch"] = this.previewBranch;
    }
    return headers;
  }
};
function createSearchQueryForSubscribeToRuns(query) {
  const searchParams = new URLSearchParams();
  if (query) {
    if (query.tasks) {
      searchParams.append("tasks", Array.isArray(query.tasks) ? query.tasks.join(",") : query.tasks);
    }
    if (query.tags) {
      searchParams.append("tags", Array.isArray(query.tags) ? query.tags.join(",") : query.tags);
    }
    if (query.createdAt) {
      searchParams.append("createdAt", query.createdAt);
    }
    if (query.skipColumns) {
      searchParams.append("skipColumns", query.skipColumns.join(","));
    }
  }
  return searchParams;
}
__name(createSearchQueryForSubscribeToRuns, "createSearchQueryForSubscribeToRuns");
function createSearchQueryForListRuns(query) {
  const searchParams = new URLSearchParams();
  if (query) {
    if (query.status) {
      searchParams.append("filter[status]", Array.isArray(query.status) ? query.status.join(",") : query.status);
    }
    if (query.taskIdentifier) {
      searchParams.append("filter[taskIdentifier]", Array.isArray(query.taskIdentifier) ? query.taskIdentifier.join(",") : query.taskIdentifier);
    }
    if (query.version) {
      searchParams.append("filter[version]", Array.isArray(query.version) ? query.version.join(",") : query.version);
    }
    if (query.bulkAction) {
      searchParams.append("filter[bulkAction]", query.bulkAction);
    }
    if (query.tag) {
      searchParams.append("filter[tag]", Array.isArray(query.tag) ? query.tag.join(",") : query.tag);
    }
    if (query.schedule) {
      searchParams.append("filter[schedule]", query.schedule);
    }
    if (typeof query.isTest === "boolean") {
      searchParams.append("filter[isTest]", String(query.isTest));
    }
    if (query.from) {
      searchParams.append("filter[createdAt][from]", query.from instanceof Date ? query.from.getTime().toString() : query.from.toString());
    }
    if (query.to) {
      searchParams.append("filter[createdAt][to]", query.to instanceof Date ? query.to.getTime().toString() : query.to.toString());
    }
    if (query.period) {
      searchParams.append("filter[createdAt][period]", query.period);
    }
    if (query.batch) {
      searchParams.append("filter[batch]", query.batch);
    }
    if (query.queue) {
      searchParams.append("filter[queue]", Array.isArray(query.queue) ? query.queue.map((q) => queueNameFromQueueTypeName(q)).join(",") : queueNameFromQueueTypeName(query.queue));
    }
    if (query.machine) {
      searchParams.append("filter[machine]", Array.isArray(query.machine) ? query.machine.join(",") : query.machine);
    }
  }
  return searchParams;
}
__name(createSearchQueryForListRuns, "createSearchQueryForListRuns");
function queueNameFromQueueTypeName(queue2) {
  if (queue2.type === "task") {
    return `task/${queue2.name}`;
  }
  return queue2.name;
}
__name(queueNameFromQueueTypeName, "queueNameFromQueueTypeName");
function createSearchQueryForListWaitpointTokens(query) {
  const searchParams = new URLSearchParams();
  if (query) {
    if (query.status) {
      searchParams.append("filter[status]", Array.isArray(query.status) ? query.status.join(",") : query.status);
    }
    if (query.idempotencyKey) {
      searchParams.append("filter[idempotencyKey]", query.idempotencyKey);
    }
    if (query.tags) {
      searchParams.append("filter[tags]", Array.isArray(query.tags) ? query.tags.join(",") : query.tags);
    }
    if (query.period) {
      searchParams.append("filter[createdAt][period]", query.period);
    }
    if (query.from) {
      searchParams.append("filter[createdAt][from]", query.from instanceof Date ? query.from.getTime().toString() : query.from.toString());
    }
    if (query.to) {
      searchParams.append("filter[createdAt][to]", query.to instanceof Date ? query.to.getTime().toString() : query.to.toString());
    }
  }
  return searchParams;
}
__name(createSearchQueryForListWaitpointTokens, "createSearchQueryForListWaitpointTokens");
function mergeRequestOptions(defaultOptions, options) {
  if (!options) {
    return defaultOptions;
  }
  return {
    ...defaultOptions,
    ...options,
    retry: {
      ...defaultOptions.retry,
      ...options.retry
    }
  };
}
__name(mergeRequestOptions, "mergeRequestOptions");

// node_modules/@trigger.dev/core/dist/esm/v3/apiClient/types.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/clock-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/clock/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/clock/simpleClock.js
init_esm();
var import_precise_date = __toESM(require_src2(), 1);
var SimpleClock = class {
  static {
    __name(this, "SimpleClock");
  }
  preciseNow() {
    const now = new import_precise_date.PreciseDate();
    const nowStruct = now.toStruct();
    return [nowStruct.seconds, nowStruct.nanos];
  }
  reset() {
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/clock/index.js
var API_NAME8 = "clock";
var SIMPLE_CLOCK = new SimpleClock();
var ClockAPI = class _ClockAPI {
  static {
    __name(this, "ClockAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _ClockAPI();
    }
    return this._instance;
  }
  setGlobalClock(clock2) {
    return registerGlobal(API_NAME8, clock2);
  }
  preciseNow() {
    return this.#getClock().preciseNow();
  }
  reset() {
    this.#getClock().reset();
  }
  #getClock() {
    return getGlobal(API_NAME8) ?? SIMPLE_CLOCK;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/clock-api.js
var clock = ClockAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/logger-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/logger/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/logger/taskLogger.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/icons.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/logger/taskLogger.js
var NoopTaskLogger = class {
  static {
    __name(this, "NoopTaskLogger");
  }
  debug() {
  }
  log() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
  trace(name2, fn) {
    return fn({});
  }
  startSpan() {
    return {};
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/logger/index.js
var API_NAME9 = "logger";
var NOOP_TASK_LOGGER = new NoopTaskLogger();
var LoggerAPI = class _LoggerAPI {
  static {
    __name(this, "LoggerAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _LoggerAPI();
    }
    return this._instance;
  }
  disable() {
    unregisterGlobal(API_NAME9);
  }
  setGlobalTaskLogger(taskLogger) {
    return registerGlobal(API_NAME9, taskLogger);
  }
  debug(message, metadata2) {
    this.#getTaskLogger().debug(message, metadata2);
  }
  log(message, metadata2) {
    this.#getTaskLogger().log(message, metadata2);
  }
  info(message, metadata2) {
    this.#getTaskLogger().info(message, metadata2);
  }
  warn(message, metadata2) {
    this.#getTaskLogger().warn(message, metadata2);
  }
  error(message, metadata2) {
    this.#getTaskLogger().error(message, metadata2);
  }
  trace(name2, fn, options) {
    return this.#getTaskLogger().trace(name2, fn, options);
  }
  startSpan(name2, options) {
    return this.#getTaskLogger().startSpan(name2, options);
  }
  #getTaskLogger() {
    return getGlobal(API_NAME9) ?? NOOP_TASK_LOGGER;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/logger-api.js
var logger = LoggerAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/runtime-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/runtime/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/runtime/noopRuntimeManager.js
init_esm();
var NoopRuntimeManager = class {
  static {
    __name(this, "NoopRuntimeManager");
  }
  disable() {
  }
  waitForWaitpoint(params) {
    return Promise.resolve({
      ok: true
    });
  }
  waitForTask(params) {
    return Promise.resolve({
      ok: false,
      id: params.id,
      error: {
        type: "INTERNAL_ERROR",
        code: TaskRunErrorCodes.CONFIGURED_INCORRECTLY
      }
    });
  }
  waitForBatch(params) {
    return Promise.resolve({
      id: params.id,
      items: []
    });
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/usage-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/usage/api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/usage/noopUsageManager.js
init_esm();
var NoopUsageManager = class {
  static {
    __name(this, "NoopUsageManager");
  }
  disable() {
  }
  async flush() {
  }
  start() {
    return {
      sample: /* @__PURE__ */ __name(() => ({ cpuTime: 0, wallTime: 0 }), "sample")
    };
  }
  stop(measurement) {
    return measurement.sample();
  }
  pauseAsync(cb) {
    return cb();
  }
  sample() {
    return void 0;
  }
  reset() {
  }
  getInitialState() {
    return {
      cpuTime: 0,
      costInCents: 0
    };
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/usage/api.js
var API_NAME10 = "usage";
var NOOP_USAGE_MANAGER = new NoopUsageManager();
var UsageAPI = class _UsageAPI {
  static {
    __name(this, "UsageAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _UsageAPI();
    }
    return this._instance;
  }
  setGlobalUsageManager(manager) {
    return registerGlobal(API_NAME10, manager);
  }
  disable() {
    this.#getUsageManager().disable();
    unregisterGlobal(API_NAME10);
  }
  start() {
    return this.#getUsageManager().start();
  }
  stop(measurement) {
    return this.#getUsageManager().stop(measurement);
  }
  pauseAsync(cb) {
    return this.#getUsageManager().pauseAsync(cb);
  }
  sample() {
    return this.#getUsageManager().sample();
  }
  flush() {
    return this.#getUsageManager().flush();
  }
  reset() {
    this.#getUsageManager().reset();
    this.disable();
  }
  getInitialState() {
    return this.#getUsageManager().getInitialState();
  }
  #getUsageManager() {
    return getGlobal(API_NAME10) ?? NOOP_USAGE_MANAGER;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/usage-api.js
var usage = UsageAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/runtime/index.js
var API_NAME11 = "runtime";
var NOOP_RUNTIME_MANAGER = new NoopRuntimeManager();
var RuntimeAPI = class _RuntimeAPI {
  static {
    __name(this, "RuntimeAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _RuntimeAPI();
    }
    return this._instance;
  }
  waitUntil(waitpointFriendlyId, finishDate) {
    return usage.pauseAsync(() => this.#getRuntimeManager().waitForWaitpoint({ waitpointFriendlyId, finishDate }));
  }
  waitForTask(params) {
    return usage.pauseAsync(() => this.#getRuntimeManager().waitForTask(params));
  }
  waitForToken(waitpointFriendlyId) {
    return usage.pauseAsync(() => this.#getRuntimeManager().waitForWaitpoint({ waitpointFriendlyId }));
  }
  waitForBatch(params) {
    return usage.pauseAsync(() => this.#getRuntimeManager().waitForBatch(params));
  }
  setGlobalRuntimeManager(runtimeManager) {
    return registerGlobal(API_NAME11, runtimeManager);
  }
  disable() {
    this.#getRuntimeManager().disable();
    unregisterGlobal(API_NAME11);
  }
  #getRuntimeManager() {
    return getGlobal(API_NAME11) ?? NOOP_RUNTIME_MANAGER;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/runtime-api.js
var runtime = RuntimeAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/trace-context-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/traceContext/api.js
init_esm();
init_esm2();
var API_NAME12 = "trace-context";
var NoopTraceContextManager = class {
  static {
    __name(this, "NoopTraceContextManager");
  }
  getTraceContext() {
    return {};
  }
  reset() {
  }
  getExternalTraceContext() {
    return void 0;
  }
  extractContext() {
    return context.active();
  }
  withExternalTrace(fn) {
    return fn();
  }
};
var NOOP_TRACE_CONTEXT_MANAGER = new NoopTraceContextManager();
var TraceContextAPI = class _TraceContextAPI {
  static {
    __name(this, "TraceContextAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _TraceContextAPI();
    }
    return this._instance;
  }
  setGlobalManager(manager) {
    return registerGlobal(API_NAME12, manager);
  }
  disable() {
    unregisterGlobal(API_NAME12);
  }
  reset() {
    this.#getManager().reset();
    this.disable();
  }
  getTraceContext() {
    return this.#getManager().getTraceContext();
  }
  getExternalTraceContext() {
    return this.#getManager().getExternalTraceContext();
  }
  extractContext() {
    return this.#getManager().extractContext();
  }
  withExternalTrace(fn) {
    return this.#getManager().withExternalTrace(fn);
  }
  #getManager() {
    return getGlobal(API_NAME12) ?? NOOP_TRACE_CONTEXT_MANAGER;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/trace-context-api.js
var traceContext = TraceContextAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/run-metadata-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/runMetadata/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/runMetadata/noopManager.js
init_esm();
var NoopRunMetadataManager = class {
  static {
    __name(this, "NoopRunMetadataManager");
  }
  append(key, value) {
    throw new Error("Method not implemented.");
  }
  remove(key, value) {
    throw new Error("Method not implemented.");
  }
  increment(key, value) {
    throw new Error("Method not implemented.");
  }
  decrement(key, value) {
    throw new Error("Method not implemented.");
  }
  stream(key, value) {
    throw new Error("Method not implemented.");
  }
  fetchStream(key, signal) {
    throw new Error("Method not implemented.");
  }
  flush(requestOptions) {
    throw new Error("Method not implemented.");
  }
  refresh(requestOptions) {
    throw new Error("Method not implemented.");
  }
  enterWithMetadata(metadata2) {
  }
  current() {
    throw new Error("Method not implemented.");
  }
  getKey(key) {
    throw new Error("Method not implemented.");
  }
  set(key, value) {
    throw new Error("Method not implemented.");
  }
  del(key) {
    throw new Error("Method not implemented.");
  }
  update(metadata2) {
    throw new Error("Method not implemented.");
  }
  get parent() {
    const self = this;
    const parentUpdater = {
      append: /* @__PURE__ */ __name(() => parentUpdater, "append"),
      set: /* @__PURE__ */ __name(() => parentUpdater, "set"),
      del: /* @__PURE__ */ __name(() => parentUpdater, "del"),
      increment: /* @__PURE__ */ __name(() => parentUpdater, "increment"),
      decrement: /* @__PURE__ */ __name(() => parentUpdater, "decrement"),
      remove: /* @__PURE__ */ __name(() => parentUpdater, "remove"),
      stream: /* @__PURE__ */ __name(() => Promise.resolve({
        [Symbol.asyncIterator]: () => ({
          next: /* @__PURE__ */ __name(() => Promise.resolve({ done: true, value: void 0 }), "next")
        })
      }), "stream"),
      update: /* @__PURE__ */ __name(() => parentUpdater, "update")
    };
    return parentUpdater;
  }
  get root() {
    const self = this;
    const rootUpdater = {
      append: /* @__PURE__ */ __name(() => rootUpdater, "append"),
      set: /* @__PURE__ */ __name(() => rootUpdater, "set"),
      del: /* @__PURE__ */ __name(() => rootUpdater, "del"),
      increment: /* @__PURE__ */ __name(() => rootUpdater, "increment"),
      decrement: /* @__PURE__ */ __name(() => rootUpdater, "decrement"),
      remove: /* @__PURE__ */ __name(() => rootUpdater, "remove"),
      stream: /* @__PURE__ */ __name(() => Promise.resolve({
        [Symbol.asyncIterator]: () => ({
          next: /* @__PURE__ */ __name(() => Promise.resolve({ done: true, value: void 0 }), "next")
        })
      }), "stream"),
      update: /* @__PURE__ */ __name(() => rootUpdater, "update")
    };
    return rootUpdater;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/runMetadata/index.js
var API_NAME13 = "run-metadata";
var NOOP_MANAGER = new NoopRunMetadataManager();
var RunMetadataAPI = class _RunMetadataAPI {
  static {
    __name(this, "RunMetadataAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _RunMetadataAPI();
    }
    return this._instance;
  }
  setGlobalManager(manager) {
    return registerGlobal(API_NAME13, manager);
  }
  #getManager() {
    return getGlobal(API_NAME13) ?? NOOP_MANAGER;
  }
  enterWithMetadata(metadata2) {
    this.#getManager().enterWithMetadata(metadata2);
  }
  current() {
    return this.#getManager().current();
  }
  getKey(key) {
    return this.#getManager().getKey(key);
  }
  set(key, value) {
    this.#getManager().set(key, value);
    return this;
  }
  del(key) {
    this.#getManager().del(key);
    return this;
  }
  increment(key, value) {
    this.#getManager().increment(key, value);
    return this;
  }
  decrement(key, value) {
    this.#getManager().decrement(key, value);
    return this;
  }
  append(key, value) {
    this.#getManager().append(key, value);
    return this;
  }
  remove(key, value) {
    this.#getManager().remove(key, value);
    return this;
  }
  update(metadata2) {
    this.#getManager().update(metadata2);
    return this;
  }
  stream(key, value, signal) {
    return this.#getManager().stream(key, value, signal);
  }
  fetchStream(key, signal) {
    return this.#getManager().fetchStream(key, signal);
  }
  flush(requestOptions) {
    return this.#getManager().flush(requestOptions);
  }
  refresh(requestOptions) {
    return this.#getManager().refresh(requestOptions);
  }
  get parent() {
    return this.#getManager().parent;
  }
  get root() {
    return this.#getManager().root;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/runMetadata/types.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/runMetadata/operations.js
init_esm();
var import_path2 = __toESM(require_lib(), 1);

// node_modules/dequal/dist/index.mjs
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/run-metadata-api.js
var runMetadata = RunMetadataAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/wait-until-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/waitUntil/index.js
init_esm();
var API_NAME14 = "wait-until";
var NoopManager = class {
  static {
    __name(this, "NoopManager");
  }
  register(promise) {
  }
  blockUntilSettled() {
    return Promise.resolve();
  }
  requiresResolving() {
    return false;
  }
};
var NOOP_MANAGER2 = new NoopManager();
var WaitUntilAPI = class _WaitUntilAPI {
  static {
    __name(this, "WaitUntilAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _WaitUntilAPI();
    }
    return this._instance;
  }
  setGlobalManager(manager) {
    return registerGlobal(API_NAME14, manager);
  }
  #getManager() {
    return getGlobal(API_NAME14) ?? NOOP_MANAGER2;
  }
  register(promise) {
    return this.#getManager().register(promise);
  }
  blockUntilSettled() {
    return this.#getManager().blockUntilSettled();
  }
  requiresResolving() {
    return this.#getManager().requiresResolving();
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/wait-until-api.js
var waitUntil = WaitUntilAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/timeout-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/timeout/api.js
init_esm();
var API_NAME15 = "timeout";
var NoopTimeoutManager = class {
  static {
    __name(this, "NoopTimeoutManager");
  }
  abortAfterTimeout(timeoutInSeconds) {
    return new AbortController();
  }
  reset() {
  }
};
var NOOP_TIMEOUT_MANAGER = new NoopTimeoutManager();
var TimeoutAPI = class _TimeoutAPI {
  static {
    __name(this, "TimeoutAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _TimeoutAPI();
    }
    return this._instance;
  }
  get signal() {
    return this.#getManager().signal;
  }
  abortAfterTimeout(timeoutInSeconds) {
    return this.#getManager().abortAfterTimeout(timeoutInSeconds);
  }
  setGlobalManager(manager) {
    return registerGlobal(API_NAME15, manager);
  }
  disable() {
    unregisterGlobal(API_NAME15);
  }
  reset() {
    this.#getManager().reset();
    this.disable();
  }
  registerListener(listener) {
    const manager = this.#getManager();
    if (manager.registerListener) {
      manager.registerListener(listener);
    }
  }
  #getManager() {
    return getGlobal(API_NAME15) ?? NOOP_TIMEOUT_MANAGER;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/timeout-api.js
var timeout = TimeoutAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/run-timeline-metrics-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/runTimelineMetrics/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/runTimelineMetrics/runTimelineMetricsManager.js
init_esm();
var NoopRunTimelineMetricsManager = class {
  static {
    __name(this, "NoopRunTimelineMetricsManager");
  }
  registerMetric(metric) {
  }
  getMetrics() {
    return [];
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/runTimelineMetrics/index.js
var API_NAME16 = "run-timeline-metrics";
var NOOP_MANAGER3 = new NoopRunTimelineMetricsManager();
var RunTimelineMetricsAPI = class _RunTimelineMetricsAPI {
  static {
    __name(this, "RunTimelineMetricsAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _RunTimelineMetricsAPI();
    }
    return this._instance;
  }
  registerMetric(metric) {
    this.#getManager().registerMetric(metric);
  }
  getMetrics() {
    return this.#getManager().getMetrics();
  }
  /**
   * Measures the execution time of an async function and registers it as a metric
   * @param metricName The name of the metric
   * @param eventName The event name
   * @param attributesOrCallback Optional attributes or the callback function
   * @param callbackFn The async function to measure (if attributes were provided)
   * @returns The result of the callback function
   */
  async measureMetric(metricName, eventName, attributesOrCallback, callbackFn) {
    let attributes = {};
    let callback;
    if (typeof attributesOrCallback === "function") {
      callback = attributesOrCallback;
    } else {
      attributes = attributesOrCallback || {};
      if (!callbackFn) {
        throw new Error("Callback function is required when attributes are provided");
      }
      callback = callbackFn;
    }
    const startTime = Date.now();
    try {
      const result = await callback();
      const duration = Date.now() - startTime;
      this.registerMetric({
        name: metricName,
        event: eventName,
        attributes: {
          ...attributes,
          duration
        },
        timestamp: startTime
      });
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.registerMetric({
        name: metricName,
        event: eventName,
        attributes: {
          ...attributes,
          duration,
          error: error instanceof Error ? error.message : String(error),
          status: "failed"
        },
        timestamp: startTime
      });
      throw error;
    }
  }
  convertMetricsToSpanEvents() {
    const metrics2 = this.getMetrics();
    const spanEvents = metrics2.map((metric) => {
      return {
        name: metric.name,
        startTime: metric.timestamp,
        attributes: {
          ...metric.attributes,
          event: metric.event
        }
      };
    });
    return spanEvents;
  }
  convertMetricsToSpanAttributes() {
    const metrics2 = this.getMetrics();
    if (metrics2.length === 0) {
      return {};
    }
    const metricsByName = metrics2.reduce((acc, metric) => {
      if (!acc[metric.name]) {
        acc[metric.name] = [];
      }
      acc[metric.name].push(metric);
      return acc;
    }, {});
    const reducedMetrics = metrics2.reduce((acc, metric) => {
      acc[metric.event] = {
        name: metric.name,
        timestamp: metric.timestamp,
        event: metric.event,
        ...flattenAttributes(metric.attributes, "attributes")
      };
      return acc;
    }, {});
    const metricEventRollups = {};
    for (const [metricName, metricEvents] of Object.entries(metricsByName)) {
      if (metricEvents.length === 0)
        continue;
      const sortedEvents = [...metricEvents].sort((a2, b2) => a2.timestamp - b2.timestamp);
      const firstTimestamp = sortedEvents[0].timestamp;
      const lastEvent = sortedEvents[sortedEvents.length - 1];
      const lastEventDuration = lastEvent.attributes?.duration ?? 0;
      const lastEventEndTime = lastEvent.timestamp + lastEventDuration;
      const duration = lastEventEndTime - firstTimestamp;
      const timestamp = firstTimestamp;
      metricEventRollups[metricName] = {
        name: metricName,
        duration,
        timestamp
      };
    }
    return {
      ...flattenAttributes(reducedMetrics, SemanticInternalAttributes.METRIC_EVENTS),
      ...flattenAttributes(metricEventRollups, SemanticInternalAttributes.METRIC_EVENTS)
    };
  }
  setGlobalManager(manager) {
    return registerGlobal(API_NAME16, manager);
  }
  #getManager() {
    return getGlobal(API_NAME16) ?? NOOP_MANAGER3;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/run-timeline-metrics-api.js
var runTimelineMetrics = RunTimelineMetricsAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/lifecycle-hooks-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/lifecycleHooks/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/lifecycleHooks/manager.js
init_esm();
var NoopLifecycleHooksManager = class {
  static {
    __name(this, "NoopLifecycleHooksManager");
  }
  registerOnCancelHookListener(listener) {
  }
  async callOnCancelHookListeners() {
  }
  registerGlobalCancelHook(hook) {
  }
  registerTaskCancelHook(taskId, hook) {
  }
  getTaskCancelHook(taskId) {
    return void 0;
  }
  getGlobalCancelHooks() {
    return [];
  }
  registerOnWaitHookListener(listener) {
  }
  async callOnWaitHookListeners(wait2) {
  }
  registerOnResumeHookListener(listener) {
  }
  async callOnResumeHookListeners(wait2) {
  }
  registerGlobalInitHook(hook) {
  }
  registerTaskInitHook(taskId, hook) {
  }
  getTaskInitHook(taskId) {
    return void 0;
  }
  getGlobalInitHooks() {
    return [];
  }
  registerGlobalStartHook(hook) {
  }
  registerTaskStartHook(taskId, hook) {
  }
  getTaskStartHook(taskId) {
    return void 0;
  }
  getGlobalStartHooks() {
    return [];
  }
  registerGlobalStartAttemptHook() {
  }
  registerTaskStartAttemptHook() {
  }
  getTaskStartAttemptHook() {
    return void 0;
  }
  getGlobalStartAttemptHooks() {
    return [];
  }
  registerGlobalFailureHook(hook) {
  }
  registerTaskFailureHook(taskId, hook) {
  }
  getTaskFailureHook(taskId) {
    return void 0;
  }
  getGlobalFailureHooks() {
    return [];
  }
  registerGlobalSuccessHook(hook) {
  }
  registerTaskSuccessHook(taskId, hook) {
  }
  getTaskSuccessHook(taskId) {
    return void 0;
  }
  getGlobalSuccessHooks() {
    return [];
  }
  registerGlobalCompleteHook(hook) {
  }
  registerTaskCompleteHook(taskId, hook) {
  }
  getTaskCompleteHook(taskId) {
    return void 0;
  }
  getGlobalCompleteHooks() {
    return [];
  }
  registerGlobalWaitHook(hook) {
  }
  registerTaskWaitHook(taskId, hook) {
  }
  getTaskWaitHook(taskId) {
    return void 0;
  }
  getGlobalWaitHooks() {
    return [];
  }
  registerGlobalResumeHook(hook) {
  }
  registerTaskResumeHook(taskId, hook) {
  }
  getTaskResumeHook(taskId) {
    return void 0;
  }
  getGlobalResumeHooks() {
    return [];
  }
  registerGlobalCatchErrorHook() {
  }
  registerTaskCatchErrorHook() {
  }
  getTaskCatchErrorHook() {
    return void 0;
  }
  getGlobalCatchErrorHooks() {
    return [];
  }
  registerGlobalMiddlewareHook() {
  }
  registerTaskMiddlewareHook() {
  }
  getTaskMiddlewareHook() {
    return void 0;
  }
  getGlobalMiddlewareHooks() {
    return [];
  }
  registerGlobalCleanupHook(hook) {
  }
  registerTaskCleanupHook(taskId, hook) {
  }
  getTaskCleanupHook(taskId) {
    return void 0;
  }
  getGlobalCleanupHooks() {
    return [];
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/lifecycleHooks/index.js
var API_NAME17 = "lifecycle-hooks";
var NOOP_LIFECYCLE_HOOKS_MANAGER = new NoopLifecycleHooksManager();
var LifecycleHooksAPI = class _LifecycleHooksAPI {
  static {
    __name(this, "LifecycleHooksAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _LifecycleHooksAPI();
    }
    return this._instance;
  }
  setGlobalLifecycleHooksManager(lifecycleHooksManager) {
    return registerGlobal(API_NAME17, lifecycleHooksManager);
  }
  disable() {
    unregisterGlobal(API_NAME17);
  }
  registerGlobalInitHook(hook) {
    this.#getManager().registerGlobalInitHook(hook);
  }
  registerTaskInitHook(taskId, hook) {
    this.#getManager().registerTaskInitHook(taskId, hook);
  }
  getTaskInitHook(taskId) {
    return this.#getManager().getTaskInitHook(taskId);
  }
  getGlobalInitHooks() {
    return this.#getManager().getGlobalInitHooks();
  }
  registerTaskStartHook(taskId, hook) {
    this.#getManager().registerTaskStartHook(taskId, hook);
  }
  registerGlobalStartHook(hook) {
    this.#getManager().registerGlobalStartHook(hook);
  }
  getTaskStartHook(taskId) {
    return this.#getManager().getTaskStartHook(taskId);
  }
  getGlobalStartHooks() {
    return this.#getManager().getGlobalStartHooks();
  }
  registerTaskStartAttemptHook(taskId, hook) {
    this.#getManager().registerTaskStartAttemptHook(taskId, hook);
  }
  registerGlobalStartAttemptHook(hook) {
    this.#getManager().registerGlobalStartAttemptHook(hook);
  }
  getTaskStartAttemptHook(taskId) {
    return this.#getManager().getTaskStartAttemptHook(taskId);
  }
  getGlobalStartAttemptHooks() {
    return this.#getManager().getGlobalStartAttemptHooks();
  }
  registerGlobalFailureHook(hook) {
    this.#getManager().registerGlobalFailureHook(hook);
  }
  registerTaskFailureHook(taskId, hook) {
    this.#getManager().registerTaskFailureHook(taskId, hook);
  }
  getTaskFailureHook(taskId) {
    return this.#getManager().getTaskFailureHook(taskId);
  }
  getGlobalFailureHooks() {
    return this.#getManager().getGlobalFailureHooks();
  }
  registerGlobalSuccessHook(hook) {
    this.#getManager().registerGlobalSuccessHook(hook);
  }
  registerTaskSuccessHook(taskId, hook) {
    this.#getManager().registerTaskSuccessHook(taskId, hook);
  }
  getTaskSuccessHook(taskId) {
    return this.#getManager().getTaskSuccessHook(taskId);
  }
  getGlobalSuccessHooks() {
    return this.#getManager().getGlobalSuccessHooks();
  }
  registerGlobalCompleteHook(hook) {
    this.#getManager().registerGlobalCompleteHook(hook);
  }
  registerTaskCompleteHook(taskId, hook) {
    this.#getManager().registerTaskCompleteHook(taskId, hook);
  }
  getTaskCompleteHook(taskId) {
    return this.#getManager().getTaskCompleteHook(taskId);
  }
  getGlobalCompleteHooks() {
    return this.#getManager().getGlobalCompleteHooks();
  }
  registerGlobalWaitHook(hook) {
    this.#getManager().registerGlobalWaitHook(hook);
  }
  registerTaskWaitHook(taskId, hook) {
    this.#getManager().registerTaskWaitHook(taskId, hook);
  }
  getTaskWaitHook(taskId) {
    return this.#getManager().getTaskWaitHook(taskId);
  }
  getGlobalWaitHooks() {
    return this.#getManager().getGlobalWaitHooks();
  }
  registerGlobalResumeHook(hook) {
    this.#getManager().registerGlobalResumeHook(hook);
  }
  registerTaskResumeHook(taskId, hook) {
    this.#getManager().registerTaskResumeHook(taskId, hook);
  }
  getTaskResumeHook(taskId) {
    return this.#getManager().getTaskResumeHook(taskId);
  }
  getGlobalResumeHooks() {
    return this.#getManager().getGlobalResumeHooks();
  }
  registerGlobalCatchErrorHook(hook) {
    this.#getManager().registerGlobalCatchErrorHook(hook);
  }
  registerTaskCatchErrorHook(taskId, hook) {
    this.#getManager().registerTaskCatchErrorHook(taskId, hook);
  }
  getTaskCatchErrorHook(taskId) {
    return this.#getManager().getTaskCatchErrorHook(taskId);
  }
  getGlobalCatchErrorHooks() {
    return this.#getManager().getGlobalCatchErrorHooks();
  }
  registerGlobalMiddlewareHook(hook) {
    this.#getManager().registerGlobalMiddlewareHook(hook);
  }
  registerTaskMiddlewareHook(taskId, hook) {
    this.#getManager().registerTaskMiddlewareHook(taskId, hook);
  }
  getTaskMiddlewareHook(taskId) {
    return this.#getManager().getTaskMiddlewareHook(taskId);
  }
  getGlobalMiddlewareHooks() {
    return this.#getManager().getGlobalMiddlewareHooks();
  }
  registerGlobalCleanupHook(hook) {
    this.#getManager().registerGlobalCleanupHook(hook);
  }
  registerTaskCleanupHook(taskId, hook) {
    this.#getManager().registerTaskCleanupHook(taskId, hook);
  }
  getTaskCleanupHook(taskId) {
    return this.#getManager().getTaskCleanupHook(taskId);
  }
  getGlobalCleanupHooks() {
    return this.#getManager().getGlobalCleanupHooks();
  }
  callOnWaitHookListeners(wait2) {
    return this.#getManager().callOnWaitHookListeners(wait2);
  }
  callOnResumeHookListeners(wait2) {
    return this.#getManager().callOnResumeHookListeners(wait2);
  }
  registerOnWaitHookListener(listener) {
    this.#getManager().registerOnWaitHookListener(listener);
  }
  registerOnResumeHookListener(listener) {
    this.#getManager().registerOnResumeHookListener(listener);
  }
  registerGlobalCancelHook(hook) {
    this.#getManager().registerGlobalCancelHook(hook);
  }
  registerTaskCancelHook(taskId, hook) {
    this.#getManager().registerTaskCancelHook(taskId, hook);
  }
  getTaskCancelHook(taskId) {
    return this.#getManager().getTaskCancelHook(taskId);
  }
  getGlobalCancelHooks() {
    return this.#getManager().getGlobalCancelHooks();
  }
  callOnCancelHookListeners() {
    return this.#getManager().callOnCancelHookListeners();
  }
  registerOnCancelHookListener(listener) {
    this.#getManager().registerOnCancelHookListener(listener);
  }
  #getManager() {
    return getGlobal(API_NAME17) ?? NOOP_LIFECYCLE_HOOKS_MANAGER;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/lifecycle-hooks-api.js
var lifecycleHooks = LifecycleHooksAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/locals-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/locals/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/locals/manager.js
init_esm();
var NoopLocalsManager = class {
  static {
    __name(this, "NoopLocalsManager");
  }
  createLocal(id) {
    return {
      __type: Symbol(),
      id
    };
  }
  getLocal(key) {
    return void 0;
  }
  setLocal(key, value) {
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/locals/index.js
var API_NAME18 = "locals";
var NOOP_LOCALS_MANAGER = new NoopLocalsManager();
var LocalsAPI = class _LocalsAPI {
  static {
    __name(this, "LocalsAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _LocalsAPI();
    }
    return this._instance;
  }
  setGlobalLocalsManager(localsManager) {
    return registerGlobal(API_NAME18, localsManager);
  }
  disable() {
    unregisterGlobal(API_NAME18);
  }
  createLocal(id) {
    return this.#getManager().createLocal(id);
  }
  getLocal(key) {
    return this.#getManager().getLocal(key);
  }
  setLocal(key, value) {
    return this.#getManager().setLocal(key, value);
  }
  #getManager() {
    return getGlobal(API_NAME18) ?? NOOP_LOCALS_MANAGER;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/locals-api.js
var localsAPI = LocalsAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/heartbeats-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/heartbeats/api.js
init_esm();
var API_NAME19 = "heartbeats";
var NoopHeartbeatsManager = class {
  static {
    __name(this, "NoopHeartbeatsManager");
  }
  startHeartbeat(id) {
    return;
  }
  stopHeartbeat() {
    return;
  }
  async yield() {
    return;
  }
  get lastHeartbeat() {
    return void 0;
  }
  reset() {
  }
};
var NOOP_HEARTBEATS_MANAGER = new NoopHeartbeatsManager();
var HeartbeatsAPI = class _HeartbeatsAPI {
  static {
    __name(this, "HeartbeatsAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _HeartbeatsAPI();
    }
    return this._instance;
  }
  setGlobalManager(manager) {
    return registerGlobal(API_NAME19, manager);
  }
  disable() {
    unregisterGlobal(API_NAME19);
  }
  reset() {
    this.#getManager().reset();
    this.disable();
  }
  get lastHeartbeat() {
    return this.#getManager().lastHeartbeat;
  }
  startHeartbeat(id) {
    return this.#getManager().startHeartbeat(id);
  }
  stopHeartbeat() {
    return this.#getManager().stopHeartbeat();
  }
  yield() {
    return this.#getManager().yield();
  }
  #getManager() {
    return getGlobal(API_NAME19) ?? NOOP_HEARTBEATS_MANAGER;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/heartbeats-api.js
var heartbeats = HeartbeatsAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/realtime-streams-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/realtimeStreams/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/realtimeStreams/noopManager.js
init_esm();
var NoopRealtimeStreamsManager = class {
  static {
    __name(this, "NoopRealtimeStreamsManager");
  }
  pipe(key, source, options) {
    return {
      wait: /* @__PURE__ */ __name(() => Promise.resolve(), "wait"),
      get stream() {
        return createAsyncIterableStreamFromAsyncIterable(source);
      }
    };
  }
  async append(key, part, options) {
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/realtimeStreams/index.js
var API_NAME20 = "realtime-streams";
var NOOP_MANAGER4 = new NoopRealtimeStreamsManager();
var RealtimeStreamsAPI = class _RealtimeStreamsAPI {
  static {
    __name(this, "RealtimeStreamsAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _RealtimeStreamsAPI();
    }
    return this._instance;
  }
  setGlobalManager(manager) {
    return registerGlobal(API_NAME20, manager);
  }
  #getManager() {
    return getGlobal(API_NAME20) ?? NOOP_MANAGER4;
  }
  pipe(key, source, options) {
    return this.#getManager().pipe(key, source, options);
  }
  append(key, part, options) {
    return this.#getManager().append(key, part, options);
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/realtimeStreams/types.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/realtime-streams-api.js
var realtimeStreams = RealtimeStreamsAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/resource-catalog-api.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/resource-catalog/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/resource-catalog/noopResourceCatalog.js
init_esm();
var NoopResourceCatalog = class {
  static {
    __name(this, "NoopResourceCatalog");
  }
  registerTaskMetadata(task3) {
  }
  setCurrentFileContext(filePath, entryPoint) {
  }
  clearCurrentFileContext() {
  }
  updateTaskMetadata(id, updates) {
  }
  listTaskManifests() {
    return [];
  }
  getTaskManifest(id) {
    return void 0;
  }
  getTask(id) {
    return void 0;
  }
  getTaskSchema(id) {
    return void 0;
  }
  taskExists(id) {
    return false;
  }
  disable() {
  }
  registerWorkerManifest(workerManifest) {
  }
  registerQueueMetadata(queue2) {
  }
  listQueueManifests() {
    return [];
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/resource-catalog/index.js
var API_NAME21 = "resource-catalog";
var NOOP_RESOURCE_CATALOG = new NoopResourceCatalog();
var ResourceCatalogAPI = class _ResourceCatalogAPI {
  static {
    __name(this, "ResourceCatalogAPI");
  }
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new _ResourceCatalogAPI();
    }
    return this._instance;
  }
  setGlobalResourceCatalog(resourceCatalog2) {
    return registerGlobal(API_NAME21, resourceCatalog2);
  }
  disable() {
    unregisterGlobal(API_NAME21);
  }
  registerQueueMetadata(queue2) {
    this.#getCatalog().registerQueueMetadata(queue2);
  }
  registerTaskMetadata(task3) {
    this.#getCatalog().registerTaskMetadata(task3);
  }
  updateTaskMetadata(id, updates) {
    this.#getCatalog().updateTaskMetadata(id, updates);
  }
  setCurrentFileContext(filePath, entryPoint) {
    this.#getCatalog().setCurrentFileContext(filePath, entryPoint);
  }
  clearCurrentFileContext() {
    this.#getCatalog().clearCurrentFileContext();
  }
  registerWorkerManifest(workerManifest) {
    this.#getCatalog().registerWorkerManifest(workerManifest);
  }
  listTaskManifests() {
    return this.#getCatalog().listTaskManifests();
  }
  getTaskManifest(id) {
    return this.#getCatalog().getTaskManifest(id);
  }
  getTask(id) {
    return this.#getCatalog().getTask(id);
  }
  getTaskSchema(id) {
    return this.#getCatalog().getTaskSchema(id);
  }
  taskExists(id) {
    return this.#getCatalog().taskExists(id);
  }
  listQueueManifests() {
    return this.#getCatalog().listQueueManifests();
  }
  #getCatalog() {
    return getGlobal(API_NAME21) ?? NOOP_RESOURCE_CATALOG;
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/resource-catalog-api.js
var resourceCatalog = ResourceCatalogAPI.getInstance();

// node_modules/@trigger.dev/core/dist/esm/v3/types/index.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/types/utils.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/types/tasks.js
init_esm();
var SubtaskUnwrapError = class extends Error {
  static {
    __name(this, "SubtaskUnwrapError");
  }
  taskId;
  runId;
  cause;
  constructor(taskId, runId, subtaskError) {
    if (subtaskError instanceof Error) {
      super(`Error in ${taskId}: ${subtaskError.message}`);
      this.cause = subtaskError;
      this.name = "SubtaskUnwrapError";
    } else {
      super(`Error in ${taskId}`);
      this.name = "SubtaskUnwrapError";
      this.cause = subtaskError;
    }
    this.taskId = taskId;
    this.runId = runId;
  }
};
var TaskRunPromise = class extends Promise {
  static {
    __name(this, "TaskRunPromise");
  }
  taskId;
  constructor(executor, taskId) {
    super(executor);
    this.taskId = taskId;
  }
  unwrap() {
    return this.then((result) => {
      if (result.ok) {
        return result.output;
      } else {
        throw new SubtaskUnwrapError(this.taskId, result.id, result.error);
      }
    });
  }
};

// node_modules/@trigger.dev/core/dist/esm/v3/types/idempotencyKeys.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/types/tools.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/types/queues.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/types/jsonSchema.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/idempotencyKeys.js
init_esm();
function isIdempotencyKey(value) {
  return typeof value === "string" && value.length === 64;
}
__name(isIdempotencyKey, "isIdempotencyKey");
function flattenIdempotencyKey(idempotencyKey) {
  if (!idempotencyKey) {
    return;
  }
  if (Array.isArray(idempotencyKey)) {
    if (idempotencyKey.some((i2) => i2 === void 0)) {
      return;
    }
    return idempotencyKey.flatMap((key) => {
      const k = flattenIdempotencyKey(key);
      if (!k)
        return [];
      return [k];
    });
  }
  return idempotencyKey;
}
__name(flattenIdempotencyKey, "flattenIdempotencyKey");
async function makeIdempotencyKey(idempotencyKey) {
  if (!idempotencyKey) {
    return;
  }
  if (isIdempotencyKey(idempotencyKey)) {
    return idempotencyKey;
  }
  return await createIdempotencyKey(idempotencyKey, { scope: "global" });
}
__name(makeIdempotencyKey, "makeIdempotencyKey");
async function createIdempotencyKey(key, options) {
  const idempotencyKey = await generateIdempotencyKey([...Array.isArray(key) ? key : [key]].concat(injectScope(options?.scope ?? "run")));
  return idempotencyKey;
}
__name(createIdempotencyKey, "createIdempotencyKey");
function injectScope(scope) {
  switch (scope) {
    case "run": {
      if (taskContext?.ctx) {
        return [taskContext.ctx.run.id];
      }
      break;
    }
    case "attempt": {
      if (taskContext?.ctx) {
        return [taskContext.ctx.run.id, taskContext.ctx.attempt.number.toString()];
      }
      break;
    }
  }
  return [];
}
__name(injectScope, "injectScope");
async function generateIdempotencyKey(keyMaterial) {
  return await digestSHA256(keyMaterial.join("-"));
}
__name(generateIdempotencyKey, "generateIdempotencyKey");

// node_modules/@trigger.dev/core/dist/esm/v3/tryCatch.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/utils/durations.js
init_esm();
var import_humanize_duration = __toESM(require_humanize_duration(), 1);

// node_modules/@trigger.dev/core/dist/esm/eventFilterMatches.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/utils/omit.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/utils/imageRef.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/utils/interval.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/config.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/types/schemas.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/hooks.js
function onStart(fnOrName, fn) {
  lifecycleHooks.registerGlobalStartHook({
    id: typeof fnOrName === "string" ? fnOrName : fnOrName.name ? fnOrName.name : void 0,
    fn: typeof fnOrName === "function" ? fnOrName : fn
  });
}
__name(onStart, "onStart");
function onStartAttempt(fnOrName, fn) {
  lifecycleHooks.registerGlobalStartAttemptHook({
    id: typeof fnOrName === "string" ? fnOrName : fnOrName.name ? fnOrName.name : void 0,
    fn: typeof fnOrName === "function" ? fnOrName : fn
  });
}
__name(onStartAttempt, "onStartAttempt");
function onFailure(fnOrName, fn) {
  lifecycleHooks.registerGlobalFailureHook({
    id: typeof fnOrName === "string" ? fnOrName : fnOrName.name ? fnOrName.name : void 0,
    fn: typeof fnOrName === "function" ? fnOrName : fn
  });
}
__name(onFailure, "onFailure");
function onSuccess(fnOrName, fn) {
  lifecycleHooks.registerGlobalSuccessHook({
    id: typeof fnOrName === "string" ? fnOrName : fnOrName.name ? fnOrName.name : void 0,
    fn: typeof fnOrName === "function" ? fnOrName : fn
  });
}
__name(onSuccess, "onSuccess");
function onComplete(fnOrName, fn) {
  lifecycleHooks.registerGlobalCompleteHook({
    id: typeof fnOrName === "string" ? fnOrName : fnOrName.name ? fnOrName.name : void 0,
    fn: typeof fnOrName === "function" ? fnOrName : fn
  });
}
__name(onComplete, "onComplete");
function onWait(fnOrName, fn) {
  lifecycleHooks.registerGlobalWaitHook({
    id: typeof fnOrName === "string" ? fnOrName : fnOrName.name ? fnOrName.name : void 0,
    fn: typeof fnOrName === "function" ? fnOrName : fn
  });
}
__name(onWait, "onWait");
function onResume(fnOrName, fn) {
  lifecycleHooks.registerGlobalResumeHook({
    id: typeof fnOrName === "string" ? fnOrName : fnOrName.name ? fnOrName.name : void 0,
    fn: typeof fnOrName === "function" ? fnOrName : fn
  });
}
__name(onResume, "onResume");
function onHandleError(fnOrName, fn) {
  onCatchError(fnOrName, fn);
}
__name(onHandleError, "onHandleError");
function onCatchError(fnOrName, fn) {
  lifecycleHooks.registerGlobalCatchErrorHook({
    id: typeof fnOrName === "string" ? fnOrName : fnOrName.name ? fnOrName.name : void 0,
    fn: typeof fnOrName === "function" ? fnOrName : fn
  });
}
__name(onCatchError, "onCatchError");
function middleware(fnOrName, fn) {
  lifecycleHooks.registerGlobalMiddlewareHook({
    id: typeof fnOrName === "string" ? fnOrName : fnOrName.name ? fnOrName.name : void 0,
    fn: typeof fnOrName === "function" ? fnOrName : fn
  });
}
__name(middleware, "middleware");
function onCancel(fnOrName, fn) {
  lifecycleHooks.registerGlobalCancelHook({
    id: typeof fnOrName === "string" ? fnOrName : fnOrName.name ? fnOrName.name : void 0,
    fn: typeof fnOrName === "function" ? fnOrName : fn
  });
}
__name(onCancel, "onCancel");

// node_modules/@trigger.dev/sdk/dist/esm/v3/shared.js
init_esm();
init_esm2();

// node_modules/@trigger.dev/sdk/dist/esm/v3/tracer.js
init_esm();

// node_modules/@trigger.dev/core/dist/esm/v3/tracer.js
init_esm();
init_esm2();
var import_api_logs = __toESM(require_src3(), 1);

// node_modules/@trigger.dev/core/dist/esm/v3/otel/utils.js
init_esm();
init_esm2();
function recordSpanException(span, error) {
  if (error instanceof Error) {
    span.recordException(sanitizeSpanError(error));
  } else if (typeof error === "string") {
    span.recordException(error.replace(/\0/g, ""));
  } else {
    span.recordException(JSON.stringify(error).replace(/\0/g, ""));
  }
  span.setStatus({ code: SpanStatusCode.ERROR });
}
__name(recordSpanException, "recordSpanException");
function sanitizeSpanError(error) {
  const sanitizedError = new Error(error.message.replace(/\0/g, ""));
  sanitizedError.name = error.name.replace(/\0/g, "");
  sanitizedError.stack = error.stack?.replace(/\0/g, "");
  return sanitizedError;
}
__name(sanitizeSpanError, "sanitizeSpanError");

// node_modules/@trigger.dev/core/dist/esm/v3/tracer.js
var TriggerTracer = class {
  static {
    __name(this, "TriggerTracer");
  }
  _config;
  constructor(_config) {
    this._config = _config;
  }
  _tracer;
  get tracer() {
    if (!this._tracer) {
      if ("tracer" in this._config)
        return this._config.tracer;
      this._tracer = trace.getTracer(this._config.name, this._config.version);
    }
    return this._tracer;
  }
  _logger;
  get logger() {
    if (!this._logger) {
      if ("logger" in this._config)
        return this._config.logger;
      this._logger = import_api_logs.logs.getLogger(this._config.name, this._config.version);
    }
    return this._logger;
  }
  startActiveSpan(name2, fn, options, ctx, signal) {
    const parentContext = ctx ?? context.active();
    const attributes = options?.attributes ?? {};
    let spanEnded = false;
    const createPartialSpanWithEvents = options?.events && options.events.length > 0;
    return this.tracer.startActiveSpan(name2, {
      ...options,
      attributes: {
        ...attributes,
        ...createPartialSpanWithEvents ? {
          [SemanticInternalAttributes.SKIP_SPAN_PARTIAL]: true
        } : {}
      },
      startTime: clock.preciseNow()
    }, parentContext, async (span) => {
      signal?.addEventListener("abort", () => {
        if (!spanEnded) {
          spanEnded = true;
          recordSpanException(span, signal.reason);
          span.end();
        }
      });
      if (taskContext.ctx && createPartialSpanWithEvents) {
        const partialSpan = this.tracer.startSpan(name2, {
          ...options,
          attributes: {
            ...attributes,
            [SemanticInternalAttributes.SPAN_PARTIAL]: true,
            [SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId
          }
        }, parentContext);
        if (options?.events) {
          for (const event of options.events) {
            partialSpan.addEvent(event.name, event.attributes, event.startTime);
          }
        }
        partialSpan.end();
      }
      if (options?.events) {
        for (const event of options.events) {
          span.addEvent(event.name, event.attributes, event.startTime);
        }
      }
      const usageMeasurement = usage.start();
      try {
        return await fn(span);
      } catch (e) {
        if (isCompleteTaskWithOutput(e)) {
          if (!spanEnded) {
            span.end(clock.preciseNow());
          }
          throw e;
        }
        if (!spanEnded) {
          if (typeof e === "string" || e instanceof Error) {
            span.recordException(e);
          }
          span.setStatus({ code: SpanStatusCode.ERROR });
        }
        throw e;
      } finally {
        if (!spanEnded) {
          spanEnded = true;
          if (taskContext.ctx) {
            const usageSample = usage.stop(usageMeasurement);
            const machine = taskContext.ctx.machine;
            span.setAttributes({
              [SemanticInternalAttributes.USAGE_DURATION_MS]: usageSample.cpuTime,
              [SemanticInternalAttributes.USAGE_COST_IN_CENTS]: machine?.centsPerMs ? usageSample.cpuTime * machine.centsPerMs : 0
            });
          }
          span.end(clock.preciseNow());
        }
      }
    });
  }
  startSpan(name2, options, ctx) {
    const parentContext = ctx ?? context.active();
    const attributes = options?.attributes ?? {};
    const span = this.tracer.startSpan(name2, options, parentContext);
    return span;
  }
};

// node_modules/@trigger.dev/sdk/dist/esm/version.js
init_esm();
var VERSION3 = "4.1.2";

// node_modules/@trigger.dev/sdk/dist/esm/v3/tracer.js
var tracer = new TriggerTracer({ name: "@trigger.dev/sdk", version: VERSION3 });

// node_modules/@trigger.dev/sdk/dist/esm/v3/shared.js
function createTask(params) {
  const task3 = {
    id: params.id,
    description: params.description,
    jsonSchema: params.jsonSchema,
    trigger: /* @__PURE__ */ __name(async (payload, options) => {
      return await trigger_internal("trigger()", params.id, payload, void 0, {
        queue: params.queue?.name,
        ...options
      });
    }, "trigger"),
    batchTrigger: /* @__PURE__ */ __name(async (items, options) => {
      return await batchTrigger_internal("batchTrigger()", params.id, items, options, void 0, void 0, params.queue?.name);
    }, "batchTrigger"),
    triggerAndWait: /* @__PURE__ */ __name((payload, options, requestOptions) => {
      return new TaskRunPromise((resolve, reject) => {
        triggerAndWait_internal("triggerAndWait()", params.id, payload, void 0, {
          queue: params.queue?.name,
          ...options
        }, requestOptions).then((result) => {
          resolve(result);
        }).catch((error) => {
          reject(error);
        });
      }, params.id);
    }, "triggerAndWait"),
    batchTriggerAndWait: /* @__PURE__ */ __name(async (items, options) => {
      return await batchTriggerAndWait_internal("batchTriggerAndWait()", params.id, items, void 0, options, void 0, params.queue?.name);
    }, "batchTriggerAndWait")
  };
  registerTaskLifecycleHooks(params.id, params);
  resourceCatalog.registerTaskMetadata({
    id: params.id,
    description: params.description,
    queue: params.queue,
    retry: params.retry ? { ...defaultRetryOptions, ...params.retry } : void 0,
    machine: typeof params.machine === "string" ? { preset: params.machine } : params.machine,
    maxDuration: params.maxDuration,
    payloadSchema: params.jsonSchema,
    fns: {
      run: params.run
    }
  });
  const queue2 = params.queue;
  if (queue2 && typeof queue2.name === "string") {
    resourceCatalog.registerQueueMetadata({
      name: queue2.name,
      concurrencyLimit: queue2.concurrencyLimit
    });
  }
  task3[Symbol.for("trigger.dev/task")] = true;
  return task3;
}
__name(createTask, "createTask");
async function trigger(id, payload, options, requestOptions) {
  return await trigger_internal("tasks.trigger()", id, payload, void 0, options, requestOptions);
}
__name(trigger, "trigger");
function triggerAndWait(id, payload, options, requestOptions) {
  return new TaskRunPromise((resolve, reject) => {
    triggerAndWait_internal("tasks.triggerAndWait()", id, payload, void 0, options, requestOptions).then((result) => {
      resolve(result);
    }).catch((error) => {
      reject(error);
    });
  }, id);
}
__name(triggerAndWait, "triggerAndWait");
async function batchTriggerAndWait(id, items, options, requestOptions) {
  return await batchTriggerAndWait_internal("tasks.batchTriggerAndWait()", id, items, void 0, options, requestOptions);
}
__name(batchTriggerAndWait, "batchTriggerAndWait");
async function batchTrigger(id, items, options, requestOptions) {
  return await batchTrigger_internal("tasks.batchTrigger()", id, items, options, void 0, requestOptions);
}
__name(batchTrigger, "batchTrigger");
async function trigger_internal(name2, id, payload, parsePayload, options, requestOptions) {
  const apiClient = apiClientManager.clientOrThrow(requestOptions?.clientConfig);
  const parsedPayload = parsePayload ? await parsePayload(payload) : payload;
  const payloadPacket = await stringifyIO(parsedPayload);
  const handle = await apiClient.triggerTask(id, {
    payload: payloadPacket.data,
    options: {
      queue: options?.queue ? { name: options.queue } : void 0,
      concurrencyKey: options?.concurrencyKey,
      test: taskContext.ctx?.run.isTest,
      payloadType: payloadPacket.dataType,
      idempotencyKey: await makeIdempotencyKey(options?.idempotencyKey),
      idempotencyKeyTTL: options?.idempotencyKeyTTL,
      delay: options?.delay,
      ttl: options?.ttl,
      tags: options?.tags,
      maxAttempts: options?.maxAttempts,
      metadata: options?.metadata,
      maxDuration: options?.maxDuration,
      parentRunId: taskContext.ctx?.run.id,
      machine: options?.machine,
      priority: options?.priority,
      region: options?.region,
      lockToVersion: options?.version ?? getEnvVar("TRIGGER_VERSION")
    }
  }, {
    spanParentAsLink: true
  }, {
    name: name2,
    tracer,
    icon: "trigger",
    onResponseBody: /* @__PURE__ */ __name((body, span) => {
      if (body && typeof body === "object" && !Array.isArray(body)) {
        if ("id" in body && typeof body.id === "string") {
          span.setAttribute("runId", body.id);
        }
      }
    }, "onResponseBody"),
    ...requestOptions
  });
  return handle;
}
__name(trigger_internal, "trigger_internal");
async function batchTrigger_internal(name2, taskIdentifier, items, options, parsePayload, requestOptions, queue2) {
  const apiClient = apiClientManager.clientOrThrow(requestOptions?.clientConfig);
  const ctx = taskContext.ctx;
  const response = await apiClient.batchTriggerV3({
    items: await Promise.all(items.map(async (item, index) => {
      const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;
      const payloadPacket = await stringifyIO(parsedPayload);
      const batchItemIdempotencyKey = await makeIdempotencyKey(flattenIdempotencyKey([options?.idempotencyKey, `${index}`]));
      return {
        task: taskIdentifier,
        payload: payloadPacket.data,
        options: {
          queue: item.options?.queue ? { name: item.options.queue } : queue2 ? { name: queue2 } : void 0,
          concurrencyKey: item.options?.concurrencyKey,
          test: taskContext.ctx?.run.isTest,
          payloadType: payloadPacket.dataType,
          delay: item.options?.delay,
          ttl: item.options?.ttl,
          tags: item.options?.tags,
          maxAttempts: item.options?.maxAttempts,
          metadata: item.options?.metadata,
          maxDuration: item.options?.maxDuration,
          idempotencyKey: await makeIdempotencyKey(item.options?.idempotencyKey) ?? batchItemIdempotencyKey,
          idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
          machine: item.options?.machine,
          priority: item.options?.priority,
          region: item.options?.region,
          lockToVersion: item.options?.version ?? getEnvVar("TRIGGER_VERSION")
        }
      };
    })),
    parentRunId: ctx?.run.id
  }, {
    spanParentAsLink: true,
    processingStrategy: options?.triggerSequentially ? "sequential" : void 0
  }, {
    name: name2,
    tracer,
    icon: "trigger",
    onResponseBody(body, span) {
      if (body && typeof body === "object" && !Array.isArray(body)) {
        if ("id" in body && typeof body.id === "string") {
          span.setAttribute("batchId", body.id);
        }
        if ("runCount" in body && Array.isArray(body.runCount)) {
          span.setAttribute("runCount", body.runCount);
        }
      }
    },
    ...requestOptions
  });
  const handle = {
    batchId: response.id,
    runCount: response.runCount,
    publicAccessToken: response.publicAccessToken
  };
  return handle;
}
__name(batchTrigger_internal, "batchTrigger_internal");
async function triggerAndWait_internal(name2, id, payload, parsePayload, options, requestOptions) {
  const ctx = taskContext.ctx;
  if (!ctx) {
    throw new Error("triggerAndWait can only be used from inside a task.run()");
  }
  const apiClient = apiClientManager.clientOrThrow(requestOptions?.clientConfig);
  const parsedPayload = parsePayload ? await parsePayload(payload) : payload;
  const payloadPacket = await stringifyIO(parsedPayload);
  return await tracer.startActiveSpan(name2, async (span) => {
    const response = await apiClient.triggerTask(id, {
      payload: payloadPacket.data,
      options: {
        lockToVersion: taskContext.worker?.version,
        // Lock to current version because we're waiting for it to finish
        queue: options?.queue ? { name: options.queue } : void 0,
        concurrencyKey: options?.concurrencyKey,
        test: taskContext.ctx?.run.isTest,
        payloadType: payloadPacket.dataType,
        delay: options?.delay,
        ttl: options?.ttl,
        tags: options?.tags,
        maxAttempts: options?.maxAttempts,
        metadata: options?.metadata,
        maxDuration: options?.maxDuration,
        resumeParentOnCompletion: true,
        parentRunId: ctx.run.id,
        idempotencyKey: await makeIdempotencyKey(options?.idempotencyKey),
        idempotencyKeyTTL: options?.idempotencyKeyTTL,
        machine: options?.machine,
        priority: options?.priority,
        region: options?.region
      }
    }, {}, requestOptions);
    span.setAttribute("runId", response.id);
    const result = await runtime.waitForTask({
      id: response.id,
      ctx
    });
    return await handleTaskRunExecutionResult(result, id);
  }, {
    kind: SpanKind.PRODUCER,
    attributes: {
      [SemanticInternalAttributes.STYLE_ICON]: "trigger",
      ...accessoryAttributes({
        items: [
          {
            text: id,
            variant: "normal"
          }
        ],
        style: "codepath"
      })
    }
  });
}
__name(triggerAndWait_internal, "triggerAndWait_internal");
async function batchTriggerAndWait_internal(name2, id, items, parsePayload, options, requestOptions, queue2) {
  const ctx = taskContext.ctx;
  if (!ctx) {
    throw new Error("batchTriggerAndWait can only be used from inside a task.run()");
  }
  const apiClient = apiClientManager.clientOrThrow(requestOptions?.clientConfig);
  return await tracer.startActiveSpan(name2, async (span) => {
    const response = await apiClient.batchTriggerV3({
      items: await Promise.all(items.map(async (item, index) => {
        const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;
        const payloadPacket = await stringifyIO(parsedPayload);
        const batchItemIdempotencyKey = await makeIdempotencyKey(flattenIdempotencyKey([options?.idempotencyKey, `${index}`]));
        return {
          task: id,
          payload: payloadPacket.data,
          options: {
            lockToVersion: taskContext.worker?.version,
            queue: item.options?.queue ? { name: item.options.queue } : queue2 ? { name: queue2 } : void 0,
            concurrencyKey: item.options?.concurrencyKey,
            test: taskContext.ctx?.run.isTest,
            payloadType: payloadPacket.dataType,
            delay: item.options?.delay,
            ttl: item.options?.ttl,
            tags: item.options?.tags,
            maxAttempts: item.options?.maxAttempts,
            metadata: item.options?.metadata,
            maxDuration: item.options?.maxDuration,
            idempotencyKey: await makeIdempotencyKey(item.options?.idempotencyKey) ?? batchItemIdempotencyKey,
            idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
            machine: item.options?.machine,
            priority: item.options?.priority,
            region: item.options?.region
          }
        };
      })),
      resumeParentOnCompletion: true,
      parentRunId: ctx.run.id
    }, {
      processingStrategy: options?.triggerSequentially ? "sequential" : void 0
    }, requestOptions);
    span.setAttribute("batchId", response.id);
    span.setAttribute("runCount", response.runCount);
    const result = await runtime.waitForBatch({
      id: response.id,
      runCount: response.runCount,
      ctx
    });
    const runs2 = await handleBatchTaskRunExecutionResult(result.items, id);
    return {
      id: result.id,
      runs: runs2
    };
  }, {
    kind: SpanKind.PRODUCER,
    attributes: {
      [SemanticInternalAttributes.STYLE_ICON]: "trigger",
      ...accessoryAttributes({
        items: [
          {
            text: id,
            variant: "normal"
          }
        ],
        style: "codepath"
      })
    }
  });
}
__name(batchTriggerAndWait_internal, "batchTriggerAndWait_internal");
async function handleBatchTaskRunExecutionResult(items, taskIdentifier) {
  const someObjectStoreOutputs = items.some((item) => item.ok && item.outputType === "application/store");
  if (!someObjectStoreOutputs) {
    const results = await Promise.all(items.map(async (item) => {
      return await handleTaskRunExecutionResult(item, taskIdentifier);
    }));
    return results;
  }
  return await tracer.startActiveSpan("store.downloadPayloads", async (span) => {
    const results = await Promise.all(items.map(async (item) => {
      return await handleTaskRunExecutionResult(item, taskIdentifier);
    }));
    return results;
  }, {
    kind: SpanKind.INTERNAL,
    [SemanticInternalAttributes.STYLE_ICON]: "cloud-download"
  });
}
__name(handleBatchTaskRunExecutionResult, "handleBatchTaskRunExecutionResult");
async function handleTaskRunExecutionResult(execution, taskIdentifier) {
  if (execution.ok) {
    const outputPacket = { data: execution.output, dataType: execution.outputType };
    const importedPacket = await conditionallyImportPacket(outputPacket, tracer);
    return {
      ok: true,
      id: execution.id,
      taskIdentifier: execution.taskIdentifier ?? taskIdentifier,
      output: await parsePacket(importedPacket)
    };
  } else {
    return {
      ok: false,
      id: execution.id,
      taskIdentifier: execution.taskIdentifier ?? taskIdentifier,
      error: createErrorTaskError(execution.error)
    };
  }
}
__name(handleTaskRunExecutionResult, "handleTaskRunExecutionResult");
function registerTaskLifecycleHooks(taskId, params) {
  if (params.init) {
    lifecycleHooks.registerTaskInitHook(taskId, {
      fn: params.init
    });
  }
  if (params.onStart) {
    lifecycleHooks.registerTaskStartHook(taskId, {
      fn: params.onStart
    });
  }
  if (params.onStartAttempt) {
    lifecycleHooks.registerTaskStartAttemptHook(taskId, {
      fn: params.onStartAttempt
    });
  }
  if (params.onFailure) {
    lifecycleHooks.registerTaskFailureHook(taskId, {
      fn: params.onFailure
    });
  }
  if (params.onSuccess) {
    lifecycleHooks.registerTaskSuccessHook(taskId, {
      fn: params.onSuccess
    });
  }
  if (params.onComplete) {
    lifecycleHooks.registerTaskCompleteHook(taskId, {
      fn: params.onComplete
    });
  }
  if (params.onWait) {
    lifecycleHooks.registerTaskWaitHook(taskId, {
      fn: params.onWait
    });
  }
  if (params.onResume) {
    lifecycleHooks.registerTaskResumeHook(taskId, {
      fn: params.onResume
    });
  }
  if (params.catchError) {
    lifecycleHooks.registerTaskCatchErrorHook(taskId, {
      fn: params.catchError
    });
  }
  if (params.handleError) {
    lifecycleHooks.registerTaskCatchErrorHook(taskId, {
      fn: params.handleError
    });
  }
  if (params.middleware) {
    lifecycleHooks.registerTaskMiddlewareHook(taskId, {
      fn: params.middleware
    });
  }
  if (params.cleanup) {
    lifecycleHooks.registerTaskCleanupHook(taskId, {
      fn: params.cleanup
    });
  }
  if (params.onCancel) {
    lifecycleHooks.registerTaskCancelHook(taskId, {
      fn: params.onCancel
    });
  }
}
__name(registerTaskLifecycleHooks, "registerTaskLifecycleHooks");

// node_modules/@trigger.dev/sdk/dist/esm/v3/tasks.js
var task = createTask;
var tasks = {
  trigger,
  batchTrigger,
  triggerAndWait,
  batchTriggerAndWait,
  /** @deprecated Use onStartAttempt instead */
  onStart,
  onStartAttempt,
  onFailure,
  onSuccess,
  onComplete,
  onWait,
  onResume,
  onCancel,
  /** @deprecated Use catchError instead */
  handleError: onHandleError,
  catchError: onCatchError,
  middleware
};

// node_modules/@trigger.dev/sdk/dist/esm/v3/schedules/index.js
var schedules_exports = {};
__export(schedules_exports, {
  activate: () => activate,
  create: () => create,
  deactivate: () => deactivate,
  del: () => del,
  list: () => list,
  retrieve: () => retrieve,
  task: () => task2,
  timezones: () => timezones,
  update: () => update
});
init_esm();
function task2(params) {
  const task3 = createTask(params);
  const cron = params.cron ? typeof params.cron === "string" ? params.cron : params.cron.pattern : void 0;
  const timezone = (params.cron && typeof params.cron !== "string" ? params.cron.timezone : "UTC") ?? "UTC";
  const environments = params.cron && typeof params.cron !== "string" ? params.cron.environments : void 0;
  resourceCatalog.updateTaskMetadata(task3.id, {
    triggerSource: "schedule",
    schedule: cron ? {
      cron,
      timezone,
      environments
    } : void 0
  });
  return task3;
}
__name(task2, "task");
function create(options, requestOptions) {
  const apiClient = apiClientManager.clientOrThrow();
  const $requestOptions = mergeRequestOptions({
    tracer,
    name: "schedules.create()",
    icon: "clock",
    attributes: {
      ...accessoryAttributes({
        items: [
          {
            text: options.cron,
            variant: "normal"
          }
        ],
        style: "codepath"
      })
    }
  }, requestOptions);
  return apiClient.createSchedule(options, $requestOptions);
}
__name(create, "create");
function retrieve(scheduleId, requestOptions) {
  const apiClient = apiClientManager.clientOrThrow();
  const $requestOptions = mergeRequestOptions({
    tracer,
    name: "schedules.retrieve()",
    icon: "clock",
    attributes: {
      scheduleId,
      ...accessoryAttributes({
        items: [
          {
            text: scheduleId,
            variant: "normal"
          }
        ],
        style: "codepath"
      })
    }
  }, requestOptions);
  return apiClient.retrieveSchedule(scheduleId, $requestOptions);
}
__name(retrieve, "retrieve");
function update(scheduleId, options, requestOptions) {
  const apiClient = apiClientManager.clientOrThrow();
  const $requestOptions = mergeRequestOptions({
    tracer,
    name: "schedules.update()",
    icon: "clock",
    attributes: {
      scheduleId,
      ...accessoryAttributes({
        items: [
          {
            text: scheduleId,
            variant: "normal"
          }
        ],
        style: "codepath"
      })
    }
  }, requestOptions);
  return apiClient.updateSchedule(scheduleId, options, $requestOptions);
}
__name(update, "update");
function del(scheduleId, requestOptions) {
  const apiClient = apiClientManager.clientOrThrow();
  const $requestOptions = mergeRequestOptions({
    tracer,
    name: "schedules.delete()",
    icon: "clock",
    attributes: {
      scheduleId,
      ...accessoryAttributes({
        items: [
          {
            text: scheduleId,
            variant: "normal"
          }
        ],
        style: "codepath"
      })
    }
  }, requestOptions);
  return apiClient.deleteSchedule(scheduleId, $requestOptions);
}
__name(del, "del");
function deactivate(scheduleId, requestOptions) {
  const apiClient = apiClientManager.clientOrThrow();
  const $requestOptions = mergeRequestOptions({
    tracer,
    name: "schedules.deactivate()",
    icon: "clock",
    attributes: {
      scheduleId,
      ...accessoryAttributes({
        items: [
          {
            text: scheduleId,
            variant: "normal"
          }
        ],
        style: "codepath"
      })
    }
  }, requestOptions);
  return apiClient.deactivateSchedule(scheduleId, $requestOptions);
}
__name(deactivate, "deactivate");
function activate(scheduleId, requestOptions) {
  const apiClient = apiClientManager.clientOrThrow();
  const $requestOptions = mergeRequestOptions({
    tracer,
    name: "schedules.activate()",
    icon: "clock",
    attributes: {
      scheduleId,
      ...accessoryAttributes({
        items: [
          {
            text: scheduleId,
            variant: "normal"
          }
        ],
        style: "codepath"
      })
    }
  }, requestOptions);
  return apiClient.activateSchedule(scheduleId, $requestOptions);
}
__name(activate, "activate");
function list(options, requestOptions) {
  const apiClient = apiClientManager.clientOrThrow();
  const $requestOptions = mergeRequestOptions({
    tracer,
    name: "schedules.list()",
    icon: "clock"
  }, requestOptions);
  return apiClient.listSchedules(options, $requestOptions);
}
__name(list, "list");
function timezones(options) {
  const baseUrl = apiClientManager.baseURL;
  return zodfetch(TimezonesResult, `${baseUrl}/api/v1/timezones${options?.excludeUtc === true ? "?excludeUtc=true" : ""}`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json"
    }
  });
}
__name(timezones, "timezones");

// node_modules/@trigger.dev/sdk/dist/esm/v3/index.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/cache.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/config.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/retry.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/wait.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/batch.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/waitUntil.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/usage.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/idempotencyKeys.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/tags.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/metadata.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/streams.js
init_esm();
init_esm2();
var DEFAULT_STREAM_KEY = "default";
function pipe(keyOrValue, valueOrOptions, options) {
  let key;
  let value;
  let opts;
  if (typeof keyOrValue === "string") {
    key = keyOrValue;
    value = valueOrOptions;
    opts = options;
  } else {
    key = DEFAULT_STREAM_KEY;
    value = keyOrValue;
    opts = valueOrOptions;
  }
  return pipeInternal(key, value, opts, "streams.pipe()");
}
__name(pipe, "pipe");
function pipeInternal(key, value, opts, spanName) {
  const runId = getRunIdForOptions(opts);
  if (!runId) {
    throw new Error("Could not determine the target run ID for the realtime stream. Please specify a target run ID using the `target` option or use this function from inside a task.");
  }
  const span = tracer.startSpan(spanName, {
    attributes: {
      key,
      runId,
      [SemanticInternalAttributes.ENTITY_TYPE]: "realtime-stream",
      [SemanticInternalAttributes.ENTITY_ID]: `${runId}:${key}`,
      [SemanticInternalAttributes.STYLE_ICON]: "streams",
      ...accessoryAttributes({
        items: [
          {
            text: key,
            variant: "normal"
          }
        ],
        style: "codepath"
      })
    }
  });
  const requestOptions = mergeRequestOptions({}, opts?.requestOptions);
  try {
    const instance = realtimeStreams.pipe(key, value, {
      signal: opts?.signal,
      target: runId,
      requestOptions
    });
    instance.wait().finally(() => {
      span.end();
    });
    return {
      stream: instance.stream,
      waitUntilComplete: /* @__PURE__ */ __name(() => instance.wait(), "waitUntilComplete")
    };
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") {
      span.end();
      throw error;
    }
    if (error instanceof Error || typeof error === "string") {
      span.recordException(error);
    } else {
      span.recordException(String(error));
    }
    span.setStatus({ code: SpanStatusCode.ERROR });
    span.end();
    throw error;
  }
}
__name(pipeInternal, "pipeInternal");
async function read(runId, keyOrOptions, options) {
  let key;
  let opts;
  if (typeof keyOrOptions === "string") {
    key = keyOrOptions;
    opts = options;
  } else {
    key = DEFAULT_STREAM_KEY;
    opts = keyOrOptions;
  }
  return readStreamImpl(runId, key, opts);
}
__name(read, "read");
async function readStreamImpl(runId, key, options) {
  const apiClient = apiClientManager.clientOrThrow();
  const span = tracer.startSpan("streams.read()", {
    attributes: {
      key,
      runId,
      [SemanticInternalAttributes.ENTITY_TYPE]: "realtime-stream",
      [SemanticInternalAttributes.ENTITY_ID]: `${runId}:${key}`,
      [SemanticInternalAttributes.ENTITY_METADATA]: JSON.stringify({
        startIndex: options?.startIndex
      }),
      [SemanticInternalAttributes.STYLE_ICON]: "streams",
      ...accessoryAttributes({
        items: [
          {
            text: key,
            variant: "normal"
          }
        ],
        style: "codepath"
      })
    }
  });
  return await apiClient.fetchStream(runId, key, {
    signal: options?.signal,
    timeoutInSeconds: options?.timeoutInSeconds ?? 60,
    lastEventId: options?.startIndex ? (options.startIndex - 1).toString() : void 0,
    onComplete: /* @__PURE__ */ __name(() => {
      span.end();
    }, "onComplete"),
    onError: /* @__PURE__ */ __name((error) => {
      span.recordException(error);
      span.setStatus({ code: SpanStatusCode.ERROR });
      span.end();
    }, "onError")
  });
}
__name(readStreamImpl, "readStreamImpl");
function append(keyOrValue, valueOrOptions, options) {
  if (typeof keyOrValue === "string" && typeof valueOrOptions === "string") {
    return appendInternal(keyOrValue, valueOrOptions, options);
  }
  if (typeof keyOrValue === "string") {
    if (isAppendStreamOptions(valueOrOptions)) {
      return appendInternal(DEFAULT_STREAM_KEY, keyOrValue, valueOrOptions);
    } else {
      if (!valueOrOptions) {
        return appendInternal(DEFAULT_STREAM_KEY, keyOrValue, options);
      }
      return appendInternal(keyOrValue, valueOrOptions, options);
    }
  } else {
    if (isAppendStreamOptions(valueOrOptions)) {
      return appendInternal(DEFAULT_STREAM_KEY, keyOrValue, valueOrOptions);
    } else {
      return appendInternal(DEFAULT_STREAM_KEY, keyOrValue, options);
    }
  }
}
__name(append, "append");
async function appendInternal(key, part, options) {
  const runId = getRunIdForOptions(options);
  if (!runId) {
    throw new Error("Could not determine the target run ID for the realtime stream. Please specify a target run ID using the `target` option or use this function from inside a task.");
  }
  const span = tracer.startSpan("streams.append()", {
    attributes: {
      key,
      runId,
      [SemanticInternalAttributes.ENTITY_TYPE]: "realtime-stream",
      [SemanticInternalAttributes.ENTITY_ID]: `${runId}:${key}`,
      [SemanticInternalAttributes.STYLE_ICON]: "streams",
      ...accessoryAttributes({
        items: [
          {
            text: key,
            variant: "normal"
          }
        ],
        style: "codepath"
      })
    }
  });
  try {
    await realtimeStreams.append(key, part, options);
    span.end();
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") {
      span.end();
      throw error;
    }
    if (error instanceof Error || typeof error === "string") {
      span.recordException(error);
    } else {
      span.recordException(String(error));
    }
    span.setStatus({ code: SpanStatusCode.ERROR });
    span.end();
    throw error;
  }
}
__name(appendInternal, "appendInternal");
function isAppendStreamOptions(val) {
  return typeof val === "object" && val !== null && !Array.isArray(val) && ("target" in val && typeof val.target === "string" || "requestOptions" in val && typeof val.requestOptions === "object");
}
__name(isAppendStreamOptions, "isAppendStreamOptions");
function writer(keyOrOptions, valueOrOptions) {
  if (typeof keyOrOptions === "string") {
    return writerInternal(keyOrOptions, valueOrOptions);
  }
  return writerInternal(DEFAULT_STREAM_KEY, keyOrOptions);
}
__name(writer, "writer");
function writerInternal(key, options) {
  let controller;
  const ongoingStreamPromises = [];
  const stream2 = new ReadableStream({
    start(controllerArg) {
      controller = controllerArg;
    }
  });
  function safeEnqueue(data) {
    try {
      controller.enqueue(data);
    } catch (error) {
    }
  }
  __name(safeEnqueue, "safeEnqueue");
  try {
    const result = options.execute({
      write(part) {
        safeEnqueue(part);
      },
      merge(streamArg) {
        ongoingStreamPromises.push((async () => {
          const reader = streamArg.getReader();
          while (true) {
            const { done, value } = await reader.read();
            if (done)
              break;
            safeEnqueue(value);
          }
        })().catch((error) => {
          console.error(error);
        }));
      }
    });
    if (result) {
      ongoingStreamPromises.push(result.catch((error) => {
        console.error(error);
      }));
    }
  } catch (error) {
    console.error(error);
  }
  const waitForStreams = new Promise((resolve, reject) => {
    (async () => {
      while (ongoingStreamPromises.length > 0) {
        await ongoingStreamPromises.shift();
      }
      resolve();
    })().catch(reject);
  });
  waitForStreams.finally(() => {
    try {
      controller.close();
    } catch (error) {
    }
  });
  return pipeInternal(key, stream2, options, "streams.writer()");
}
__name(writerInternal, "writerInternal");
function define2(opts) {
  return {
    id: opts.id,
    pipe(value, options) {
      return pipe(opts.id, value, options);
    },
    read(runId, options) {
      return read(runId, opts.id, options);
    },
    append(value, options) {
      return append(opts.id, value, options);
    },
    writer(options) {
      return writer(opts.id, options);
    }
  };
}
__name(define2, "define");
var streams = {
  pipe,
  read,
  append,
  writer,
  define: define2
};
function getRunIdForOptions(options) {
  if (options?.target) {
    if (options.target === "parent") {
      return taskContext.ctx?.run?.parentTaskRunId;
    }
    if (options.target === "root") {
      return taskContext.ctx?.run?.rootTaskRunId;
    }
    if (options.target === "self") {
      return taskContext.ctx?.run?.id;
    }
    return options.target;
  }
  return taskContext.ctx?.run?.id;
}
__name(getRunIdForOptions, "getRunIdForOptions");

// node_modules/@trigger.dev/sdk/dist/esm/v3/metadata.js
var parentMetadataUpdater = runMetadata.parent;
var rootMetadataUpdater = runMetadata.root;
var metadataUpdater = {
  set: setMetadataKey,
  del: deleteMetadataKey,
  append: appendMetadataKey,
  remove: removeMetadataKey,
  increment: incrementMetadataKey,
  decrement: decrementMetadataKey,
  flush: flushMetadata
};
var metadata = {
  current: currentMetadata,
  get: getMetadataKey,
  save: saveMetadata,
  replace: replaceMetadata,
  stream,
  fetchStream,
  parent: parentMetadataUpdater,
  root: rootMetadataUpdater,
  refresh: refreshMetadata,
  ...metadataUpdater
};
function currentMetadata() {
  return runMetadata.current();
}
__name(currentMetadata, "currentMetadata");
function getMetadataKey(key) {
  return runMetadata.getKey(key);
}
__name(getMetadataKey, "getMetadataKey");
function setMetadataKey(key, value) {
  runMetadata.set(key, value);
  return metadataUpdater;
}
__name(setMetadataKey, "setMetadataKey");
function deleteMetadataKey(key) {
  runMetadata.del(key);
  return metadataUpdater;
}
__name(deleteMetadataKey, "deleteMetadataKey");
function replaceMetadata(metadata2) {
  runMetadata.update(metadata2);
}
__name(replaceMetadata, "replaceMetadata");
function saveMetadata(metadata2) {
  runMetadata.update(metadata2);
}
__name(saveMetadata, "saveMetadata");
function incrementMetadataKey(key, value = 1) {
  runMetadata.increment(key, value);
  return metadataUpdater;
}
__name(incrementMetadataKey, "incrementMetadataKey");
function decrementMetadataKey(key, value = 1) {
  runMetadata.decrement(key, value);
  return metadataUpdater;
}
__name(decrementMetadataKey, "decrementMetadataKey");
function appendMetadataKey(key, value) {
  runMetadata.append(key, value);
  return metadataUpdater;
}
__name(appendMetadataKey, "appendMetadataKey");
function removeMetadataKey(key, value) {
  runMetadata.remove(key, value);
  return metadataUpdater;
}
__name(removeMetadataKey, "removeMetadataKey");
async function flushMetadata(requestOptions) {
  const $requestOptions = mergeRequestOptions({
    tracer,
    name: "metadata.flush()",
    icon: "code-plus"
  }, requestOptions);
  await runMetadata.flush($requestOptions);
}
__name(flushMetadata, "flushMetadata");
async function refreshMetadata(requestOptions) {
  const $requestOptions = mergeRequestOptions({
    tracer,
    name: "metadata.refresh()",
    icon: "code-plus"
  }, requestOptions);
  await runMetadata.refresh($requestOptions);
}
__name(refreshMetadata, "refreshMetadata");
async function stream(key, value, signal) {
  const streamInstance = await streams.pipe(key, value, {
    signal
  });
  return streamInstance.stream;
}
__name(stream, "stream");
async function fetchStream(key, signal) {
  return runMetadata.fetchStream(key, signal);
}
__name(fetchStream, "fetchStream");

// node_modules/@trigger.dev/sdk/dist/esm/v3/timeout.js
init_esm();
var MAXIMUM_MAX_DURATION = 2147483647;
var timeout2 = {
  None: MAXIMUM_MAX_DURATION,
  signal: timeout.signal
};

// node_modules/@trigger.dev/sdk/dist/esm/v3/webhooks.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/imports/uncrypto.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/locals.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/otel.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/schemas.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/heartbeats.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/runs.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/envvars.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/queues.js
init_esm();

// node_modules/@trigger.dev/sdk/dist/esm/v3/auth.js
init_esm();

// src/lib/prisma.ts
init_esm();
var import_client2 = __toESM(require_default2());
var databaseUrl = process.env.DATABASE_URL;
var prismaClientSingleton = /* @__PURE__ */ __name(() => {
  return new import_client2.PrismaClient({
    log: ["error", "warn"],
    datasources: {
      db: {
        url: databaseUrl
      }
    }
  });
}, "prismaClientSingleton");
var prisma = globalThis.prisma ?? prismaClientSingleton();
globalThis.prisma = prisma;

export {
  task,
  tasks,
  schedules_exports,
  prisma
};
/*! Bundled license information:

@google-cloud/precise-date/build/src/index.js:
  (*!
   * Copyright 2019 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@prisma/client/runtime/binary.js:
  (*! Bundled license information:
  
  undici/lib/web/fetch/body.js:
    (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  
  undici/lib/web/websocket/frame.js:
    (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.5.0
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  *)
*/
//# sourceMappingURL=chunk-Y7OMAXU5.mjs.map
