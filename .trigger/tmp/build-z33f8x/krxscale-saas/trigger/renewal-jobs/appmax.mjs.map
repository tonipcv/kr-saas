{
  "version": 3,
  "sources": ["../../../../../../trigger/renewal-jobs/appmax.ts", "../../../../../../src/lib/payments/appmax/sdk.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk/v3\";\nimport { prisma } from \"@/lib/prisma\";\nimport { buildAppmaxClientForMerchant } from \"@/lib/payments/appmax/sdk\";\n\nexport const appmaxRenewal = task({\n  id: \"appmax-renewal\",\n  retry: { maxAttempts: 5, minTimeoutInMs: 2000, maxTimeoutInMs: 60000, factor: 2 },\n  queue: { concurrencyLimit: 10 },\n  run: async (payload: { subscriptionId: string }) => {\n    const { subscriptionId } = payload;\n    console.log(`üîÑ Processing Appmax renewal for subscription: ${subscriptionId}`);\n\n    if (!subscriptionId) {\n      console.warn(\"‚ö†Ô∏è  Missing subscriptionId in payload. Skipping Appmax renewal.\");\n      return { skipped: true, reason: \"missing_subscription_id\" };\n    }\n\n    if (process.env.TRIGGER_ENABLE_APPMAX !== \"true\") {\n      console.log(\"‚ö†Ô∏è  Feature disabled: TRIGGER_ENABLE_APPMAX\");\n      return { skipped: true, reason: \"feature_disabled\" };\n    }\n    const subscription = await prisma.customerSubscription.findUnique({\n      where: { id: subscriptionId },\n      include: { customer: true },\n    });\n\n    if (!subscription) throw new Error(`Subscription ${subscriptionId} not found`);\n    if (!subscription.currentPeriodEnd) return { skipped: true, reason: \"missing_current_period\" };\n\n    // Only process due\n    if (subscription.currentPeriodEnd > new Date()) return { skipped: true, reason: \"not_due\" };\n\n    // Normalize metadata (flatten nested `{ set: ... }`), preferring outer keys over inner keys\n    const normalizeMeta = (m: any): any => {\n      if (!m || typeof m !== \"object\") return {};\n      let node: any = m;\n      let extras: Record<string, any> = {};\n      // Walk down through `set` layers, accumulating sibling keys (excluding `set`)\n      while (node && typeof node === \"object\" && node.set && typeof node.set === \"object\") {\n        const { set, ...rest } = node;\n        // Outer keys should win, so collect them and continue downward\n        extras = { ...rest, ...extras };\n        node = set;\n      }\n      // Merge final leaf with accumulated outer keys (outer overrides inner)\n      const leaf = (node && typeof node === \"object\") ? node : {};\n      return { ...leaf, ...extras };\n    };\n\n    // Compute next period\n    const meta = normalizeMeta((subscription.metadata as any) || {});\n    const intervalUnit: string = meta.intervalUnit || \"MONTH\";\n    const intervalCount: number = Number(meta.intervalCount || 1);\n    const nextPeriodStart: Date = subscription.currentPeriodEnd;\n    const nextPeriodEnd: Date = calculateNextPeriod(nextPeriodStart, intervalUnit, intervalCount);\n\n    // Build Appmax client from merchant integration\n    const client = await buildAppmaxClientForMerchant(subscription.merchantId);\n\n    // Buscar m√©todo de pagamento salvo em customer_payment_methods\n    const paymentMethod = await prisma.customerPaymentMethod.findFirst({\n      where: {\n        customerId: subscription.customerId,\n        provider: 'APPMAX' as any,\n        status: 'ACTIVE' as any\n      },\n      orderBy: { isDefault: 'desc' }\n    });\n\n    if (!paymentMethod?.providerPaymentMethodId) {\n      console.warn(\"‚ö†Ô∏è  No saved Appmax card found for customer\");\n      return { skipped: true, reason: \"no_payment_method\" };\n    }\n\n    const appmaxCardToken = paymentMethod.providerPaymentMethodId;\n\n    // Create order in Appmax ensuring required identifiers are present\n    const metaCustomerId: string | undefined = meta.appmaxCustomerId;\n    if (!metaCustomerId) {\n      console.warn(\"‚ö†Ô∏è  Missing appmaxCustomerId in metadata. Skipping Appmax renewal.\");\n      return { skipped: true, reason: \"missing_appmax_customer_id\" };\n    }\n\n    // CRITICAL: Use the SAME payload format as checkout (which works)\n    // Appmax API expects: total, products (not items), shipping (number, not object), freight_type\n    const totalReais = Number((subscription.priceCents / 100).toFixed(2));\n    const shippingReais = 0; // No shipping for digital subscription renewals\n\n    const orderPayload: any = {\n      total: totalReais, // AppMax expects REAIS (Decimal 10,2)\n      products: [\n        {\n          sku: String(subscription.productId || subscription.id || \"subscription\"),\n          name: `Renova√ß√£o ${subscription.productId || \"subscription\"}`,\n          qty: 1,\n          price: totalReais, // Price in REAIS\n        },\n      ],\n      shipping: shippingReais, // Number (not object)\n      discount: 0,\n      customer_id: Number(metaCustomerId), // Appmax expects numeric customer_id\n      freight_type: \"PAC\", // Required string\n      digital_product: 1, // Subscription is digital\n    };\n\n    console.log(\"[appmax][order][payload]\", orderPayload);\n\n    let order: any = null;\n    try {\n      order = await client.ordersCreate(orderPayload);\n    } catch (e: any) {\n      console.error(\"‚ùå Appmax order creation failed\", {\n        message: e?.message,\n        status: e?.status,\n        response: e?.response,\n      });\n      throw e;\n    }\n\n    // Extract orderId from Appmax response (data.id)\n    const orderId: number | null = Number(order?.data?.id ?? order?.id ?? order?.order_id ?? NaN) || null;\n\n    // Charge credit card immediately using saved token (mirror checkout route payload shape)\n    let paymentResp: any = null;\n    try {\n      const buyerDoc = String((subscription.customer as any)?.document || '')\n        .toString()\n        .replace(/\\D+/g, '')\n        .slice(0, 14);\n      const buyerName = String((subscription.customer as any)?.name || 'Cliente');\n      const payPayload: any = {\n        cart: { order_id: orderId },\n        customer: { customer_id: Number(metaCustomerId) },\n        payment: {\n          CreditCard: {\n            token: appmaxCardToken,\n            installments: 1,\n            soft_descriptor: 'KRXLABS',\n            document_number: buyerDoc,\n            name: buyerName,\n          },\n        },\n      };\n      paymentResp = await client.paymentsCreditCardNoRetry(payPayload);\n    } catch (e: any) {\n      console.error(\"‚ùå Appmax payment error\", { message: e?.message, status: e?.status });\n    }\n\n    // Map status to string, never store numeric HTTP codes\n    const mappedStatus = (() => {\n      const s = String(paymentResp?.status || paymentResp?.data?.status || '').toLowerCase();\n      const txt = String(paymentResp?.text || paymentResp?.data?.text || '').toLowerCase();\n      if (s.includes('aprov')) return 'paid';\n      if (s.includes('autor')) return 'authorized';\n      if (s.includes('pend')) return 'pending';\n      if (txt.includes('captur') || (txt.includes('autoriz') && txt.includes('sucesso'))) return 'paid';\n      return 'processing';\n    })();\n\n    // Build deterministic transaction id per subscription + billing period (YYYYMM)\n    const periodKey = `${nextPeriodStart.getUTCFullYear()}${String(nextPeriodStart.getUTCMonth() + 1).padStart(2, \"0\")}`;\n    const txId = `tx_appmax_${subscriptionId}_${periodKey}`;\n\n    // Build create/update payloads, avoiding empty strings on provider ids\n    const providerOrderIdStr = orderId ? String(orderId) : null;\n    const providerChargeIdStr = paymentResp?.id ? String(paymentResp.id) : null;\n\n    // If another transaction already recorded this providerChargeId, reuse that record to avoid unique constraint\n    let txIdToUse = txId;\n    if (providerChargeIdStr) {\n      const existing = await prisma.paymentTransaction.findFirst({\n        where: { provider: \"appmax\" as any, providerChargeId: providerChargeIdStr },\n        select: { id: true },\n      });\n      if (existing?.id && existing.id !== txIdToUse) {\n        txIdToUse = existing.id;\n      }\n    }\n\n    await prisma.paymentTransaction.upsert({\n      where: { id: txIdToUse },\n      create: {\n        id: txIdToUse,\n        provider: \"appmax\",\n        provider_v2: \"APPMAX\" as any,\n        providerOrderId: providerOrderIdStr as any,\n        ...(providerChargeIdStr ? { providerChargeId: providerChargeIdStr as any } : {}),\n        merchantId: subscription.merchantId,\n        customerId: subscription.customerId,\n        customerSubscriptionId: subscription.id,\n        productId: subscription.productId,\n        amountCents: subscription.priceCents,\n        currency: String(subscription.currency).toLowerCase(),\n        status: mappedStatus,\n        status_v2: mapStatus(mappedStatus),\n        paymentMethodType: \"subscription_renewal\",\n        billingPeriodStart: nextPeriodStart,\n        billingPeriodEnd: nextPeriodEnd,\n        rawPayload: { order, paymentResp } as any,\n      },\n      update: {\n        providerOrderId: providerOrderIdStr as any,\n        ...(providerChargeIdStr ? { providerChargeId: providerChargeIdStr as any } : {}),\n        status: mappedStatus,\n        status_v2: mapStatus(mappedStatus),\n        rawPayload: { order, paymentResp } as any,\n      },\n    });\n\n    if (mappedStatus === \"paid\" || mappedStatus === \"completed\" || mappedStatus === \"approved\") {\n      await prisma.customerSubscription.update({\n        where: { id: subscriptionId },\n        data: {\n          status: \"ACTIVE\",\n          currentPeriodStart: nextPeriodStart,\n          currentPeriodEnd: nextPeriodEnd,\n        },\n      });\n    } else if (mappedStatus === \"failed\" || mappedStatus === \"rejected\") {\n      await prisma.customerSubscription.update({\n        where: { id: subscriptionId },\n        data: {\n          status: \"PAST_DUE\",\n          metadata: {\n            ...(subscription.metadata as any),\n            lastRenewalError: `appmax_status_${mappedStatus}`,\n            lastRenewalAttempt: new Date().toISOString(),\n          },\n        },\n      });\n    }\n\n    console.log(`‚úÖ Renewal processed (Appmax)`, { subscriptionId, status: mappedStatus });\n    return { success: true, status: mappedStatus };\n  },\n});\n\nfunction calculateNextPeriod(current: Date, unit: string, count: number): Date {\n  const next = new Date(current);\n  switch (unit) {\n    case \"DAY\":\n      next.setDate(next.getDate() + count);\n      break;\n    case \"WEEK\":\n      next.setDate(next.getDate() + count * 7);\n      break;\n    case \"MONTH\":\n      next.setMonth(next.getMonth() + count);\n      break;\n    case \"YEAR\":\n      next.setFullYear(next.getFullYear() + count);\n      break;\n  }\n  return next;\n}\n\nfunction mapStatus(status?: string): any {\n  const map: Record<string, any> = {\n    paid: \"SUCCEEDED\",\n    approved: \"SUCCEEDED\",\n    completed: \"SUCCEEDED\",\n    processing: \"PROCESSING\",\n    pending: \"PROCESSING\",\n    failed: \"FAILED\",\n    rejected: \"FAILED\",\n    canceled: \"CANCELED\",\n    refunded: \"REFUNDED\",\n  };\n  return status ? map[status] || \"PROCESSING\" : \"PROCESSING\";\n}\n", "import { prisma } from '@/lib/prisma'\n\ntype AppmaxOptions = { testMode?: boolean, baseURL?: string }\n\nexport class AppmaxClient {\n  private apiKey: string\n  private baseURL: string\n\n  constructor(apiKey: string, opts?: AppmaxOptions) {\n    this.apiKey = (apiKey || '').trim()\n    const explicit = opts?.baseURL\n    const test = opts?.testMode === true\n    // Produ√ß√£o usa admin.appmax.com.br (n√£o api.appmax.com.br)\n    this.baseURL = explicit || (test ? 'https://homolog.sandboxappmax.com.br/api/v3' : 'https://admin.appmax.com.br/api/v3')\n  }\n\n  private async post<T = any>(path: string, body: Record<string, any>, retryAttempts: number = 2): Promise<T> {\n    const url = `${this.baseURL}${path}`\n    // Token vai no header, n√£o no body (padr√£o Appmax oficial)\n    const payload = { ...(body || {}) }\n    const headers: Record<string, string> = { \n      'Content-Type': 'application/json',\n      'access-token': this.apiKey\n    }\n    const sanitize = (obj: any) => {\n      try {\n        const c = JSON.parse(JSON.stringify(obj || {}))\n        if (c && typeof c === 'object') {\n          if ('access-token' in c) c['access-token'] = '***'\n          if (c.payment && c.payment.CreditCard && c.payment.CreditCard.number) c.payment.CreditCard.number = '****'\n          if (c.payment && c.payment.pix && c.payment.pix.document_number) c.payment.pix.document_number = '****'\n        }\n        return c\n      } catch {\n        return obj\n      }\n    }\n\n    let lastErr: any = null\n    for (let attempt = 1; attempt <= Math.max(1, retryAttempts); attempt++) {\n      const controller = new AbortController()\n      const timeoutMs = 20000\n      const timer = setTimeout(() => controller.abort(), timeoutMs)\n      const start = Date.now()\n      try {\n        const tokenLen = this.apiKey ? this.apiKey.length : 0\n        const tokenPreview = this.apiKey ? `${this.apiKey.slice(0, 8)}...${this.apiKey.slice(-8)}` : 'MISSING'\n        console.log('[appmax][request]', { \n          url, \n          path, \n          attempt, \n          tokenLen,\n          tokenPreview,\n          headersPresent: Object.keys(headers),\n          payload: sanitize(payload) \n        })\n        const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(payload), signal: controller.signal })\n        const text = await res.text()\n        let json: any = null\n        try { json = text ? JSON.parse(text) : null } catch { json = { raw: text } }\n        const durationMs = Date.now() - start\n        console.log('[appmax][response]', { url, path, attempt, status: res.status, durationMs, body: sanitize(json) })\n        if (!res.ok) {\n          const err: any = new Error(json?.message || 'appmax_error')\n          err.status = res.status\n          err.response = json\n          throw err\n        }\n        clearTimeout(timer)\n        return json as T\n      } catch (e: any) {\n        clearTimeout(timer)\n        lastErr = e\n        const durationMs = Date.now() - start\n        console.error('[appmax][error]', { url, path, attempt, durationMs, message: e?.message, status: e?.status, response: sanitize(e?.response) })\n        const retriable = e?.name === 'AbortError' || (Number(e?.status) >= 500)\n        if (attempt < Math.max(1, retryAttempts) && retriable) {\n          await new Promise(r => setTimeout(r, 500))\n          continue\n        }\n        break\n      }\n    }\n    if (lastErr) throw lastErr\n    throw new Error('appmax_error')\n  }\n\n  customersCreate(body: Record<string, any>) {\n    return this.post('/customer', body)\n  }\n\n  ordersCreate(body: Record<string, any>) {\n    return this.post('/order', body)\n  }\n\n  paymentsCreditCard(body: Record<string, any>) {\n    return this.post('/payment/credit-card', body, 2)\n  }\n\n  // Important: avoid automatic retry for payments, as the gateway may cancel the order after a failed attempt\n  paymentsCreditCardNoRetry(body: Record<string, any>) {\n    return this.post('/payment/credit-card', body, 1)\n  }\n\n  paymentsPix(body: Record<string, any>) {\n    return this.post('/payment/pix', body)\n  }\n\n  paymentsBillet(body: Record<string, any>) {\n    return this.post('/payment/billet', body)\n  }\n\n  tokenizeCard(body: Record<string, any>) {\n    return this.post('/tokenize/card', body)\n  }\n\n  refund(body: Record<string, any>) {\n    return this.post('/refund', body)\n  }\n}\n\nexport async function buildAppmaxClientForMerchant(merchantId: string) {\n  const integ = await prisma.merchantIntegration.findUnique({\n    where: { merchantId_provider: { merchantId: String(merchantId), provider: 'APPMAX' as any } },\n    select: { credentials: true, isActive: true },\n  })\n  if (!integ || !integ.isActive) throw new Error('appmax_integration_inactive')\n  const creds = (integ.credentials || {}) as any\n  const apiKey: string | undefined = creds?.apiKey\n  const testMode: boolean = !!creds?.testMode\n  if (!apiKey) throw new Error('appmax_api_key_missing')\n  return new AppmaxClient(apiKey, { testMode })\n}\n"],
  "mappings": "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",
  "names": []
}
